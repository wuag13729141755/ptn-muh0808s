#define __PROJECT_VAR_FUN_CONFIG_C__

#include "includes.h"



stProjectSpecVar_t  stMHD1616SRXSpecVar;

static bool         sg_bChangePowerStateFlag = FALSE;
static volatile u32 g_MHD1616SRX_Timers[emUserTimer_Max];
u8 g_u8BdAddr = 0x01;
stInputTimingVar_t g_stRxResolution[_HDMI_INPUT_PORT_USED_NUMBER];


extern stProjectGlobalAllVar_t g_stPrjGloVar;
void mapp_MHD1616SRXStartupToRecoveryState(void);
void report_video_timing(void);

unsigned char const  _1_1024x768p60[256] =
{
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x55, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x32, 0x1C, 0x01, 0x03, 0x80, 0x50, 0x2D, 0x78, 0x0E, 0xEE, 0x91, 0xA3, 0x54, 0x4C, 0x99, 0x26,
    0x0F, 0x50, 0x54, 0x01, 0x08, 0x00, 0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xD6, 0x18, 0x00, 0x30, 0x41, 0x00, 0x1E, 0x30, 0x30, 0x68,
    0x34, 0x00, 0x20, 0xC2, 0x31, 0x00, 0x00, 0x1C, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20,
    0xB8, 0x28, 0x55, 0x40, 0x20, 0xC2, 0x31, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x18,
    0x4B, 0x1A, 0x51, 0x08, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC,
    0x00, 0x48, 0x44, 0x20, 0x56, 0x69, 0x64, 0x65, 0x6F, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x01, 0xFD,
    0x02, 0x03, 0x1C, 0x72, 0x44, 0x84, 0x93, 0x12, 0x03, 0x23, 0x09, 0x1F, 0x07, 0x83, 0x01, 0x00,
    0x00, 0x67, 0x03, 0x0C, 0x00, 0x10, 0x00, 0xB8, 0x10, 0xE2, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8,
};


unsigned char const  _2_1280x720p60[256] =
{
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x55, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x32, 0x1C, 0x01, 0x03, 0x80, 0x50, 0x2D, 0x78, 0x0E, 0xEE, 0x91, 0xA3, 0x54, 0x4C, 0x99, 0x26,
    0x0F, 0x50, 0x54, 0x01, 0x08, 0x00, 0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x1D, 0x00, 0x72, 0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28,
    0x55, 0x00, 0x20, 0xC2, 0x31, 0x00, 0x00, 0x1E, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20,
    0xB8, 0x28, 0x55, 0x40, 0x20, 0xC2, 0x31, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x18,
    0x4B, 0x1A, 0x51, 0x08, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC,
    0x00, 0x48, 0x44, 0x20, 0x56, 0x69, 0x64, 0x65, 0x6F, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x01, 0x9A,
    0x02, 0x03, 0x1C, 0x72, 0x44, 0x84, 0x93, 0x12, 0x03, 0x23, 0x09, 0x1F, 0x07, 0x83, 0x01, 0x00,
    0x00, 0x67, 0x03, 0x0C, 0x00, 0x10, 0x00, 0xB8, 0x10, 0xE2, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8,
};
unsigned char const  _3_1360x768p60[256] = //
{
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x55, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x32, 0x1C, 0x01, 0x03, 0x80, 0x50, 0x2D, 0x78, 0x0E, 0xEE, 0x91, 0xA3, 0x54, 0x4C, 0x99, 0x26,
    0x0F, 0x50, 0x54, 0x01, 0x08, 0x00, 0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x1B, 0x21, 0x50, 0xA0, 0x51, 0x00, 0x1E, 0x30, 0x48, 0x88,
    0x3A, 0x00, 0x20, 0xC2, 0x31, 0x00, 0x00, 0x1C, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20,
    0xB8, 0x28, 0x55, 0x40, 0x20, 0xC2, 0x31, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x18,
    0x4B, 0x1A, 0x51, 0x08, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC,
    0x00, 0x48, 0x44, 0x20, 0x56, 0x69, 0x64, 0x65, 0x6F, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x01, 0xA1,
    0x02, 0x03, 0x1C, 0x72, 0x44, 0x84, 0x93, 0x12, 0x03, 0x23, 0x09, 0x1F, 0x07, 0x83, 0x01, 0x00,
    0x00, 0x67, 0x03, 0x0C, 0x00, 0x10, 0x00, 0xB8, 0x10, 0xE2, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8,
};

unsigned char const  _4_1920x1200p60[256] =
{
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x55, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x32, 0x1C, 0x01, 0x03, 0x80, 0x50, 0x2D, 0x78, 0x0A, 0xEE, 0x95, 0xA3, 0x54, 0x4C, 0x99, 0x26,
    0x0F, 0x50, 0x54, 0x21, 0x08, 0x00, 0xD1, 0x00, 0x81, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x28, 0x3C, 0x80, 0xA0, 0x70, 0xB0, 0x23, 0x40, 0x30, 0x20,
    0x36, 0x00, 0x80, 0xB0, 0x74, 0x00, 0x00, 0x1A, 0x9E, 0x20, 0x00, 0x90, 0x51, 0x20, 0x1F, 0x30,
    0x48, 0x80, 0x36, 0x00, 0x20, 0xF4, 0x31, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x18,
    0x4B, 0x1A, 0x51, 0x10, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC,
    0x00, 0x48, 0x44, 0x20, 0x56, 0x69, 0x64, 0x65, 0x6F, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x01, 0x96,
    0x02, 0x03, 0x1C, 0x70, 0x44, 0x10, 0x1F, 0x04, 0x13, 0x23, 0x09, 0x1F, 0x07, 0x83, 0x01, 0x00,
    0x00, 0x67, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x00, 0x20, 0xE2, 0x00, 0x4F, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38,

};

unsigned char const  _5_1600x1200p60[256] = //
{
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x55, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x32, 0x1C, 0x01, 0x03, 0x80, 0x50, 0x2D, 0x78, 0x0E, 0xEE, 0x91, 0xA3, 0x54, 0x4C, 0x99, 0x26,
    0x0F, 0x50, 0x54, 0x01, 0x08, 0x00, 0x81, 0xC0, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x07, 0x3F, 0x40, 0x30, 0x62, 0xB0, 0x2D, 0x40, 0x70, 0xA8,
    0x34, 0x00, 0x20, 0xC2, 0x31, 0x00, 0x00, 0x1C, 0x01, 0x1D, 0x00, 0xBC, 0x52, 0xD0, 0x1E, 0x20,
    0xB8, 0x28, 0x55, 0x40, 0x20, 0xC2, 0x31, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x18,
    0x4B, 0x1A, 0x51, 0x08, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xFC,
    0x00, 0x48, 0x44, 0x20, 0x56, 0x69, 0x64, 0x65, 0x6F, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x01, 0xF5,
    0x02, 0x03, 0x1C, 0x72, 0x44, 0x84, 0x93, 0x12, 0x03, 0x23, 0x09, 0x1F, 0x07, 0x83, 0x01, 0x00,
    0x00, 0x67, 0x03, 0x0C, 0x00, 0x10, 0x00, 0xB8, 0x10, 0xE2, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE8,
};

unsigned char const  _6_1920x1080p60[256] =
{
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x55, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x32, 0x1C, 0x01, 0x03, 0x80, 0x50, 0x2D, 0x78, 0x0A, 0xEE, 0x91, 0xA3, 0x54, 0x4C, 0x99, 0x26,
    0x0F, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0x20, 0xC2, 0x31, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC,
    0x00, 0x48, 0x44, 0x20, 0x56, 0x69, 0x64, 0x65, 0x6F, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x01, 0x68,
    0x02, 0x03, 0x23, 0x72, 0x4B, 0x90, 0x9F, 0x22, 0x21, 0x20, 0x05, 0x14, 0x04, 0x13, 0x12, 0x03,
    0x23, 0x09, 0x1F, 0x07, 0x83, 0x01, 0x00, 0x00, 0x67, 0x03, 0x0C, 0x00, 0x10, 0x00, 0x00, 0x20,
    0xE2, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD7,
};

//========================================================================================
// add by wf8421 20190820
//------------------------------------------------------------------------------
// Function:    mapp_MHD1616SRX_PlatformTimerSet
// Description: 设置相关功能定时器时间
//------------------------------------------------------------------------------
void mapp_MHD1616SRX_PlatformTimerSet( uint8_t index, u32 m_sec )
{
    switch ( index )
    {
        default:
            if (index<emUserTimer_Max)
            {
                g_MHD1616SRX_Timers[index] = m_sec;
            }
            break;
    }
}

//------------------------------------------------------------------------------
// Function:    mapp_MHD1616SRX_PlatformTimerGet
// Description: 获取相关功能定时器时间
//------------------------------------------------------------------------------
u32 mapp_MHD1616SRX_PlatformTimerGet(uint8_t eTimer)
{
    return(g_MHD1616SRX_Timers[eTimer]);
}

//------------------------------------------------------------------------------
// Function:    mapp_MHD1616SRX_PlatformTimerInit
// Description: 定时器初始化
//------------------------------------------------------------------------------
void mapp_MHD1616SRX_PlatformTimerInit (void)
{
    int i;
    //initializer timer counters in array
    for ( i = 0; i < emUserTimer_Max; i++ )
    {
        g_MHD1616SRX_Timers[ i ] = 0;
    }

    //PlatformTimerSet(etKEY_Detect,5000);
}

//------------------------------------------------------------------------------
// Function:    mapp_MHD1616SRX_PlatformTimerTask
// Description: 定时器递减函数
//------------------------------------------------------------------------------
void mapp_MHD1616SRX_PlatformTimerTask(void)
{
    int i;
    for(i=0;i<emUserTimer_Max;i++)
    {
        if(g_MHD1616SRX_Timers[i] > 0)
        {
            g_MHD1616SRX_Timers[i]--;
        }
    }
}

//------------------------------------------------------------------------------
// Function:    mapp_MHD1616SRX_PlatformTimerExpired
// Description: 相关功能定时器时间是否为0
//------------------------------------------------------------------------------
uint8_t mapp_MHD1616SRX_PlatformTimerExpired ( uint8_t timer )           //定时时间到函数
{
    if ( timer < emUserTimer_Max )
    {
        return( g_MHD1616SRX_Timers[ timer ] == 0);              //定时时间到时返回1
    }

    return( 0 );                                           //定时时间还没到时返回0
}
//========================================================================================

void MHD1616SRX_1msTimerIrq(void)
{
    mapp_MHD1616SRX_PlatformTimerTask();
}

void MHD1616SRX_SpecificVarInit(void)
{
    pstProjectGlobalAllVar_t    pstPrjAllVar = &g_stPrjGloVar;
    pstProjectGlobalSaveVar_t   pstPrjSaveVar = &pstPrjAllVar->stPrjSaveVar;
    pstProjectSpecVar_t         pstSpecVar = &stMHD1616SRXSpecVar;

    memset(pstSpecVar, 0, sizeof(stProjectSpecVar_t));
    pstPrjSaveVar->stSaveSpecVar.pvSpecVar = (void *)pstSpecVar;
    pstPrjSaveVar->stSaveSpecVar.u16SpecVarSize = sizeof(stProjectSpecVar_t);

}

void MHD1616SRX_SpecificVarDefault(void)
{
    MHD1616SRX_SpecBasicVarDefault();
}

void MHD1616SRX_SpecBasicVarDefault(void)
{
    pstProjectSpecVar_t         pstSpecVar = &stMHD1616SRXSpecVar;

    pstSpecVar->stBasSpecVar.bPowerOnSta = TRUE;
    pstSpecVar->stBasSpecVar.bIsLock = FALSE;
}

bool MHD1616SRX_SpecVarValidCheck(void)
{
    pstProjectSpecVar_t         pstSpecVar = &stMHD1616SRXSpecVar;
    bool                        isSpecVarValid = TRUE;

    if(pstSpecVar->stBasSpecVar.u8CheckSum != CRC8Calculate((uint8_t *)&pstSpecVar->stBasSpecVar,((uint8_t *)&pstSpecVar->stBasSpecVar.u8CheckSum-(uint8_t *)&pstSpecVar->stBasSpecVar)))
    {
        MHD1616SRX_SpecBasicVarDefault();
        pstSpecVar->stBasSpecVar.u8CheckSum = CRC8Calculate((uint8_t *)&pstSpecVar->stBasSpecVar,((uint8_t *)&pstSpecVar->stBasSpecVar.u8CheckSum-(uint8_t *)&pstSpecVar->stBasSpecVar));

        isSpecVarValid = FALSE;
    }

    return isSpecVarValid;
}

void SetUserData_SpecBasicVar(void)
{
    pstProjectGlobalAllVar_t    pstPrjAllVar = &g_stPrjGloVar;
    pstProjectGlobalSaveVar_t   pstPrjSaveVar = &pstPrjAllVar->stPrjSaveVar;
    pstProjectSpecVar_t         pstSpecVar = &stMHD1616SRXSpecVar;
    pstBasicSpecVar_t           pstBasicVar = &pstSpecVar->stBasSpecVar;

    pstBasicVar->u8CheckSum = CRC8Calculate((uint8_t *)pstBasicVar, ((uint8_t *)&pstBasicVar->u8CheckSum-(uint8_t *)pstBasicVar));
    SaveUserDataToEep(eEepDataIndex_SpecBlock1,\
        (ADDR_EEPROM_USER_START+((uint8_t *)&pstPrjSaveVar->stSaveSpecVar-(uint8_t *)pstPrjSaveVar)),\
        (uint8_t *)pstBasicVar, sizeof(stBasicSpecVar_t), TIME_SAVE_TO_EEPROM_IMMEDIATELY, FALSE);
}

// the status when power on device
void MHD1616SRX_PrjStatePowerOnInit(void)
{
    pstProjectSpecVar_t         pstSpecVar = &stMHD1616SRXSpecVar;
    pstBasicSpecVar_t           pstBasicVar = &pstSpecVar->stBasSpecVar;

    pFuncPrj1MsLoopHook = MHD1616SRX_1msTimerIrq;

    memset(g_stRxResolution,0,sizeof(stInputTimingVar_t)*_HDMI_INPUT_PORT_USED_NUMBER);
    System_Default_Edid_table = (iTE_u8 *)_6_1920x1080p60;

    g_u8BdAddr = (mapp_GetIDPinState() == FALSE)?0x01:0x02;
    g_bEnableDbgFlag = pstBasicVar->bIsDebugEn;
    pstBasicVar->bPowerOnSta = TRUE;
}

void MHD1616SRX_SetPowerStateFlag(bool bstate)
{
    sg_bChangePowerStateFlag = bstate;
}

bool MHD1616SRX_GetPowerStateFlag(void)
{
    return sg_bChangePowerStateFlag;
}

void mapp_MHD1616SRXStartupMessage(void)
{
    RS232_printf("\r\n");
    RS232_printf("System Initializing...\r\n");
    RS232_printf("\r\n");
    RS232_printf("Initialization Finished!\r\n");
    RS232_printf("@%s %s",_STRING_FW_VERSION,_STRING_FW_VER_NUM);
}

void mapp_MHD1616SRXLedProcess(void)
{
    static bool sl_bLedSta = FALSE;
    if(mapp_MHD1616SRX_PlatformTimerExpired(emUserTimer_LedActive))
    {
        mapp_MHD1616SRX_PlatformTimerSet(emUserTimer_LedActive,500);
        if(sl_bLedSta)
        {
            sl_bLedSta = FALSE;
            led_on(led_name_ActiveState);
        }
        else
        {
            sl_bLedSta = TRUE;
            led_off(led_name_ActiveState);
        }
    }
}

void mapp_MHD1616SRXMainFunction(void)
{
    mapp_MHD1616SRXLedProcess();
    report_video_timing();
    mapp_MHD1616SRXStartupToRecoveryState();
}

void mapp_MHD1616SRX_SendDataToFpag(pu8 pu8Data, u16 u16Len)
{
    pstUartCom_t pUartCommVar = &g_stUart2CommVar;
    pUartCommVar->SendBytes(pu8Data,u16Len,FALSE);
}
void send_cmd_to_fpga(uint8_t addr,uint8_t cmd,uint8_t* data,uint16_t len)
{
	uint8_t buff[100]={0xff,0xff,0xa5,0xfe,0xcc,0x01,0x00,0xaa};
	uint16_t i;

	if(len>99)return ;
	buff[3]=addr;
	buff[4]=cmd;

	buff[5]=len;
	buff[6]=len>>8;
	for(i=0;i<len;i++)
	   buff[7+i]=data[i];

	mapp_MHD1616SRX_SendDataToFpag(buff,7+i);
}

#define REPORT_TIMING_TIME  3000
void report_video_timing(void)
{
    uint8_t buff[20];
    uint16_t i,j;
    u16 l_u16HActive,l_u16VActive;
    u32 l_u32Pclk;
    u8 l_u8VFreq;

//    if((sys_temp.mcu_updata_flag==1)||(sys_temp.fpga_updata_flag==1)||(sys_temp.updata_edid_flag==1))
//        return;
    if(!mapp_MHD1616SRX_PlatformTimerExpired(emUserTimer_ReportTiming))
        return;
    mapp_MHD1616SRX_PlatformTimerSet(emUserTimer_ReportTiming,REPORT_TIMING_TIME);

    for(i=0;i<_HDMI_INPUT_PORT_USED_NUMBER;i++)
    {
        g_stRxResolution[i].u8ScanMode = it66021_GetInputTiming(i,&l_u16HActive,&l_u16VActive,&l_u32Pclk);
        it66021_GetInputVFreq(i,&l_u8VFreq);
        g_stRxResolution[i].u16HActive = l_u16HActive;
        g_stRxResolution[i].u16VActive = l_u16VActive;
        g_stRxResolution[i].u8VFreq    = l_u8VFreq;

        j=0;
        buff[j++] = i+1; //ch
        buff[j++] = l_u16HActive >> 8;
        buff[j++] = l_u16HActive & 0xFF;

        buff[j++] = l_u16VActive >> 8;
        buff[j++] = l_u16VActive & 0xFF;

        send_cmd_to_fpga(0xFE,0x52,buff,5);
    }
}

void mapp_SendCmdToSwitchBD(u8 u8DevAddr,u8 u8Cmd,pu8 pu8Data, u16 u16Len)
{
    pstUartCom_t pUartCommVar = &g_stUart1CommVar;
    u8 l_u8SendValue[1100];
    u16 i=0;
    u16 l_u16index=0;

    memset(l_u8SendValue,0,1100);
    l_u8SendValue[l_u16index++] = 0xFF;
    l_u8SendValue[l_u16index++] = 0xFF;
    l_u8SendValue[l_u16index++] = 0xA5;
    l_u8SendValue[l_u16index++] = u8DevAddr;
    l_u8SendValue[l_u16index++] = u8Cmd;
    l_u8SendValue[l_u16index++] = u16Len&0xFF;
    l_u8SendValue[l_u16index++] = (u16Len>>8)&0xFF;
    for(i=0;i<u16Len;i++)
    {
        l_u8SendValue[l_u16index+i] = pu8Data[i];
    }

    pUartCommVar->SendBytes(l_u8SendValue,l_u16index+u16Len,FALSE);
//    {
//        pstUartCom_t pUartDbgVar = &g_stUart3CommVar;
//        pUartDbgVar->SendBytes(l_u8SendValue,l_u16index+u16Len,FALSE);
//    }
}

void mapp_MHD1616SRXSendCmdToSWBD(u8 u8cmd,u8 *pu8Data, u16 u16Len)
{
    mapp_SendCmdToSwitchBD(g_u8BdAddr,u8cmd,pu8Data,u16Len);
}

void mapp_GetFpgaVersion(u8 u8Addr)
{
    u8 l_u8Addr;
    u8 l_u8Cmd;
    u8 l_u8Data = 0;

    l_u8Addr = u8Addr;
    l_u8Cmd = 0x03;//eFpgaRegGetVersion;
	send_cmd_to_fpga(l_u8Addr,l_u8Cmd,&l_u8Data,1);
}

typedef enum _eStartupLoopType_t_
{
    eSt_SInit,
    eSt_GetFPGAVersion,
    eSt_None,
}eStartupLoopType_t;

void mapp_MHD1616SRXStartupToRecoveryState(void)
{
    static bool sl_bStartupFlag = TRUE;
    static eStartupLoopType_t sl_eStartupLoop = eSt_None;

    if(!mapp_MHD1616SRX_PlatformTimerExpired(emUserTimer_StartupTime))
        return;

    if(sl_bStartupFlag)
    {
        sl_bStartupFlag = FALSE;
        sl_eStartupLoop = eSt_SInit;
    }

    switch(sl_eStartupLoop)
    {
        case eSt_SInit:
            {
                sl_eStartupLoop++;
            }
            break;
        case eSt_GetFPGAVersion:
            {
                mapp_GetFpgaVersion(0xFE);
                delay_ms(50);
//                mapp_GetFpgaVersion(5);
//                delay_ms(50);
//                mapp_GetFpgaVersion(9);
//                delay_ms(50);
//                mapp_GetFpgaVersion(13);
                mapp_MHD1616SRX_PlatformTimerSet(emUserTimer_StartupTime,500);
                delay_ms(50);
                if(g_u8VersionReceive)
                    sl_eStartupLoop++;
            }
            break;

        case eSt_None:
        default:
            break;
    }
}

#define DM_FW_BYTES_MIX         (15*1024)

#define DM_FW_BYTES_MAX         (190*1024)  //100KB
#define DM_FW_DATA_ADDR         0x8033800
#define DM_FW_FLAG_ADDR         0x8063000
#define PAGE_SIZE               0x800

#define DM_FW_FLAG_INVALID      0x44332211
#define DM_FW_FLAG_VALID        0x11223344
#define DM_FW_SIZE_ADDR         (DM_FW_FLAG_ADDR+4)

typedef struct _stUpdateVar_t_
{
    u8 u8UpdateMode;
    u8 u8UpdateFlag;
    u32 u32TotalBytes;
    u32 u32PageIndex;
    u16 u16PackIndex;
    u8 u8LastData[1024];
}stUpdateVar_t;

stUpdateVar_t g_stMcuUpdateVar;


int8_t FLASH_If_Erase(uint32_t StartSector)
{
  uint32_t FlashAddress;

  FlashAddress = StartSector;

  while (FlashAddress <   DM_FW_FLAG_ADDR)
  {
	if (FLASH_EraseOnePage(FlashAddress) == FLASH_COMPL)
	{
		FlashAddress += PAGE_SIZE;

			  IWDG_CntReload( 0xff0);
	}
	else
	{
		return -1;
	}
  }

  return 0;
}

uint8_t mcu_file_updata(uint8_t step ,uint8_t *data ,uint16_t len)
{
	uint16_t i,j=0;
	FLASH_STS f_sta;
	uint32_t* buff;
	image_header_t packet;

	static uint8_t LeftBytesTab[4]={0};
	static uint8_t LeftBytes=0;

	switch(step)
	{
		case 0:
//			dbg_printf("iap updata mode %d\r\n",sys_temp.mcu_updata_mode);
			dbg_printf("iap start Erase Sector\r\n");
			FLASH_Unlock();
			if(FLASH_If_Erase(DM_FW_DATA_ADDR) != 0)        /* 1Kbyte *3 */
			{
				FLASH_Lock();
				return 0;
			}
			FLASH_Lock();
			dbg_printf("Erase Sector finish\r\n");
			g_stMcuUpdateVar.u32TotalBytes = 0;
			g_stMcuUpdateVar.u8UpdateFlag=1;
			LeftBytes=0;
			memset(LeftBytesTab,0,4);
            g_stMcuUpdateVar.u32PageIndex = 0;
            mapp_MHD1616SRX_PlatformTimerSet(emUserTimer_FirmwareUpdate,10000);
			break;
		case 1:
            g_stMcuUpdateVar.u16PackIndex++;

            if(g_stMcuUpdateVar.u32PageIndex<FW_VECT_OFFSET)
            {
                g_stMcuUpdateVar.u32PageIndex +=len;
                return 0;
            }
            else
                g_stMcuUpdateVar.u32PageIndex +=len;
			//dbg_printf("LeftBytes[%d]\r\n",LeftBytes);
			if(LeftBytes)
			{
				while(LeftBytes<=3)
				{
					if(len>j)
					{
						LeftBytesTab[LeftBytes++] = *(data+j);
					}
					else
					{
						LeftBytesTab[LeftBytes++] = 0xFF;
					}
					j++;
				}

				FLASH_Unlock();
				FLASH_ProgramWord(DM_FW_DATA_ADDR+g_stMcuUpdateVar.u32TotalBytes,*(u32 *)LeftBytesTab);
				FLASH_Lock();
				//dbg_printf("d=%08x\r\n",*(u32 *)LeftBytesTab);
				LeftBytes =0;

				g_stMcuUpdateVar.u32TotalBytes=g_stMcuUpdateVar.u32TotalBytes+4;

				if (len >j)
				{
					/* update data pointer */
					data = (data+j);
					len = len -j;
				}
			}


			buff = (uint32_t*)(data);

			if((g_stMcuUpdateVar.u32TotalBytes  + len) > DM_FW_BYTES_MAX)
			{
			   return 0;
			}
			FLASH_Unlock();
			for(i = 0; i < len/4; i++)
			{
				f_sta = FLASH_ProgramWord(DM_FW_DATA_ADDR+g_stMcuUpdateVar.u32TotalBytes+i*4,  *(buff+i));
				if(f_sta != FLASH_COMPL)
				{
					dbg_printf("E=%d\r\n",f_sta);
					FLASH_EraseOnePage(DM_FW_FLAG_ADDR);	//Parameter
					FLASH_ProgramWord(DM_FW_FLAG_ADDR, DM_FW_FLAG_INVALID);
					break;
				}
			}
			//??
			i=len%4;
			//dbg_printf("i[%d]\r\n",i);
			if (i>0)
			{
					LeftBytes=0;
					for(;i>0;i--)
				  {
						  LeftBytesTab[LeftBytes++] = *(data+ len-i);
					   // dbg_printf("%02X ",*(data+ len-i));
				  }

					g_stMcuUpdateVar.u32TotalBytes +=len-i;
			}
			else
				g_stMcuUpdateVar.u32TotalBytes +=len;
            if(len<1024)
                memcpy(g_stMcuUpdateVar.u8LastData,data,len);

			FLASH_Lock();
			//dbg_printf(".");
			break;
		case 2:
			FLASH_Unlock();


			FLASH_EraseOnePage(DM_FW_FLAG_ADDR);  //Parameter

			g_stMcuUpdateVar.u32TotalBytes +=len;
			if(g_stMcuUpdateVar.u32TotalBytes>DM_FW_BYTES_MIX)
			{
                memcpy((uint8_t*)&packet,g_stMcuUpdateVar.u8LastData, sizeof(image_header_t));
				dbg_printf("iap end\r\n");
				dbg_printf("total_bytes [%d]\r\n",g_stMcuUpdateVar.u32TotalBytes );
				dbg_printf("ih_magic [0x%x]\r\n",packet.ih_magic );
				dbg_printf("ih_arch [%d]\r\n",packet.ih_arch );
				dbg_printf("ih_name [%s]\r\n",packet.ih_name );
                if((packet.ih_magic==0x4e545047)&&(packet.ih_arch==2)&&!strncmp((char*)packet.ih_name,_STRING_FACTORY_MODEL,strlen(_STRING_FACTORY_MODEL)))
				{
					dbg_printf("data check ok\r\n");

					f_sta =FLASH_ProgramWord(DM_FW_FLAG_ADDR, DM_FW_FLAG_VALID);
					dbg_printf("f_sta=%d\r\n",f_sta);
					FLASH_ProgramWord(DM_FW_SIZE_ADDR, g_stMcuUpdateVar.u32TotalBytes );
				}
//				  else
//				  {
//					  dbg_printf("data check fail\r\n");
//				  }
			}
			else
			{
				  dbg_printf("iap err\r\n");
				  FLASH_ProgramWord(DM_FW_FLAG_ADDR, DM_FW_FLAG_INVALID);
			}
			FLASH_Lock();
			g_stMcuUpdateVar.u8UpdateFlag=0;
			RCC_EnableAPB1PeriphClk(RCC_APB1_PERIPH_WWDG,ENABLE);
			WWDG_Enable(0x40);
			break;
	}
	return 1;
}

u8 mapp_FirmwareUpdateProcess(pstUartCom_t pComVar)
{
    if(g_stMcuUpdateVar.u8UpdateFlag==1)
    {
        mapp_MHD1616SRX_PlatformTimerSet(emUserTimer_FirmwareUpdate,5500);
        mcu_file_updata(1,(uint8_t*)pComVar->pRecBuffer,pComVar->u16RecCnt);

        pComVar->SendPrintf("pack %d\r\n",g_stMcuUpdateVar.u16PackIndex);
        dbg_printf("pack %d\r\n",g_stMcuUpdateVar.u16PackIndex);
        return 1;
    }
    else
        return 0;
}

void mapp_FirmwareUpdateTimeOutFunction(void)
{
    if(g_stMcuUpdateVar.u8UpdateFlag==1&&mapp_MHD1616SRX_PlatformTimerExpired(emUserTimer_FirmwareUpdate))
    {
        mcu_file_updata(2,NULL,0);
    }
}

