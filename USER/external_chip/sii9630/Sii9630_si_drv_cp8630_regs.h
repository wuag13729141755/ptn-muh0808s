/*
* SiI8630/SiI8632/SiI9630 Linux Driver
*
* 2016 © Lattice Semiconductor Corporation
*
* This program is free software; you can redistribute it and/or
* modify it only under the terms of  version 2 of the GNU General Public License
* as published by the Free Software Foundation, and not any later version.
*
* This program is distributed “AS IS” WITHOUT ANY WARRANTY of any kind,
* whether express or implied, including without limitation the implied warranty
* of MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE or NON-INFRINGEMENT.
* See the GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software Foundation, Inc.,
* 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*
* You may contact Lattice Semiconductor Corporation at 111 SW 5th Ave,
* Suite 700, Portland, OR 97204
*/

#ifndef _SI_DRV_CP8630_REGS_H_
#define _SI_DRV_CP8630_REGS_H_

#define BASE_ADDRESS 0x0000

enum page_t
{
	TOP = (BASE_ADDRESS | 0x0000),
	RX_AON = (BASE_ADDRESS | 0x1000),
	RX_PWD_HDCP1X = (BASE_ADDRESS | 0x1300),
	RX_VIDPATH = (BASE_ADDRESS | 0x1A00),
	RX_TBIST = (BASE_ADDRESS | 0x1B00),
	RX_DEPACK_1 = (BASE_ADDRESS | 0x1C00),
	RX_DEPACK_2 = (BASE_ADDRESS | 0x1D00),
	RX_EDID = (BASE_ADDRESS | 0x1E00),
	RX_HDCP2 = (BASE_ADDRESS | 0x1F00),
	DSC_ENC_CORE = (BASE_ADDRESS | 0x2000),
	DSC_ENC_WRAP = (BASE_ADDRESS | 0x2100),
	TX_TOP_P0 = (BASE_ADDRESS | 0x3000),
	TX_DSEDID_HDMI2MHL1 = (BASE_ADDRESS | 0x3200),
	TX_EMSC_MHLTOP_TDM = (BASE_ADDRESS | 0x3300),
	TX_MHLSPEC = (BASE_ADDRESS | 0x3400),
	TX_CBUS_MSCAGENT_DISC = (BASE_ADDRESS | 0x3500),
	TX_TPI = (BASE_ADDRESS | 0x3600),
	TX_HDCP2 = (BASE_ADDRESS | 0x3800),
	TX_HDMI2_HDMI2MHL3 = (BASE_ADDRESS | 0x3900),
	TX_API = (BASE_ADDRESS | 0x3A00),
	ANAPHY_RXDPLL = (BASE_ADDRESS | 0x4000),
	AVLINK_TXZONE = (BASE_ADDRESS | 0x4100),
	COCSRC = (BASE_ADDRESS | 0x4200),
	RX_XBIST = (BASE_ADDRESS | 0x4300),
	RX_ZONE = (BASE_ADDRESS | 0x4400),
};

struct page_info{
    enum page_t page_num;
    uint8_t dev_id;
};

//***************************************************************************
// TOP. Address: 60
// Banner Chip ID Lower Byte Register
#define REG_ADDR__BANNER_CHIP_LID                                        (TOP | 0x0000)
  // (ReadOnly, Bits 7:0) 
  // Banner Chip ID Lower Byte
  #define BIT_MSK__BANNER_CHIP_LID__REG_CHIP_ID_B7_B0                                     0xFF

// Banner Chip ID Upper Byte Register
#define REG_ADDR__BANNER_CHIP_UID                                        (TOP | 0x0001)
  // (ReadOnly, Bits 7:0) 
  // Banner Chip ID Lower Byte
  #define BIT_MSK__BANNER_CHIP_UID__REG_CHIP_ID_B15_B8                                    0xFF

// Banner Hardware Version Register
#define REG_ADDR__BANNER_HW_VER                                          (TOP | 0x0002)
  // (ReadOnly, Bits 7:0) 
  // Banner Hardware Version
  #define BIT_MSK__BANNER_HW_VER__REG_HW_VERSION                                        0xFF

// Banner Firmware Version Register
#define REG_ADDR__BANNER_FW_VER                                          (TOP | 0x0003)
  // (ReadOnly, Bits 7:0) 
  // Banner Firmware Version
  #define BIT_MSK__BANNER_FW_VER__REG_FW_VERSION                                        0xFF

// Banner Soft Reset #0 Register
#define REG_ADDR__SW_RST_REG0                                            (TOP | 0x0004)
  // (ReadWrite, Bits 0) 
  // Soft reset control to complete logic of Banner. This resets all internal logic except register interface. 1 - Reset 0 - Normal operation (default).
  #define BIT_MSK__SW_RST_REG0__REG_SRST_FULL                                         0x01
  // (ReadWrite, Bits 1) 
  // auto Soft reset control for DSC encoder. This resets all internal logic of DSC encoder except registers in it. 1 - Reset 0 - Normal operation (default).
  #define BIT_MSK__SW_RST_REG0__REG_DSC_ENC_AUTO_SW_RST                               0x02
  // (ReadWrite, Bits 4) 
  // Soft reset control to Reisters in Dual-Mode TX logic (Cypress) Normally registers will reset with soft-reset. But if there is a requirement to reset the registers without giving HW reset then use this bit reset all  the registers in TX logic.
  #define BIT_MSK__SW_RST_REG0__REG_TX_REG_SRST                                       0x10
  // (ReadWrite, Bits 5) 
  // Soft reset control for Banner Power Sate machin. 1 - Reset 0 - Normal operation (default).
  #define BIT_MSK__SW_RST_REG0__REG_PWR_FSM_SW_RST                                    0x20
  // (ReadWrite, Bits 6) 
  // Soft reset control for DSC encoder. This resets all internal logic of DSC encoder except registers in it. 1 - Reset 0 - Normal operation (default).
  #define BIT_MSK__SW_RST_REG0__REG_DSC_ENC_SW_RST                                    0x40
  // (ReadWrite, Bits 7) 
  // Soft reset control for OSC Calibration logic. 1 - Reset 0 - Normal operation (default).
  #define BIT_MSK__SW_RST_REG0__REG_OSC_CAL_SW_RST                                    0x80

// Banner Software Reset #1 Register
#define REG_ADDR__SW_RST_REG1                                            (TOP | 0x0005)
  // (ReadWrite, Bits 0) 
  // TX HDCP2x DDC master Control software reset 0 - Normal operation (default) 1 - Resets HDCP2x DDC master control logic
  #define BIT_MSK__SW_RST_REG1__REG_TX_DDCM2_SW_RST                                   0x01
  // (ReadWrite, Bits 1) 
  // TX HDCP1x DDC master Control software reset 0 - Normal operation (default) 1 - Resets HDCP1x DDC master control logic
  #define BIT_MSK__SW_RST_REG1__REG_TX_DDCM1_SW_RST                                   0x02
  // (ReadWrite, Bits 2) 
  // TX DDC (I2C) master software reset 0 - Normal operation (default) 1 - Resets TPI DDC master logic
  #define BIT_MSK__SW_RST_REG1__REG_TX_DDC_I2C_SW_RST                                 0x04
  // (ReadWrite, Bits 5) 
  // switch to allow either hardware or software to reset CBUS block except for cbus_regtx block 0- allows hardware to reset cbus block   1- allows FW to reset through reg_cbus_rst_SW (default)
  #define BIT_MSK__SW_RST_REG1__REG_CBUS_RST_SW_EN                                    0x20
  // (ReadWrite, Bits 6) 
  // CBUS block reset (except for cbus_regtx) 0 - Normal operation (default) 1- Reset CBUS block
  #define BIT_MSK__SW_RST_REG1__REG_CBUS_RST_SW                                       0x40
  // (ReadWrite, Bits 7) 
  // Data Island Clock domain sofeware reset 0 - Normal Operation (default) 1 - Reset Data Island domain logic
  #define BIT_MSK__SW_RST_REG1__REG_DIPKT_SW_RST                                      0x80

// Banner Software Reset #2 Register
#define REG_ADDR__SW_RST_REG2                                            (TOP | 0x0006)
  // (ReadWrite, Bits 0) 
  // TDM Link clock domain SW reset and is not applicable to functions other than TDM IP.
  #define BIT_MSK__SW_RST_REG2__REG_TDM_LSRST                                         0x01
  // (ReadWrite, Bits 4) 
  // SPI SW reset for non-CBUS and non-HDCP area
  #define BIT_MSK__SW_RST_REG2__REG_SPI_SRST                                          0x10
  // (ReadWrite, Bits 5) 
  // SPI SW reset for CBUS related
  #define BIT_MSK__SW_RST_REG2__REG_SPI_CBUSRST                                       0x20
  // (ReadWrite, Bits 6) 
  // SPI SW reset for HDCP related logic
  #define BIT_MSK__SW_RST_REG2__REG_SPI_HDCPRST                                       0x40

// Banner Software Reset #3 Register
#define REG_ADDR__SW_RST_REG4                                            (TOP | 0x0007)
  // (ReadWrite, Bits 0) 
  // Reset MHL FIFO when there is overflow or underflow happens 0 - Disable 1 - Enable (default)
  #define BIT_MSK__SW_RST_REG4__REG_MHL_FIFO_AUTO_RST_EN                              0x01
  // (ReadWrite, Bits 1) 
  // Reset timing closure FIFO when there is overflow or underflow happens 0 - Disable (default) 1 - Enable
  #define BIT_MSK__SW_RST_REG4__REG_TCF_AUTO_RST_EN                                   0x02
  // (ReadWrite, Bits 2) 
  // Reset MHL3 CTS FIFO when there is overflow or underflow happens 0 - Disable 1 - Enable (default)
  #define BIT_MSK__SW_RST_REG4__REG_CTS_FIFO_AUTO_RST_EN                              0x04
  // (ReadWrite, Bits 3) 
  // Soft reset for TX HDCP1x OTP control logic 0 - Disable (default) 1 - Enable
  #define BIT_MSK__SW_RST_REG4__REG_TX_OTP_RST                                        0x08
  // (ReadWrite, Bits 4) 
  // Soft reset for TX HDCP1x SHA control logic 0 - Disable (default) 1 - Enable
  #define BIT_MSK__SW_RST_REG4__REG_TX_SHA_RST                                        0x10
  // (ReadWrite, Bits 5) 
  // Soft reset for TX Pixel clock domain logic 0 - Disable (default) 1 - Enable
  #define BIT_MSK__SW_RST_REG4__REG_TX_PCLK_RST                                       0x20
  // (ReadWrite, Bits 6) 
  // Soft reset for TX TMDS clock domain logic 0 - Disable (default) 1 - Enable
  #define BIT_MSK__SW_RST_REG4__REG_TX_TCLK_RST                                       0x40
  // (ReadWrite, Bits 7) 
  // Soft reset for Oscillator (60MHz) clock domain 0 - Disable (default) 1 - Enable
  #define BIT_MSK__SW_RST_REG4__REG_OSC_RST                                           0x80

// Banner Clock Phase Control Register
#define REG_ADDR__CLKPHASE1                                              (TOP | 0x0008)
  // (ReadWrite, Bits 0) 
  // register bit to control the phase of mif_clk 0: no phase change (default) 1: inverted 
  #define BIT_MSK__CLKPHASE1__REG_MIF_CLK_PHASE                                     0x01
  // (ReadWrite, Bits 2) 
  // register bit to control the phase of pclknx 0: no phase change (default) 1: inverted 
  #define BIT_MSK__CLKPHASE1__REG_PCLKNX_PHASE                                      0x04
  // (ReadWrite, Bits 3) 
  // register bit to control the phase of pclk 0: no phase change (default) 1: inverted 
  #define BIT_MSK__CLKPHASE1__REG_PCLK_PHASE                                        0x08
  // (ReadWrite, Bits 4) 
  // register bit to control the phase of iclk 0: no phase change (default) 1: inverted 
  #define BIT_MSK__CLKPHASE1__REG_IDCK_PHASE                                        0x10
  // (ReadWrite, Bits 5) 
  // Selects cts_tck phase.   0 - Original phase; the same as it comes out of PLL (default) 1 - Invert cts_tck: change its phase 180 degrees 
  #define BIT_MSK__CLKPHASE1__REG_CTS_TCK_PHASE                                     0x20
  // (ReadWrite, Bits 7) 
  // Selects tdm_lclk phase.   0 - Original phase; the same as it comes out of PLL (default) 1 - Invert tdm_lclk: change its phase 180 degrees
  #define BIT_MSK__CLKPHASE1__REG_TDM_LCLK_PHASE                                    0x80

// Banner Power Down Enable Register
#define REG_ADDR__PD_REG                                                 (TOP | 0x0009)
  // (ReadWrite, Bits 3) 
  // Gate off mhl1/2/3 clock. Active low. Default 0.
  #define BIT_MSK__PD_REG__REG_PD_MHL_CLK_N                                      0x08
  // (ReadWrite, Bits 4) 
  // Gate off pclk. Active low. Default 0.
  #define BIT_MSK__PD_REG__REG_PDIDCK_N                                          0x10
  // (ReadWrite, Bits 5) 
  // Gate off Data Island packet clock. Active low. Default 0.
  #define BIT_MSK__PD_REG__REG_PD_DIPKT_CLK_N                                    0x20
  // (ReadWrite, Bits 6) 
  // Clock gating enable to MHL TX logic (Cypress MHL)
  #define BIT_MSK__PD_REG__REG_PD_MHL_TX                                         0x40
  // (ReadWrite, Bits 7) 
  // Clock gating enable to HDCP2X logic (Valid for both RX and TX HDCP2X logic)
  #define BIT_MSK__PD_REG__REG_PD_HDCP2X                                         0x80

// Banner I2C Slave Address Register
#define REG_ADDR__I2C_SLV_ADDR                                           (TOP | 0x000A)
  // (ReadWrite, Bits 7:0) 
  // I2C slave address register
  #define BIT_MSK__I2C_SLV_ADDR__REG_I2C_SLV_ADDR                                      0xFF

// Banner MPI Timeout Count #0 Register
#define REG_ADDR__MPI_TIMEOUT_CNT0                                       (TOP | 0x000B)
  // (ReadWrite, Bits 7:0) 
  // MPI Timeout count Lower Byte Assume 10us is the maximum allowed time out period then set this signals as 10'd300 for 30MHz reference clock (mpi_clk)  (1 / 30M) * 300 = 10usec
  #define BIT_MSK__MPI_TIMEOUT_CNT0__REG_MPI_TIMEOUT_CNT_B7_B0                             0xFF

// Banner MPI Timeout Count #1 Register
#define REG_ADDR__MPI_TIMEOUT_CNT1                                       (TOP | 0x000C)
  // (ReadWrite, Bits 7:0) 
  // MPI Timeout count MSB Byte Assume 10us is the maximum allowed time out period then set this signals as 10'd300 for 30MHz reference clock (mpi_clk)  (1 / 30M) * 300 = 10usec
  #define BIT_MSK__MPI_TIMEOUT_CNT1__REG_MPI_TIMEOUT_CNT_B15_B8                            0xFF

// Banner I2C Timeout Count LOW Register
#define REG_ADDR__I2C_TIMEOUT_CNT0                                       (TOP | 0x000D)
  // (ReadWrite, Bits 7:0) 
  // I2C Timeout Count Lower Byte
  #define BIT_MSK__I2C_TIMEOUT_CNT0__REG_I2C_TIMEOUT_CNT_B7_B0                             0xFF

// Banner I2C Timeout Count HIGH Register
#define REG_ADDR__I2C_TIMEOUT_CNT1                                       (TOP | 0x000E)
  // (ReadWrite, Bits 7:0) 
  // I2C Timeout Count Upper Byte
  #define BIT_MSK__I2C_TIMEOUT_CNT1__REG_I2C_TIMEOUT_CNT_B15_B8                            0xFF

// Banner SPI Timeout Count LOW Register
#define REG_ADDR__SPI_TIMEOUT_CNT0                                       (TOP | 0x000F)
  // (ReadWrite, Bits 7:0) 
  // SPI Timeout Count Lower Byte
  #define BIT_MSK__SPI_TIMEOUT_CNT0__REG_SPI_TIMEOUT_CNT_B7_B0                             0xFF

// Banner SPI Timeout Count HIGH Register
#define REG_ADDR__SPI_TIMEOUT_CNT1                                       (TOP | 0x0010)
  // (ReadWrite, Bits 7:0) 
  // I2C Timeout Count Upper Byte
  #define BIT_MSK__SPI_TIMEOUT_CNT1__REG_SPI_TIMEOUT_CNT_B15_B8                            0xFF

// Banner MPI Source Select Register
#define REG_ADDR__MPI_SRC_SEL                                            (TOP | 0x0011)
  // (ReadWrite, Bits 1:0) 
  // MPI source0 select 00 : I2C source (default) 01 : SPI source Others : unused  Drives SRC0 onto PRIF0
  #define BIT_MSK__MPI_SRC_SEL__REG_MPI_SRC0_SEL                                      0x03
  // (ReadWrite, Bits 3:2) 
  // MPI source0 select 00 : I2C source 01 : SPI source (default) Others : unused  Drives SRC1 onto PRIF1
  #define BIT_MSK__MPI_SRC_SEL__REG_MPI_SRC1_SEL                                      0x0C

// Function Select Register
#define REG_ADDR__FUNC_SEL                                               (TOP | 0x0012)
  // (ReadWrite, Bits 0) 
  // Enable HDMI for Tx Setting this bit enables the HDMI mode output in TX (Cypress). Setting this bit and FUNC_SEL[1] is illegal.
  #define BIT_MSK__FUNC_SEL__REG_TX_HDMI_EN                                        0x01
  // (ReadWrite, Bits 1) 
  // Enable MHL3 for Tx Setting this bit enables the MHL3 mode output in TX (Cypress). To keep the TX in MHL2 mode reset this bit. Setting this bit and FUNC_SEL[0] is illegal.
  #define BIT_MSK__FUNC_SEL__REG_TX_MHL3_EN                                        0x02
  // (ReadWrite, Bits 2) 
  // Enable 60KHz CBUS Discovery 1 : 60KHz is used by discovery logic 0 : 30MHz is used by discovery logic (default)
  #define BIT_MSK__FUNC_SEL__REG_DISCMODE_60K_SEL                                  0x04
  // (ReadWrite, Bits 3) 
  // Select single slice or two slice operation depending on resolution 0: single slice operation 1: two slice operation
  #define BIT_MSK__FUNC_SEL__REG_DSC_ENC_SLICE_OPERATION                           0x08
  // (ReadWrite, Bits 4) 
  // Enable DSC Encoder 0 : DSC Encoder in bypassed (default) 1 : DSC Encoder enabled
  #define BIT_MSK__FUNC_SEL__REG_DSC_ENC_EN                                        0x10
  // (ReadWrite, Bits 5) 
  // Control to select /2 or /3 compression. This bit is valid only when reg_dsc_enc_en is set. 0 : Output stream of DSC encoder is /2 of input stream 1 : Output stream of DSC encoder is /3 of input stream
  #define BIT_MSK__FUNC_SEL__REG_DSC_ENC_OUT_MODE                                  0x20
  // (ReadWrite, Bits 6) 
  // Enable to set 420 upsampling 0 : Input to Banner is in 420 mode and no need to convert it to either 422 or 444 1 : Input to Banner is in 420 mode and need to convert it to either 422 or 444
  #define BIT_MSK__FUNC_SEL__REG_420_UPSMPL_EN                                     0x40
  // (ReadWrite, Bits 7) 
  // Enables DSC 420 mode enable Setting this signal will assert format conversion required by DSC encoder incase of 420 input 0 : Normal operation (default) 1 : DSC 420 mode enable (Output of dsc_enc_420_wrap.sv output is connected to dsc_enc instead of direct pixel input)
  #define BIT_MSK__FUNC_SEL__REG_DSC_420_MODE_EN                                   0x80

// Banner MISC #0 Register
#define REG_ADDR__MISC0_REG                                              (TOP | 0x0013)
  // (ReadWrite, Bits 0) 
  // Edge select for SPI MOSI. 1'b0: MOSI is latched by the rising edge of spi_sclk 1'b1: MOSI is latched by the falling edge of spi_sclk
  #define BIT_MSK__MISC0_REG__REG_SPI_MOSI_EDGE                                     0x01
  // (ReadWrite, Bits 1) 
  // Edge select for SPI MISO.  1'b0: MISO is launched by the falling edge of spi_sclk 1'b1: MISO is launched by the rising edge of spi_sclk
  #define BIT_MSK__MISC0_REG__REG_SPI_MISO_EDGE                                     0x02
  // (ReadWrite, Bits 7:3) 
  // [0]:  bypass MIF Clock [1]:  bypass MHL Clock [2]:  bypass TX FB Clock [3]:  bypass TX REF Clock [4]:  bypass TX TCLKNX Clock
  #define BIT_MSK__MISC0_REG__REG_BYPASS_PLL_CLK                                    0xF8

// Banner MISC #1 Register
#define REG_ADDR__MISC1_REG                                              (TOP | 0x0014)
  // (ReadWrite, Bits 1:0) 
  // OCLK Divide 00: by 2 (default); 01; by 4; 10: by 8; 11: by 16
  #define BIT_MSK__MISC1_REG__REG_OCLKDIV                                           0x03
  // (ReadWrite, Bits 2) 
  // RX HDCP2X ROM Signature out select 0 : Signature out of Lower Half ROM will be selected 1 : Signature out of Upper Half ROM will be selected
  #define BIT_MSK__MISC1_REG__REG_RHDCP_MBIST_SOUT_SEL                              0x04
  // (ReadWrite, Bits 3) 
  // TX PLL source reference clock selection. 0: from DPLL (default) 1: from HDMI RX Core 
  #define BIT_MSK__MISC1_REG__REG_PCLK_REF_SEL                                      0x08
  // (ReadWrite, Bits 4) 
  // rclk clock selection. 0: from DPLL (default) 1: from HDMI RX Core 
  #define BIT_MSK__MISC1_REG__REG_RCLK_REF_SEL                                      0x10
  // (ReadWrite, Bits 5) 
  // Enable I2C communicate with EMSC instead of SPI
  #define BIT_MSK__MISC1_REG__REG_I2C_TO_EMSC_EN                                    0x20
  // (ReadWrite, Bits 7:6) 
  // I2C filter select This register is used to select filtering on CSCL / CSDA
  #define BIT_MSK__MISC1_REG__REG_I2C_FILT_SEL                                      0xC0

// Banner Config #0 Register
#define REG_ADDR__BANNER_CONFIG0                                         (TOP | 0x0015)
  // (ReadWrite, Bits 0) 
  // CoC snoop mode enable
  #define BIT_MSK__BANNER_CONFIG0__REG_COC_SNOOP_MODE_EN                                 0x01
  // (ReadWrite, Bits 2:1) 
  // DDC filter select This register is used to select filtering on RX_DSCL / RX_DSDA / TX_DSCL / TX_DSDA
  #define BIT_MSK__BANNER_CONFIG0__REG_DDC_FILT_SEL                                      0x06
  // (ReadWrite, Bits 3) 
  // HDCP encription enable. Effects only when reg_hdcp_enc_en_ovr is set. 0 : Encryption is disabled 1 : Encryption is enabled
  #define BIT_MSK__BANNER_CONFIG0__REG_HDCP_ENC_EN                                       0x08
  // (ReadWrite, Bits 4) 
  // HDCP encription enable SW ovrewrite.
  #define BIT_MSK__BANNER_CONFIG0__REG_HDCP_ENC_EN_OVR                                   0x10
  // (ReadWrite, Bits 5) 
  // Pass the actual source clock instead of divided clock 0 : Pass the divided clock 1 : Pass the clock before divider
  #define BIT_MSK__BANNER_CONFIG0__REG_PASS_SRC_CLK                                      0x20
  // (ReadWrite, Bits 6) 
  // Loop back BIST enable
  #define BIT_MSK__BANNER_CONFIG0__REG_LB_BIST_EN                                        0x40
  // (ReadWrite, Bits 7) 
  // Loop back BIST encryption Bypass enable
  #define BIT_MSK__BANNER_CONFIG0__REG_LB_BIST_ENC_BYP                                   0x80

// Banner Config #1 Register
#define REG_ADDR__BANNER_CONFIG1                                         (TOP | 0x0016)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__BANNER_CONFIG1__REG_TX_IPREG_RST0                                     0xFF

// Banner Config #2 Register
#define REG_ADDR__BANNER_CONFIG2                                         (TOP | 0x0017)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__BANNER_CONFIG2__REG_TX_IPREG_RST1                                     0xFF

// Banner Config #3 Register
#define REG_ADDR__BANNER_CONFIG3                                         (TOP | 0x0018)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__BANNER_CONFIG3__REG_TX_IPREG_RST2                                     0xFF

// Banner Config #4 Register
#define REG_ADDR__BANNER_CONFIG4                                         (TOP | 0x0019)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__BANNER_CONFIG4__REG_TX_IPREG_RST3                                     0xFF

// Banner Status #0 Register
#define REG_ADDR__BANNER_STATUS0                                         (TOP | 0x001A)
  // (ReadOnly, Bits 0) 
  // I2C access time out error
  #define BIT_MSK__BANNER_STATUS0__REG_I2C_TOUT_ERR                                      0x01
  // (ReadOnly, Bits 1) 
  // SPI access time out error
  #define BIT_MSK__BANNER_STATUS0__REG_SPI_TOUT_ERR                                      0x02
  // (ReadOnly, Bits 3:2) 
  // I2C error
  #define BIT_MSK__BANNER_STATUS0__REG_I2C_ERROR                                         0x0C
  // (ReadOnly, Bits 5:4) 
  // SPI error
  #define BIT_MSK__BANNER_STATUS0__REG_SPI_ERROR                                         0x30
  // (ReadOnly, Bits 6) 
  // SPI access opcode error
  #define BIT_MSK__BANNER_STATUS0__REG_SPI_OPCODE_ERR                                    0x40
  // (ReadOnly, Bits 7) 
  // SPI access prefetch error
  #define BIT_MSK__BANNER_STATUS0__REG_SPI_PREFETCH_ERR                                  0x80

// Banner Power Down Enable #1 Register
#define REG_ADDR__PD_REG1                                                (TOP | 0x001B)
  // (ReadWrite, Bits 0) 
  // Re-auth request for HDCP2 TX. Used to wakeup HDCP2x authentication engine when in power down.
  #define BIT_MSK__PD_REG1__REG_HDCP2TX_REAUTH_REQ                                0x01
  // (ReadWrite, Bits 1) 
  // Power Down enable control for 420 mode memories. Setting this will assert Power Down of 420 (video upsampling) memories.
  #define BIT_MSK__PD_REG1__REG_420_MEM_PD_EN                                     0x02
  // (ReadWrite, Bits 2) 
  // DSC Encoder Power Down enable control. Setting this will assert Power Down of DSC Encoder Logic and Memories.
  #define BIT_MSK__PD_REG1__REG_DSC_ENC_PD_EN                                     0x04

// I2C Tine Out Register Address Lower Byte Register
#define REG_ADDR__I2C_TOUR_REG_ADDR0                                     (TOP | 0x001C)
  // (ReadOnly, Bits 7:0) 
  // Upper Byte address value of I2C Timeout register
  #define BIT_MSK__I2C_TOUR_REG_ADDR0__REG_I2C_TOUT_ADDR_B7_B0                               0xFF

// I2C Tine Out Register Address Upper Byte Register
#define REG_ADDR__I2C_TOUR_REG_ADDR1                                     (TOP | 0x001D)
  // (ReadOnly, Bits 7:0) 
  // Upper Byte address value of I2C Timeout register
  #define BIT_MSK__I2C_TOUR_REG_ADDR1__REG_I2C_TOUT_ADDR_B15_B8                              0xFF

// SPI Tine Out Register Address Lower Byte Register
#define REG_ADDR__SPI_TOUR_REG_ADDR0                                     (TOP | 0x001E)
  // (ReadOnly, Bits 7:0) 
  // Upper Byte address value of SPI Timeout register
  #define BIT_MSK__SPI_TOUR_REG_ADDR0__REG_SPI_TOUT_ADDR_B7_B0                               0xFF

// SPI Tine Out Register Address Upper Byte Register
#define REG_ADDR__SPI_TOUR_REG_ADDR1                                     (TOP | 0x001F)
  // (ReadOnly, Bits 7:0) 
  // Upper Byte address value of SPI Timeout register
  #define BIT_MSK__SPI_TOUR_REG_ADDR1__REG_SPI_TOUT_ADDR_B15_B8                              0xFF

// HDCP2X Config Register
#define REG_ADDR__HDCP2X_DDC_CONFIG                                      (TOP | 0x0020)
  // (ReadWrite, Bits 0) 
  // 
  #define BIT_MSK__HDCP2X_DDC_CONFIG__RI_PROG_DONE                                          0x01
  // (ReadWrite, Bits 1) 
  // 
  #define BIT_MSK__HDCP2X_DDC_CONFIG__RI_HDCP2X_PROG_EN_SW                                  0x02
  // (ReadWrite, Bits 2) 
  // 
  #define BIT_MSK__HDCP2X_DDC_CONFIG__RI_DDC_BYPASS_OVRD_EN                                 0x04
  // (ReadWrite, Bits 3) 
  // 
  #define BIT_MSK__HDCP2X_DDC_CONFIG__RI_DDC_BYPASS_OVRD_VAL                                0x08

// HDCP2X Threshold #1 Register
#define REG_ADDR__HDCP2X_THRESH0                                         (TOP | 0x0021)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__HDCP2X_THRESH0__RI_HDCP2X_THRESH_B7_B0                                0xFF

// HDCP2X Threshold #2 Register
#define REG_ADDR__HDCP2X_THRESH1                                         (TOP | 0x0022)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__HDCP2X_THRESH1__RI_HDCP2X_THRESH_B15_B8                               0xFF

// SPI DUMMY BYTE Register
#define REG_ADDR__SPI_DUMMY_BYTE                                         (TOP | 0x0023)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SPI_DUMMY_BYTE__RI_SPI_DUMMY_BYTE                                     0xFF

// DACR Control Register
#define REG_ADDR__DACR_CTRL_REG                                          (TOP | 0x0024)
  // (ReadWrite, Bits 0) 
  // Control to select the clock between audio clock and fine audio clock outputs of DACR. 0 : Uses normal Audio clock output. 1 : Uses Fine Audio clock output (default)
  #define BIT_MSK__DACR_CTRL_REG__REG_USE_FINE_MCLK                                     0x01
  // (ReadWrite, Bits 1) 
  // Soft reset control to DACR logic of Banner. 1 - Reset 0 - Normal operation (default).
  #define BIT_MSK__DACR_CTRL_REG__REG_DACR_SW_RST                                       0x02
  // (ReadWrite, Bits 4) 
  // DACR start pulse
  #define BIT_MSK__DACR_CTRL_REG__REG_DACR_INIT                                         0x10
  // (ReadWrite, Bits 6:5) 
  // DACR FM value 00 : fs * 128 01 : fs * 256 10 : fs * 192 11 : fs * 512
  #define BIT_MSK__DACR_CTRL_REG__REG_DACR_FM_VAL                                       0x60

// Banner Status #1 Register
#define REG_ADDR__BANNER_STATUS1                                         (TOP | 0x0025)
  // (ReadOnly, Bits 0) 
  // TX PHY RX_SENSE_N status 
  #define BIT_MSK__BANNER_STATUS1__REG_TX_RSENSE_N                                       0x01
  // (ReadOnly, Bits 1) 
  // TX PHY RX_SENSE_P status 
  #define BIT_MSK__BANNER_STATUS1__REG_TX_RSENSE_P                                       0x02

// Banner Config #5 Register
#define REG_ADDR__BANNER_CONFIG5                                         (TOP | 0x0026)
  // (ReadWrite, Bits 0) 
  // Enable to select the XTAL clock for video path registers' access. 0: Uses Oscillator (60MHz/2 = 30MHZ) for registers access 1: Uses Crystal (24MHz) for registers access
  #define BIT_MSK__BANNER_CONFIG5__REG_USE_XTAL_FOR_VIDREG_EN                            0x01
  // (ReadWrite, Bits 1) 
  // Enable to select the XTAL clock for Zone control logic. 0: Uses 5MHz Oscillator clock for Zone VCO operation 1: Uses 6MHz clock derived from Crystal (24MHz/4) for Zone VCO operation (need to change the counters accordingly)
  #define BIT_MSK__BANNER_CONFIG5__REG_USE_XTAL_FOR_ZONEVCO_EN                           0x02
  // (ReadWrite, Bits 3) 
  // Setting this bit will enable Deep-Color input bypass. 0 : Deep-Color data will be processed (Default) 1 : Deep-Color data will be bypassed (no-processing)
  #define BIT_MSK__BANNER_CONFIG5__REG_DC_BYPASS                                         0x08
  // (ReadWrite, Bits 4) 
  // Setting this bit will enable path from RX (eSally) REFCK to TX (harry_banner) PXL_CLK.
  #define BIT_MSK__BANNER_CONFIG5__REG_RXREF_TO_TXPXL_SEL                                0x10
  // (ReadWrite, Bits 5) 
  // Setting this bit will enable path from RX (eSally) DIV5OUT to TX (harry_banner) PXL_CLK.
  #define BIT_MSK__BANNER_CONFIG5__REG_RXDIV5_TO_TXPXL_SEL                               0x20
  // (ReadWrite, Bits 7) 
  // Setting this bit will gate the pixel clock input of TX (harry_banner). Active LOW signal. 0 : Clock gating enabled 1 : Clock gating disabled (Default)
  #define BIT_MSK__BANNER_CONFIG5__REG_TXPXL_CLK_PD_N                                    0x80

// Banner Software Reset #5 Register
#define REG_ADDR__SW_RST_REG5                                            (TOP | 0x0027)
  // (ReadWrite, Bits 0) 
  // SW reset to RX Zone control loogic 0 - Disable (default) 1 - Enable
  #define BIT_MSK__SW_RST_REG5__REG_RXZONE_SW_RST                                     0x01
  // (ReadWrite, Bits 1) 
  // SW reset to TX Zone control loogic 0 - Disable (default) 1 - Enable
  #define BIT_MSK__SW_RST_REG5__REG_TXZONE_SW_RST                                     0x02
  // (ReadWrite, Bits 2) 
  // Disable control for the assertion of SW reset to RX zone control logic when CKDT is lost 0 - Disable (default) 1 - Enable
  #define BIT_MSK__SW_RST_REG5__REG_RXZONE_CKDT_RST_DIS                               0x04
  // (ReadWrite, Bits 3) 
  // Disable control for the assertion of SW reset to TX zone control logic when CKDT is lost 0 - Disable (default) 1 - Enable
  #define BIT_MSK__SW_RST_REG5__REG_TXZONE_CKDT_RST_DIS                               0x08

// Banner Interrupt Control Register
#define REG_ADDR__INTR_CTRL                                              (TOP | 0x0040)
  // (ReadWrite, Bits 0) 
  // Interrupt Polarity 0 : Positive 1 : Negative (Default) Note: IP level (Sherman/Cypress) interrupt polarity should be unchanged. This top level polarity control should be used to change the output interrupt polarity.
  #define BIT_MSK__INTR_CTRL__REG_INTR_POLARITY                                     0x01
  // (ReadWrite, Bits 1) 
  // Interrupt Opendrain
  #define BIT_MSK__INTR_CTRL__REG_INTR_OPENDRAIN                                    0x02
  // (ReadOnly, Bits 2) 
  // Interrupt status
  #define BIT_MSK__INTR_CTRL__REG_INTR_STAT                                         0x04
  // (ReadOnly, Bits 3) 
  // Interrupt level
  #define BIT_MSK__INTR_CTRL__REG_INTR_LEVEL                                        0x08

// Banner Interrupt Status0 Register
#define REG_ADDR__INTR_STAT0                                             (TOP | 0x0041)
  // (ReadOnly, Bits 0) 
  // Sherman Interrupt Status
  #define BIT_MSK__INTR_STAT0__REG_INTR0_STAT0                                       0x01
  // (ReadOnly, Bits 1) 
  // Cypress Interrupt Status
  #define BIT_MSK__INTR_STAT0__REG_INTR0_STAT1                                       0x02
  // (ReadOnly, Bits 2) 
  // DPLL Interrupt Status
  #define BIT_MSK__INTR_STAT0__REG_INTR0_STAT2                                       0x04
  // (ReadOnly, Bits 3) 
  // COC Interrupt Status
  #define BIT_MSK__INTR_STAT0__REG_INTR0_STAT3                                       0x08
  // (ReadOnly, Bits 4) 
  // RX New Zone VCO Interrupt Status
  #define BIT_MSK__INTR_STAT0__REG_INTR0_STAT4                                       0x10
  // (ReadWrite, Bits 5) 
  // RX New Zone PLL Locked Interrupt Status
  #define BIT_MSK__INTR_STAT0__REG_INTR0_STAT5                                       0x20
  // (ReadOnly, Bits 6) 
  // AVLink Interrupt status
  #define BIT_MSK__INTR_STAT0__REG_INTR0_STAT6                                       0x40
  // (ReadWrite, Bits 7) 
  // TX New Zone PLL Locked Interrupt Status
  #define BIT_MSK__INTR_STAT0__REG_INTR0_STAT7                                       0x80

// Banner Interrupt Mask0 Register
#define REG_ADDR__INTR_MASK0                                             (TOP | 0x0042)
  // (ReadWrite, Bits 0) 
  // Sherman Interrupt Mask 0 : Interupt Masked (Default) 1 : Interupt Enabled
  #define BIT_MSK__INTR_MASK0__REG_INTR0_MASK0                                       0x01
  // (ReadWrite, Bits 1) 
  // Cypress Interrupt Mask 0 : Interupt Masked (Default) 1 : Interupt Enabled
  #define BIT_MSK__INTR_MASK0__REG_INTR0_MASK1                                       0x02
  // (ReadWrite, Bits 2) 
  // DPLL Interrupt Mask 0 : Interupt Masked (Default) 1 : Interupt Enabled
  #define BIT_MSK__INTR_MASK0__REG_INTR0_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // COC Interrupt Mask 0 : Interupt Masked (Default) 1 : Interupt Enabled
  #define BIT_MSK__INTR_MASK0__REG_INTR0_MASK3                                       0x08
  // (ReadWrite, Bits 4) 
  // RX New Zone VCO Interrupt Mask 0 : Interupt Masked (Default) 1 : Interupt Enabled
  #define BIT_MSK__INTR_MASK0__REG_INTR0_MASK4                                       0x10
  // (ReadWrite, Bits 5) 
  // RX New Zone PLL Locked Interrupt Mask 0 : Interupt Masked (Default) 1 : Interupt Enabled
  #define BIT_MSK__INTR_MASK0__REG_INTR0_MASK5                                       0x20
  // (ReadWrite, Bits 6) 
  // AV Link wrapper Interrupt Mask 0 : Interupt Masked (Default) 1 : Interupt Enabled
  #define BIT_MSK__INTR_MASK0__REG_INTR0_MASK6                                       0x40
  // (ReadWrite, Bits 7) 
  // TX New Zone PLL Locked Interrupt Mask 0 : Interupt Masked (Default) 1 : Interupt Enabled
  #define BIT_MSK__INTR_MASK0__REG_INTR0_MASK7                                       0x80

// Banner Interrupt Status1 Register
#define REG_ADDR__INTR_STAT1                                             (TOP | 0x0043)
  // (ReadWrite, Bits 0) 
  // KSV Read Done Interrupt
  #define BIT_MSK__INTR_STAT1__REG_INTR1_STAT0                                       0x01
  // (ReadWrite, Bits 1) 
  // GhostFish Key Generation Done Interrupt
  #define BIT_MSK__INTR_STAT1__REG_INTR1_STAT1                                       0x02
  // (ReadWrite, Bits 2) 
  // I2C Error Interrupt
  #define BIT_MSK__INTR_STAT1__REG_INTR1_STAT2                                       0x04
  // (ReadWrite, Bits 3) 
  // SPI Error Interrupt
  #define BIT_MSK__INTR_STAT1__REG_INTR1_STAT3                                       0x08
  // (ReadWrite, Bits 4) 
  // Specifies that a message is written to HDCP2XCORE from DDC wrapper.
  #define BIT_MSK__INTR_STAT1__REG_INTR1_STAT4                                       0x10
  // (ReadWrite, Bits 5) 
  // GPIO0 edge detection interrupt (Rise edge or fall edge depend on reg_gp_ctrl1[0]
  #define BIT_MSK__INTR_STAT1__REG_INTR1_STAT5                                       0x20
  // (ReadWrite, Bits 6) 
  // GPIO1 edge detection interrupt (Rise edge or fall edge depend on reg_gp_ctrl1[1]
  #define BIT_MSK__INTR_STAT1__REG_INTR1_STAT6                                       0x40
  // (ReadWrite, Bits 7) 
  // Specifies that a message is written through DDC. This can be used to enable the power for HDCP2X authentication engine.
  #define BIT_MSK__INTR_STAT1__REG_INTR1_STAT7                                       0x80

// Banner Interrupt Mask1 Register
#define REG_ADDR__INTR_MASK1                                             (TOP | 0x0044)
  // (ReadWrite, Bits 0) 
  // INT1 MASK0
  #define BIT_MSK__INTR_MASK1__REG_INTR1_MASK0                                       0x01
  // (ReadWrite, Bits 1) 
  // INT1 MASK1
  #define BIT_MSK__INTR_MASK1__REG_INTR1_MASK1                                       0x02
  // (ReadWrite, Bits 2) 
  // INT1 MASK2
  #define BIT_MSK__INTR_MASK1__REG_INTR1_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // INT1 MASK3
  #define BIT_MSK__INTR_MASK1__REG_INTR1_MASK3                                       0x08
  // (ReadWrite, Bits 4) 
  // INT1 MASK4
  #define BIT_MSK__INTR_MASK1__REG_INTR1_MASK4                                       0x10
  // (ReadWrite, Bits 5) 
  // INT1 MASK5
  #define BIT_MSK__INTR_MASK1__REG_INTR1_MASK5                                       0x20
  // (ReadWrite, Bits 6) 
  // INT1 MASK6
  #define BIT_MSK__INTR_MASK1__REG_INTR1_MASK6                                       0x40
  // (ReadWrite, Bits 7) 
  // INT1 MASK7
  #define BIT_MSK__INTR_MASK1__REG_INTR1_MASK7                                       0x80

// Banner Interrupt Status2 Register
#define REG_ADDR__INTR_STAT2                                             (TOP | 0x0045)
  // (ReadWrite, Bits 0) 
  // DSC Encoder PD ON Interrupt. Write 1 t clear.
  #define BIT_MSK__INTR_STAT2__REG_INTR2_STAT0                                       0x01
  // (ReadWrite, Bits 1) 
  // MHL TX PD ON Interrupt. Write 1 t clear.
  #define BIT_MSK__INTR_STAT2__REG_INTR2_STAT1                                       0x02
  // (ReadWrite, Bits 2) 
  // HDCP2X Authentication Engine PD ON Interrupt. Write 1 t clear.
  #define BIT_MSK__INTR_STAT2__REG_INTR2_STAT2                                       0x04
  // (ReadWrite, Bits 3) 
  // Video Upsampling PD ON Interrupt. Write 1 t clear.
  #define BIT_MSK__INTR_STAT2__REG_INTR2_STAT3                                       0x08
  // (ReadWrite, Bits 4) 
  // DSC Encoder PD OFF Interrupt. Write 1 t clear.
  #define BIT_MSK__INTR_STAT2__REG_INTR2_STAT4                                       0x10
  // (ReadWrite, Bits 5) 
  // MHL TX PD OFF Interrupt. Write 1 t clear.
  #define BIT_MSK__INTR_STAT2__REG_INTR2_STAT5                                       0x20
  // (ReadWrite, Bits 6) 
  // HDCP2X Authentication Engine PD OFF Interrupt. Write 1 t clear.
  #define BIT_MSK__INTR_STAT2__REG_INTR2_STAT6                                       0x40
  // (ReadWrite, Bits 7) 
  // Video Upsampling PD OFF Interrupt. Write 1 t clear.
  #define BIT_MSK__INTR_STAT2__REG_INTR2_STAT7                                       0x80

// Banner Interrupt Mask2 Register
#define REG_ADDR__INTR_MASK2                                             (TOP | 0x0046)
  // (ReadWrite, Bits 0) 
  // INT2 MASK0
  #define BIT_MSK__INTR_MASK2__REG_INTR2_MASK0                                       0x01
  // (ReadWrite, Bits 1) 
  // INT2 MASK1
  #define BIT_MSK__INTR_MASK2__REG_INTR2_MASK1                                       0x02
  // (ReadWrite, Bits 2) 
  // INT2 MASK2
  #define BIT_MSK__INTR_MASK2__REG_INTR2_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // INT2 MASK3
  #define BIT_MSK__INTR_MASK2__REG_INTR2_MASK3                                       0x08
  // (ReadWrite, Bits 4) 
  // INT2 MASK4
  #define BIT_MSK__INTR_MASK2__REG_INTR2_MASK4                                       0x10
  // (ReadWrite, Bits 5) 
  // INT2 MASK5
  #define BIT_MSK__INTR_MASK2__REG_INTR2_MASK5                                       0x20
  // (ReadWrite, Bits 6) 
  // INT2 MASK6
  #define BIT_MSK__INTR_MASK2__REG_INTR2_MASK6                                       0x40
  // (ReadWrite, Bits 7) 
  // INT2 MASK7
  #define BIT_MSK__INTR_MASK2__REG_INTR2_MASK7                                       0x80

// Banner Interrupt Status and Mask3 Register
#define REG_ADDR__INTR_STAT_MASK3                                        (TOP | 0x0047)
  // (ReadWrite, Bits 0) 
  // CBUS0 Rground interrupt. Asserted on LOW to HIGH transition on cbus0_rgnd signal. Write 1 t clear.
  #define BIT_MSK__INTR_STAT_MASK3__REG_INTR3_STAT0                                       0x01
  // (ReadWrite, Bits 1) 
  // CBUS1 Rground interrupt. Asserted on LOW to HIGH transition on cbus1_rgnd signal. Write 1 t clear.
  #define BIT_MSK__INTR_STAT_MASK3__REG_INTR3_STAT1                                       0x02
  // (ReadWrite, Bits 2) 
  // CBUS0 Level High to Low change interrupt. Asserted on HIGH to LOW transition on cbus0_level. Write 1 t clear.
  #define BIT_MSK__INTR_STAT_MASK3__REG_INTR3_STAT2                                       0x04
  // (ReadWrite, Bits 3) 
  // CBUS1 Level High to Low change interrupt. Asserted on HIGH to LOW transition on cbus1_level. Write 1 t clear.
  #define BIT_MSK__INTR_STAT_MASK3__REG_INTR3_STAT3                                       0x08
  // (ReadWrite, Bits 4) 
  // INT3 MASK0
  #define BIT_MSK__INTR_STAT_MASK3__REG_INTR3_MASK0                                       0x10
  // (ReadWrite, Bits 5) 
  // INT3 MASK1
  #define BIT_MSK__INTR_STAT_MASK3__REG_INTR3_MASK1                                       0x20
  // (ReadWrite, Bits 6) 
  // INT3 MASK2
  #define BIT_MSK__INTR_STAT_MASK3__REG_INTR3_MASK2                                       0x40
  // (ReadWrite, Bits 7) 
  // INT3 MASK3
  #define BIT_MSK__INTR_STAT_MASK3__REG_INTR3_MASK3                                       0x80

// Banner OTP Control #1 Register
#define REG_ADDR__OTP_MUTE_CTRL                                          (TOP | 0x0048)
  // (ReadWrite, Bits 0) 
  // SW OTP HDCP 1.4 and 2.x Audio Mute Override set bit
  #define BIT_MSK__OTP_MUTE_CTRL__REG_OTPAMUTEOVR_SET                                   0x01
  // (ReadWrite, Bits 1) 
  // SW OTP HDCP 1.4 and 2.x  Audio Drop Override set bit
  #define BIT_MSK__OTP_MUTE_CTRL__REG_OTPADROPOVR_SET                                   0x02
  // (ReadWrite, Bits 2) 
  // SW OTP HDCP 1.4 and 2.x Video Mute Override set bit
  #define BIT_MSK__OTP_MUTE_CTRL__REG_OTPVMUTEOVR_SET                                   0x04
  // (ReadWrite, Bits 4) 
  // Enable bit to let SW override OTP HDCP2.x Audio control. Override value is reg_otpamuteovr_set and reg_otpadropovr_set. These 2 bits can not be both 1.
  #define BIT_MSK__OTP_MUTE_CTRL__REG_OTP2XAOVR_EN                                      0x10
  // (ReadWrite, Bits 5) 
  // Enable bit to let SW override OTP HDCP2.x Video control. Override value is reg_otpvmuteovr_set.
  #define BIT_MSK__OTP_MUTE_CTRL__REG_OTP2XVOVR_EN                                      0x20
  // (ReadWrite, Bits 6) 
  // Enable bit to let SW override OTP HDCP1.4 Audio control. Override value is reg_otpamuteovr_set and reg_otpadropovr_set. These 2 bits can not be both 1.
  #define BIT_MSK__OTP_MUTE_CTRL__REG_OTP14AOVR_EN                                      0x40
  // (ReadWrite, Bits 7) 
  // Enable bit to let SW override OTP HDCP1.4 Video control. Override value is reg_otpvmuteovr_set.
  #define BIT_MSK__OTP_MUTE_CTRL__REG_OTP14VOVR_EN                                      0x80

// Banner OTP Control #1 Register
#define REG_ADDR__OTP_CTRL1_REG                                          (TOP | 0x0049)
  // (ReadWrite, Bits 0) 
  // Ghost fish enable (for HDCP1.4 RX/TX key generation)
  #define BIT_MSK__OTP_CTRL1_REG__REG_GF_EN                                             0x01
  // (ReadWrite, Bits 1) 
  // NVMI enable. Enables the control logic to access NVMI/OTP data
  #define BIT_MSK__OTP_CTRL1_REG__REG_NVM_EN                                            0x02
  // (ReadWrite, Bits 2) 
  // KSV read enable. Enables the reading both RX and TX KSVs along with other configuration values from OTP.
  #define BIT_MSK__OTP_CTRL1_REG__REG_LD_KSV                                            0x04
  // (ReadWrite, Bits 3) 
  // KSV read done clear. Software clear to the KSV read done flag assrted after the KSV sequence read is completed.
  #define BIT_MSK__OTP_CTRL1_REG__REG_KSV_RD_DONE_CLR                                   0x08
  // (ReadOnly, Bits 7) 
  // Locked status of HDCP1x OTP content
  #define BIT_MSK__OTP_CTRL1_REG__REG_NVMI_LOCKED                                       0x80

// Banner OTP Control #2 Register
#define REG_ADDR__OTP_CTRL2_REG                                          (TOP | 0x004A)
  // (ReadOnly, Bits 0) 
  // OTP status for HDCP Video Mute option. 1 : indicates when HDCP encryption off; video will be blank 0 : indicates when HDCP encryption off; video is sent as-is.
  #define BIT_MSK__OTP_CTRL2_REG__REG_OTP_HDCPVMUTE                                     0x01
  // (ReadOnly, Bits 2:1) 
  // OTP status for HDCP Audio Mute option.  00 indicates when HDCP encryption off; audio is sent as-is. 01 indicates when HDCP encryption off; audio will be blank.  10 indicates when HDCP encryption off; audio related packets or InfoFrames will be dropped.  11 reserved
  #define BIT_MSK__OTP_CTRL2_REG__REG_OTP_HDCPADRPMUT                                   0x06
  // (ReadWrite, Bits 3) 
  // OTP_PS bit
  #define BIT_MSK__OTP_CTRL2_REG__REG_OTP_PS                                            0x08
  // (ReadWrite, Bits 4) 
  // OTP_PD bit
  #define BIT_MSK__OTP_CTRL2_REG__REG_OTP_PD                                            0x10
  // (ReadWrite, Bits 7) 
  // VDDQ enable
  #define BIT_MSK__OTP_CTRL2_REG__REG_VDDQ_EN                                           0x80

// Banner OTP OSC Calibration Status Register
#define REG_ADDR__OTP_OSC_CALIB_STS                                      (TOP | 0x004B)
  // (ReadOnly, Bits 0) 
  // Valid status for OSC Calibration value stored in OTP
  #define BIT_MSK__OTP_OSC_CALIB_STS__REG_OTP_OSC_CALIB_VALID                               0x01
  // (ReadOnly, Bits 5:1) 
  // OSC Calibration value stored in OTP
  #define BIT_MSK__OTP_OSC_CALIB_STS__REG_OTP_OSC_CALIB_VALUE                               0x3E

// Banner HDCP1x RXKEY Read Port Register
#define REG_ADDR__H14_RXKEY_READ_PORT                                    (TOP | 0x004C)
  // (ReadOnly, Bits 7:0) 
  // HDCP1.4 RXKEY SRAM Read Data Port
  #define BIT_MSK__H14_RXKEY_READ_PORT__REG_H14_RXKEY_RDATA                                   0xFF

// Banner HDCP1x TXKEY Read Port Register
#define REG_ADDR__H14_TXKEY_READ_PORT                                    (TOP | 0x004D)
  // (ReadOnly, Bits 7:0) 
  // HDCP1.4 TXKEY SRAM Read Data Port
  #define BIT_MSK__H14_TXKEY_READ_PORT__REG_H14_TXKEY_RDATA                                   0xFF

// Banner OTP Config Byte0 Status Register
#define REG_ADDR__OTP_CFG0_BYTE                                          (TOP | 0x004E)
  // (ReadOnly, Bits 7:0) 
  // Banner OTP Config Byte0 Status Register
  #define BIT_MSK__OTP_CFG0_BYTE__REG_OTP_CONFIG0_BYTE                                  0xFF

// Banner OTP Config Byte1 Status Register
#define REG_ADDR__OTP_CFG1_BYTE                                          (TOP | 0x004F)
  // (ReadOnly, Bits 7:0) 
  // Banner OTP Config Byte1 Status Register
  #define BIT_MSK__OTP_CFG1_BYTE__REG_OTP_CONFIG1_BYTE                                  0xFF

// Banner OTP Config Byte2 Status Register
#define REG_ADDR__OTP_CFG2_BYTE                                          (TOP | 0x0050)
  // (ReadOnly, Bits 7:0) 
  // Banner OTP Config Byte2 Status Register
  #define BIT_MSK__OTP_CFG2_BYTE__REG_OTP_CONFIG2_BYTE                                  0xFF

// Banner OTP Config Byte3 Status Register
#define REG_ADDR__OTP_CFG3_BYTE                                          (TOP | 0x0051)
  // (ReadOnly, Bits 7:0) 
  // Banner OTP Config Byte3 Status Register
  #define BIT_MSK__OTP_CFG3_BYTE__REG_OTP_CONFIG3_BYTE                                  0xFF

// Banner OTP2 CRC Byte0 Register
#define REG_ADDR__OTP1_CRC_BYTE0                                         (TOP | 0x0052)
  // (ReadOnly, Bits 7:0) 
  // Banner OTP2 CRC Byte0 Status Register
  #define BIT_MSK__OTP1_CRC_BYTE0__REG_OTP2_CRC_BYTE0                                    0xFF

// Banner OTP2 CRC Byte1 Register
#define REG_ADDR__OTP1_CRC_BYTE1                                         (TOP | 0x0053)
  // (ReadOnly, Bits 7:0) 
  // Banner OTP2 CRC Byte1 Status Register
  #define BIT_MSK__OTP1_CRC_BYTE1__REG_OTP2_CRC_BYTE1                                    0xFF

// EDID Mbist Register
#define REG_ADDR__EDID_MBIST_REG                                         (TOP | 0x0058)
  // (ReadWrite, Bits 0) 
  // EDID memory bist enable
  #define BIT_MSK__EDID_MBIST_REG__REG_EDID_MBIST_EN                                     0x01
  // (ReadOnly, Bits 1) 
  // EDID memory bist fail status
  #define BIT_MSK__EDID_MBIST_REG__REG_EDID_MBIST_FAIL                                   0x02
  // (ReadOnly, Bits 2) 
  // EDID memory bist error map status
  #define BIT_MSK__EDID_MBIST_REG__REG_EDID_MBIST_ERR                                    0x04
  // (ReadOnly, Bits 3) 
  // EDID memory bist finish status
  #define BIT_MSK__EDID_MBIST_REG__REG_EDID_MBIST_FINISH                                 0x08
  // (ReadWrite, Bits 7:5) 
  // EDID memory bist read-write margin
  #define BIT_MSK__EDID_MBIST_REG__REG_EDID_MBIST_RW_MARGIN                              0xE0

// GhostFish Memory Bist Register
#define REG_ADDR__GF_MBIST_REG                                           (TOP | 0x0059)
  // (ReadWrite, Bits 0) 
  // GF memory bist enable
  #define BIT_MSK__GF_MBIST_REG__REG_GF_MBIST_EN                                       0x01
  // (ReadOnly, Bits 1) 
  // GF memory bist fail status
  #define BIT_MSK__GF_MBIST_REG__REG_GF_MBIST_FAIL                                     0x02
  // (ReadOnly, Bits 2) 
  // GF memory bist error map status
  #define BIT_MSK__GF_MBIST_REG__REG_GF_MBIST_ERR                                      0x04
  // (ReadOnly, Bits 3) 
  // GF memory bist finish status
  #define BIT_MSK__GF_MBIST_REG__REG_GF_MBIST_FINISH                                   0x08
  // (ReadWrite, Bits 7:5) 
  // GF memory bist read-write margin
  #define BIT_MSK__GF_MBIST_REG__REG_GF_MBIST_RW_MARGIN                                0xE0

// GhostFish ROM Bist Register
#define REG_ADDR__GF_ROM_MBIST_REG                                       (TOP | 0x005A)
  // (ReadWrite, Bits 0) 
  // GF ROM memory bist enable
  #define BIT_MSK__GF_ROM_MBIST_REG__REG_GF_ROM_MBIST_EN                                   0x01
  // (ReadOnly, Bits 1) 
  // GF ROM memory bist fail status
  #define BIT_MSK__GF_ROM_MBIST_REG__REG_GF_ROM_MBIST_FAIL                                 0x02
  // (ReadOnly, Bits 2) 
  // GF ROM memory bist shiftEnd status
  #define BIT_MSK__GF_ROM_MBIST_REG__REG_GF_ROM_MBIST_SHIFTEND                             0x04
  // (ReadOnly, Bits 3) 
  // GF ROM memory bist finish status
  #define BIT_MSK__GF_ROM_MBIST_REG__REG_GF_ROM_MBIST_FINISH                               0x08

// EMSC Memory Bist #1 Register
#define REG_ADDR__EMSC_MBIST_REG                                         (TOP | 0x005B)
  // (ReadWrite, Bits 0) 
  // EMSC memory bist enable
  #define BIT_MSK__EMSC_MBIST_REG__REG_EMSC_MBIST_EN                                     0x01
  // (ReadOnly, Bits 1) 
  // EMSC memory bist fail status
  #define BIT_MSK__EMSC_MBIST_REG__REG_EMSC_MBIST_FAIL                                   0x02
  // (ReadOnly, Bits 2) 
  // EMSC memory bist error map status
  #define BIT_MSK__EMSC_MBIST_REG__REG_EMSC_MBIST_ERR                                    0x04
  // (ReadOnly, Bits 3) 
  // EMSC memory bist finish status
  #define BIT_MSK__EMSC_MBIST_REG__REG_EMSC_MBIST_FINISH                                 0x08
  // (ReadWrite, Bits 7:5) 
  // EMSC memory bist read-write margin
  #define BIT_MSK__EMSC_MBIST_REG__REG_EMSC_MBIST_RW_MARGIN                              0xE0

// AIP Memory Bist Register
#define REG_ADDR__AIP_MBIST_REG                                          (TOP | 0x005D)
  // (ReadWrite, Bits 0) 
  // AIP memory bist enable
  #define BIT_MSK__AIP_MBIST_REG__REG_AIP_MBIST_EN                                      0x01
  // (ReadOnly, Bits 1) 
  // AIP memory bist fail status
  #define BIT_MSK__AIP_MBIST_REG__REG_AIP_MBIST_FAIL                                    0x02
  // (ReadOnly, Bits 2) 
  // AIP memory bist error map status
  #define BIT_MSK__AIP_MBIST_REG__REG_AIP_MBIST_ERR                                     0x04
  // (ReadOnly, Bits 3) 
  // AIP memory bist finish status
  #define BIT_MSK__AIP_MBIST_REG__REG_AIP_MBIST_FINISH                                  0x08
  // (ReadWrite, Bits 7:5) 
  // AIP memory bist read-write margin
  #define BIT_MSK__AIP_MBIST_REG__REG_AIP_MBIST_RW_MARGIN                               0xE0

// Video Path Y Memory Bist Register
#define REG_ADDR__VPY_MBIST_REG                                          (TOP | 0x005E)
  // (ReadWrite, Bits 0) 
  // Video Path Y memory bist enable
  #define BIT_MSK__VPY_MBIST_REG__REG_VPY_MBIST_EN                                      0x01
  // (ReadOnly, Bits 1) 
  // Video Path Y memory bist fail status
  #define BIT_MSK__VPY_MBIST_REG__REG_VPY_MBIST_FAIL                                    0x02
  // (ReadOnly, Bits 2) 
  // Video Path Y memory bist error map status
  #define BIT_MSK__VPY_MBIST_REG__REG_VPY_MBIST_ERR                                     0x04
  // (ReadOnly, Bits 3) 
  // Video Path Y memory bist finish status
  #define BIT_MSK__VPY_MBIST_REG__REG_VPY_MBIST_FINISH                                  0x08
  // (ReadWrite, Bits 7:5) 
  // Video Path Y memory bist read-write margin
  #define BIT_MSK__VPY_MBIST_REG__REG_VPY_MBIST_RW_MARGIN                               0xE0

// Video Path Cb Memory Bist Register
#define REG_ADDR__VPCB_MBIST_REG                                         (TOP | 0x005F)
  // (ReadWrite, Bits 0) 
  // Video Path Cb memory bist enable
  #define BIT_MSK__VPCB_MBIST_REG__REG_VPCB_MBIST_EN                                     0x01
  // (ReadOnly, Bits 1) 
  // Video Path Cb memory bist fail status
  #define BIT_MSK__VPCB_MBIST_REG__REG_VPCB_MBIST_FAIL                                   0x02
  // (ReadOnly, Bits 2) 
  // Video Path Cb memory bist error map status
  #define BIT_MSK__VPCB_MBIST_REG__REG_VPCB_MBIST_ERR                                    0x04
  // (ReadOnly, Bits 3) 
  // Video Path Cb memory bist finish status
  #define BIT_MSK__VPCB_MBIST_REG__REG_VPCB_MBIST_FINISH                                 0x08
  // (ReadWrite, Bits 7:5) 
  // Video Path Cb memory bist read-write margin
  #define BIT_MSK__VPCB_MBIST_REG__REG_VPCB_MBIST_RW_MARGIN                              0xE0

// Video Path Cr Memory Bist Register
#define REG_ADDR__VPCR_MBIST_REG                                         (TOP | 0x0060)
  // (ReadWrite, Bits 0) 
  // Video Path Cr memory bist enable
  #define BIT_MSK__VPCR_MBIST_REG__REG_VPCR_MBIST_EN                                     0x01
  // (ReadOnly, Bits 1) 
  // Video Path Cr memory bist fail status
  #define BIT_MSK__VPCR_MBIST_REG__REG_VPCR_MBIST_FAIL                                   0x02
  // (ReadOnly, Bits 2) 
  // Video Path Cr memory bist error map status
  #define BIT_MSK__VPCR_MBIST_REG__REG_VPCR_MBIST_ERR                                    0x04
  // (ReadOnly, Bits 3) 
  // Video Path Cr memory bist finish status
  #define BIT_MSK__VPCR_MBIST_REG__REG_VPCR_MBIST_FINISH                                 0x08
  // (ReadWrite, Bits 7:5) 
  // Video Path Cr memory bist read-write margin
  #define BIT_MSK__VPCR_MBIST_REG__REG_VPCR_MBIST_RW_MARGIN                              0xE0

// Video Path FIFO Memory Bist Register
#define REG_ADDR__VPFIFO_MBIST_REG                                       (TOP | 0x0061)
  // (ReadWrite, Bits 0) 
  // Video Path FIFO memory bist enable
  #define BIT_MSK__VPFIFO_MBIST_REG__REG_VPFIFO_MBIST_EN                                   0x01
  // (ReadOnly, Bits 1) 
  // Video Path FIFO memory bist fail status
  #define BIT_MSK__VPFIFO_MBIST_REG__REG_VPFIFO_MBIST_FAIL                                 0x02
  // (ReadOnly, Bits 2) 
  // Video Path FIFO memory bist error map status
  #define BIT_MSK__VPFIFO_MBIST_REG__REG_VPFIFO_MBIST_ERR                                  0x04
  // (ReadOnly, Bits 3) 
  // Video Path FIFO memory bist finish status
  #define BIT_MSK__VPFIFO_MBIST_REG__REG_VPFIFO_MBIST_FINISH                               0x08
  // (ReadWrite, Bits 7:5) 
  // Video Path FIFO memory bist read-write margin
  #define BIT_MSK__VPFIFO_MBIST_REG__REG_VPFIFO_MBIST_RW_MARGIN                            0xE0

// DSCENC Core #0 Memory Bist #1 Register
#define REG_ADDR__DSCENC_C0_MBIST1_REG                                   (TOP | 0x0062)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Memory1 bist enable
  #define BIT_MSK__DSCENC_C0_MBIST1_REG__REG_DSC_CORE0_1_MBIST_EN                              0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Memory1 bist fail status
  #define BIT_MSK__DSCENC_C0_MBIST1_REG__REG_DSC_CORE0_1_MBIST_FAIL                            0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Memory1 bist error map status
  #define BIT_MSK__DSCENC_C0_MBIST1_REG__REG_DSC_CORE0_1_MBIST_ERR                             0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Memory1 bist finish status
  #define BIT_MSK__DSCENC_C0_MBIST1_REG__REG_DSC_CORE0_1_MBIST_FINISH                          0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Memory1 bist read-write margin
  #define BIT_MSK__DSCENC_C0_MBIST1_REG__REG_DSC_CORE0_1_MBIST_RW_MARGIN                       0xE0

// DSCENC Core #0 Memory Bist #2 Register
#define REG_ADDR__DSCENC_C0_MBIST2_REG                                   (TOP | 0x0063)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Memory2 bist enable
  #define BIT_MSK__DSCENC_C0_MBIST2_REG__REG_DSC_CORE0_2_MBIST_EN                              0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Memory2 bist fail status
  #define BIT_MSK__DSCENC_C0_MBIST2_REG__REG_DSC_CORE0_2_MBIST_FAIL                            0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Memory2 bist error map status
  #define BIT_MSK__DSCENC_C0_MBIST2_REG__REG_DSC_CORE0_2_MBIST_ERR                             0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Memory2 bist finish status
  #define BIT_MSK__DSCENC_C0_MBIST2_REG__REG_DSC_CORE0_2_MBIST_FINISH                          0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Memory2 bist read-write margin
  #define BIT_MSK__DSCENC_C0_MBIST2_REG__REG_DSC_CORE0_2_MBIST_RW_MARGIN                       0xE0

// DSCENC Core #0 Memory Bist #3 Register
#define REG_ADDR__DSCENC_C0_MBIST3_REG                                   (TOP | 0x0064)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Memory3 bist enable
  #define BIT_MSK__DSCENC_C0_MBIST3_REG__REG_DSC_CORE0_3_MBIST_EN                              0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Memory3 bist fail status
  #define BIT_MSK__DSCENC_C0_MBIST3_REG__REG_DSC_CORE0_3_MBIST_FAIL                            0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Memory3 bist error map status
  #define BIT_MSK__DSCENC_C0_MBIST3_REG__REG_DSC_CORE0_3_MBIST_ERR                             0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Memory3 bist finish status
  #define BIT_MSK__DSCENC_C0_MBIST3_REG__REG_DSC_CORE0_3_MBIST_FINISH                          0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Memory3 bist read-write margin
  #define BIT_MSK__DSCENC_C0_MBIST3_REG__REG_DSC_CORE0_3_MBIST_RW_MARGIN                       0xE0

// DSCENC Core #0 Memory Bist #4 Register
#define REG_ADDR__DSCENC_C0_MBIST4_REG                                   (TOP | 0x0065)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Memory4 bist enable
  #define BIT_MSK__DSCENC_C0_MBIST4_REG__REG_DSC_CORE0_4_MBIST_EN                              0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Memory4 bist fail status
  #define BIT_MSK__DSCENC_C0_MBIST4_REG__REG_DSC_CORE0_4_MBIST_FAIL                            0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Memory4 bist error map status
  #define BIT_MSK__DSCENC_C0_MBIST4_REG__REG_DSC_CORE0_4_MBIST_ERR                             0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Memory4 bist finish status
  #define BIT_MSK__DSCENC_C0_MBIST4_REG__REG_DSC_CORE0_4_MBIST_FINISH                          0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Memory4 bist read-write margin
  #define BIT_MSK__DSCENC_C0_MBIST4_REG__REG_DSC_CORE0_4_MBIST_RW_MARGIN                       0xE0

// DSCENC Core #0 Memory Bist #5 Register
#define REG_ADDR__DSCENC_C0_MBIST5_REG                                   (TOP | 0x0066)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Memory5 bist enable
  #define BIT_MSK__DSCENC_C0_MBIST5_REG__REG_DSC_CORE0_5_MBIST_EN                              0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Memory5 bist fail status
  #define BIT_MSK__DSCENC_C0_MBIST5_REG__REG_DSC_CORE0_5_MBIST_FAIL                            0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Memory5 bist error map status
  #define BIT_MSK__DSCENC_C0_MBIST5_REG__REG_DSC_CORE0_5_MBIST_ERR                             0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Memory5 bist finish status
  #define BIT_MSK__DSCENC_C0_MBIST5_REG__REG_DSC_CORE0_5_MBIST_FINISH                          0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Memory5 bist read-write margin
  #define BIT_MSK__DSCENC_C0_MBIST5_REG__REG_DSC_CORE0_5_MBIST_RW_MARGIN                       0xE0

// DSCENC Core #0 Memory Bist #6 Register
#define REG_ADDR__DSCENC_C0_MBIST6_REG                                   (TOP | 0x0067)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Memory6 bist enable
  #define BIT_MSK__DSCENC_C0_MBIST6_REG__REG_DSC_CORE0_6_MBIST_EN                              0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Memory6 bist fail status
  #define BIT_MSK__DSCENC_C0_MBIST6_REG__REG_DSC_CORE0_6_MBIST_FAIL                            0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Memory6 bist error map status
  #define BIT_MSK__DSCENC_C0_MBIST6_REG__REG_DSC_CORE0_6_MBIST_ERR                             0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Memory6 bist finish status
  #define BIT_MSK__DSCENC_C0_MBIST6_REG__REG_DSC_CORE0_6_MBIST_FINISH                          0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Memory6 bist read-write margin
  #define BIT_MSK__DSCENC_C0_MBIST6_REG__REG_DSC_CORE0_6_MBIST_RW_MARGIN                       0xE0

// DSCENC Core #0 Memory Bist #7 Register
#define REG_ADDR__DSCENC_C0_MBIST7_REG                                   (TOP | 0x0068)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Memory7 bist enable
  #define BIT_MSK__DSCENC_C0_MBIST7_REG__REG_DSC_CORE0_7_MBIST_EN                              0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Memory7 bist fail status
  #define BIT_MSK__DSCENC_C0_MBIST7_REG__REG_DSC_CORE0_7_MBIST_FAIL                            0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Memory7 bist error map status
  #define BIT_MSK__DSCENC_C0_MBIST7_REG__REG_DSC_CORE0_7_MBIST_ERR                             0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Memory7 bist finish status
  #define BIT_MSK__DSCENC_C0_MBIST7_REG__REG_DSC_CORE0_7_MBIST_FINISH                          0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Memory7 bist read-write margin
  #define BIT_MSK__DSCENC_C0_MBIST7_REG__REG_DSC_CORE0_7_MBIST_RW_MARGIN                       0xE0

// DSCENC Core #0 Memory Bist #8 Register
#define REG_ADDR__DSCENC_C0_MBIST8_REG                                   (TOP | 0x0069)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Memory8 bist enable
  #define BIT_MSK__DSCENC_C0_MBIST8_REG__REG_DSC_CORE0_8_MBIST_EN                              0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Memory8 bist fail status
  #define BIT_MSK__DSCENC_C0_MBIST8_REG__REG_DSC_CORE0_8_MBIST_FAIL                            0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Memory8 bist error map status
  #define BIT_MSK__DSCENC_C0_MBIST8_REG__REG_DSC_CORE0_8_MBIST_ERR                             0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Memory8 bist finish status
  #define BIT_MSK__DSCENC_C0_MBIST8_REG__REG_DSC_CORE0_8_MBIST_FINISH                          0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Memory8 bist read-write margin
  #define BIT_MSK__DSCENC_C0_MBIST8_REG__REG_DSC_CORE0_8_MBIST_RW_MARGIN                       0xE0

// DSCENC Core #1 Memory Bist #1 Register
#define REG_ADDR__DSCENC_C1_MBIST1_REG                                   (TOP | 0x006A)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Memory1 bist enable
  #define BIT_MSK__DSCENC_C1_MBIST1_REG__REG_DSC_CORE1_1_MBIST_EN                              0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Memory1 bist fail status
  #define BIT_MSK__DSCENC_C1_MBIST1_REG__REG_DSC_CORE1_1_MBIST_FAIL                            0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Memory1 bist error map status
  #define BIT_MSK__DSCENC_C1_MBIST1_REG__REG_DSC_CORE1_1_MBIST_ERR                             0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Memory1 bist finish status
  #define BIT_MSK__DSCENC_C1_MBIST1_REG__REG_DSC_CORE1_1_MBIST_FINISH                          0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Memory1 bist read-write margin
  #define BIT_MSK__DSCENC_C1_MBIST1_REG__REG_DSC_CORE1_1_MBIST_RW_MARGIN                       0xE0

// DSCENC Core #1 Memory Bist #2 Register
#define REG_ADDR__DSCENC_C1_MBIST2_REG                                   (TOP | 0x006B)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Memory2 bist enable
  #define BIT_MSK__DSCENC_C1_MBIST2_REG__REG_DSC_CORE1_2_MBIST_EN                              0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Memory2 bist fail status
  #define BIT_MSK__DSCENC_C1_MBIST2_REG__REG_DSC_CORE1_2_MBIST_FAIL                            0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Memory2 bist error map status
  #define BIT_MSK__DSCENC_C1_MBIST2_REG__REG_DSC_CORE1_2_MBIST_ERR                             0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Memory2 bist finish status
  #define BIT_MSK__DSCENC_C1_MBIST2_REG__REG_DSC_CORE1_2_MBIST_FINISH                          0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Memory2 bist read-write margin
  #define BIT_MSK__DSCENC_C1_MBIST2_REG__REG_DSC_CORE1_2_MBIST_RW_MARGIN                       0xE0

// DSCENC Core #1 Memory Bist #3 Register
#define REG_ADDR__DSCENC_C1_MBIST3_REG                                   (TOP | 0x006C)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Memory3 bist enable
  #define BIT_MSK__DSCENC_C1_MBIST3_REG__REG_DSC_CORE1_3_MBIST_EN                              0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Memory3 bist fail status
  #define BIT_MSK__DSCENC_C1_MBIST3_REG__REG_DSC_CORE1_3_MBIST_FAIL                            0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Memory3 bist error map status
  #define BIT_MSK__DSCENC_C1_MBIST3_REG__REG_DSC_CORE1_3_MBIST_ERR                             0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Memory3 bist finish status
  #define BIT_MSK__DSCENC_C1_MBIST3_REG__REG_DSC_CORE1_3_MBIST_FINISH                          0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Memory3 bist read-write margin
  #define BIT_MSK__DSCENC_C1_MBIST3_REG__REG_DSC_CORE1_3_MBIST_RW_MARGIN                       0xE0

// DSCENC Core #1 Memory Bist #4 Register
#define REG_ADDR__DSCENC_C1_MBIST4_REG                                   (TOP | 0x006D)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Memory4 bist enable
  #define BIT_MSK__DSCENC_C1_MBIST4_REG__REG_DSC_CORE1_4_MBIST_EN                              0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Memory4 bist fail status
  #define BIT_MSK__DSCENC_C1_MBIST4_REG__REG_DSC_CORE1_4_MBIST_FAIL                            0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Memory4 bist error map status
  #define BIT_MSK__DSCENC_C1_MBIST4_REG__REG_DSC_CORE1_4_MBIST_ERR                             0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Memory4 bist finish status
  #define BIT_MSK__DSCENC_C1_MBIST4_REG__REG_DSC_CORE1_4_MBIST_FINISH                          0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Memory4 bist read-write margin
  #define BIT_MSK__DSCENC_C1_MBIST4_REG__REG_DSC_CORE1_4_MBIST_RW_MARGIN                       0xE0

// DSCENC Core #1 Memory Bist #5 Register
#define REG_ADDR__DSCENC_C1_MBIST5_REG                                   (TOP | 0x006E)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Memory5 bist enable
  #define BIT_MSK__DSCENC_C1_MBIST5_REG__REG_DSC_CORE1_5_MBIST_EN                              0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Memory5 bist fail status
  #define BIT_MSK__DSCENC_C1_MBIST5_REG__REG_DSC_CORE1_5_MBIST_FAIL                            0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Memory5 bist error map status
  #define BIT_MSK__DSCENC_C1_MBIST5_REG__REG_DSC_CORE1_5_MBIST_ERR                             0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Memory5 bist finish status
  #define BIT_MSK__DSCENC_C1_MBIST5_REG__REG_DSC_CORE1_5_MBIST_FINISH                          0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Memory5 bist read-write margin
  #define BIT_MSK__DSCENC_C1_MBIST5_REG__REG_DSC_CORE1_5_MBIST_RW_MARGIN                       0xE0

// DSCENC Core #1 Memory Bist #6 Register
#define REG_ADDR__DSCENC_C1_MBIST6_REG                                   (TOP | 0x006F)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Memory6 bist enable
  #define BIT_MSK__DSCENC_C1_MBIST6_REG__REG_DSC_CORE1_6_MBIST_EN                              0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Memory6 bist fail status
  #define BIT_MSK__DSCENC_C1_MBIST6_REG__REG_DSC_CORE1_6_MBIST_FAIL                            0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Memory6 bist error map status
  #define BIT_MSK__DSCENC_C1_MBIST6_REG__REG_DSC_CORE1_6_MBIST_ERR                             0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Memory6 bist finish status
  #define BIT_MSK__DSCENC_C1_MBIST6_REG__REG_DSC_CORE1_6_MBIST_FINISH                          0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Memory6 bist read-write margin
  #define BIT_MSK__DSCENC_C1_MBIST6_REG__REG_DSC_CORE1_6_MBIST_RW_MARGIN                       0xE0

// DSCENC Core #1 Memory Bist #7 Register
#define REG_ADDR__DSCENC_C1_MBIST7_REG                                   (TOP | 0x0070)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Memory7 bist enable
  #define BIT_MSK__DSCENC_C1_MBIST7_REG__REG_DSC_CORE1_7_MBIST_EN                              0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Memory7 bist fail status
  #define BIT_MSK__DSCENC_C1_MBIST7_REG__REG_DSC_CORE1_7_MBIST_FAIL                            0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Memory7 bist error map status
  #define BIT_MSK__DSCENC_C1_MBIST7_REG__REG_DSC_CORE1_7_MBIST_ERR                             0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Memory7 bist finish status
  #define BIT_MSK__DSCENC_C1_MBIST7_REG__REG_DSC_CORE1_7_MBIST_FINISH                          0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Memory7 bist read-write margin
  #define BIT_MSK__DSCENC_C1_MBIST7_REG__REG_DSC_CORE1_7_MBIST_RW_MARGIN                       0xE0

// DSCENC Core #1 Memory Bist #8 Register
#define REG_ADDR__DSCENC_C1_MBIST8_REG                                   (TOP | 0x0071)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Memory8 bist enable
  #define BIT_MSK__DSCENC_C1_MBIST8_REG__REG_DSC_CORE1_8_MBIST_EN                              0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Memory8 bist fail status
  #define BIT_MSK__DSCENC_C1_MBIST8_REG__REG_DSC_CORE1_8_MBIST_FAIL                            0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Memory8 bist error map status
  #define BIT_MSK__DSCENC_C1_MBIST8_REG__REG_DSC_CORE1_8_MBIST_ERR                             0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Memory8 bist finish status
  #define BIT_MSK__DSCENC_C1_MBIST8_REG__REG_DSC_CORE1_8_MBIST_FINISH                          0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Memory8 bist read-write margin
  #define BIT_MSK__DSCENC_C1_MBIST8_REG__REG_DSC_CORE1_8_MBIST_RW_MARGIN                       0xE0

// DSCENC IIF Core #0 Memory Bist  Register
#define REG_ADDR__DSCENC_IIF_C0_MBIST_REG                                (TOP | 0x0072)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Input IF Memory core0 bist enable
  #define BIT_MSK__DSCENC_IIF_C0_MBIST_REG__REG_DSC_IIF_CORE0_MBIST_EN                            0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Input IF Memory core0 bist fail status
  #define BIT_MSK__DSCENC_IIF_C0_MBIST_REG__REG_DSC_IIF_CORE0_MBIST_FAIL                          0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Input IF Memory core0 bist error map status
  #define BIT_MSK__DSCENC_IIF_C0_MBIST_REG__REG_DSC_IIF_CORE0_MBIST_ERR                           0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Input IF Memory core0 bist finish status
  #define BIT_MSK__DSCENC_IIF_C0_MBIST_REG__REG_DSC_IIF_CORE0_MBIST_FINISH                        0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Input IF Memory core0 bist read-write margin
  #define BIT_MSK__DSCENC_IIF_C0_MBIST_REG__REG_DSC_IIF_CORE0_MBIST_RW_MARGIN                     0xE0

// DSCENC IIF Core #1 Memory Bist  Register
#define REG_ADDR__DSCENC_IIF_C1_MBIST_REG                                (TOP | 0x0073)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Input IF Memory core1 bist enable
  #define BIT_MSK__DSCENC_IIF_C1_MBIST_REG__REG_DSC_IIF_CORE1_MBIST_EN                            0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Input IF Memory core1 bist fail status
  #define BIT_MSK__DSCENC_IIF_C1_MBIST_REG__REG_DSC_IIF_CORE1_MBIST_FAIL                          0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Input IF Memory core1 bist error map status
  #define BIT_MSK__DSCENC_IIF_C1_MBIST_REG__REG_DSC_IIF_CORE1_MBIST_ERR                           0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Input IF Memory core1 bist finish status
  #define BIT_MSK__DSCENC_IIF_C1_MBIST_REG__REG_DSC_IIF_CORE1_MBIST_FINISH                        0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Input IF Memory core1 bist read-write margin
  #define BIT_MSK__DSCENC_IIF_C1_MBIST_REG__REG_DSC_IIF_CORE1_MBIST_RW_MARGIN                     0xE0

// DSCENC OIF Memory Bist  Register
#define REG_ADDR__DSCENC_OIF_MBIST_REG                                   (TOP | 0x0074)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Output IF Memory bist enable
  #define BIT_MSK__DSCENC_OIF_MBIST_REG__REG_DSC_OIF_MBIST_EN                                  0x01
  // (ReadOnly, Bits 1) 
  // DSC Encoder Output IF Memory bist fail status
  #define BIT_MSK__DSCENC_OIF_MBIST_REG__REG_DSC_OIF_MBIST_FAIL                                0x02
  // (ReadOnly, Bits 2) 
  // DSC Encoder Output IF Memory bist error map status
  #define BIT_MSK__DSCENC_OIF_MBIST_REG__REG_DSC_OIF_MBIST_ERR                                 0x04
  // (ReadOnly, Bits 3) 
  // DSC Encoder Output IF Memory bist finish status
  #define BIT_MSK__DSCENC_OIF_MBIST_REG__REG_DSC_OIF_MBIST_FINISH                              0x08
  // (ReadWrite, Bits 7:5) 
  // DSC Encoder Output IF Memory bist read-write margin
  #define BIT_MSK__DSCENC_OIF_MBIST_REG__REG_DSC_OIF_MBIST_RW_MARGIN                           0xE0

// HDMI2MHL3 Memory Bist Register
#define REG_ADDR__H2M3_MBIST_REG                                         (TOP | 0x0075)
  // (ReadWrite, Bits 0) 
  // HDMI2MHL3 memory bist enable
  #define BIT_MSK__H2M3_MBIST_REG__REG_H2M3_MBIST_EN                                     0x01
  // (ReadOnly, Bits 1) 
  // HDMI2MHL3 memory bist fail status
  #define BIT_MSK__H2M3_MBIST_REG__REG_H2M3_MBIST_FAIL                                   0x02
  // (ReadOnly, Bits 2) 
  // HDMI2MHL3 memory bist error map status
  #define BIT_MSK__H2M3_MBIST_REG__REG_H2M3_MBIST_ERR                                    0x04
  // (ReadOnly, Bits 3) 
  // HDMI2MHL3 memory bist finish status
  #define BIT_MSK__H2M3_MBIST_REG__REG_H2M3_MBIST_FINISH                                 0x08
  // (ReadWrite, Bits 7:5) 
  // HDMI2MHL3 memory bist read-write margin
  #define BIT_MSK__H2M3_MBIST_REG__REG_H2M3_MBIST_RW_MARGIN                              0xE0

// HDCP2X RX CRAM Memory Bist Register
#define REG_ADDR__RXHDCP_CRAM_MBIST_REG                                  (TOP | 0x0076)
  // (ReadWrite, Bits 0) 
  // RX HDCP Code RAM memory bist enable
  #define BIT_MSK__RXHDCP_CRAM_MBIST_REG__REG_RHDCP_CRAM_MBIST_EN                               0x01
  // (ReadOnly, Bits 1) 
  // RX HDCP Code RAM memory bist fail status
  #define BIT_MSK__RXHDCP_CRAM_MBIST_REG__REG_RHDCP_CRAM_MBIST_FAIL                             0x02
  // (ReadOnly, Bits 2) 
  // RX HDCP Code RAM memory bist error map status
  #define BIT_MSK__RXHDCP_CRAM_MBIST_REG__REG_RHDCP_CRAM_MBIST_ERR                              0x04
  // (ReadOnly, Bits 3) 
  // RX HDCP Code RAM memory bist finish status
  #define BIT_MSK__RXHDCP_CRAM_MBIST_REG__REG_RHDCP_CRAM_MBIST_FINISH                           0x08
  // (ReadWrite, Bits 7:5) 
  // RX HDCP Code RAM memory bist read-write margin
  #define BIT_MSK__RXHDCP_CRAM_MBIST_REG__REG_RHDCP_CRAM_MBIST_RW_MARGIN                        0xE0

// HDCP2X RX IRAM Memory Bist Register
#define REG_ADDR__RXHDCP_IRAM_MBIST_REG                                  (TOP | 0x0077)
  // (ReadWrite, Bits 0) 
  // RX HDCP Internal RAM memory bist enable
  #define BIT_MSK__RXHDCP_IRAM_MBIST_REG__REG_RHDCP_IRAM_MBIST_EN                               0x01
  // (ReadOnly, Bits 1) 
  // RX HDCP Internal RAM memory bist fail status
  #define BIT_MSK__RXHDCP_IRAM_MBIST_REG__REG_RHDCP_IRAM_MBIST_FAIL                             0x02
  // (ReadOnly, Bits 2) 
  // RX HDCP Internal RAM memory bist error map status
  #define BIT_MSK__RXHDCP_IRAM_MBIST_REG__REG_RHDCP_IRAM_MBIST_ERR                              0x04
  // (ReadOnly, Bits 3) 
  // RX HDCP Internal RAM memory bist finish status
  #define BIT_MSK__RXHDCP_IRAM_MBIST_REG__REG_RHDCP_IRAM_MBIST_FINISH                           0x08
  // (ReadWrite, Bits 7:5) 
  // RX HDCP Internal RAM memory bist read-write margin
  #define BIT_MSK__RXHDCP_IRAM_MBIST_REG__REG_RHDCP_IRAM_MBIST_RW_MARGIN                        0xE0

// HDCP2X RX PROM Memory Bist #0 Register
#define REG_ADDR__RXHDCP_PROM_MBIST_REG                                  (TOP | 0x0078)
  // (ReadWrite, Bits 0) 
  // RX HDCP Program ROM memory bist enable
  #define BIT_MSK__RXHDCP_PROM_MBIST_REG__REG_RHDCP_PROM_MBIST_EN                               0x01
  // (ReadOnly, Bits 1) 
  // RX HDCP Program ROM memory bist fail status
  #define BIT_MSK__RXHDCP_PROM_MBIST_REG__REG_RHDCP_PROM_MBIST_FAIL                             0x02
  // (ReadOnly, Bits 2) 
  // RX HDCP Program ROM memory bist shiftEnd status
  #define BIT_MSK__RXHDCP_PROM_MBIST_REG__REG_RHDCP_PROM_MBIST_SHIFTEND                         0x04
  // (ReadOnly, Bits 3) 
  // RX HDCP Program ROM memory bist finish status
  #define BIT_MSK__RXHDCP_PROM_MBIST_REG__REG_RHDCP_PROM_MBIST_FINISH                           0x08
  // (ReadOnly, Bits 7:5) 
  // RX HDCP Program ROM memory bist signature out
  #define BIT_MSK__RXHDCP_PROM_MBIST_REG__REG_RHDCP_PROM_MBIST_SIGNOUT_B2_B0                    0xE0

// HDCP2X TX PROM Memory Bist #1 Register
#define REG_ADDR__RXHDCP_PROM_MBIST_REG1                                 (TOP | 0x0079)
  // (ReadWrite, Bits 7:0) 
  // RX HDCP Program ROM memory bist signature out
  #define BIT_MSK__RXHDCP_PROM_MBIST_REG1__REG_RHDCP_PROM_MBIST_SIGNOUT_B10_B3                   0xFF

// HDCP2X TX PROM Memory Bist #2 Register
#define REG_ADDR__RXHDCP_PROM_MBIST_REG2                                 (TOP | 0x007A)
  // (ReadWrite, Bits 7:0) 
  // RX HDCP Program ROM memory bist signature out
  #define BIT_MSK__RXHDCP_PROM_MBIST_REG2__REG_RHDCP_PROM_MBIST_SIGNOUT_B18_B11                  0xFF

// HDCP2X TX PROM Memory Bist #3 Register
#define REG_ADDR__RXHDCP_PROM_MBIST_REG3                                 (TOP | 0x007B)
  // (ReadWrite, Bits 7:0) 
  // RX HDCP Program ROM memory bist signature out
  #define BIT_MSK__RXHDCP_PROM_MBIST_REG3__REG_RHDCP_PROM_MBIST_SIGNOUT_B26_B19                  0xFF

// HDCP2X TX CRAM Memory Bist Register
#define REG_ADDR__TXHDCP_CRAM_MBIST_REG                                  (TOP | 0x007C)
  // (ReadWrite, Bits 0) 
  // TX HDCP Code RAM memory bist enable
  #define BIT_MSK__TXHDCP_CRAM_MBIST_REG__REG_THDCP_CRAM_MBIST_EN                               0x01
  // (ReadOnly, Bits 1) 
  // TX HDCP Code RAM memory bist fail status
  #define BIT_MSK__TXHDCP_CRAM_MBIST_REG__REG_THDCP_CRAM_MBIST_FAIL                             0x02
  // (ReadOnly, Bits 2) 
  // TX HDCP Code RAM memory bist error map status
  #define BIT_MSK__TXHDCP_CRAM_MBIST_REG__REG_THDCP_CRAM_MBIST_ERR                              0x04
  // (ReadOnly, Bits 3) 
  // TX HDCP Code RAM memory bist finish status
  #define BIT_MSK__TXHDCP_CRAM_MBIST_REG__REG_THDCP_CRAM_MBIST_FINISH                           0x08
  // (ReadWrite, Bits 7:5) 
  // TX HDCP Code RAM memory bist read-write margin
  #define BIT_MSK__TXHDCP_CRAM_MBIST_REG__REG_THDCP_CRAM_MBIST_RW_MARGIN                        0xE0

// HDCP2X TX IRAM Memory Bist Register
#define REG_ADDR__TXHDCP_IRAM_MBIST_REG                                  (TOP | 0x007D)
  // (ReadWrite, Bits 0) 
  // TX HDCP Internal RAM memory bist enable
  #define BIT_MSK__TXHDCP_IRAM_MBIST_REG__REG_THDCP_IRAM_MBIST_EN                               0x01
  // (ReadOnly, Bits 1) 
  // TX HDCP Internal RAM memory bist fail status
  #define BIT_MSK__TXHDCP_IRAM_MBIST_REG__REG_THDCP_IRAM_MBIST_FAIL                             0x02
  // (ReadOnly, Bits 2) 
  // TX HDCP Internal RAM memory bist error map status
  #define BIT_MSK__TXHDCP_IRAM_MBIST_REG__REG_THDCP_IRAM_MBIST_ERR                              0x04
  // (ReadOnly, Bits 3) 
  // TX HDCP Internal RAM memory bist finish status
  #define BIT_MSK__TXHDCP_IRAM_MBIST_REG__REG_THDCP_IRAM_MBIST_FINISH                           0x08
  // (ReadWrite, Bits 7:5) 
  // TX HDCP Internal RAM memory bist read-write margin
  #define BIT_MSK__TXHDCP_IRAM_MBIST_REG__REG_THDCP_IRAM_MBIST_RW_MARGIN                        0xE0

// Power FSM State Register
#define REG_ADDR__PWR_FSM_STATE                                          (TOP | 0x0080)
  // (ReadWrite, Bits 0) 
  // Power state machine Software overwrite enable. Asserting this will overwrite the power control signals of FSM with the SW overwrite values (reg_pwr_en_sw_val).
  #define BIT_MSK__PWR_FSM_STATE__REG_PWR_FSM_SW_OVR                                    0x01
  // (ReadOnly, Bits 7:4) 
  // Current state of Power state machine.
  #define BIT_MSK__PWR_FSM_STATE__REG_PWR_FSM_STATE                                     0xF0

// Power Control SW Overwrite #1 Register
#define REG_ADDR__PWR_CTRL_SW_OVR1                                       (TOP | 0x0081)
  // (ReadWrite, Bits 7:0) 
  // LSB byte of power FSM control enable software overwrite value [0] : PD clock enable control for dsc_enc [1] : PD clock enable control for mhl_tx [2] : PD clock enable control for hdcp2x authentication engine [3] : PD clock enable control for video upsampler [4] : PD reset enable control for dsc_enc [5] : PD reset enable control for mhl_tx [6] : PD reset enable control for hdcp2x authentication engine [7] : PD reset enable control for video upsampler
  #define BIT_MSK__PWR_CTRL_SW_OVR1__REG_PWR_CTRL_SW_OVR_VAL_B7_B0                         0xFF

// Power Control SW Overwrite #2 Register
#define REG_ADDR__PWR_CTRL_SW_OVR2                                       (TOP | 0x0082)
  // (ReadWrite, Bits 7:0) 
  // MSB byte of power FSM control enable software overwrite value [0] : PD isolation enable control for dsc_enc [1] : PD isolation enable control for mhl_tx [2] : PD isolation enable control for hdcp2x authentication engine [3] : PD isolation enable control for video upsampler [4] : PD power-down enable control for dsc_enc [5] : PD power-down enable control for mhl_tx [6] : PD power-down enable control for hdcp2x authentication engine [7] : PD power-down enable control for video upsampler
  #define BIT_MSK__PWR_CTRL_SW_OVR2__REG_PWR_CTRL_SW_OVR_VAL_B15_B8                        0xFF

// Power Control Status #1 Register
#define REG_ADDR__PWR_CTRL_STATUS1                                       (TOP | 0x0083)
  // (ReadOnly, Bits 7:0) 
  // LSB byte of power FSM control status value [0] : PD clock enable status for dsc_enc [1] : PD clock enable status for mhl_tx [2] : PD clock enable status for hdcp2x authentication engine [3] : PD clock enable status for video upsampler [4] : PD reset enable status for dsc_enc [5] : PD reset enable status for mhl_tx [6] : PD reset enable status for hdcp2x authentication engine [7] : PD reset enable status for video upsampler
  #define BIT_MSK__PWR_CTRL_STATUS1__REG_PWR_CTRL_STATUS_B7_B0                             0xFF

// Power Control Status #2 Register
#define REG_ADDR__PWR_CTRL_STATUS2                                       (TOP | 0x0084)
  // (ReadOnly, Bits 7:0) 
  // MSB byte of power FSM control status value [0] : PD isolation enable status for dsc_enc [1] : PD isolation enable status for mhl_tx [2] : PD isolation enable status for hdcp2x authentication engine [3] : PD isolation enable status for video upsampler [4] : PD power-down enable status for dsc_enc [5] : PD power-down enable status for mhl_tx [6] : PD power-down enable status for hdcp2x authentication engine [7] : PD power-down enable status for video upsampler
  #define BIT_MSK__PWR_CTRL_STATUS2__REG_PWR_CTRL_STATUS_B15_B8                            0xFF

// Power Down Polarity Control Register
#define REG_ADDR__PWR_CTRL_POLARITY                                      (TOP | 0x0085)
  // (ReadWrite, Bits 0) 
  // DSC Encoder Power Down Enable Invert Control 0 : Invert (Default) 1 : Non Invert
  #define BIT_MSK__PWR_CTRL_POLARITY__REG_DSCENC_PD_EN_INV                                  0x01
  // (ReadWrite, Bits 1) 
  // DSC Encoder Power Down ACK Invert Control 0 : Invert (Default) 1 : Non Invert
  #define BIT_MSK__PWR_CTRL_POLARITY__REG_DSCENC_PD_ACK_INV                                 0x02
  // (ReadWrite, Bits 2) 
  // MHL TX Power Down Enable Invert Control 0 : Invert (Default) 1 : Non Invert
  #define BIT_MSK__PWR_CTRL_POLARITY__REG_MHLTX_PD_EN_INV                                   0x04
  // (ReadWrite, Bits 3) 
  // MHL TX Power Down ACK Invert Control 0 : Invert (Default) 1 : Non Invert
  #define BIT_MSK__PWR_CTRL_POLARITY__REG_MHLTX_PD_ACK_INV                                  0x08
  // (ReadWrite, Bits 4) 
  // HDCP2X AES Power Down Enable Invert Control 0 : Invert (Default) 1 : Non Invert
  #define BIT_MSK__PWR_CTRL_POLARITY__REG_H2XAES_PD_EN_INV                                  0x10
  // (ReadWrite, Bits 5) 
  // HDCP2X AES Power Down ACK Invert Control 0 : Invert (Default) 1 : Non Invert
  #define BIT_MSK__PWR_CTRL_POLARITY__REG_H2XAES_PD_ACK_INV                                 0x20
  // (ReadWrite, Bits 6) 
  // Video Up-Sampler Power Down Enable Invert Control 0 : Invert (Default) 1 : Non Invert
  #define BIT_MSK__PWR_CTRL_POLARITY__REG_VIDUPS_PD_EN_INV                                  0x40
  // (ReadWrite, Bits 7) 
  // Video Up-Sampler Power Down ACK Invert Control 0 : Invert (Default) 1 : Non Invert
  #define BIT_MSK__PWR_CTRL_POLARITY__REG_VIDUPS_PD_ACK_INV                                 0x80

// General Purpose Control #0 Registers
#define REG_ADDR__GP_CTRL0_REG                                           (TOP | 0x0090)
  // (ReadWrite, Bits 0) 
  // If the reg_gp_ctrl0[3] is 1'b0 then the value written in to this register will be driven to GPIO0 pad
  #define BIT_MSK__GP_CTRL0_REG__REG_GP_CTRL0_B0                                       0x01
  // (ReadWrite, Bits 1) 
  // If the reg_gp_ctrl0[4] is 1'b0 then the value written in to this register will be driven to GPIO1 pad
  #define BIT_MSK__GP_CTRL0_REG__REG_GP_CTRL0_B1                                       0x02
  // (ReadWrite, Bits 2) 
  // General Purpose Control Register
  #define BIT_MSK__GP_CTRL0_REG__REG_GP_CTRL0_B2                                       0x04
  // (ReadWrite, Bits 3) 
  // Used to select the direction of GPIO0. If 1'b0 then in output direction.Else input direction
  #define BIT_MSK__GP_CTRL0_REG__REG_GP_CTRL0_B3                                       0x08
  // (ReadWrite, Bits 4) 
  // Used to select the direction of GPIO1. If 1'b0 then in output direction.Else input direction
  #define BIT_MSK__GP_CTRL0_REG__REG_GP_CTRL0_B4                                       0x10
  // (ReadWrite, Bits 7:5) 
  // General Purpose Control Register: bit 0: reg_gpio0_out . Ouput data to drive on gpio0 bit 1: reg_gpio1_out.  Ouput data to drive on gpio1 bit 2: reg_gpio2_out.  Ouput data to drive on gpio2 bit 3: reg_gpio0_oen. Ouptut enable of gpio0 (if 0 enable) bit 4: reg_gpio1_oen. Ouptut enable of gpio1 (if 0 enable) bit 5: reg_gpio2_oen. Ouptut enable of gpio2 (if 0 enable)
  #define BIT_MSK__GP_CTRL0_REG__REG_GP_CTRL0_B7_B5                                    0xE0

// General Purpose Control #1 Registers
#define REG_ADDR__GP_CTRL1_REG                                           (TOP | 0x0091)
  // (ReadWrite, Bits 0) 
  // Used to select the rise edge detection on GPIO0 input. If 1'b1 then rise edge detection is enble. Else disable
  #define BIT_MSK__GP_CTRL1_REG__REG_GP_CTRL1_B0                                       0x01
  // (ReadWrite, Bits 1) 
  // Used to select the rise edge detection on GPIO1 input. If 1'b1 then rise edge detection is enble. Else disable
  #define BIT_MSK__GP_CTRL1_REG__REG_GP_CTRL1_B1                                       0x02
  // (ReadWrite, Bits 2) 
  // General Purpose Control Register
  #define BIT_MSK__GP_CTRL1_REG__REG_GP_CTRL1_B2                                       0x04
  // (ReadWrite, Bits 3) 
  // Used to select the fall edge detection on GPIO0 input. If 1'b1 then fall edge detection is enble. Else disable
  #define BIT_MSK__GP_CTRL1_REG__REG_GP_CTRL1_B3                                       0x08
  // (ReadWrite, Bits 4) 
  // Used to select the fall edge detection on GPIO1 input. If 1'b1 then fall edge detection is enble. Else disable
  #define BIT_MSK__GP_CTRL1_REG__REG_GP_CTRL1_B4                                       0x10
  // (ReadWrite, Bits 7:5) 
  // General Purpose Control Register: bit 0: reg_gpio0_out . Ouput data to drive on gpio0 bit 1: reg_gpio1_out.  Ouput data to drive on gpio1 bit 2: reg_gpio2_out.  Ouput data to drive on gpio2 bit 3: reg_gpio0_oen. Ouptut enable of gpio0 (if 0 enable) bit 4: reg_gpio1_oen. Ouptut enable of gpio1 (if 0 enable) bit 5: reg_gpio2_oen. Ouptut enable of gpio2 (if 0 enable)
  #define BIT_MSK__GP_CTRL1_REG__REG_GP_CTRL1_B7_B5                                    0xE0

// General Purpose Control #2 Registers
#define REG_ADDR__GP_CTRL2_REG                                           (TOP | 0x0092)
  // (ReadWrite, Bits 7:0) 
  // General Purpose Control Register
  #define BIT_MSK__GP_CTRL2_REG__REG_GP_CTRL2                                          0xFF

// General Purpose Control #3 Registers
#define REG_ADDR__GP_CTRL3_REG                                           (TOP | 0x0093)
  // (ReadWrite, Bits 7:0) 
  // General Purpose Control Register
  #define BIT_MSK__GP_CTRL3_REG__REG_GP_CTRL3                                          0xFF

// General Purpose Control #4 Registers
#define REG_ADDR__GP_CTRL4_REG                                           (TOP | 0x0094)
  // (ReadWrite, Bits 7:0) 
  // General Purpose Control Register
  #define BIT_MSK__GP_CTRL4_REG__REG_GP_CTRL4                                          0xFF

// General Purpose Status  #0 Registers
#define REG_ADDR__GP_STATUS0_REG                                         (TOP | 0x0095)
  // (ReadOnly, Bits 0) 
  // The level on the GPIO0 is reflected here when GPIO0 is in input direction
  #define BIT_MSK__GP_STATUS0_REG__REG_GP_STATUS0_B0                                     0x01
  // (ReadOnly, Bits 1) 
  // The level on the GPIO1 is reflected here when GPIO1 is in input direction
  #define BIT_MSK__GP_STATUS0_REG__REG_GP_STATUS0_B1                                     0x02
  // (ReadOnly, Bits 7:2) 
  // General Purpose Status Register bit 0: gpio0_padi level indication bit 1: gpio1_padi level indication bit 2: gpio2_padi level indication
  #define BIT_MSK__GP_STATUS0_REG__REG_GP_STATUS0_B7_B2                                  0xFC

// General Purpose Status  #1 Registers
#define REG_ADDR__GP_STATUS1_REG                                         (TOP | 0x0096)
  // (ReadOnly, Bits 7:0) 
  // General Purpose Status Register
  #define BIT_MSK__GP_STATUS1_REG__REG_GP_STATUS1                                        0xFF

// General Purpose Status  #2 Registers
#define REG_ADDR__GP_STATUS2_REG                                         (TOP | 0x0097)
  // (ReadOnly, Bits 7:0) 
  // General Purpose Status Register
  #define BIT_MSK__GP_STATUS2_REG__REG_GP_STATUS2                                        0xFF

// OSC Calib Control Register
#define REG_ADDR__OSC_CALIB_CTRL                                         (TOP | 0x00A0)
  // (ReadWrite, Bits 0) 
  // Oscillator clock calibration value valid
  #define BIT_MSK__OSC_CALIB_CTRL__REG_OSC_CAL_VALID                                     0x01
  // (ReadWrite, Bits 5:1) 
  // Oscillator clock calibration value
  #define BIT_MSK__OSC_CALIB_CTRL__REG_OSC_CAL_VALUE                                     0x3E
  // (ReadWrite, Bits 6) 
  // Oscillator clock calibration value valid 0 : Crystal clock (XTAL) used as reference for OSC calibration 1 : Clock driven on GPIO1 is used as reference for OSC calibration
  #define BIT_MSK__OSC_CALIB_CTRL__REG_OSC_CAL_CLK_SEL                                   0x40
  // (ReadWrite, Bits 7) 
  // Oscillator clock calibration SW overwrite enable 0 : Uses the calibration value from osc_cal HW logic 1 : Uses the calibration value programmed in OSC_CTRL register in Analog registers page
  #define BIT_MSK__OSC_CALIB_CTRL__REG_OSC_CAL_SW_OVR                                    0x80

// OSC Calib Status #0 Register
#define REG_ADDR__OSC_CALIB_STATUS0                                      (TOP | 0x00A1)
  // (ReadOnly, Bits 0) 
  // Oscillator clock calibration value valid status after calibration
  #define BIT_MSK__OSC_CALIB_STATUS0__REG_TX_OSC_CAL_VALID                                  0x01
  // (ReadOnly, Bits 5:1) 
  // Oscillator clock calibration value Status after calibration
  #define BIT_MSK__OSC_CALIB_STATUS0__REG_TX_OSC_CAL_VALUE                                  0x3E

// OSC Calib Status #1 Register
#define REG_ADDR__OSC_CALIB_STATUS1                                      (TOP | 0x00A2)
  // (ReadOnly, Bits 4:0) 
  // Oscillator clock calibration control value Status after calibration
  #define BIT_MSK__OSC_CALIB_STATUS1__REG_TX_OSC_CAL_CTRL                                   0x1F

// OSC Calib REF clock count Register
#define REG_ADDR__OSC_CAL_REF_CLK_CNT                                    (TOP | 0x00A3)
  // (ReadWrite, Bits 7:0) 
  // Calibration Reference clock count 2usec precision count for 24MHz ref clock count = 48 for 30MHz ref clock count = 60
  #define BIT_MSK__OSC_CAL_REF_CLK_CNT__REG_CALIB_REF_CLK_CNT                                 0xFF

// OSC Calib Oscillator clock count Register
#define REG_ADDR__OSC_CAL_OSC_CLK_CNT                                    (TOP | 0x00A4)
  // (ReadWrite, Bits 7:0) 
  // Calibration Oscillator clock count 2usec precision count This must match (REF_CLK_Period / OSC_CLK_Period) * reg_calib_ref_clk_cnt
  #define BIT_MSK__OSC_CAL_OSC_CLK_CNT__REG_CALIB_OSC_CLK_CNT                                 0xFF

// OSC Calib Lock count #0 Register
#define REG_ADDR__OSC_CAL_LOCK_CNT0                                      (TOP | 0x00A5)
  // (ReadWrite, Bits 7:0) 
  // Oscillator Calibration Lock count Default: 100msec
  #define BIT_MSK__OSC_CAL_LOCK_CNT0__REG_CALIB_LOCK_CNT_B7_B0                              0xFF

// OSC Calib Lock count #1 Register
#define REG_ADDR__OSC_CAL_LOCK_CNT1                                      (TOP | 0x00A6)
  // (ReadWrite, Bits 7:0) 
  // Oscillator Calibration Lock count Default: 100msec
  #define BIT_MSK__OSC_CAL_LOCK_CNT1__REG_CALIB_LOCK_CNT_B15_B8                             0xFF

// OSC Calib Lock count #2 Register
#define REG_ADDR__OSC_CAL_LOCK_CNT2                                      (TOP | 0x00A7)
  // (ReadWrite, Bits 5:0) 
  // Oscillator Calibration Lock count Default: 100msec
  #define BIT_MSK__OSC_CAL_LOCK_CNT2__REG_CALIB_LOCK_CNT_B21_B16                            0x3F

// RX CLK1X Characterization Control Register
#define REG_ADDR__RX_CLK1X_CHAR_CTRL                                     (TOP | 0x00A8)
  // (ReadWrite, Bits 0) 
  // Enable to bring out rx_clk1x clock for characterization 
  #define BIT_MSK__RX_CLK1X_CHAR_CTRL__REG_RX_CLK1X_CHAR_EN                                  0x01
  // (ReadWrite, Bits 2:1) 
  // Clock division value of rx_clk1x for characterization 00 : divide-by-2 01 : divide-by-4 10 : divide-by-8 11 : divide-by-16 (default)
  #define BIT_MSK__RX_CLK1X_CHAR_CTRL__REG_RX_CLK1X_CHAR_DIV                                 0x06

// TX Clock Characterization Control Register
#define REG_ADDR__TX_CLK_CHAR_CTRL                                       (TOP | 0x00A9)
  // (ReadWrite, Bits 0) 
  // Enable to bring out tx_align clock for characterization 
  #define BIT_MSK__TX_CLK_CHAR_CTRL__REG_TX_ALIGN_CHAR_EN                                  0x01
  // (ReadWrite, Bits 2:1) 
  // Clock division value of tx_align for characterization 00 : divide-by-2 01 : divide-by-4 10 : divide-by-8 11 : divide-by-16 (default)
  #define BIT_MSK__TX_CLK_CHAR_CTRL__REG_TX_ALIGN_CHAR_DIV                                 0x06
  // (ReadWrite, Bits 3) 
  // Enable to bring out tx_osc clock for characterization 
  #define BIT_MSK__TX_CLK_CHAR_CTRL__REG_TX_OSC_CHAR_EN                                    0x08
  // (ReadWrite, Bits 5:4) 
  // Clock division value of tx_osc for characterization 00 : divide-by-2 (default) 01 : divide-by-4 10 : divide-by-8 11 : divide-by-16
  #define BIT_MSK__TX_CLK_CHAR_CTRL__REG_TX_OSC_CHAR_DIV                                   0x30
  // (ReadWrite, Bits 6) 
  // Enable to select Crystal clock as reference for SWAY FPLL 0 : RX pixel clock is taken as reference clock 1 : clock driven on XTAL is taken as reference clock
  #define BIT_MSK__TX_CLK_CHAR_CTRL__REG_XTAL_SWAY_REF_EN                                  0x40
  // (ReadWrite, Bits 7) 
  // Enable to select external clock as reference for SWAY FPLL 0 : RX pixel clock / XTAL is taken as reference clock 1 : clock driven on GPIO0 is taken as reference clock
  #define BIT_MSK__TX_CLK_CHAR_CTRL__REG_EXT_SWAY_REF_EN                                   0x80

// FPLL STRM Clock Characterization Control Register
#define REG_ADDR__FPLL_STRM_CHAR_CTRL                                    (TOP | 0x00AA)
  // (ReadWrite, Bits 0) 
  // Enable to bring out fpll_strm clock for characterization 
  #define BIT_MSK__FPLL_STRM_CHAR_CTRL__REG_FPLL_STRM_CHAR_EN                                 0x01
  // (ReadWrite, Bits 2:1) 
  // Clock division value of fpll_strm for characterization 00 : divide-by-2 01 : divide-by-4 10 : divide-by-8 11 : divide-by-16 (default)
  #define BIT_MSK__FPLL_STRM_CHAR_CTRL__REG_FPLL_STRM_CHAR_DIV                                0x06

// GF ROM MBIST #1 Register
#define REG_ADDR__GF_ROM_MBIST_REG1                                      (TOP | 0x00B0)
  // (ReadWrite, Bits 7:0) 
  // GF ROM memory bist signature out
  #define BIT_MSK__GF_ROM_MBIST_REG1__REG_GF_ROM_MBIST_SIGNOUT_B7_B0                        0xFF

// GF ROM MBIST #2 Register
#define REG_ADDR__GF_ROM_MBIST_REG2                                      (TOP | 0x00B1)
  // (ReadWrite, Bits 7:0) 
  // GF ROM memory bist signature out
  #define BIT_MSK__GF_ROM_MBIST_REG2__REG_GF_ROM_MBIST_SIGNOUT_B15_B8                       0xFF

// GF ROM MBIST #3 Register
#define REG_ADDR__GF_ROM_MBIST_REG3                                      (TOP | 0x00B2)
  // (ReadWrite, Bits 7:0) 
  // GF ROM memory bist signature out
  #define BIT_MSK__GF_ROM_MBIST_REG3__REG_GF_ROM_MBIST_SIGNOUT_B23_B16                      0xFF

// GF ROM MBIST #4 Register
#define REG_ADDR__GF_ROM_MBIST_REG4                                      (TOP | 0x00B3)
  // (ReadWrite, Bits 7:0) 
  // GF ROM memory bist signature out
  #define BIT_MSK__GF_ROM_MBIST_REG4__REG_GF_ROM_MBIST_SIGNOUT_B31_B24                      0xFF

// GF ROM MBIST #5 Register
#define REG_ADDR__GF_ROM_MBIST_REG5                                      (TOP | 0x00B4)
  // (ReadWrite, Bits 7:0) 
  // GF ROM memory bist signature out
  #define BIT_MSK__GF_ROM_MBIST_REG5__REG_GF_ROM_MBIST_SIGNOUT_B39_B32                      0xFF

// GF ROM MBIST #6 Register
#define REG_ADDR__GF_ROM_MBIST_REG6                                      (TOP | 0x00B5)
  // (ReadWrite, Bits 7:0) 
  // GF ROM memory bist signature out
  #define BIT_MSK__GF_ROM_MBIST_REG6__REG_GF_ROM_MBIST_SIGNOUT_B47_B40                      0xFF

// GF ROM MBIST #7 Register
#define REG_ADDR__GF_ROM_MBIST_REG7                                      (TOP | 0x00B6)
  // (ReadWrite, Bits 7:0) 
  // GF ROM memory bist signature out
  #define BIT_MSK__GF_ROM_MBIST_REG7__REG_GF_ROM_MBIST_SIGNOUT_B55_B48                      0xFF

// GF ROM MBIST #8 Register
#define REG_ADDR__GF_ROM_MBIST_REG8                                      (TOP | 0x00B7)
  // (ReadWrite, Bits 7:0) 
  // GF ROM memory bist signature out
  #define BIT_MSK__GF_ROM_MBIST_REG8__REG_GF_ROM_MBIST_SIGNOUT_B63_B56                      0xFF

// GF ROM MBIST #9 Register
#define REG_ADDR__GF_ROM_MBIST_REG9                                      (TOP | 0x00B8)
  // (ReadWrite, Bits 7:0) 
  // GF ROM memory bist signature out
  #define BIT_MSK__GF_ROM_MBIST_REG9__REG_GF_ROM_MBIST_SIGNOUT_B71_B64                      0xFF

// Clock Period Check Control and Status Register
#define REG_ADDR__CLK_PRD_CHK_CTRL                                       (TOP | 0x00C0)
  // (ReadWrite, Bits 0) 
  // Enable to bring out rx_clk1x clock for characterization 
  #define BIT_MSK__CLK_PRD_CHK_CTRL__REG_CLK_PRD_CHK_EN                                    0x01
  // (ReadWrite, Bits 2:1) 
  // Clock division value of rx_clk1x for characterization 00 : CLK1x clock (default) 01 : TX_ALIGN clock 10 : SWAW_FPLL clock 11 : TX OSC clock
  #define BIT_MSK__CLK_PRD_CHK_CTRL__REG_CLK_PRD_CHK_CLKSEL                                0x06
  // (ReadOnly, Bits 4) 
  // 
  #define BIT_MSK__CLK_PRD_CHK_CTRL__REG_CLK_PRD_CHK_DONE                                  0x10
  // (ReadOnly, Bits 5) 
  // 
  #define BIT_MSK__CLK_PRD_CHK_CTRL__REG_CLK_PRD_CHK_ERR                                   0x20
  // (ReadOnly, Bits 6) 
  // 
  #define BIT_MSK__CLK_PRD_CHK_CTRL__REG_CLK_PRD_CHK_CHANGE                                0x40

// Reference Clock Max Count #0 Register
#define REG_ADDR__REF_CLK_MAX_CNT0                                       (TOP | 0x00C1)
  // (ReadWrite, Bits 7:0) 
  // Reference Clock Max Count LSB byte
  #define BIT_MSK__REF_CLK_MAX_CNT0__REG_REF_CLK_MAX_CNT_B7_B0                             0xFF

// Reference Clock Max Count #1 Register
#define REG_ADDR__REF_CLK_MAX_CNT1                                       (TOP | 0x00C2)
  // (ReadWrite, Bits 7:0) 
  // Reference Clock Max Count MSB byte
  #define BIT_MSK__REF_CLK_MAX_CNT1__REG_REF_CLK_MAX_CNT_B15_B8                            0xFF

// Clock Period Check Base Count #0 Register
#define REG_ADDR__CLK_PRD_CHK_BASE0                                      (TOP | 0x00C3)
  // (ReadWrite, Bits 7:0) 
  // Clock Period Check Base Count LSB byte
  #define BIT_MSK__CLK_PRD_CHK_BASE0__REG_CLK_PRD_CHK_BASE_B7_B0                            0xFF

// Clock Period Check Base Count #1 Register
#define REG_ADDR__CLK_PRD_CHK_BASE1                                      (TOP | 0x00C4)
  // (ReadWrite, Bits 7:0) 
  // Clock Period Check Base Count MSB byte
  #define BIT_MSK__CLK_PRD_CHK_BASE1__REG_CLK_PRD_CHK_BASE_B15_B8                           0xFF

// Clock Period Check Threshold Count #0 Register
#define REG_ADDR__CLK_PRD_CHK_THRSHD                                     (TOP | 0x00C5)
  // (ReadWrite, Bits 7:0) 
  // Clock Period Check Threshold Count 
  #define BIT_MSK__CLK_PRD_CHK_THRSHD__REG_CLK_PRD_CHK_THRSHD                                0xFF

// Clock Period in REF Clock Status #0 Register
#define REG_ADDR__CLK_PRD_IN_REFCLK0                                     (TOP | 0x00C6)
  // (ReadOnly, Bits 7:0) 
  // Clock Period in REF Clock Status LSB byte 
  #define BIT_MSK__CLK_PRD_IN_REFCLK0__REG_CLK_PRD_IN_REFCLK_B7_B0                           0xFF

// Clock Period in REF Clock Status #1 Register
#define REG_ADDR__CLK_PRD_IN_REFCLK1                                     (TOP | 0x00C7)
  // (ReadOnly, Bits 7:0) 
  // Clock Period in REF Clock Status MSB byte 
  #define BIT_MSK__CLK_PRD_IN_REFCLK1__REG_CLK_PRD_IN_REFCLK_B15_B8                          0xFF

// Clock Period in REF Clock Diff Status #0 Register
#define REG_ADDR__CLK_PRD_IN_REFCLK_DIFF0                                (TOP | 0x00C8)
  // (ReadOnly, Bits 7:0) 
  // Clock Period in REF Clock Difference LSB byte
  #define BIT_MSK__CLK_PRD_IN_REFCLK_DIFF0__REG_CLK_PRD_IN_REFCLK_DIFF_B7_B0                      0xFF

// Clock Period in REF Clock Diff Status #1 Register
#define REG_ADDR__CLK_PRD_IN_REFCLK_DIFF1                                (TOP | 0x00C9)
  // (ReadOnly, Bits 7:0) 
  // Clock Period in REF Clock Difference MSB byte
  #define BIT_MSK__CLK_PRD_IN_REFCLK_DIFF1__REG_CLK_PRD_IN_REFCLK_DIFF_B15_B8                     0xFF

//***************************************************************************
// RX_AON. Address: 60
// SYS Device ID Low byte Register
#define REG_ADDR__RX_DEV_IDL                                             (RX_AON | 0x0000)
  // (ReadOnly, Bits 7:0) 
  // Device ID Low byte
  #define BIT_MSK__RX_DEV_IDL__REG_DEV_IDL                                           0xFF

// SYS Device ID High byte Register
#define REG_ADDR__RX_DEV_IDH                                             (RX_AON | 0x0001)
  // (ReadOnly, Bits 7:0) 
  // Device ID High byte
  #define BIT_MSK__RX_DEV_IDH__REG_DEV_IDH                                           0xFF

// SYS Device Revision Register
#define REG_ADDR__RX_DEV_REV                                             (RX_AON | 0x0002)
  // (ReadOnly, Bits 7:0) 
  // Device Revision
  #define BIT_MSK__RX_DEV_REV__DEV_REV_ID                                            0xFF

// SYS Vendor ID Low byte Register
#define REG_ADDR__RX_VND_IDL                                             (RX_AON | 0x0003)
  // (ReadOnly, Bits 7:0) 
  // Vendor ID Low byte
  #define BIT_MSK__RX_VND_IDL__REG_VHDL_IDL                                          0xFF

// SYS Vendor ID High byte Register
#define REG_ADDR__RX_VND_IDH                                             (RX_AON | 0x0004)
  // (ReadOnly, Bits 7:0) 
  // Vendor ID High byte
  #define BIT_MSK__RX_VND_IDH__REG_VHDL_IDH                                          0xFF

// AON Software Reset Register
#define REG_ADDR__RX_AON_SRST                                            (RX_AON | 0x0005)
  // (ReadWrite, Bits 0) 
  // Software Reset. Reset all internal logic; except register interface; acr; hdcp; aac and EEPROM interface.  Note: asserting Software Reset will not reset writable register contents: 1 - Reset 0 - Normal operation (default).
  #define BIT_MSK__RX_AON_SRST__REG_SW_RST                                            0x01
  // (ReadWrite, Bits 4) 
  // Auto Software reset - will not reset AAC: 0 - Manual software reset (default) 1 - Auto software reset whenever SCDT = 0
  #define BIT_MSK__RX_AON_SRST__REG_SW_RST_AUTO                                       0x10

// SYS Switch Config Register
#define REG_ADDR__RX_SYS_SWTCHC                                          (RX_AON | 0x0009)
  // (ReadWrite, Bits 0) 
  // EDID DDC Select: 0 - Disables EDID accesses on DDC 1 - Enables EDID accesses on DDC
  #define BIT_MSK__RX_SYS_SWTCHC__REG_DDC_EDID_EN                                       0x01
  // (ReadWrite, Bits 1) 
  // HDCP DDC Select: 0 - Disables HDCP accesses on DDC 1 - Enables HDCP accesses on DDC
  #define BIT_MSK__RX_SYS_SWTCHC__REG_DDC_HDCP_EN                                       0x02
  // (ReadWrite, Bits 2) 
  // SCDC DDC Select: 0 - Disables SCDC accesses on DDC 1 - Enables SCDC accesses on DDC
  #define BIT_MSK__RX_SYS_SWTCHC__REG_DDC_SCDC_EN                                       0x04
  // (ReadWrite, Bits 5:4) 
  // Enable DDC Filter: 2'b10 - 3 tap 2'b11 - 5 tap Rest are No Filter.
  #define BIT_MSK__RX_SYS_SWTCHC__DDC_FILTER_SEL                                        0x30
  // (ReadWrite, Bits 6) 
  // Enable the I2C SDA del: 1 - default is enable. I2C delay has been inserted into the SDA line to create 300ns delay for the falling edge of the DDC SDA signal in order to avoid erroneous I2C START condition.  The real start condition must have setup time of the 600ns and therefore this delay of 300ns will not remove the real START condition. 
  #define BIT_MSK__RX_SYS_SWTCHC__REG_DDC_SDA_OUT_DEL_EN                                0x40
  // (ReadWrite, Bits 7) 
  // Enable the DDC del: 1 - default is enable. DDC delay has been inserted into the SDA line to create 300ns delay for the falling edge of the DDC SDA signal in order to avoid erroneous I2C START condition.  The real start condition must have setup time of the 600ns and therefore this delay of 300ns will not remove the real START condition. 
  #define BIT_MSK__RX_SYS_SWTCHC__REG_DDC_SDA_IN_DEL_EN                                 0x80

// Channel 0 System Software Reset 2 Register
#define REG_ADDR__RX_C0_SRST2                                            (RX_AON | 0x000B)
  // (ReadWrite, Bits 4) 
  // Software reset for HDMI-M control bus logic 1 - Reset 0 - Normal operation (default).
  #define BIT_MSK__RX_C0_SRST2__REG_HDMIM_SW_RST                                      0x10
  // (ReadWrite, Bits 6) 
  // Software reset for CEC logic. 1 - Reset 0 - Normal operation (default).
  #define BIT_MSK__RX_C0_SRST2__REG_CEC_SW_RST                                        0x40

// Always ON Rx State Register
#define REG_ADDR__RX_STATE_AON                                           (RX_AON | 0x000C)
  // (ReadOnly, Bits 0) 
  // State of the Sync Detect. A HIGH level is outputted when DE is actively togging indicating that the link is alive. A low level is outputted when DE is inactive; indicating the link is down. 
  #define BIT_MSK__RX_STATE_AON__SCDT                                                  0x01
  // (ReadOnly, Bits 1) 
  // State of the Clock Detect. '1' if a clock is detected on the TMDS signals. 
  #define BIT_MSK__RX_STATE_AON__CKDT                                                  0x02
  // (ReadOnly, Bits 3) 
  // State of the selected port's 5V power detect pin.
  #define BIT_MSK__RX_STATE_AON__HDMI_TX_CONNECTED                                     0x08

// Parallel Interface Time Out Low Register
#define REG_ADDR__PI_TO_LIMIT_L                                          (RX_AON | 0x0010)
  // (ReadWrite, Bits 7:0) 
  // Bits [7:0] of [9:0] of parrelllel interface time-out limit. If set to value above 0 then time-out will be set as soon as busclk counter will be more than this value. Counter will start as soon as write or read request is generated to either INT; SHA; CEC; CBUS or EDID. Used to prevent parrell register interface getting stuck. Default value is set to 1023: 
  #define BIT_MSK__PI_TO_LIMIT_L__REG_TO_LIMIT_B7_B0                                    0xFF

// Parallel Interface Time Out High Register
#define REG_ADDR__PI_TO_LIMIT_H                                          (RX_AON | 0x0011)
  // (ReadWrite, Bits 1:0) 
  // Bits [9:8] of [9:0] of parrelllel interface time-out limit. If set to value above 0 then time-out will be set as soon as busclk counter will be more than this value. Counter will start as soon as write or read request is generated to either INT; SHA; CEC; CBUS or EDID. Used to prevent parrell register interface getting stuck. Default value is set to 1023: 
  #define BIT_MSK__PI_TO_LIMIT_H__REG_TO_LIMIT_B9_B8                                    0x03

// Dumy Config #1 Register
#define REG_ADDR__RX_DUMMY_CONFIG1                                       (RX_AON | 0x0018)
  // (ReadWrite, Bits 7:0) 
  // Dummy config used in FPGA debugging. Bit-0 : Used as enable to generate HPD signal in FPGA mode. This bit ANDed with tx_connected (pwr5v) to generate HPD. Bit-1 : Used as active LOW enable for CBUS connected in FPGA mode.  Bit-2 : Used to set the PLL RESET for FPGA PHY. TO apply reset to FPGA RX PHY drive low on this bit and release by programming HIGH. Bit-3 : Used to genearte PLL enable for FPGA PHY.
  #define BIT_MSK__RX_DUMMY_CONFIG1__REG_DUMMY_CONFIG1                                     0xFF

// Dumy Config #2 Register
#define REG_ADDR__RX_DUMMY_CONFIG2                                       (RX_AON | 0x0019)
  // (ReadWrite, Bits 7:0) 
  // Dummy config
  #define BIT_MSK__RX_DUMMY_CONFIG2__REG_DUMMY_CONFIG2                                     0xFF

// Dumy status Register
#define REG_ADDR__RX_DUMMY_STATUS                                        (RX_AON | 0x001A)
  // (ReadOnly, Bits 7:0) 
  // Dummy status
  #define BIT_MSK__RX_DUMMY_STATUS__DUMMY_STATUS                                          0xFF

// Slave AON Register
#define REG_ADDR__RX_SLAVE_AON                                           (RX_AON | 0x0020)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #0 (AON) The page address driving on I2C line should match with this value with the exception of bit-1.  Bit-1 value depends on external signal i_rx_i2c_page_addr_ctl. Limitation : The upper 4-bits are programmable. Lower 4-bits programming is not allowed.
  #define BIT_MSK__RX_SLAVE_AON__REG_SLAVE_ADDR_AON                                    0xFF

// Slave Addr3 Register
#define REG_ADDR__RX_SLAVE_VIDEO_1                                       (RX_AON | 0x0021)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address #3 mapping to page #9 (Video_1)
  #define BIT_MSK__RX_SLAVE_VIDEO_1__REG_SLAVE_ADDR_VIDEO_1                                0xFF

// Slave CEC Register
#define REG_ADDR__RX_SLAVE_CEC                                           (RX_AON | 0x0022)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #8 (CEC)
  #define BIT_MSK__RX_SLAVE_CEC__REG_SLAVE_ADDR_CEC                                    0xFF

// Slave CBUS Register
#define REG_ADDR__RX_SLAVE_CBUS                                          (RX_AON | 0x0023)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #5 (CBUS)
  #define BIT_MSK__RX_SLAVE_CBUS__REG_SLAVE_ADDR_CBUS                                   0xFF

// Slave Audio Register
#define REG_ADDR__RX_SLAVE_AUDIO                                         (RX_AON | 0x0024)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #1 (Audio)
  #define BIT_MSK__RX_SLAVE_AUDIO__REG_SLAVE_ADDR_AUDIO                                  0xFF

// Slave Video Register
#define REG_ADDR__RX_SLAVE_VIDEO_0                                       (RX_AON | 0x0025)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address #2 mapping to page #10 (Video)
  #define BIT_MSK__RX_SLAVE_VIDEO_0__REG_SLAVE_ADDR_VIDEO_0                                0xFF

// Slave EDID Register
#define REG_ADDR__RX_SLAVE_EDID                                          (RX_AON | 0x0026)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #14 (EDID)
  #define BIT_MSK__RX_SLAVE_EDID__REG_SLAVE_ADDR_EDID                                   0xFF

// Slave DEPACK1 Register
#define REG_ADDR__RX_SLAVE_DEPACK1                                       (RX_AON | 0x0027)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #12 (ECC; AVI; MPEG; ACP;..)
  #define BIT_MSK__RX_SLAVE_DEPACK1__REG_SLAVE_ADDR_DEPACK1                                0xFF

// Slave DEPACK2 Register
#define REG_ADDR__RX_SLAVE_DEPACK2                                       (RX_AON | 0x0028)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #13 (VSIF)
  #define BIT_MSK__RX_SLAVE_DEPACK2__REG_SLAVE_ADDR_DEPACK2                                0xFF

// Slave PWD Register
#define REG_ADDR__RX_SLAVE_PWD                                           (RX_AON | 0x0029)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #3 (HDCP and other PWD)
  #define BIT_MSK__RX_SLAVE_PWD__REG_SLAVE_ADDR_PWD                                    0xFF

// Slave TMDS BIST Register
#define REG_ADDR__RX_SLAVE_TBIST                                         (RX_AON | 0x002A)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #11 (TMDS BIST)
  #define BIT_MSK__RX_SLAVE_TBIST__REG_SLAVE_ADDR_TBIST                                  0xFF

// Slave DPLL Register
#define REG_ADDR__RX_SLAVE_DPLL                                          (RX_AON | 0x002B)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #18 (DPLL)
  #define BIT_MSK__RX_SLAVE_DPLL__REG_SLAVE_ADDR_DPLL                                   0xFF

// Slave HDCP2x Register
#define REG_ADDR__RX_SLAVE_HDCP2X                                        (RX_AON | 0x002C)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #15 (HDCP2x)
  #define BIT_MSK__RX_SLAVE_HDCP2X__REG_SLAVE_ADDR_HDCP2X                                 0xFF

// Slave USB tunnel TDM Register
#define REG_ADDR__RX_SLAVE_TDM                                           (RX_AON | 0x002D)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #7 (TDM)
  #define BIT_MSK__RX_SLAVE_TDM__REG_SLAVE_ADDR_TDM                                    0xFF

// Slave HSIC Register
#define REG_ADDR__RX_SLAVE_HSIC                                          (RX_AON | 0x002E)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #6 (HSIC)
  #define BIT_MSK__RX_SLAVE_HSIC__REG_SLAVE_ADDR_HSIC                                   0xFF

// Slave M32H Register
#define REG_ADDR__RX_SLAVE_M32H                                          (RX_AON | 0x002F)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #2 (MHL32HDMI)
  #define BIT_MSK__RX_SLAVE_M32H__REG_SLAVE_ADDR_M32H                                   0xFF

// Slave MHL Spec Register
#define REG_ADDR__RX_SLAVE_MHLSPEC                                       (RX_AON | 0x0030)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #4 (Video_1)
  #define BIT_MSK__RX_SLAVE_MHLSPEC__REG_SLAVE_ADDR_MHLSPEC                                0xFF

// Slave EMSC Register
#define REG_ADDR__RX_SLAVE_EMSC                                          (RX_AON | 0x0031)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #16 (EMSC)
  #define BIT_MSK__RX_SLAVE_EMSC__REG_SLAVE_ADDR_EMSC                                   0xFF

// Slave EDID2 Register
#define REG_ADDR__RX_SLAVE_EDID2                                         (RX_AON | 0x0032)
  // (ReadWrite, Bits 7:0) 
  // Programmable Slave Address mapping to page #17 (EDID2)
  #define BIT_MSK__RX_SLAVE_EDID2__REG_SLAVE_ADDR_EDID2                                  0xFF

// HDMI2 Mode Control Register
#define REG_ADDR__HDMI2_MODE_CTRL                                        (RX_AON | 0x0040)
  // (ReadWrite, Bits 0) 
  // HDMI2 mode FW overwrite value
  #define BIT_MSK__HDMI2_MODE_CTRL__REG_HDMI2_ON_VAL                                      0x01
  // (ReadWrite, Bits 1) 
  // Scramble ON FW overwrite value
  #define BIT_MSK__HDMI2_MODE_CTRL__REG_SCRAMBLE_ON_VAL                                   0x02
  // (ReadWrite, Bits 4) 
  // HDMI2 mode FW overwrite enable
  #define BIT_MSK__HDMI2_MODE_CTRL__REG_HDMI2_ON_OVR                                      0x10
  // (ReadWrite, Bits 5) 
  // Scramble ON FW overwrite enable
  #define BIT_MSK__HDMI2_MODE_CTRL__REG_SCRAMBLE_ON_OVR                                   0x20

// MHL Mode Overwrite Register
#define REG_ADDR__MHL_MODE_OVR                                           (RX_AON | 0x0041)
  // (ReadWrite, Bits 0) 
  // HDMIM mode FW overwrite value
  #define BIT_MSK__MHL_MODE_OVR__REG_HDMIM_MODE_VAL                                    0x01
  // (ReadWrite, Bits 1) 
  // MHL3 mode FW overwrite value
  #define BIT_MSK__MHL_MODE_OVR__REG_MHL3_MODE_VAL                                     0x02
  // (ReadWrite, Bits 2) 
  // MHL 1X mode FW overwrite value
  #define BIT_MSK__MHL_MODE_OVR__REG_MHL1X_MODE_VAL                                    0x04
  // (ReadWrite, Bits 3) 
  // MHL PP mode FW overwrite value
  #define BIT_MSK__MHL_MODE_OVR__REG_MHLPP_MODE_VAL                                    0x08
  // (ReadWrite, Bits 4) 
  // HDMIM mode FW overwrite enable
  #define BIT_MSK__MHL_MODE_OVR__REG_HDMIM_MODE_OVR                                    0x10
  // (ReadWrite, Bits 5) 
  // MHL3 mode FW overwrite enable
  #define BIT_MSK__MHL_MODE_OVR__REG_MHL3_MODE_OVR                                     0x20
  // (ReadWrite, Bits 6) 
  // MHL 1X mode FW overwrite enable
  #define BIT_MSK__MHL_MODE_OVR__REG_MHL1X_MODE_OVR                                    0x40
  // (ReadWrite, Bits 7) 
  // MHL PP mode FW overwrite enable
  #define BIT_MSK__MHL_MODE_OVR__REG_MHLPP_MODE_OVR                                    0x80

// RX PRIF Burst Control Register
#define REG_ADDR__RX_PRIF_BURST_CTRL                                     (RX_AON | 0x0050)
  // (ReadWrite, Bits 0) 
  // Start generation for Parallel interface logic while accessing Memories or FIFOs This should be programmed to 1 before starting the burst access (1 Pulse signal) With PRIF Burst access can be done by multiple signle accesses.
  #define BIT_MSK__RX_PRIF_BURST_CTRL__REG_PRIF_BRST_START                                   0x01
  // (ReadWrite, Bits 1) 
  // Stop generation for Parallel interface logic while accessing Memories or FIFOs This should be programmed to 1 at the end of the burst access  (1 Pulse signal) With PRIF Burst access can be done by multiple signle accesses.
  #define BIT_MSK__RX_PRIF_BURST_CTRL__REG_PRIF_BRST_STOP                                    0x02

// Interrupt State Register
#define REG_ADDR__RX_INTR_STATE                                          (RX_AON | 0x0070)
  // (ReadOnly, Bits 0) 
  // Interrupt state bit value.  It shows whether the interrupt is active or not.  It is one gate before the polarity is applied to the interrupt.  In other words; whenever the interrupt is asserted; this bit is high.
  #define BIT_MSK__RX_INTR_STATE__REG_INTR                                              0x01

// Interrupt Control Register
#define REG_ADDR__RX_INT_CTRL                                            (RX_AON | 0x0079)
  // (ReadWrite, Bits 1) 
  // INT pin assert polarity level: 1 - INT output is asserted when set to '0' (default) 0 - INT output is asserted when set to '1'
  #define BIT_MSK__RX_INT_CTRL__REG_INTR_POLARITY                                     0x02
  // (ReadWrite, Bits 3) 
  // Set software interrupt: 0 - disable software interrupt (default); 1 - set software interrupt (would triger interrupt untill this bit is cleared).
  #define BIT_MSK__RX_INT_CTRL__REG_SOFT_INTR_EN                                      0x08

// Interrupt Status AON #2 Register
#define REG_ADDR__RX_INTR2_AON                                           (RX_AON | 0x0080)
  // (ReadWrite, Bits 3) 
  // Sync Detect.  During normal operation: A HIGH level is outputted when DE is actively togging indicating that the link is alive. A low level is outputted when DE is inactive; indicating the link is down. It is asserted if change in SCDT is detected. During power down: A HIGH level is output when DE is changed from 0 to 1.  Asserted if set to 1. Write 1 to clear.
  #define BIT_MSK__RX_INTR2_AON__REG_INTR2_STAT3_AON                                   0x08
  // (ReadWrite, Bits 4) 
  // CKDT - Clock Detect. '1' if a clock is detected on the TMDS signals. Asserte if change in CKDT is detected. Asserted if set to 1.  Write '1' to clear.
  #define BIT_MSK__RX_INTR2_AON__REG_INTR2_STAT4_AON                                   0x10
  // (ReadWrite, Bits 5) 
  // Software induced interrupt. Asserted if set to 1. This is a dynamic interrupt and clears on programming the reg_soft_intr_en bit of RX_INT_CTRL register LOW.
  #define BIT_MSK__RX_INTR2_AON__REG_INTR2_STAT5_AON                                   0x20

// Interrupt Status AON #6 Register
#define REG_ADDR__RX_INTR6_AON                                           (RX_AON | 0x0081)
  // (ReadWrite, Bits 0) 
  // Cable Unplug Interrupt: This Interrupt when asserted indicates the Cable is Unplugged. Asserted HIGH when a falling edge is detected on PWR5V. Write 1 to clear.
  #define BIT_MSK__RX_INTR6_AON__REG_INTR6_STAT0_AON                                   0x01

// AON Interrupt Status #7 Register
#define REG_ADDR__RX_INTR7_AON                                           (RX_AON | 0x0082)
  // (ReadOnly, Bits 3) 
  // CBUS Interrupt Status
  #define BIT_MSK__RX_INTR7_AON__REG_INTR7_STAT3_AON                                   0x08
  // (ReadOnly, Bits 4) 
  // CEC Interrupt Status
  #define BIT_MSK__RX_INTR7_AON__REG_INTR7_STAT4_AON                                   0x10
  // (ReadWrite, Bits 6) 
  // scramble_en change from 0-]1 and 1-]0
  #define BIT_MSK__RX_INTR7_AON__REG_INTR7_STAT6_AON                                   0x40
  // (ReadWrite, Bits 7) 
  // tmds_clk_ratio change from 0-]1 and 1-]0
  #define BIT_MSK__RX_INTR7_AON__REG_INTR7_STAT7_AON                                   0x80

// Interrupt Status AON #8 Register
#define REG_ADDR__RX_INTR8_AON                                           (RX_AON | 0x0083)
  // (ReadWrite, Bits 1) 
  // Cable Plugin Interrupt: This Interrupt when asserted indicates the Cable is Plugged in. Asserted HIGH when a rising edge is detected on PWR5V. Write 1 to clear.
  #define BIT_MSK__RX_INTR8_AON__REG_INTR8_STAT1_AON                                   0x02
  // (ReadWrite, Bits 2) 
  // MHL wakeup was detected
  #define BIT_MSK__RX_INTR8_AON__REG_INTR8_STAT2_AON                                   0x04

// AON Interrupt Status #9 Register
#define REG_ADDR__RX_INTR9_AON                                           (RX_AON | 0x0084)
  // (ReadWrite, Bits 0) 
  // src_ver value or rr_enable value change
  #define BIT_MSK__RX_INTR9_AON__REG_INTR9_STAT0_AON                                   0x01
  // (ReadWrite, Bits 1) 
  // status_update change from 0-] 1 or 1-] 0
  #define BIT_MSK__RX_INTR9_AON__REG_INTR9_STAT1_AON                                   0x02
  // (ReadWrite, Bits 2) 
  // ced_update change from 0-]1 or 1-] 0
  #define BIT_MSK__RX_INTR9_AON__REG_INTR9_STAT2_AON                                   0x04
  // (ReadWrite, Bits 3) 
  // rr_test change from 0-]1 or 1-] 0
  #define BIT_MSK__RX_INTR9_AON__REG_INTR9_STAT3_AON                                   0x08
  // (ReadWrite, Bits 6) 
  // char_errdet_cnt change
  #define BIT_MSK__RX_INTR9_AON__REG_INTR9_STAT6_AON                                   0x40
  // (ReadWrite, Bits 7) 
  // test_rd_req change
  #define BIT_MSK__RX_INTR9_AON__REG_INTR9_STAT7_AON                                   0x80

// AON Interrupt #2 Mask Register
#define REG_ADDR__RX_INTR2_MASK_AON                                      (RX_AON | 0x0090)
  // (ReadWrite, Bits 3) 
  // Enable INT2[3]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR2_MASK_AON__REG_INTR2_MASK3_AON                                   0x08
  // (ReadWrite, Bits 4) 
  // Enable INT2[4]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR2_MASK_AON__REG_INTR2_MASK4_AON                                   0x10
  // (ReadWrite, Bits 5) 
  // Enable INT2[5]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR2_MASK_AON__REG_INTR2_MASK5_AON                                   0x20

// AON Interrupt #6 Mask Register
#define REG_ADDR__RX_INTR6_MASK_AON                                      (RX_AON | 0x0091)
  // (ReadWrite, Bits 0) 
  // Enable INT6[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR6_MASK_AON__REG_INTR6_MASK0_AON                                   0x01

// AON Interrupt Mask #7 Register
#define REG_ADDR__RX_INTR7_MASK_AON                                      (RX_AON | 0x0092)
  // (ReadWrite, Bits 3) 
  // Enable INT7[3]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR7_MASK_AON__REG_INTR7_MASK3_AON                                   0x08
  // (ReadWrite, Bits 4) 
  // Enable INT7[4]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR7_MASK_AON__REG_INTR7_MASK4_AON                                   0x10
  // (ReadWrite, Bits 6) 
  // Enable INT7[6]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR7_MASK_AON__REG_INTR7_MASK6_AON                                   0x40
  // (ReadWrite, Bits 7) 
  // Enable INT7[7]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR7_MASK_AON__REG_INTR7_MASK7_AON                                   0x80

// AON Interrupt #8 Mask Register
#define REG_ADDR__RX_INTR8_MASK_AON                                      (RX_AON | 0x0093)
  // (ReadWrite, Bits 1) 
  // Enable INT8[1]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR8_MASK_AON__REG_INTR8_MASK1_AON                                   0x02
  // (ReadWrite, Bits 2) 
  // Enable INT8[2]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR8_MASK_AON__REG_INTR8_MASK2_AON                                   0x04

// AON Interrupt Mask #9 Register
#define REG_ADDR__RX_INTR9_MASK_AON                                      (RX_AON | 0x0094)
  // (ReadWrite, Bits 0) 
  // Enable INT7[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR9_MASK_AON__REG_INTR9_MASK0_AON                                   0x01
  // (ReadWrite, Bits 1) 
  // Enable INT7[1]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR9_MASK_AON__REG_INTR9_MASK1_AON                                   0x02
  // (ReadWrite, Bits 2) 
  // Enable INT7[2]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR9_MASK_AON__REG_INTR9_MASK2_AON                                   0x04
  // (ReadWrite, Bits 3) 
  // Enable INT7[3]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR9_MASK_AON__REG_INTR9_MASK3_AON                                   0x08
  // (ReadWrite, Bits 6) 
  // Enable INT7[6]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR9_MASK_AON__REG_INTR9_MASK6_AON                                   0x40
  // (ReadWrite, Bits 7) 
  // Enable INT7[7]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR9_MASK_AON__REG_INTR9_MASK7_AON                                   0x80

// SCDCS 500ns Caib Cnt Register
#define REG_ADDR__SCDCS_500NS_CNT                                        (RX_AON | 0x00A0)
  // (ReadWrite, Bits 7:0) 
  // SCDCS 500ns calibration count value. Defaul value is 1 (assuming OCLK as 2MHz)
  #define BIT_MSK__SCDCS_500NS_CNT__REG_500NS_CALIB_CNT                                   0xFF

// SCDCS 4.7Us WRT 500ns Cnt Register
#define REG_ADDR__SCDCS_4P7_IN_500NS_CNT                                 (RX_AON | 0x00A1)
  // (ReadWrite, Bits 7:0) 
  // SCDCS 4.7us count register. The value should be in counts of 500ns. Defaul value is 8'h0A.
  #define BIT_MSK__SCDCS_4P7_IN_500NS_CNT__REG_4P7US_IN_500NS_CNT                                0xFF

// SCDCS 1ms WRT 500ns Cnt0 Register
#define REG_ADDR__SCDCS_1MS_IN_500NS_CNT0                                (RX_AON | 0x00A2)
  // (ReadWrite, Bits 7:0) 
  // SCDCS 1ms count register. The value should be in counts of 500ns. Defaul value is 8'hD0 (Lower byte of 11'h7D0) This register is not required to program any new value provided reg_500ns_calib_cnt is programmed as per the rate of OCLK. This is mainly provided for debugging.
  #define BIT_MSK__SCDCS_1MS_IN_500NS_CNT0__REG_1MS_IN_500NS_CNT0                                 0xFF

// SCDCS 1ms WRT 500ns Cnt1 Register
#define REG_ADDR__SCDCS_1MS_IN_500NS_CNT1                                (RX_AON | 0x00A3)
  // (ReadWrite, Bits 2:0) 
  // SCDCS 1ms count register. The value should be in counts of 500ns. Defaul value is 3'b111 (Upper byte of 11'h7D0). This register is not required to program any new value provided reg_500ns_calib_cnt is programmed as per the rate of OCLK. This is mainly provided for debugging.
  #define BIT_MSK__SCDCS_1MS_IN_500NS_CNT1__REG_1MS_IN_500NS_CNT1                                 0x07

// SCDCS 20ms WRT 1ms Cnt Register
#define REG_ADDR__SCDCS_20MS_IN_1MS_CNT                                  (RX_AON | 0x00A4)
  // (ReadWrite, Bits 7:0) 
  // SCDCS 20ms count register. The value should be in counts of 1ms. Defaul value is 8'h14. This count is used to hold the SCDCS logic for 20ms after PWR5V is active. This register is not required to program any new value provided reg_500ns_calib_cnt is programmed as per the rate of OCLK. This is mainly provided for debugging.
  #define BIT_MSK__SCDCS_20MS_IN_1MS_CNT__REG_20MS_IN_1MS_CNT                                   0xFF

// SCDCS 100ms WRT 1ms Cnt Register
#define REG_ADDR__SCDCS_100MS_IN_1MS_CNT                                 (RX_AON | 0x00A5)
  // (ReadWrite, Bits 7:0) 
  // SCDCS 100ms count register. The value should be in counts of 1ms. Defaul value is 8'h64. This count is used to generate time out condition for read request. This register is not required to program any new value provided reg_500ns_calib_cnt is programmed as per the rate of OCLK. This is mainly provided for debugging.
  #define BIT_MSK__SCDCS_100MS_IN_1MS_CNT__REG_100MS_IN_1MS_CNT                                  0xFF

// SCDCS 1s WRT 20ms Cnt Register
#define REG_ADDR__SCDCS_1S_IN_20MS_CNT                                   (RX_AON | 0x00A6)
  // (ReadWrite, Bits 7:0) 
  // SCDCS 1s count register. The value should be in counts of 20ms. Defaul value is 8'h32. This is used to check maximum number of Character Error Detect counnts. This register is not required to program any new value provided reg_500ns_calib_cnt is programmed as per the rate of OCLK. This is mainly provided for debugging.
  #define BIT_MSK__SCDCS_1S_IN_20MS_CNT__REG_1S_IN_20MS_CNT                                    0xFF

// SCDCS Character Error Count Max Limit0 Register
#define REG_ADDR__SCDCS_CHR_ERRCNT_MAX0                                  (RX_AON | 0x00A7)
  // (ReadWrite, Bits 7:0) 
  // SCDCS Character Error Maximum limit Counter (LSB Byte). When the channel error count detected on any one of the three channels is crossed this limit then CED_UPD status in SCDCS register will be set. If the error count is not crossed and if the error count is greater than 4 in 1sec time then also CED_UPD will be set.
  #define BIT_MSK__SCDCS_CHR_ERRCNT_MAX0__REG_CHR_ERRCNT_MAX1                                   0xFF

// SCDCS Character Error Count Max Limit1 Register
#define REG_ADDR__SCDCS_CHR_ERRCNT_MAX1                                  (RX_AON | 0x00A8)
  // (ReadWrite, Bits 6:0) 
  // SCDCS Character Error Maximum limit Counter (MSB 7-bits). When the channel error count detected on any one of the three channels is crossed this limit then CED_UPD status in SCDCS register will be set. If the error count is not crossed and if the error count is greater than 4 in 1sec time then also CED_UPD will be set.
  #define BIT_MSK__SCDCS_CHR_ERRCNT_MAX1__REG_CHR_ERRCNT_MAX2                                   0x7F

// SCDCS Control Register
#define REG_ADDR__SCDCS_CNTL                                             (RX_AON | 0x00A9)
  // (ReadWrite, Bits 0) 
  // SCDCS enabled. FW should set this bit if SCDCS of Sink is set in E-EDID. FW should program it initially after boot up. Whenever FW changes this bit in E-EDID same should be programmed into this bit by FW.  When this bit is changed from 0 to 1 (disabled-]enabled) RX/Sink resets RE_Enable bit in DDC-SCDC registers. If the programming clock is much faster and ss implemented hardware operates with 2MHz oscillator clock Sink should see this transition. So frequent switching (0-]1) of this bit may not affect until first transition is sampled on the destination domain.
  #define BIT_MSK__SCDCS_CNTL__REG_SCDCS_ENABLED                                     0x01
  // (ReadWrite, Bits 1) 
  // SW select enable for manufacturer specific values. [0] : Parametric values defined in SCDCS Top module will be used. (Default to 1'b0) [1] : Register values from 0xB0 through 0xDF defined in this sheet will be used.
  #define BIT_MSK__SCDCS_CNTL__REG_SCDCS_MFG_SPFC_SW_SEL                             0x02
  // (ReadWrite, Bits 2) 
  // SCDCS Firmware Read Request Set. FW can assert the read request by setting this bit. This bit automatically cleared by HW once the correesponding Read request was set by RX SCDC DDC.
  #define BIT_MSK__SCDCS_CNTL__REG_SW_RD_REQ_SET                                     0x04
  // (ReadWrite, Bits 4) 
  // Read Request generation FSM SW set. This is used to force the FSM to a state provided in reg_rrgen_fsm_state. This is used for debugging.
  #define BIT_MSK__SCDCS_CNTL__REG_RRGEN_FSM_SET                                     0x10
  // (ReadWrite, Bits 7:5) 
  // Read Request generation FSM SW state. This is used to force the FSM to a required state. This is valid only when reg_rrgen_fsm_set is HIGH. This is used for debugging.
  #define BIT_MSK__SCDCS_CNTL__REG_RRGEN_FSM_STATE                                   0xE0

// SCDCS Debug Status Register
#define REG_ADDR__SCDCS_DBG_STS                                          (RX_AON | 0x00AA)
  // (ReadOnly, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_DBG_STS__REG_SCDCS_DEBUG                                       0xFF

// SCDCS Sink Version Register
#define REG_ADDR__SINK_VERSION                                           (RX_AON | 0x00AB)
  // (ReadWrite, Bits 7:0) 
  // Sink version
  #define BIT_MSK__SINK_VERSION__REG_SCDCS_SNK_VER                                     0xFF

// SCDCS Status0 Register
#define REG_ADDR__SOURCE_VERSION                                         (RX_AON | 0x00AC)
  // (ReadOnly, Bits 7:0) 
  // Source version
  #define BIT_MSK__SOURCE_VERSION__SCDCS_SRC_VER                                         0xFF

// SCDCS Status1 Register
#define REG_ADDR__SCDCS_STATUS1                                          (RX_AON | 0x00AD)
  // (ReadOnly, Bits 0) 
  // This shall set (=1) when a value is changed in the Status Flags register. The sink shall not change this bit when the Source reads a Character Error Detection Register. The Source may write this bit to 1 to clear it. The Sink shall reset the bit to 0 when the Source writes a 1 value to this bit.
  #define BIT_MSK__SCDCS_STATUS1__SCDCS_STS_UPD                                         0x01
  // (ReadOnly, Bits 1) 
  // This shall set (=1) this bit when a value is changed in the Character Error Detection registers. The Source may write this bit to 1 to clear it. The Sink shall reset the bit to 0 when the Source writes a 1 value to this bit. The Sink shall not change this bit when the Source reads a Character Error Detection Register.
  #define BIT_MSK__SCDCS_STATUS1__SCDCS_CED_UPD                                         0x02
  // (ReadOnly, Bits 2) 
  // The Sink shall set (=1) this bit when a test Read Request is generated in response to the setting (=1) of the TestReadRequest bit in the Test Configuration register.
  #define BIT_MSK__SCDCS_STATUS1__SCDCS_RR_TEST                                         0x04
  // (ReadOnly, Bits 3) 
  // Scramble Status. This bit shall be set (=1) by the Sink when the Sink device detects scrambled control code sequences and reset (=0) when the sink does not detect scrambled control code sequences.
  #define BIT_MSK__SCDCS_STATUS1__SCDCS_SCRBL_STATUS                                    0x08
  // (ReadOnly, Bits 4) 
  // This bit shall be set (=1) by the Sink when the Sink device detects a valid clock signal and reset (=0) by the Sink if this condition no longer exists.
  #define BIT_MSK__SCDCS_STATUS1__SCDCS_CLK_DETECTED                                    0x10
  // (ReadOnly, Bits 5) 
  // This bit shall be set (=1) by the Sink when the Sink device is successfully decoding data on HDMI Channel 0 and reset (=0) by the Sink if this condition no longer exists.
  #define BIT_MSK__SCDCS_STATUS1__SCDCS_CH0_LOCKED                                      0x20
  // (ReadOnly, Bits 6) 
  // This bit shall be set (=1) by the Sink when the Sink device is successfully decoding data on HDMI Channel 1 and reset (=0) by the Sink if this condition no longer exists.
  #define BIT_MSK__SCDCS_STATUS1__SCDCS_CH1_LOCKED                                      0x40
  // (ReadOnly, Bits 7) 
  // This bit shall be set (=1) by the Sink when the Sink device is successfully decoding data on HDMI Channel 2 and reset (=0) by the Sink if this condition no longer exists.
  #define BIT_MSK__SCDCS_STATUS1__SCDCS_CH2_LOCKED                                      0x80

// SCDCS Config Status Register
#define REG_ADDR__SCDCS_CONFIG_STATUS                                    (RX_AON | 0x00AE)
  // (ReadOnly, Bits 0) 
  // Read request enable. The Source shall set this bit (=1) when the Source supports Read Request. The Source shall reset this bit (=0) when the Source supports only polling of the update flags. The Sink shall reset (=0) this bit when 1. when +5V Power Signal is not provided by the Source or 2. when the Hot Plug Detect pin has voltage = low for 100 ms or more or 3. when the SCDC of the Sink goes from disabled to enabled state.
  #define BIT_MSK__SCDCS_CONFIG_STATUS__SCDCS_RR_ENABLE                                       0x01
  // (ReadOnly, Bits 2) 
  // Scramble enable. The Source shall set (=1) this bit to enable scrambling in the Sink The Source shall reset (=0) this bit to disable scrambling in the Sink
  #define BIT_MSK__SCDCS_CONFIG_STATUS__SCDCS_SCRBL_ENABLE                                    0x04
  // (ReadOnly, Bits 3) 
  // TMDS bit clock ratio. 0 = (TMDS Bit Period)/(TMDS Clock Period) ratio is 1/10 1 = (TMDS Bit Period)/(TMDS Clock Period) ratio is 1/40
  #define BIT_MSK__SCDCS_CONFIG_STATUS__SCDCS_TMDS_BCLK_RATIO                                 0x08

// SCDCS Test Config Status Register
#define REG_ADDR__SCDCS_TEST_CONFIG                                      (RX_AON | 0x00AF)
  // (ReadOnly, Bits 6:0) 
  // Used in conjunction with the TestReadRequest field. This value should be written with the same DDC transaction that is used to set (=1) TestReadRequest.
  #define BIT_MSK__SCDCS_TEST_CONFIG__SCDCS_TEST_RD_REQ_DLY                                 0x7F
  // (ReadOnly, Bits 7) 
  // After setting the RR_Enable bit, Source Devices may set this bit to 1. Sink devices shall delay TestReadRequestDelay milliseconds before issuing a Read Request. After the Read Request has been issued, the Sink Device shall automatically clear (=0) the TestReadRequest field. In addition, immediately prior to issuing the Read Request, the Sink shall set (=1) the RR_Test Update Flag.
  #define BIT_MSK__SCDCS_TEST_CONFIG__SCDCS_TEST_RD_REQ                                     0x80

// SCDCS CH0 CEDL Status Register
#define REG_ADDR__SCDCS_CED0_L                                           (RX_AON | 0x00B0)
  // (ReadOnly, Bits 7:0) 
  // Channel0 character error count byte0. Bits : [7:0] The Character Error Detection counters are not writable by the Source and cleared on read by the Source.
  #define BIT_MSK__SCDCS_CED0_L__SCDCS_CH0_CED_CNT_B7_B0                               0xFF

// SCDCS CH0 CEDH Status Register
#define REG_ADDR__SCDCS_CED0_H                                           (RX_AON | 0x00B1)
  // (ReadOnly, Bits 6:0) 
  // Channel0 character error count byte0. Bits : [14:8] The Character Error Detection counters are not writable by the Source and cleared on read by the Source.
  #define BIT_MSK__SCDCS_CED0_H__SCDCS_CH0_CED_CNT_B14_B8                              0x7F
  // (ReadOnly, Bits 7) 
  // Channel0 valid. Cleared on read by the Source.
  #define BIT_MSK__SCDCS_CED0_H__SCDCS_CH0_VLD                                         0x80

// SCDCS CH1 CEDL Status Register
#define REG_ADDR__SCDCS_CED1_L                                           (RX_AON | 0x00B2)
  // (ReadOnly, Bits 7:0) 
  // Channel1 character error count byte0. Bits : [7:0] The Character Error Detection counters are not writable by the Source and cleared on read by the Source.
  #define BIT_MSK__SCDCS_CED1_L__SCDCS_CH1_CED_CNT_B7_B0                               0xFF

// SCDCS CH1 CEDH Status Register
#define REG_ADDR__SCDCS_CED1_H                                           (RX_AON | 0x00B3)
  // (ReadOnly, Bits 6:0) 
  // Channel1 character error count byte0. Bits : [14:8] The Character Error Detection counters are not writable by the Source and cleared on read by the Source.
  #define BIT_MSK__SCDCS_CED1_H__SCDCS_CH1_CED_CNT_B14_B8                              0x7F
  // (ReadOnly, Bits 7) 
  // Channel1 valid. Cleared on read by the Source.
  #define BIT_MSK__SCDCS_CED1_H__SCDCS_CH1_VLD                                         0x80

// SCDCS CH2 CEDL Status Register
#define REG_ADDR__SCDCS_CED2_L                                           (RX_AON | 0x00B4)
  // (ReadOnly, Bits 7:0) 
  // Channel2 character error count byte0. Bits : [7:0] The Character Error Detection counters are not writable by the Source and cleared on read by the Source.
  #define BIT_MSK__SCDCS_CED2_L__SCDCS_CH2_CED_CNT_B7_B0                               0xFF

// SCDCS CH2 CEDH Status Register
#define REG_ADDR__SCDCS_CED2_H                                           (RX_AON | 0x00B5)
  // (ReadOnly, Bits 6:0) 
  // Channel2 character error count byte0. Bits : [14:8] The Character Error Detection counters are not writable by the Source and cleared on read by the Source.
  #define BIT_MSK__SCDCS_CED2_H__SCDCS_CH2_CED_CNT_B14_B8                              0x7F
  // (ReadOnly, Bits 7) 
  // Channel2 valid. Cleared on read by the Source.
  #define BIT_MSK__SCDCS_CED2_H__SCDCS_CH2_VLD                                         0x80

// SCDCS CED Checksum Status Register
#define REG_ADDR__SCDCS_CED_CHECKSUM                                     (RX_AON | 0x00B6)
  // (ReadOnly, Bits 7:0) 
  // The Checksum shall be implemented such that a one-byte sum of the 7 registers of Character Error Detection including the Checksum itself (reg_chX_chr_errdet_cnt and reg_chr_errcnt_chksum) is equal to zero.
  #define BIT_MSK__SCDCS_CED_CHECKSUM__SCDCS_CED_CHKSUM                                      0xFF

// SCDCS MFCTR OUI1 Register
#define REG_ADDR__SCDCS_MFCTR_OUI1                                       (RX_AON | 0x00B7)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_OUI1__REG_SCDCS_MFG_OUI1                                    0xFF

// SCDCS MFCTR OUI2 Register
#define REG_ADDR__SCDCS_MFCTR_OUI2                                       (RX_AON | 0x00B8)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_OUI2__REG_SCDCS_MFG_OUI2                                    0xFF

// SCDCS MFCTR OUI3 Register
#define REG_ADDR__SCDCS_MFCTR_OUI3                                       (RX_AON | 0x00B9)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_OUI3__REG_SCDCS_MFG_OUI3                                    0xFF

// SCDCS DEV_ID_STR0 Register
#define REG_ADDR__SCDCS_DEV_ID_STR0                                      (RX_AON | 0x00BA)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_DEV_ID_STR0__REG_SCDCS_DEV_ID_B7_B0                                0xFF

// SCDCS DEV_ID_STR1 Register
#define REG_ADDR__SCDCS_DEV_ID_STR1                                      (RX_AON | 0x00BB)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_DEV_ID_STR1__REG_SCDCS_DEV_ID_B15_B8                               0xFF

// SCDCS DEV_ID_STR2 Register
#define REG_ADDR__SCDCS_DEV_ID_STR2                                      (RX_AON | 0x00BC)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_DEV_ID_STR2__REG_SCDCS_DEV_ID_B23_B16                              0xFF

// SCDCS DEV_ID_STR3 Register
#define REG_ADDR__SCDCS_DEV_ID_STR3                                      (RX_AON | 0x00BD)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_DEV_ID_STR3__REG_SCDCS_DEV_ID_B31_B24                              0xFF

// SCDCS DEV_ID_STR4 Register
#define REG_ADDR__SCDCS_DEV_ID_STR4                                      (RX_AON | 0x00BE)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_DEV_ID_STR4__REG_SCDCS_DEV_ID_B39_B32                              0xFF

// SCDCS DEV_ID_STR5 Register
#define REG_ADDR__SCDCS_DEV_ID_STR5                                      (RX_AON | 0x00BF)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_DEV_ID_STR5__REG_SCDCS_DEV_ID_B47_B40                              0xFF

// SCDCS DEV_ID_STR5 Register
#define REG_ADDR__SCDCS_DEV_ID_STR6                                      (RX_AON | 0x00C0)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_DEV_ID_STR6__REG_SCDCS_DEV_ID_B55_B48                              0xFF

// SCDCS DEV_ID_STR7 Register
#define REG_ADDR__SCDCS_DEV_ID_STR7                                      (RX_AON | 0x00C1)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_DEV_ID_STR7__REG_SCDCS_DEV_ID_B63_B56                              0xFF

// SCDCS HW_REV Register
#define REG_ADDR__SCDCS_HW_REV                                           (RX_AON | 0x00C2)
  // (ReadWrite, Bits 3:0) 
  // 
  #define BIT_MSK__SCDCS_HW_REV__REG_SCDCS_HW_MNR_REV                                  0x0F
  // (ReadWrite, Bits 7:4) 
  // 
  #define BIT_MSK__SCDCS_HW_REV__REG_SCDCS_HW_MJR_REV                                  0xF0

// SCDCS SW_MAJOR_REV Register
#define REG_ADDR__SCDCS_SW_MJR_REV                                       (RX_AON | 0x00C3)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_SW_MJR_REV__REG_SCDCS_SW_MJR_REV                                  0xFF

// SCDCS SW_MINOR_REV Register
#define REG_ADDR__SCDCS_SW_MNR_REV                                       (RX_AON | 0x00C4)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_SW_MNR_REV__REG_SCDCS_SW_MNR_REV                                  0xFF

// SCDCS MFCTR SPCF0 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF0                                      (RX_AON | 0x00C5)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF0__REG_SCDCS_MFCTR_SPCF_B7_B0                            0xFF

// SCDCS MFCTR SPCF1 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF1                                      (RX_AON | 0x00C6)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF1__REG_SCDCS_MFCTR_SPCF_B15_B8                           0xFF

// SCDCS MFCTR SPCF2 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF2                                      (RX_AON | 0x00C7)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF2__REG_SCDCS_MFCTR_SPCF_B23_B16                          0xFF

// SCDCS MFCTR SPCF3 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF3                                      (RX_AON | 0x00C8)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF3__REG_SCDCS_MFCTR_SPCF_B31_B24                          0xFF

// SCDCS MFCTR SPCF4 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF4                                      (RX_AON | 0x00C9)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF4__REG_SCDCS_MFCTR_SPCF_B39_B32                          0xFF

// SCDCS MFCTR SPCF5 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF5                                      (RX_AON | 0x00CA)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF5__REG_SCDCS_MFCTR_SPCF_B47_B40                          0xFF

// SCDCS MFCTR SPCF6 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF6                                      (RX_AON | 0x00CB)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF6__REG_SCDCS_MFCTR_SPCF_B55_B48                          0xFF

// SCDCS MFCTR SPCF7 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF7                                      (RX_AON | 0x00CC)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF7__REG_SCDCS_MFCTR_SPCF_B63_B56                          0xFF

// SCDCS MFCTR SPCF8 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF8                                      (RX_AON | 0x00CD)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF8__REG_SCDCS_MFCTR_SPCF_B71_B64                          0xFF

// SCDCS MFCTR SPCF9 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF9                                      (RX_AON | 0x00CE)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF9__REG_SCDCS_MFCTR_SPCF_B79_B72                          0xFF

// SCDCS MFCTR SPCF10 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF10                                     (RX_AON | 0x00CF)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF10__REG_SCDCS_MFCTR_SPCF_B87_B80                          0xFF

// SCDCS MFCTR SPCF11 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF11                                     (RX_AON | 0x00D0)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF11__REG_SCDCS_MFCTR_SPCF_B95_B88                          0xFF

// SCDCS MFCTR SPCF12 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF12                                     (RX_AON | 0x00D1)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF12__REG_SCDCS_MFCTR_SPCF_B103_B96                         0xFF

// SCDCS MFCTR SPCF13 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF13                                     (RX_AON | 0x00D2)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF13__REG_SCDCS_MFCTR_SPCF_B111_B104                        0xFF

// SCDCS MFCTR SPCF14 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF14                                     (RX_AON | 0x00D3)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF14__REG_SCDCS_MFCTR_SPCF_B119_B112                        0xFF

// SCDCS MFCTR SPCF15 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF15                                     (RX_AON | 0x00D4)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF15__REG_SCDCS_MFCTR_SPCF_B127_B120                        0xFF

// SCDCS MFCTR SPCF16 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF16                                     (RX_AON | 0x00D5)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF16__REG_SCDCS_MFCTR_SPCF_B135_B128                        0xFF

// SCDCS MFCTR SPCF17 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF17                                     (RX_AON | 0x00D6)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF17__REG_SCDCS_MFCTR_SPCF_B143_B136                        0xFF

// SCDCS MFCTR SPCF18 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF18                                     (RX_AON | 0x00D7)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF18__REG_SCDCS_MFCTR_SPCF_B151_B144                        0xFF

// SCDCS MFCTR SPCF19 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF19                                     (RX_AON | 0x00D8)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF19__REG_SCDCS_MFCTR_SPCF_B159_B152                        0xFF

// SCDCS MFCTR SPCF20 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF20                                     (RX_AON | 0x00D9)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF20__REG_SCDCS_MFCTR_SPCF_B167_B160                        0xFF

// SCDCS MFCTR SPCF21 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF21                                     (RX_AON | 0x00DA)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF21__REG_SCDCS_MFCTR_SPCF_B175_B168                        0xFF

// SCDCS MFCTR SPCF22 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF22                                     (RX_AON | 0x00DB)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF22__REG_SCDCS_MFCTR_SPCF_B183_B176                        0xFF

// SCDCS MFCTR SPCF23 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF23                                     (RX_AON | 0x00DC)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF23__REG_SCDCS_MFCTR_SPCF_B191_B184                        0xFF

// SCDCS MFCTR SPCF24 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF24                                     (RX_AON | 0x00DD)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF24__REG_SCDCS_MFCTR_SPCF_B199_B192                        0xFF

// SCDCS MFCTR SPCF25 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF25                                     (RX_AON | 0x00DE)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF25__REG_SCDCS_MFCTR_SPCF_B207_B200                        0xFF

// SCDCS MFCTR SPCF26 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF26                                     (RX_AON | 0x00DF)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF26__REG_SCDCS_MFCTR_SPCF_B215_B208                        0xFF

// SCDCS MFCTR SPCF27 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF27                                     (RX_AON | 0x00E0)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF27__REG_SCDCS_MFCTR_SPCF_B223_B216                        0xFF

// SCDCS MFCTR SPCF28 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF28                                     (RX_AON | 0x00E1)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF28__REG_SCDCS_MFCTR_SPCF_B231_B224                        0xFF

// SCDCS MFCTR SPCF29 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF29                                     (RX_AON | 0x00E2)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF29__REG_SCDCS_MFCTR_SPCF_B239_B232                        0xFF

// SCDCS MFCTR SPCF30 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF30                                     (RX_AON | 0x00E3)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF30__REG_SCDCS_MFCTR_SPCF_B247_B240                        0xFF

// SCDCS MFCTR SPCF31 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF31                                     (RX_AON | 0x00E4)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF31__REG_SCDCS_MFCTR_SPCF_B255_B248                        0xFF

// SCDCS MFCTR SPCF32 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF32                                     (RX_AON | 0x00E5)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF32__REG_SCDCS_MFCTR_SPCF_B263_B256                        0xFF

// SCDCS MFCTR SPCF33 Register
#define REG_ADDR__SCDCS_MFCTR_SPCF33                                     (RX_AON | 0x00E6)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__SCDCS_MFCTR_SPCF33__REG_SCDCS_MFCTR_SPCF_B271_B264                        0xFF

// HDMI-M Control Bus Control Register
#define REG_ADDR__RX_HDMIM_CP_CTRL                                       (RX_AON | 0x00F1)
  // (ReadWrite, Bits 0) 
  // Force port 0 HDMI-M mode
  #define BIT_MSK__RX_HDMIM_CP_CTRL__REG_FORCE_HDMIM_MODE0                                 0x01
  // (ReadWrite, Bits 4) 
  // Disable port[3:0] HDMI-M mode
  #define BIT_MSK__RX_HDMIM_CP_CTRL__REG_HDMIM_PORT_DISABLE                                0x10

// HDMI-M Control Bus PAD status Register
#define REG_ADDR__RX_HDMIM_CP_PAD_STAT                                   (RX_AON | 0x00F2)
  // (ReadOnly, Bits 4) 
  // 20MHz oscillator power save control signal status
  #define BIT_MSK__RX_HDMIM_CP_PAD_STAT__REG_HDMIM_OSC_EN                                      0x10

// CBUS connected Register
#define REG_ADDR__RX_CBUS_CONNECTED                                      (RX_AON | 0x00F3)
  // (ReadOnly, Bits 0) 
  // Device is connected  to this port
  #define BIT_MSK__RX_CBUS_CONNECTED__CBUS_CONNECTED                                        0x01

// HPD c Ctrl  Register
#define REG_ADDR__RX_HPD_C_CTRL                                          (RX_AON | 0x00F5)
  // (ReadWrite, Bits 0) 
  // This register bit carries the value to be driven on hpd_c output. Value in this register bit is driven onto hpd_c output when any of the following conditions is true. 1. reg_hpd_ovrt_ctrl field of RX_HPD_OVRT_CTRL register is HIGH. 2. When the link established is not an MHL connection and a HDMI connection is established.
  #define BIT_MSK__RX_HPD_C_CTRL__REG_HPD_C_CTRL                                        0x01

// HPD oen Ctrl  Register
#define REG_ADDR__RX_HPD_OEN_CTRL                                        (RX_AON | 0x00F6)
  // (ReadWrite, Bits 0) 
  // This register bit carries the value to be driven on hpd_oen output. Value in this register bit is driven onto hpd_oen output when any of the following conditions is true. 1. reg_hpd_ovrt_ctrl field of RX_HPD_OVRT_CTRL register is HIGH. 2. When the link established is not an MHL connection.
  #define BIT_MSK__RX_HPD_OEN_CTRL__REG_HPD_OEN_CTRL                                      0x01

// HPD PE Ctrl  Register
#define REG_ADDR__RX_HPD_PE_CTRL                                         (RX_AON | 0x00F7)
  // (ReadWrite, Bits 0) 
  // This register bit carries the value to be driven on hpd_pe output. Value in this register bit is driven onto hpd_pe output when any of the following conditions is true. 1. reg_hpd_ovrt_ctrl field of RX_HPD_OVRT_CTRL register is HIGH. 2. When the link established is not an MHL connection.
  #define BIT_MSK__RX_HPD_PE_CTRL__REG_HPD_PE_CTRL                                       0x01

// HPD PU Ctrl  Register
#define REG_ADDR__RX_HPD_PU_CTRL                                         (RX_AON | 0x00F8)
  // (ReadWrite, Bits 0) 
  // This register bit carries the value to be driven on hpd_pu output. Value in this register bit is driven onto hpd_pu output when any of the following conditions is true. 1. reg_hpd_ovrt_ctrl field of RX_HPD_OVRT_CTRL register is HIGH. 2. When the link established is not an MHL connection.
  #define BIT_MSK__RX_HPD_PU_CTRL__REG_HPD_PU_CTRL                                       0x01

// HPD Software Control Register
#define REG_ADDR__RX_HPD_OVRT_CTRL                                       (RX_AON | 0x00F9)
  // (ReadWrite, Bits 0) 
  // HPD Overwrite control: This register bit controls the HPD PAD signal overriding. 0 -  No Override. Values from hardware drive the HPD PAD signals 1 - Override. Values from respective registers above drive the HPD PAD signals
  #define BIT_MSK__RX_HPD_OVRT_CTRL__REG_HPD_OVRT_CTRL                                     0x01
  // (ReadWrite, Bits 1) 
  // CBUS Tri-state Enable: This register field control the Enabling of CBUS PAD Tri-state logic. 0 - Disabled 1 - Enabled  This field when HIGH, tri-states the CBUS PAD i.e. forces it to Input mode of operation.
  #define BIT_MSK__RX_HPD_OVRT_CTRL__REG_TRI_CBUS_EN                                       0x02

// RSEN Ctrl Register
#define REG_ADDR__RX_RSEN_CTRL                                           (RX_AON | 0x00FA)
  // (ReadWrite, Bits 7) 
  // 1 will sending HPD set packet when MHL is discovered. 0 will NOT sending HPD set packet when MHL is discovered
  #define BIT_MSK__RX_RSEN_CTRL__NVRAM_MHL_HPD_EN                                      0x80

// NVRAM #1 Register
#define REG_ADDR__RX_MHL_CTRL                                            (RX_AON | 0x00FC)
  // (ReadWrite, Bits 3) 
  // when 1 and MHL cable connected discovery logic will start
  #define BIT_MSK__RX_MHL_CTRL__HW_CABLE_CONN                                         0x08

// CBUS MHL3 Discovery Register
#define REG_ADDR__CBUS_MHL3_DISC                                         (RX_AON | 0x00FD)
  // (ReadWrite, Bits 0) 
  // 
  #define BIT_MSK__CBUS_MHL3_DISC__MHL3DISC_EN_SW                                        0x01
  // (ReadWrite, Bits 1) 
  // 
  #define BIT_MSK__CBUS_MHL3_DISC__MHL3DISC_EN                                           0x02
  // (ReadOnly, Bits 4) 
  // 
  #define BIT_MSK__CBUS_MHL3_DISC__MHL3DISC_EN_HW                                        0x10

// CBUS MHL3 Control Register
#define REG_ADDR__RX_CBUS_PORT_SEL                                       (RX_AON | 0x00FE)
  // (ReadWrite, Bits 0) 
  // 
  #define BIT_MSK__RX_CBUS_PORT_SEL__SW_MHL3_SEL                                           0x01
  // (ReadWrite, Bits 1) 
  // 
  #define BIT_MSK__RX_CBUS_PORT_SEL__M3AV_EN                                               0x02
  // (ReadWrite, Bits 2) 
  // 
  #define BIT_MSK__RX_CBUS_PORT_SEL__EXTMHL3_EN                                            0x04

//***************************************************************************
// RX_PWD_HDCP1X. Address: 60
// Power Down Control Register
#define REG_ADDR__RX_PWD_CTRL                                            (RX_PWD_HDCP1X | 0x0001)
  // (ReadWrite, Bits 0) 
  // TMDS Core Isolation enable. Reconfigures pins so we could test the part as a discrete core
  #define BIT_MSK__RX_PWD_CTRL__REG_CORE_ISO_EN                                       0x01
  // (ReadWrite, Bits 1) 
  // PoWer Down Domain Isolation Enabled: This bit drives the PoWer Down domain to Always ON domain isolation enable. This bit is static and never to be programmed when Power Domain separation is required in the design.
  #define BIT_MSK__RX_PWD_CTRL__RI_PWD_ISOLATION_EN                                   0x02
  // (ReadWrite, Bits 4) 
  // default=0;  This bit is xored with mode signal coming from TMDS core and then used to send the data out in dvi_rx_dig bypass mode
  #define BIT_MSK__RX_PWD_CTRL__REG_TMDS_MODE_INV                                     0x10
  // (ReadWrite, Bits 5) 
  // Receiver digital logic bypass mode.
  #define BIT_MSK__RX_PWD_CTRL__REG_DVI_RX_DIG_BYPASS                                 0x20
  // (ReadWrite, Bits 7) 
  // Consumer Elctronics or Mobile selection 0 : Mobile 1 : Consumer electronics
  #define BIT_MSK__RX_PWD_CTRL__REG_MHL3CE_SEL_RX                                     0x80

// Power Down Software Reset 3 Register
#define REG_ADDR__RX_PWD_SRST3                                           (RX_PWD_HDCP1X | 0x0004)
  // (ReadWrite, Bits 2) 
  // Active high CoC sink soft reset
  #define BIT_MSK__RX_PWD_SRST3__REG_COCSNK_SRST                                       0x04
  // (ReadWrite, Bits 3) 
  // Active high DoC sink soft reset
  #define BIT_MSK__RX_PWD_SRST3__REG_DOCSNK_SRST                                       0x08
  // (ReadWrite, Bits 4) 
  // Active high reset soft signal for TDM. Power on reset and should be controlled by software. (External synchronizer is required)
  #define BIT_MSK__RX_PWD_SRST3__REG_TDM_SRST                                          0x10

// Power Down Software Reset Register
#define REG_ADDR__RX_PWD_SRST                                            (RX_PWD_HDCP1X | 0x0005)
  // (ReadWrite, Bits 0) 
  // Auto audio FIFO reset: 0 - Manual audio FIFO reset (default) 1 - Auto audio FIFO reset whenever audio FIFO overflows or under runs
  #define BIT_MSK__RX_PWD_SRST__REG_AUD_FIFO_RST_AUTO                                 0x01
  // (ReadWrite, Bits 1) 
  // Audio FIFO reset.  Note: asserting Software Reset will also reset (flush) the FIFO: 1 - Reset (flush) FIFO; 0 - Normal operation (default).
  #define BIT_MSK__RX_PWD_SRST__REG_FIFO_RST                                          0x02
  // (ReadWrite, Bits 2) 
  // Audio Clock Regeneration reset: 1 - Reset ACR clock divider circuits; 0 - Normal operation (default).
  #define BIT_MSK__RX_PWD_SRST__REG_ACR_RST                                           0x04
  // (ReadWrite, Bits 3) 
  // HDCP1x Soft Reset. 0 - Normal operation(default) 1 - Resets HDCP1x logic
  #define BIT_MSK__RX_PWD_SRST__REG_HDCP_RST                                          0x08
  // (ReadWrite, Bits 4) 
  // Deep-color FIFO reset.  Note: asserting Software Reset will also reset (flush) the FIFO: 1 - Reset (flush) FIFO; 0 - Normal operation (default).
  #define BIT_MSK__RX_PWD_SRST__REG_DC_FIFO_RST                                       0x10
  // (ReadWrite, Bits 5) 
  // Auto Audio Config reset: 1 - Reset AAC logic; 0 - Normal operation (default).
  #define BIT_MSK__RX_PWD_SRST__REG_AAC_RST                                           0x20
  // (ReadWrite, Bits 6) 
  // Auto ACR reset: 0 - Manual ACR reset (default) 1 - Auto ACR reset whenever SCDT = 0 If SRST (reg. 0x005[0]) is applied then pclk stop interrupt may continue to be stuck in asserted condition. Need to assert this reset to clear receiving side of the handshaking logic.
  #define BIT_MSK__RX_PWD_SRST__REG_ACR_RST_AUTO                                      0x40
  // (ReadWrite, Bits 7) 
  // Auto HDCP1x reset. This bit controls the reset behaviour of the HDCP1x Reset when SCDT goes LOW. 0 - Manual HDCP1x reset (default) 1 - Auto HDCP1x reset when SCDT is LOW
  #define BIT_MSK__RX_PWD_SRST__REG_HDCP_RST_AUTO                                     0x80

// Power Down Rx State Register
#define REG_ADDR__RX_STATE_PWD                                           (RX_PWD_HDCP1X | 0x0006)
  // (ReadOnly, Bits 2) 
  // State of VSYNC: This signal indicates the state/level of VSYNC in the hardware.  It is more or less useful for hardware debug in case of any basic check needed. No software action is required on this status register.
  #define BIT_MSK__RX_STATE_PWD__VSYNC_CAP                                             0x04

// System Control Register#1
#define REG_ADDR__RX_SYS_CTRL1                                           (RX_PWD_HDCP1X | 0x0007)
  // (ReadWrite, Bits 0) 
  // Power Down everything except PD_OSC; PD_FULL; PD_TERM; PD_PCLK; PD_MCLK. 0 - Power down (default).   1 - normal operation.
  #define BIT_MSK__RX_SYS_CTRL1__REG_PD_ALL                                            0x01
  // (ReadWrite, Bits 1) 
  // 1 -  sync polarity is positive (default) 0-  sync polarity is negative.
  #define BIT_MSK__RX_SYS_CTRL1__REG_SYNC_POL                                          0x02

// System TMDS to Channel mapping Register
#define REG_ADDR__SYS_TMDS_CH_MAP                                        (RX_PWD_HDCP1X | 0x000E)
  // (ReadWrite, Bits 1:0) 
  // TMDS Data select for channel #0:  00 - will take tmds phy data[23:16] - default 01 - will take tmds phy data[15:8] 10 - will take tmds phy data[7:0] 11 - will assign zero
  #define BIT_MSK__SYS_TMDS_CH_MAP__REG_DI_CH0_SEL                                        0x03
  // (ReadWrite, Bits 3:2) 
  // TMDS Data select for channel #1:  00 - will take tmds phy data[23:16] 01 - will take tmds phy data[15:8] - default 10 - will take tmds phy data[7:0] 11 - will assign zero
  #define BIT_MSK__SYS_TMDS_CH_MAP__REG_DI_CH1_SEL                                        0x0C
  // (ReadWrite, Bits 5:4) 
  // TMDS Data select for channel #1:  00 - will take tmds phy data[23:16] 01 - will take tmds phy data[15:8] 10 - will take tmds phy data[7:0] - default 11 - will assign zero
  #define BIT_MSK__SYS_TMDS_CH_MAP__REG_DI_CH2_SEL                                        0x30

// System invert and revert TMDS data Register
#define REG_ADDR__SYS_TMDS_D_IR                                          (RX_PWD_HDCP1X | 0x000F)
  // (ReadWrite, Bits 0) 
  // Select for channle #0 between [7:0] and [0:7] format: 0 is [7:0]
  #define BIT_MSK__SYS_TMDS_D_IR__REG_DI_CH0_BSI                                        0x01
  // (ReadWrite, Bits 1) 
  // Select for channle #1 between [7:0] and [0:7] format: 0 is [7:0]
  #define BIT_MSK__SYS_TMDS_D_IR__REG_DI_CH1_BSI                                        0x02
  // (ReadWrite, Bits 2) 
  // Select for channle #2 between [7:0] and [0:7] format: 0 is [7:0]
  #define BIT_MSK__SYS_TMDS_D_IR__REG_DI_CH2_BSI                                        0x04
  // (ReadWrite, Bits 3) 
  // Select for channle #0 to invert data: 0 - no invert
  #define BIT_MSK__SYS_TMDS_D_IR__REG_DI_CH0_INVT                                       0x08
  // (ReadWrite, Bits 4) 
  // Select for channle #1 to invert data: 0 - no invert
  #define BIT_MSK__SYS_TMDS_D_IR__REG_DI_CH1_INVT                                       0x10
  // (ReadWrite, Bits 5) 
  // Select for channle #2 to invert data: 0 - no invert
  #define BIT_MSK__SYS_TMDS_D_IR__REG_DI_CH2_INVT                                       0x20
  // (ReadWrite, Bits 6) 
  // Enable for dff latching data coming from TMDS Phy: 0 - enable
  #define BIT_MSK__SYS_TMDS_D_IR__REG_PHY_DI_DFF_EN                                     0x40

// Repater FIFO RDY CTRL Register
#define REG_ADDR__RX_RPT_RDY_CTRL                                        (RX_PWD_HDCP1X | 0x0010)
  // (ReadWrite, Bits 2:0) 
  // [0] enable clear of FIFO_RDY if ckdt interrupt is set [1] enable clear of FIFO_RDY if skdt interrupt is set [2] enable clear of FIFO_RDY if no pwr5V  interrupt is set  This is also used to clear the HDMI mode enable when reg_hdmi_mode_clr_en is set
  #define BIT_MSK__RX_RPT_RDY_CTRL__REG_FIFORDY_CLR_EN                                    0x07
  // (ReadWrite, Bits 3) 
  // enable clear of bstatus hdmi mode if no pwr5V
  #define BIT_MSK__RX_RPT_RDY_CTRL__REG_HDMI_MODE_CLR_EN                                  0x08

// Power Down Software Reset Register2
#define REG_ADDR__RX_PWD_SRST2                                           (RX_PWD_HDCP1X | 0x0011)
  // (ReadWrite, Bits 0) 
  // HSCP2x TMDS Soft Reset. 0 - Normal operation(default) 1 - Resets the Decryption logic in HDCP2x operating with TMDS Clock
  #define BIT_MSK__RX_PWD_SRST2__REG_HDCP2_TRST                                        0x01
  // (ReadWrite, Bits 1) 
  // Auto HDCP2x TMDS Reset. This bit controls the reset behaviour of the HDCP2x TMDS Reset when SCDT goes LOW. 0 - Manual HDCP2 reset (default) 1 - Auto HDCP2 reset when SCDT is LOW
  #define BIT_MSK__RX_PWD_SRST2__REG_HDCP2_TRST_AUTO                                   0x02
  // (ReadWrite, Bits 2) 
  // HDCP2x Timer Clock Soft Reset: 1 - Resets logic operating in timer clock i.e. eclk of HDCP2x 0 - Normal operation (default).
  #define BIT_MSK__RX_PWD_SRST2__REG_HDCP2X_ERST                                       0x04
  // (ReadWrite, Bits 3) 
  // HDCP2x Core Clock Soft Reset: 1 - Resets logic operating in core clock i.e. cclk of HDCP2x 0 - Normal operation (default).
  #define BIT_MSK__RX_PWD_SRST2__REG_HDCP2X_CRST                                       0x08
  // (ReadWrite, Bits 4) 
  // Digital Audio Clock Regeneration Soft Reset: 1 - Resets (DACR) Digital clock recovery circuits 0 - Normal operation (default).
  #define BIT_MSK__RX_PWD_SRST2__REG_DACR_RST                                          0x10
  // (ReadWrite, Bits 7) 
  // MHL3 Rx AV Link Reset 0 - No effect 1 - Resets the MHL3 Rx AV Link logic
  #define BIT_MSK__RX_PWD_SRST2__REG_RXAV_LSRST                                        0x80

// Power Down Software Reset Register4
#define REG_ADDR__RX_PWD_SRST4                                           (RX_PWD_HDCP1X | 0x0012)
  // (ReadWrite, Bits 0) 
  // Edge select for SPI MOSI. Set 1 to choose negedge for MOSI capture. Set 0 to choose posedge for MOSI capture.
  #define BIT_MSK__RX_PWD_SRST4__REG_SPI_MOSI_EDGE                                     0x01
  // (ReadWrite, Bits 1) 
  // Edge select for SPI MISO. Set 1 to choose posedge for MISO data launch. Set 0 to choose negedge for MISO data launch.
  #define BIT_MSK__RX_PWD_SRST4__REG_SPI_MISO_EDGE                                     0x02
  // (ReadWrite, Bits 5) 
  // SPI SW reset for non-CBUS and non-HDCP area
  #define BIT_MSK__RX_PWD_SRST4__REG_SPI_SRST                                          0x20
  // (ReadWrite, Bits 6) 
  // SPI SW reset for CBUS related
  #define BIT_MSK__RX_PWD_SRST4__REG_SPI_CBUSRST                                       0x40
  // (ReadWrite, Bits 7) 
  // SPI SW reset for HDCP related logic
  #define BIT_MSK__RX_PWD_SRST4__REG_SPI_HDCPRST                                       0x80

// TMDS clock Control Register 2
#define REG_ADDR__RX_TMDS_CCTRL2                                         (RX_PWD_HDCP1X | 0x0013)
  // (ReadWrite, Bits 3:0) 
  // Control bits for the Deep-color clock from the TMDS Rx core. 000x = 8bpp 1x clock  001x = 8bpp 2x clock  0100 = 10bpp 1x Deep-color clock 0101 = 12bpp 1x Deep-color clock 0110 = 10bpp 2x Deep-color clock 0111 = 12bpp 2x Deep-color clock 1xxx = reserved
  #define BIT_MSK__RX_TMDS_CCTRL2__REG_DC_CTL                                            0x0F
  // (ReadWrite, Bits 4) 
  // Deep Color Control overwrite. 0 - Uses hw value (default) 1 - Uses sw value from 0x081[3:0].
  #define BIT_MSK__RX_TMDS_CCTRL2__REG_DC_CTL_OW                                         0x10
  // (ReadWrite, Bits 5) 
  // Enable for the Alice18 core DC balance compensation 0 = disable  1 = enable (default)
  #define BIT_MSK__RX_TMDS_CCTRL2__REG_OFFSET_COEN                                       0x20

// HDCP2x Control Register
#define REG_ADDR__RX_HDCP2X_CTRL                                         (RX_PWD_HDCP1X | 0x0014)
  // (ReadWrite, Bits 0) 
  // HDCP2x Enabled:This bit controls the enabling of HDCP2x functionality. 0 - HDCP2x Disabled 1 - HDCP2x Enabled This bit when set HIGH; enables HDCP2x functionality as well else only HDCP1x is functional.
  #define BIT_MSK__RX_HDCP2X_CTRL__RI_HDCP2X_EN                                          0x01
  // (ReadOnly, Bits 7) 
  // HDCP2x Mode Selected: This bit indicates the HDCP device selection from Source. 0 - HDCP1x Device 1 - HDCP2x Device This big when HIGH; indicates that an HDCP2x device is selected for decryption by the Source else HDCP1x is selected. This bit is valid only ri_hdcpex_en bit is HIGH.
  #define BIT_MSK__RX_HDCP2X_CTRL__HDCP2X_MODE_SEL                                       0x80

// Video Path Page Address Control Register
#define REG_ADDR__VIDEO_PATH_PAGE_CTRL                                   (RX_PWD_HDCP1X | 0x0015)
  // (ReadWrite, Bits 1:0) 
  // This field is used to control the page address of the video path core registers Page-A represents the video path registers. Video path has 3 pages. Based on this field value corresponding page of video path will be selected. 00 : Video Path Core Registers 01 : Video Path Core Registers CMS core registers 10 : Video Path Core Registers CMS core registers CSC core 0 and 1 registers 11 : Reserved
  #define BIT_MSK__VIDEO_PATH_PAGE_CTRL__REG_VIDPATH_PAGE_CTRL                                 0x03

// Video Mode Control Register
#define REG_ADDR__VIDEO_MODE_CTRL                                        (RX_PWD_HDCP1X | 0x0016)
  // (ReadWrite, Bits 0) 
  // This field is used to enable YCC 422 luminance and chroma components separation
  #define BIT_MSK__VIDEO_MODE_CTRL__REG_EXT_BIT_MODE                                      0x01
  // (ReadWrite, Bits 1) 
  // This field controls the Deep Colour Conversion Bypass. 0 - Routes the output of TMDS Clock to Pixel Clock to Video Pipeline 1 - Routes the input of TMDS Clock to Pixel Clock to Video Pipeline
  #define BIT_MSK__VIDEO_MODE_CTRL__REG_DC_BYPASS                                         0x02

// Stream Page Control Register
#define REG_ADDR__STREAM_PAGE_CTRL                                       (RX_PWD_HDCP1X | 0x0017)
  // (ReadWrite, Bits 1:0) 
  // This field is used to control the page address of the depacketizer registers for different streams 00 : Depacketizer Registers for stream0 01 : Depacketizer Registers for stream1 10 - 11 : Reserved
  #define BIT_MSK__STREAM_PAGE_CTRL__REG_DEPKT_PAGE_CTRL                                   0x03

// PWD Clock Gating Control Register0
#define REG_ADDR__PWD_CLK_CTRL0                                          (RX_PWD_HDCP1X | 0x0018)
  // (ReadWrite, Bits 0) 
  // This field controls the Gating of Clock to TMDS BIST logic in Sherman. 0 - Does Not Gate the Clock 1 - Gates the Clock
  #define BIT_MSK__PWD_CLK_CTRL0__RI_TBIST_CLK_GATE                                     0x01
  // (ReadWrite, Bits 1) 
  // This field controls the Hardware Gating of Clocks to the Depacketizer logic in Sherman. 0 - Does Not Enable Gating the Clock 1 - Enables Gating the Clock
  #define BIT_MSK__PWD_CLK_CTRL0__RI_DEPACK_CLK_GATE_EN                                 0x02
  // (ReadWrite, Bits 4) 
  // This field controls the Hardware Gating of Core Clock to HDCP2x. 0 - Does Not Enable Gating the Clock 1 - Enables Gating the Clock
  #define BIT_MSK__PWD_CLK_CTRL0__RI_HDCP2X_CCLK_GATE_EN                                0x10
  // (ReadWrite, Bits 5) 
  // This field controls the Hardware Gating of Timer Clock to HDCP2x. 0 - Does Not Enable Gating the Clock 1 - Enables Gating the Clock
  #define BIT_MSK__PWD_CLK_CTRL0__RI_HDCP2X_ECLK_GATE_EN                                0x20
  // (ReadWrite, Bits 6) 
  // This field controls the Hardware Gating of Stream Clock to HDCP2x. 0 - Does Not Enable Gating the Clock 1 - Enables Gating the Clock
  #define BIT_MSK__PWD_CLK_CTRL0__RI_HDCP2X_SCLK_GATE_EN                                0x40
  // (ReadWrite, Bits 7) 
  // This field controls the Hardware Gating of TMDS Clock to HDCP2x. 0 - Does Not Enable Gating the Clock 1 - Enables Gating the Clock
  #define BIT_MSK__PWD_CLK_CTRL0__RI_HDCP2X_TCLK_GATE_EN                                0x80

// T4 Corrected Threshold Register
#define REG_ADDR__RX_T4_THRES                                            (RX_PWD_HDCP1X | 0x0020)
  // (ReadWrite, Bits 6:0) 
  // T4 corrected threshold
  #define BIT_MSK__RX_T4_THRES__REG_T4_CORR_THRESH                                    0x7F

// T4 Uncorrected Threshold Register
#define REG_ADDR__RX_T4_UNTHRES                                          (RX_PWD_HDCP1X | 0x0021)
  // (ReadWrite, Bits 6:0) 
  // T4 uncorrected threshold
  #define BIT_MSK__RX_T4_UNTHRES__REG_T4_UNCORR_THRESH                                  0x7F

// HDMI SW Overwrite Register
#define REG_ADDR__RX_SW_HDMI_MODE                                        (RX_PWD_HDCP1X | 0x0022)
  // (ReadWrite, Bits 0) 
  // If 1 then overwrite HDMI MODE hardware value with software value
  #define BIT_MSK__RX_SW_HDMI_MODE__REG_HDMI_MODE_OVERWRITE                               0x01
  // (ReadWrite, Bits 1) 
  // HDMI MODE software overwrite value
  #define BIT_MSK__RX_SW_HDMI_MODE__REG_HDMI_MODE_SW_VALUE                                0x02
  // (ReadWrite, Bits 2) 
  // When it is set hdcp ctrl3 singal will be set in DVI mode even if ENC_EN signal placed in the center and trailing positions of vertical blanking period
  #define BIT_MSK__RX_SW_HDMI_MODE__REG_FIX_DVIHDCP                                       0x04

// VIDEO/DATA ISLAND Preamble Criteria Register
#define REG_ADDR__RX_PREAMBLE_CRIT                                       (RX_PWD_HDCP1X | 0x0023)
  // (ReadWrite, Bits 4:0) 
  // Preamble criteria: selects the required number of repetition for valid preamble
  #define BIT_MSK__RX_PREAMBLE_CRIT__REG_PREAMBLE_CRI                                      0x1F

// HDCP enable Criteria Register
#define REG_ADDR__RX_HDCP_PREAMBLE_CRIT                                  (RX_PWD_HDCP1X | 0x0024)
  // (ReadWrite, Bits 4:0) 
  // HDCP preamble enable criteria: 
  #define BIT_MSK__RX_HDCP_PREAMBLE_CRIT__REG_HDCP_CRI                                          0x1F

// Audio PATH Filter Register
#define REG_ADDR__RX_AUDP_FILT                                           (RX_PWD_HDCP1X | 0x0025)
  // (ReadWrite, Bits 0) 
  // 1 = Set disables data alignment to DE(default 0 - clear)
  #define BIT_MSK__RX_AUDP_FILT__REG_BYP_DALIGN                                        0x01
  // (ReadWrite, Bits 1) 
  // 1 = Set disables h/vsync glitch filtering (default 0 - clear)
  #define BIT_MSK__RX_AUDP_FILT__REG_BYP_SYNC                                          0x02
  // (ReadWrite, Bits 2) 
  // 1 = Disable dvi filtering (default 0)
  #define BIT_MSK__RX_AUDP_FILT__REG_BYP_DVIFILT                                       0x04

// Audio PATH FIFO read write ptr difference Register
#define REG_ADDR__RX_AUDP_FIFO                                           (RX_PWD_HDCP1X | 0x0026)
  // (ReadOnly, Bits 6:0) 
  // FIFO read/write ptr difference
  #define BIT_MSK__RX_AUDP_FIFO__HDMI_FIFO_DIFF                                        0x7F

// Video Path Input Status Register
#define REG_ADDR__RX_VIDIN_STS                                           (RX_PWD_HDCP1X | 0x0027)
  // (ReadOnly, Bits 3:0) 
  // Colour Depth from Hardware: This field indicates the Colour Depth on which the Video Path is operating.  This field value is computed in the HDMI Pipeline as per the HDMI specification for CD field of GCP packet.
  #define BIT_MSK__RX_VIDIN_STS__RO_COLOUR_DEPTH                                       0x0F

// Test Control  Register
#define REG_ADDR__RX_TEST_CTRL                                           (RX_PWD_HDCP1X | 0x003A)
  // (ReadWrite, Bits 2) 
  // Test ODCK = TCLK. 0 - Test ODCK = TCLK disabled (default) 1 - ODCK is selected as the source of the tclk tree.  Also need PD_ODCK = 0 to disable ODCK output.  This mode used for RAM BIST testing.
  #define BIT_MSK__RX_TEST_CTRL__REG_RBIST_CLK                                         0x04
  // (ReadWrite, Bits 4) 
  // Test Audio PLL clocks. 0 - Test Audio PLL clocks disabled (default) 1 - Audio PLL clocks muxed to test output pins.  
  #define BIT_MSK__RX_TEST_CTRL__REG_TST_APLLCK                                        0x10
  // (ReadWrite, Bits 7) 
  // Test pllref. 0 - Test pllref disabled (default) 1 - pllref muxed to test output pin.
  #define BIT_MSK__RX_TEST_CTRL__REG_TST_PLLREF                                        0x80

// Test Status Register
#define REG_ADDR__RX_TEST_STAT                                           (RX_PWD_HDCP1X | 0x003B)
  // (ReadWrite, Bits 2) 
  // 0 - Test pclk disable (default) 1 - WS is selected as the source of the pclk clock tree.  PD_AO would also need to be set to 0 to disable WS.
  #define BIT_MSK__RX_TEST_STAT__REG_TST_PCLK_EN                                       0x04
  // (ReadWrite, Bits 5) 
  // When 1 it would invert the tclk.
  #define BIT_MSK__RX_TEST_STAT__REG_INVERT_TCLK                                       0x20
  // (ReadWrite, Bits 6) 
  // Test CKDT. 0 - Test CKDT disabled (default) 1 - CKDT muxed to test output pin.
  #define BIT_MSK__RX_TEST_STAT__REG_TST_CKDT                                          0x40
  // (ReadWrite, Bits 7) 
  // Test Crystal Oscillator Clock. 0 - Test Crystal Oscillator Clock disabled (default) 1 - Crystal Oscillator Clock muxed to test output pin.
  #define BIT_MSK__RX_TEST_STAT__REG_TST_XCLK                                          0x80

// System Power Down Total Register
#define REG_ADDR__RX_PD_TOT                                              (RX_PWD_HDCP1X | 0x003C)
  // (ReadWrite, Bits 0) 
  // Power Down Everything!  No exceptions.  0 = Power down.   1 = normal operation (default).
  #define BIT_MSK__RX_PD_TOT__REG_PD_TOTAL                                          0x01

// System Power Down 2 Register
#define REG_ADDR__RX_PD_SYS2                                             (RX_PWD_HDCP1X | 0x003E)
  // (ReadWrite, Bits 6) 
  // Power Down MCLK clock tree. 0 = Gate off MCLK.  Disables all logic that runs off mclk domain (mostly audio output logic). 1 = Normal operation (default).
  #define BIT_MSK__RX_PD_SYS2__REG_PD_MCLK                                           0x40
  // (ReadWrite, Bits 7) 
  // Power Down PCLK clock tree. 0 = Gate off PCLK.  Disables all logic that runs off pclk domain (most of chip). 1 = Normal operation (default).
  #define BIT_MSK__RX_PD_SYS2__REG_PD_PCLK                                           0x80

// Interrupt Status #1 Register
#define REG_ADDR__RX_INTR1                                               (RX_PWD_HDCP1X | 0x0040)
  // (ReadWrite, Bits 0) 
  // HDCP authentication done. Asserted if set to 1.  It is asserted if change in Authentication done  is detected. Write 1 to clear. Software reset will not clear interrupt.
  #define BIT_MSK__RX_INTR1__REG_INTR1_STAT0                                       0x01
  // (ReadWrite, Bits 1) 
  // HDCP authentication start. Asserted if set to 1.  Write 1 to clear. 
  #define BIT_MSK__RX_INTR1__REG_INTR1_STAT1                                       0x02
  // (ReadWrite, Bits 2) 
  // This bit indicates the Depacketizer block Interrupt status.  0 - No Depacketizer Interrupt is Set 1 - One or more Depacketizer Interrupts are Set
  #define BIT_MSK__RX_INTR1__REG_INTR1_STAT2                                       0x04
  // (ReadWrite, Bits 3) 
  // Audio FIFO Error. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_INTR1__REG_INTR1_STAT3                                       0x08
  // (ReadWrite, Bits 4) 
  // Audio PLL Unlocked. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_INTR1__REG_INTR1_STAT4                                       0x10
  // (ReadWrite, Bits 5) 
  // Audio N/CTS packet decode error. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_INTR1__REG_INTR1_STAT5                                       0x20
  // (ReadWrite, Bits 6) 
  // Most recent ACR hardware N value is different from previous. Write 1 to clear
  #define BIT_MSK__RX_INTR1__REG_INTR1_STAT6                                       0x40
  // (ReadWrite, Bits 7) 
  // Most recent ACR hardware CTS value is different from previous. Write 1 to clear
  #define BIT_MSK__RX_INTR1__REG_INTR1_STAT7                                       0x80

// Interrupt Status #2 Register
#define REG_ADDR__RX_INTR2                                               (RX_PWD_HDCP1X | 0x0041)
  // (ReadWrite, Bits 0) 
  // Video Clock change. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_INTR2__REG_INTR2_STAT0                                       0x01
  // (ReadWrite, Bits 6) 
  // VSync active edge is recognized.  Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_INTR2__REG_INTR2_STAT6                                       0x40
  // (ReadWrite, Bits 7) 
  // This Interrupt indicates a change in the HDMI Mode of the link. This Interrupt is asserted HIGH if the link changes from HDMI to DVI or vice-versa. Software override changes due to change in programming of the register bit reg_hdmi_mode_sw_value of register RX_SW_HDMI_MODE, when register bit reg_hdmi_mode_overwrite of RX_SW_HDMI_MODE register is HIGH also asserts this Interrupt bit. Write 1 to Clear the Interrupt.
  #define BIT_MSK__RX_INTR2__REG_INTR2_STAT7                                       0x80

// Interrupt Status #3 Register
#define REG_ADDR__RX_INTR3                                               (RX_PWD_HDCP1X | 0x0042)
  // (ReadWrite, Bits 5) 
  // Spdif parity error. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_INTR3__REG_INTR3_STAT5                                       0x20

// Interrupt Status #4 Register
#define REG_ADDR__RX_INTR4                                               (RX_PWD_HDCP1X | 0x0043)
  // (ReadWrite, Bits 0) 
  // FIFO underun.  Write 1 to clear
  #define BIT_MSK__RX_INTR4__REG_INTR4_STAT0                                       0x01
  // (ReadWrite, Bits 1) 
  // FIFO overun. Write 1 to clear
  #define BIT_MSK__RX_INTR4__REG_INTR4_STAT1                                       0x02
  // (ReadWrite, Bits 2) 
  // Interrupt indicating the CTS value was reused because a new CTS packet value was not available when the previous NCLK period was finished;. Write 1 to clear
  #define BIT_MSK__RX_INTR4__REG_INTR4_STAT2                                       0x04
  // (ReadWrite, Bits 3) 
  // Interrupt indicating the CTS value was dropped because a new packet value overwrote a CTS value before it was used to generate an NCLK period;   Write 1 to clear
  #define BIT_MSK__RX_INTR4__REG_INTR4_STAT3                                       0x08

// Interrupt Status #5 Register
#define REG_ADDR__RX_INTR5                                               (RX_PWD_HDCP1X | 0x0044)
  // (ReadWrite, Bits 0) 
  // Audio Fs changed. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_INTR5__REG_INTR5_STAT0                                       0x01
  // (ReadWrite, Bits 6) 
  // Audio Auto Config muted the audio as result of 1 of the interrupts;   Write 1 to clear
  #define BIT_MSK__RX_INTR5__REG_INTR5_STAT6                                       0x40
  // (ReadWrite, Bits 7) 
  // This Interrupt is asserted when a N value change is noticed by the Auto Audio Control block in the hardware. Value change in N is initiated from receiving an ACR packet from the Source. Software can write 1 to clear. Apart from that this bit gets auto cleared by the Auto Audio Control block if any of the following conditions are true. 1. When Enabling Cable Stability check. 2. When Cable Stability check is done and bit[0] of reg_aac_ctrl4 register is set HIGH. 3. If Audio Stability check is done successfully.
  #define BIT_MSK__RX_INTR5__REG_INTR5_STAT7                                       0x80

// Interrupt Status #6 Register
#define REG_ADDR__RX_INTR6                                               (RX_PWD_HDCP1X | 0x0045)
  // (ReadWrite, Bits 3) 
  // dsd invalid.
  #define BIT_MSK__RX_INTR6__REG_INTR6_STAT3                                       0x08
  // (ReadWrite, Bits 5) 
  // Finished loading the Channel Status bits: Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_INTR6__REG_INTR6_STAT5                                       0x20
  // (ReadWrite, Bits 6) 
  // 1 or all audio stream got flat bit: Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_INTR6__REG_INTR6_STAT6                                       0x40

// Interrupt Status #7 Register
#define REG_ADDR__RX_INTR7                                               (RX_PWD_HDCP1X | 0x0046)
  // (ReadWrite, Bits 0) 
  // The state of the pclk_stable has changed.
  #define BIT_MSK__RX_INTR7__REG_INTR7_STAT0                                       0x01
  // (ReadWrite, Bits 2) 
  // Pclk had been stopped
  #define BIT_MSK__RX_INTR7__REG_INTR7_STAT2                                       0x04
  // (ReadWrite, Bits 5) 
  // Left and Right data mismatch flag This Interrupt indicates a Left-Right channel mismatch in transmission of data on the I2S SD lines. This Interrupt goes HIGH if a new word transfer has started and the channel data for transmission is Right while I2S protocol starts with Left. 0 -  No Left-Right channel Mismatch occurred 1 -  Left-Right channel Mismatch occurred
  #define BIT_MSK__RX_INTR7__REG_INTR7_STAT5                                       0x20

// Interrupt Status #8 Register
#define REG_ADDR__RX_INTR8                                               (RX_PWD_HDCP1X | 0x0047)
  // (ReadWrite, Bits 7) 
  // Interrupt indicating the audio Channel status is Changed;  Write 1 to clear
  #define BIT_MSK__RX_INTR8__REG_INTR8_STAT7                                       0x80

// Interrupt Status #10 Register
#define REG_ADDR__RX_INTR10                                              (RX_PWD_HDCP1X | 0x0049)
  // (ReadWrite, Bits 0) 
  // AAC done unmute
  #define BIT_MSK__RX_INTR10__REG_INTR10_STAT0                                      0x01

// Interrupt Status #12 Register
#define REG_ADDR__RX_INTR12                                              (RX_PWD_HDCP1X | 0x004B)
  // (ReadWrite, Bits 0) 
  // This bit indicates the p0_valid interrupt. Write 1 to Clear.
  #define BIT_MSK__RX_INTR12__REG_INTR12_STAT0                                      0x01
  // (ReadWrite, Bits 1) 
  // This bit indicates the p0_invalid interrupt. Write 1 to Clear.
  #define BIT_MSK__RX_INTR12__REG_INTR12_STAT1                                      0x02
  // (ReadWrite, Bits 2) 
  // This bit indicates the p0_clk_rdy interrupt. Write 1 to Clear.
  #define BIT_MSK__RX_INTR12__REG_INTR12_STAT2                                      0x04
  // (ReadWrite, Bits 3) 
  // This bit indicates the p0_clk_lost interrupt. Write 1 to Clear.
  #define BIT_MSK__RX_INTR12__REG_INTR12_STAT3                                      0x08
  // (ReadWrite, Bits 4) 
  // This bit indicates the p0_sr_lock[0] interrupt. Write 1 to Clear.
  #define BIT_MSK__RX_INTR12__REG_INTR12_STAT4                                      0x10
  // (ReadWrite, Bits 5) 
  // This bit indicates the p0_sr_lock[1] interrupt. Write 1 to Clear.
  #define BIT_MSK__RX_INTR12__REG_INTR12_STAT5                                      0x20
  // (ReadWrite, Bits 6) 
  // This bit indicates the p0_sr_lock[2] interrupt. Write 1 to Clear.
  #define BIT_MSK__RX_INTR12__REG_INTR12_STAT6                                      0x40

// Interrupt Status #13 Register
#define REG_ADDR__RX_INTR13                                              (RX_PWD_HDCP1X | 0x004C)
  // (ReadOnly, Bits 0) 
  // This bit indicates the Video Path Core block Interrupt status.  0 - No Video Path Core Interrupt is Set 1 - One or more Video Path Core Interrupts are Set
  #define BIT_MSK__RX_INTR13__REG_INTR13_STAT0                                      0x01
  // (ReadOnly, Bits 1) 
  // This bit indicates the HDCP2x block Interrupt status.  0 - No HDCP2x Interrupt is Set 1 - One or more HDCP2x Interrupts are Set
  #define BIT_MSK__RX_INTR13__REG_INTR13_STAT1                                      0x02
  // (ReadOnly, Bits 2) 
  // This bit indicates the TDM Core block Interrupt status.  0 - No TDM Core Interrupt is Set 1 - One or more TDM Core Interrupts are Set  This Interrupt Status is valid only for MHL3 Compliant devices.
  #define BIT_MSK__RX_INTR13__REG_INTR13_STAT2                                      0x04
  // (ReadOnly, Bits 3) 
  // This bit indicates the EMSC block Interrupt status.  0 - No EMSC Interrupt is Set 1 - One or more EMSC Interrupts are Set  This Interrupt Status is valid only for MHL3 devices supporting EMSC feature.
  #define BIT_MSK__RX_INTR13__REG_INTR13_STAT3                                      0x08
  // (ReadOnly, Bits 4) 
  // This bit indicates the USB Tunnel Core block Interrupt status.  0 - No USB Tunnel Core Interrupt is Set 1 - One or more USB Tunnel Core Interrupts are Set  This Interrupt Status is valid only for MHL3 devices supporting USB Tunneling feature.
  #define BIT_MSK__RX_INTR13__REG_INTR13_STAT4                                      0x10
  // (ReadOnly, Bits 5) 
  // This bit indicates the HDCP1x block Interrupt status.  0 - No HDCP1x Interrupt is Set 1 - One or more HDCP1x Interrupts are Set
  #define BIT_MSK__RX_INTR13__REG_INTR13_STAT5                                      0x20

// Interrupt Status #14 Register
#define REG_ADDR__RX_INTR14                                              (RX_PWD_HDCP1X | 0x004D)
  // (ReadWrite, Bits 0) 
  // This bit indicates the p1_valid interrupt. Write 1 to Clear.
  #define BIT_MSK__RX_INTR14__REG_INTR14_STAT0                                      0x01
  // (ReadWrite, Bits 1) 
  // This bit indicates the p1_invalid interrupt. Write 1 to Clear.
  #define BIT_MSK__RX_INTR14__REG_INTR14_STAT1                                      0x02
  // (ReadWrite, Bits 2) 
  // This bit indicates the p1_clk_rdy interrupt. Write 1 to Clear.
  #define BIT_MSK__RX_INTR14__REG_INTR14_STAT2                                      0x04
  // (ReadWrite, Bits 3) 
  // This bit indicates the p1_clk_lost interrupt. Write 1 to Clear.
  #define BIT_MSK__RX_INTR14__REG_INTR14_STAT3                                      0x08

// Interrupt #1 Mask Register
#define REG_ADDR__RX_INTR1_MASK                                          (RX_PWD_HDCP1X | 0x0050)
  // (ReadWrite, Bits 0) 
  // Enable INT1[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR1_MASK__REG_INTR1_MASK0                                       0x01
  // (ReadWrite, Bits 1) 
  // Enable INT1[1]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR1_MASK__REG_INTR1_MASK1                                       0x02
  // (ReadWrite, Bits 2) 
  // Enable INT1[2]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR1_MASK__REG_INTR1_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // Enable INT1[3]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR1_MASK__REG_INTR1_MASK3                                       0x08
  // (ReadWrite, Bits 4) 
  // Enable INT1[4]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR1_MASK__REG_INTR1_MASK4                                       0x10
  // (ReadWrite, Bits 5) 
  // Enable INT1[5]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR1_MASK__REG_INTR1_MASK5                                       0x20
  // (ReadWrite, Bits 6) 
  // Enable INT1[6]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR1_MASK__REG_INTR1_MASK6                                       0x40
  // (ReadWrite, Bits 7) 
  // Enable INT1[7]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR1_MASK__REG_INTR1_MASK7                                       0x80

// Interrupt #2 Mask Register
#define REG_ADDR__RX_INTR2_MASK                                          (RX_PWD_HDCP1X | 0x0051)
  // (ReadWrite, Bits 0) 
  // Enable INT2[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR2_MASK__REG_INTR2_MASK0                                       0x01
  // (ReadWrite, Bits 6) 
  // Enable INT2[6]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR2_MASK__REG_INTR2_MASK6                                       0x40
  // (ReadWrite, Bits 7) 
  // Enable INT2[7]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR2_MASK__REG_INTR2_MASK7                                       0x80

// Interrupt #3 Mask Register
#define REG_ADDR__RX_INTR3_MASK                                          (RX_PWD_HDCP1X | 0x0052)
  // (ReadWrite, Bits 5) 
  // Enable INT3[5]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR3_MASK__REG_INTR3_MASK5                                       0x20

// Interrupt #4 Mask Register
#define REG_ADDR__RX_INTR4_MASK                                          (RX_PWD_HDCP1X | 0x0053)
  // (ReadWrite, Bits 0) 
  // Enable INT4[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR4_MASK__REG_INTR4_MASK0                                       0x01
  // (ReadWrite, Bits 1) 
  // Enable INT4[1]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR4_MASK__REG_INTR4_MASK1                                       0x02
  // (ReadWrite, Bits 2) 
  // Enable INT4[2]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR4_MASK__REG_INTR4_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // Enable INT4[3]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR4_MASK__REG_INTR4_MASK3                                       0x08

// Interrupt #5 Mask Register
#define REG_ADDR__RX_INTR5_MASK                                          (RX_PWD_HDCP1X | 0x0054)
  // (ReadWrite, Bits 0) 
  // Enable INT5[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR5_MASK__REG_INTR5_MASK0                                       0x01
  // (ReadWrite, Bits 6) 
  // Enable INT5[6]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR5_MASK__REG_INTR5_MASK6                                       0x40
  // (ReadWrite, Bits 7) 
  // Enable INT5[7]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR5_MASK__REG_INTR5_MASK7                                       0x80

// Interrupt #6 Mask Register
#define REG_ADDR__RX_INTR6_MASK                                          (RX_PWD_HDCP1X | 0x0055)
  // (ReadWrite, Bits 3) 
  // Enable INT6[3]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR6_MASK__REG_INTR6_MASK3                                       0x08
  // (ReadWrite, Bits 5) 
  // Enable INT6[5]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR6_MASK__REG_INTR6_MASK5                                       0x20
  // (ReadWrite, Bits 6) 
  // Enable INT6[6]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR6_MASK__REG_INTR6_MASK6                                       0x40

// Interrupt #7 Mask Register
#define REG_ADDR__RX_INTR7_MASK                                          (RX_PWD_HDCP1X | 0x0056)
  // (ReadWrite, Bits 0) 
  // Enable INT7[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR7_MASK__REG_INTR7_MASK0                                       0x01
  // (ReadWrite, Bits 2) 
  // Enable INT7[2]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR7_MASK__REG_INTR7_MASK2                                       0x04
  // (ReadWrite, Bits 5) 
  // Enable INT7[5]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR7_MASK__REG_INTR7_MASK5                                       0x20

// Interrupt #8 Mask Register
#define REG_ADDR__RX_INTR8_MASK                                          (RX_PWD_HDCP1X | 0x0057)
  // (ReadWrite, Bits 7) 
  // Enable INT8[7]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR8_MASK__REG_INTR8_MASK7                                       0x80

// Interrupt #10 Mask Register
#define REG_ADDR__RX_INTR10_MASK                                         (RX_PWD_HDCP1X | 0x0059)
  // (ReadWrite, Bits 0) 
  // Enable INT10[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR10_MASK__REG_INTR10_MASK0                                      0x01

// Interrupt #12 Mask Register
#define REG_ADDR__RX_INTR12_MASK                                         (RX_PWD_HDCP1X | 0x005B)
  // (ReadWrite, Bits 0) 
  // Enable INT12[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR12_MASK__REG_INTR12_MASK0                                      0x01
  // (ReadWrite, Bits 1) 
  // Enable INT12[1]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR12_MASK__REG_INTR12_MASK1                                      0x02
  // (ReadWrite, Bits 2) 
  // Enable INT12[2]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR12_MASK__REG_INTR12_MASK2                                      0x04
  // (ReadWrite, Bits 3) 
  // Enable INT12[3]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR12_MASK__REG_INTR12_MASK3                                      0x08
  // (ReadWrite, Bits 4) 
  // Enable INT12[4]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR12_MASK__REG_INTR12_MASK4                                      0x10
  // (ReadWrite, Bits 5) 
  // Enable INT12[5]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR12_MASK__REG_INTR12_MASK5                                      0x20
  // (ReadWrite, Bits 6) 
  // Enable INT12[6]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR12_MASK__REG_INTR12_MASK6                                      0x40

// Interrupt #13 Mask Register
#define REG_ADDR__RX_INTR13_MASK                                         (RX_PWD_HDCP1X | 0x005C)
  // (ReadWrite, Bits 0) 
  // Enable INT13[0]: 1 - Enable 0 - Disable (defualt)
  #define BIT_MSK__RX_INTR13_MASK__REG_INTR13_MASK0                                      0x01
  // (ReadWrite, Bits 1) 
  // Enable INT13[1]: 1 - Enable 0 - Disable (defualt)
  #define BIT_MSK__RX_INTR13_MASK__REG_INTR13_MASK1                                      0x02
  // (ReadWrite, Bits 2) 
  // Enable INT13[2]: 1 - Enable 0 - Disable (defualt)
  #define BIT_MSK__RX_INTR13_MASK__REG_INTR13_MASK2                                      0x04
  // (ReadWrite, Bits 3) 
  // Enable INT13[3]: 1 - Enable 0 - Disable (defualt)
  #define BIT_MSK__RX_INTR13_MASK__REG_INTR13_MASK3                                      0x08
  // (ReadWrite, Bits 4) 
  // Enable INT13[4]: 1 - Enable 0 - Disable (defualt)
  #define BIT_MSK__RX_INTR13_MASK__REG_INTR13_MASK4                                      0x10
  // (ReadWrite, Bits 5) 
  // Enable INT13[5]: 1 - Enable 0 - Disable (defualt)
  #define BIT_MSK__RX_INTR13_MASK__REG_INTR13_MASK5                                      0x20

// Interrupt #14 Mask Register
#define REG_ADDR__RX_INTR14_MASK                                         (RX_PWD_HDCP1X | 0x005D)
  // (ReadWrite, Bits 0) 
  // Enable INT14[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR14_MASK__REG_INTR14_MASK0                                      0x01
  // (ReadWrite, Bits 1) 
  // Enable INT14[1]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR14_MASK__REG_INTR14_MASK1                                      0x02
  // (ReadWrite, Bits 2) 
  // Enable INT14[2]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR14_MASK__REG_INTR14_MASK2                                      0x04
  // (ReadWrite, Bits 3) 
  // Enable INT14[3]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_INTR14_MASK__REG_INTR14_MASK3                                      0x08

// DPLL CH0 Err Count1 Register
#define REG_ADDR__DPLL_CH0_ERR_CNT1                                      (RX_PWD_HDCP1X | 0x0060)
  // (ReadWrite, Bits 7:0) 
  // Channel0 Error Count Lower Byte
  #define BIT_MSK__DPLL_CH0_ERR_CNT1__REG_DPLL_CH0_ERR_CNT_B7_B0                            0xFF

// DPLL CH0 Err Count2 Register
#define REG_ADDR__DPLL_CH0_ERR_CNT2                                      (RX_PWD_HDCP1X | 0x0061)
  // (ReadWrite, Bits 6:0) 
  // Channel0 Error Count Upper Byte
  #define BIT_MSK__DPLL_CH0_ERR_CNT2__REG_DPLL_CH0_ERR_CNT_B14_B8                           0x7F
  // (ReadWrite, Bits 7) 
  // Channel0 Valid
  #define BIT_MSK__DPLL_CH0_ERR_CNT2__REG_DPLL_CH0_VALID                                    0x80

// DPLL CH1 Err Count1 Register
#define REG_ADDR__DPLL_CH1_ERR_CNT1                                      (RX_PWD_HDCP1X | 0x0062)
  // (ReadWrite, Bits 7:0) 
  // Channel1 Error Count Lower Byte
  #define BIT_MSK__DPLL_CH1_ERR_CNT1__REG_DPLL_CH1_ERR_CNT_B7_B0                            0xFF

// DPLL CH1 Err Count2 Register
#define REG_ADDR__DPLL_CH1_ERR_CNT2                                      (RX_PWD_HDCP1X | 0x0063)
  // (ReadWrite, Bits 6:0) 
  // Channel1 Error Count Upper Byte
  #define BIT_MSK__DPLL_CH1_ERR_CNT2__REG_DPLL_CH1_ERR_CNT_B14_B8                           0x7F
  // (ReadWrite, Bits 7) 
  // Channel1 Valid
  #define BIT_MSK__DPLL_CH1_ERR_CNT2__REG_DPLL_CH1_VALID                                    0x80

// DPLL CH2 Err Count1 Register
#define REG_ADDR__DPLL_CH2_ERR_CNT1                                      (RX_PWD_HDCP1X | 0x0064)
  // (ReadWrite, Bits 7:0) 
  // Channel2 Error Count Lower Byte
  #define BIT_MSK__DPLL_CH2_ERR_CNT1__REG_DPLL_CH2_ERR_CNT_B7_B0                            0xFF

// DPLL CH2 Err Count2 Register
#define REG_ADDR__DPLL_CH2_ERR_CNT2                                      (RX_PWD_HDCP1X | 0x0065)
  // (ReadWrite, Bits 6:0) 
  // Channel2 Error Count Upper Byte
  #define BIT_MSK__DPLL_CH2_ERR_CNT2__REG_DPLL_CH2_ERR_CNT_B14_B8                           0x7F
  // (ReadWrite, Bits 7) 
  // Channel2 Valid
  #define BIT_MSK__DPLL_CH2_ERR_CNT2__REG_DPLL_CH2_VALID                                    0x80

// DPLL Status10 Register
#define REG_ADDR__DPLL_SCDC_CTRL                                         (RX_PWD_HDCP1X | 0x0066)
  // (ReadWrite, Bits 0) 
  // DPLL Bypass Enable: This bit controls the DPLL -] SCDC signal bypass. 0 - No Bypass 1 - Bypass This bit when set HIGH; bypasses the signals from DPLL to SCDC logic and provides the values from registers. This is useful in case of isolating DPLL from SCDC logic and eases debug of SCDC logic as a stand-alone.
  #define BIT_MSK__DPLL_SCDC_CTRL__REG_DPLL_BYPASS_EN                                    0x01
  // (ReadWrite, Bits 3) 
  // DPLL Clock Detected
  #define BIT_MSK__DPLL_SCDC_CTRL__REG_DPLL_CLK_DETECTED                                 0x08
  // (ReadWrite, Bits 6:4) 
  // DPLL Channel Locked
  #define BIT_MSK__DPLL_SCDC_CTRL__REG_DPLL_CH_LOCKED                                    0x70
  // (ReadWrite, Bits 7) 
  // DPLL Scramble Status
  #define BIT_MSK__DPLL_SCDC_CTRL__REG_DPLL_SCRAMBLE_STAT                                0x80

// HDCP ECC Control Register
#define REG_ADDR__HDCP_ECC_CTRL                                          (RX_PWD_HDCP1X | 0x0070)
  // (ReadWrite, Bits 0) 
  // Enable ECC based out-of-sync detection
  #define BIT_MSK__HDCP_ECC_CTRL__RI_ECC_CHK_EN                                         0x01
  // (ReadWrite, Bits 2:1) 
  // 00: accumulates ECC errors until it reaches a given threshold. 01: In a given number of consecutive frames in which ECC errors keep reaching the threshold 10: In a given number of consecutive frames we don't get any correct ECC 11: Accumulates ECC errors for a given number of frames
  #define BIT_MSK__HDCP_ECC_CTRL__RI_ECC_CHK_MODE                                       0x06
  // (ReadWrite, Bits 3) 
  // Write 1 then 0 to clear counter manually.
  #define BIT_MSK__HDCP_ECC_CTRL__RI_ACCM_ERR_MANU_CLR                                  0x08

// HDCP ECC Count for Check 0 Register
#define REG_ADDR__HDCP_ECC_CNT2CHK_0                                     (RX_PWD_HDCP1X | 0x0071)
  // (ReadWrite, Bits 7:0) 
  // VSYNC count to skip before starting ECC check
  #define BIT_MSK__HDCP_ECC_CNT2CHK_0__RI_CNT2CHK_ECC_B7_B0                                  0xFF

// HDCP ECC Count for Check 1 Register
#define REG_ADDR__HDCP_ECC_CNT2CHK_1                                     (RX_PWD_HDCP1X | 0x0072)
  // (ReadWrite, Bits 0) 
  // VSYNC count to skip before starting ECC check
  #define BIT_MSK__HDCP_ECC_CNT2CHK_1__RI_CNT2CHK_ECC_B8                                     0x01

// HDCP ECC ACCM Error Threshold 0 Register
#define REG_ADDR__HDCP_ECC_ACCM_ERR_THR_0                                (RX_PWD_HDCP1X | 0x0073)
  // (ReadWrite, Bits 7:0) 
  // Threadshold for accumulated ECC error
  #define BIT_MSK__HDCP_ECC_ACCM_ERR_THR_0__RI_ACCM_ERR_THR_B7_B0                                 0xFF

// HDCP ECC ACCM Error Threshold 1 Register
#define REG_ADDR__HDCP_ECC_ACCM_ERR_THR_1                                (RX_PWD_HDCP1X | 0x0074)
  // (ReadWrite, Bits 7:0) 
  // Threadshold for accumulated ECC error
  #define BIT_MSK__HDCP_ECC_ACCM_ERR_THR_1__RI_ACCM_ERR_THR_B15_B8                                0xFF

// HDCP ECC ACCM Error Threshold 2 Register
#define REG_ADDR__HDCP_ECC_ACCM_ERR_THR_2                                (RX_PWD_HDCP1X | 0x0075)
  // (ReadWrite, Bits 4:0) 
  // Threadshold for accumulated ECC error
  #define BIT_MSK__HDCP_ECC_ACCM_ERR_THR_2__RI_ACCM_ERR_THR_B20_B16                               0x1F

// HDCP ECC Frame Error Threshold 0 Register
#define REG_ADDR__HDCP_ECC_FRM_ERR_THR_0                                 (RX_PWD_HDCP1X | 0x0076)
  // (ReadWrite, Bits 7:0) 
  // Threadshold for frame ECC error
  #define BIT_MSK__HDCP_ECC_FRM_ERR_THR_0__RI_FRAME_ECC_ERR_THR_B7_B0                            0xFF

// HDCP ECC Frame Error Threshold 1 Register
#define REG_ADDR__HDCP_ECC_FRM_ERR_THR_1                                 (RX_PWD_HDCP1X | 0x0077)
  // (ReadWrite, Bits 7:0) 
  // Threadshold for frame ECC error
  #define BIT_MSK__HDCP_ECC_FRM_ERR_THR_1__RI_FRAME_ECC_ERR_THR_B15_B8                           0xFF

// HDCP ECC Consecutive Frames Error Threshold Register
#define REG_ADDR__HDCP_CONS_ERR_THR                                      (RX_PWD_HDCP1X | 0x0078)
  // (ReadWrite, Bits 7:0) 
  // Number of consecutive frames in which ECC error get threshold
  #define BIT_MSK__HDCP_CONS_ERR_THR__RI_CONS_ECC_ERR_THR_B7_B0                             0xFF

// HDCP ECC No Error Threshold Register
#define REG_ADDR__HDCP_ECC_NO_ERR_THR                                    (RX_PWD_HDCP1X | 0x0079)
  // (ReadWrite, Bits 7:0) 
  // Number of consecutive frames that does not get correct ECC
  #define BIT_MSK__HDCP_ECC_NO_ERR_THR__RI_NO_ECC_THR_B7_B0                                   0xFF

// HDCP ECC Given Frame Error Register
#define REG_ADDR__HDCP_GVN_FRM                                           (RX_PWD_HDCP1X | 0x007A)
  // (ReadWrite, Bits 7:0) 
  // Number of consecutive frames in which accumulate ECC error
  #define BIT_MSK__HDCP_GVN_FRM__RI_GIVEN_FRAME_B7_B0                                  0xFF

// HDCP ECC Given Frame Error Threshold 0 Register
#define REG_ADDR__HDCP_ECC_GVN_FRM_ERR_THR_0                             (RX_PWD_HDCP1X | 0x007B)
  // (ReadWrite, Bits 7:0) 
  // Threshold for the number of ECC errors in given frames
  #define BIT_MSK__HDCP_ECC_GVN_FRM_ERR_THR_0__RI_GIVEN_FRAME_ERR_THR_B7_B0                          0xFF

// HDCP ECC Given Frame Error Threshold 1 Register
#define REG_ADDR__HDCP_ECC_GVN_FRM_ERR_THR_1                             (RX_PWD_HDCP1X | 0x007C)
  // (ReadWrite, Bits 7:0) 
  // Threshold for the number of ECC errors in given frames
  #define BIT_MSK__HDCP_ECC_GVN_FRM_ERR_THR_1__RI_GIVEN_FRAME_ERR_THR_B15_B8                         0xFF

// HDCP ECC Given Frame Error Threshold 2 Register
#define REG_ADDR__HDCP_ECC_GVN_FRM_ERR_THR_2                             (RX_PWD_HDCP1X | 0x007D)
  // (ReadWrite, Bits 4:0) 
  // Threshold for the number of ECC errors in given frames
  #define BIT_MSK__HDCP_ECC_GVN_FRM_ERR_THR_2__RI_GIVEN_FRAME_ERR_THR_B20_B16                        0x1F

// Shadow BKSV_1 Register
#define REG_ADDR__RX_SHD_BKSV_1                                          (RX_PWD_HDCP1X | 0x008A)
  // (ReadOnly, Bits 7:0) 
  // Video receivers key selection vector (KSV). This value must always be available for reading; and may be used to determine that the video receiver is HDCP capable.  Valid KSVs contain 20 ones and 20 zeros; a characteristic that must be verified by the video transmitter hardware before encryption is enabled.
  #define BIT_MSK__RX_SHD_BKSV_1__HDCP_BKSV1                                            0xFF

// Shadow BKSV_2 Register
#define REG_ADDR__RX_SHD_BKSV_2                                          (RX_PWD_HDCP1X | 0x008B)
  // (ReadOnly, Bits 7:0) 
  // Video receivers key selection vector (KSV). This value must always be available for reading; and may be used to determine that the video receiver is HDCP capable.  Valid KSVs contain 20 ones and 20 zeros; a characteristic that must be verified by the video transmitter hardware before encryption is enabled.
  #define BIT_MSK__RX_SHD_BKSV_2__HDCP_BKSV2                                            0xFF

// Shadow BKSV_3 Register
#define REG_ADDR__RX_SHD_BKSV_3                                          (RX_PWD_HDCP1X | 0x008C)
  // (ReadOnly, Bits 7:0) 
  // Video receivers key selection vector (KSV). This value must always be available for reading; and may be used to determine that the video receiver is HDCP capable.  Valid KSVs contain 20 ones and 20 zeros; a characteristic that must be verified by the video transmitter hardware before encryption is enabled.
  #define BIT_MSK__RX_SHD_BKSV_3__HDCP_BKSV3                                            0xFF

// Shadow BKSV_4 Register
#define REG_ADDR__RX_SHD_BKSV_4                                          (RX_PWD_HDCP1X | 0x008D)
  // (ReadOnly, Bits 7:0) 
  // Video receivers key selection vector (KSV). This value must always be available for reading; and may be used to determine that the video receiver is HDCP capable.  Valid KSVs contain 20 ones and 20 zeros; a characteristic that must be verified by the video transmitter hardware before encryption is enabled.
  #define BIT_MSK__RX_SHD_BKSV_4__HDCP_BKSV4                                            0xFF

// Shadow BKSV_5 Register
#define REG_ADDR__RX_SHD_BKSV_5                                          (RX_PWD_HDCP1X | 0x008E)
  // (ReadOnly, Bits 7:0) 
  // Video receivers key selection vector (KSV). This value must always be available for reading; and may be used to determine that the video receiver is HDCP capable.  Valid KSVs contain 20 ones and 20 zeros; a characteristic that must be verified by the video transmitter hardware before encryption is enabled.
  #define BIT_MSK__RX_SHD_BKSV_5__HDCP_BKSV5                                            0xFF

// Shadow Ri_1 Register
#define REG_ADDR__RX_SHD_RI1                                             (RX_PWD_HDCP1X | 0x008F)
  // (ReadOnly, Bits 7:0) 
  // Link verification response.  Updated every 128th frame.  It is recommended that graphics systems protect against errors in the I2C transmission by re-reading this value when unexpected values are received.  This value must be available at all times between updates.  R0 is available a maximum of 100 ms after Aksv is received.  Subsequent Ri values are available a maximum of 128 pixel clocks following the assertion of CTL3.
  #define BIT_MSK__RX_SHD_RI1__RI0                                                   0xFF

// Shadow Ri_2 Register
#define REG_ADDR__RX_SHD_RI2                                             (RX_PWD_HDCP1X | 0x0090)
  // (ReadOnly, Bits 7:0) 
  // Link verification response.  Updated every 128th frame.  It is recommended that graphics systems protect against errors in the I2C transmission by re-reading this value when unexpected values are received.  This value must be available at all times between updates.  R0 is available a maximum of 100 ms after Aksv is received.  Subsequent Ri values are available a maximum of 128 pixel clocks following the assertion of CTL3.
  #define BIT_MSK__RX_SHD_RI2__RI1                                                   0xFF

// Shadow AKSV1 Register
#define REG_ADDR__RX_SHD_AKSV1                                           (RX_PWD_HDCP1X | 0x0091)
  // (ReadOnly, Bits 7:0) 
  // Video transmitters key selection vector (KSV). 
  #define BIT_MSK__RX_SHD_AKSV1__HDCP_AKSV1                                            0xFF

// Shadow AKSV2 Register
#define REG_ADDR__RX_SHD_AKSV2                                           (RX_PWD_HDCP1X | 0x0092)
  // (ReadOnly, Bits 7:0) 
  // Video transmitters key selection vector (KSV). 
  #define BIT_MSK__RX_SHD_AKSV2__HDCP_AKSV2                                            0xFF

// Shadow AKSV3 Register
#define REG_ADDR__RX_SHD_AKSV3                                           (RX_PWD_HDCP1X | 0x0093)
  // (ReadOnly, Bits 7:0) 
  // Video transmitters key selection vector (KSV). 
  #define BIT_MSK__RX_SHD_AKSV3__HDCP_AKSV3                                            0xFF

// Shadow AKSV4 Register
#define REG_ADDR__RX_SHD_AKSV4                                           (RX_PWD_HDCP1X | 0x0094)
  // (ReadOnly, Bits 7:0) 
  // Video transmitters key selection vector (KSV). 
  #define BIT_MSK__RX_SHD_AKSV4__HDCP_AKSV4                                            0xFF

// Shadow AKSV5 Register
#define REG_ADDR__RX_SHD_AKSV5                                           (RX_PWD_HDCP1X | 0x0095)
  // (ReadOnly, Bits 7:0) 
  // Video transmitters key selection vector (KSV). 
  #define BIT_MSK__RX_SHD_AKSV5__HDCP_AKSV5                                            0xFF

// Shadow AN1 Register
#define REG_ADDR__RX_SHD_AN1                                             (RX_PWD_HDCP1X | 0x0096)
  // (ReadOnly, Bits 7:0) 
  // Session random number.   A 64-bit pseudo-random value written from the transmitter during authentication process.  Alternatively; this value may be generated by software or hardware; and then written here.  Eight bytes: 1 is the LSB; 8 is the MSB.  This multi-byte value must be written by the graphics system before the KSV is written.
  #define BIT_MSK__RX_SHD_AN1__HDCP_AN1                                              0xFF

// Shadow AN2 Register
#define REG_ADDR__RX_SHD_AN2                                             (RX_PWD_HDCP1X | 0x0097)
  // (ReadOnly, Bits 7:0) 
  // Session random number.   A 64-bit pseudo-random value written from the transmitter during authentication process.  Alternatively; this value may be generated by software or hardware; and then written here.  Eight bytes: 1 is the LSB; 8 is the MSB.  This multi-byte value must be written by the graphics system before the KSV is written.
  #define BIT_MSK__RX_SHD_AN2__HDCP_AN2                                              0xFF

// Shadow AN3 Register
#define REG_ADDR__RX_SHD_AN3                                             (RX_PWD_HDCP1X | 0x0098)
  // (ReadOnly, Bits 7:0) 
  // Session random number.   A 64-bit pseudo-random value written from the transmitter during authentication process.  Alternatively; this value may be generated by software or hardware; and then written here.  Eight bytes: 1 is the LSB; 8 is the MSB.  This multi-byte value must be written by the graphics system before the KSV is written.
  #define BIT_MSK__RX_SHD_AN3__HDCP_AN3                                              0xFF

// Shadow AN4 Register
#define REG_ADDR__RX_SHD_AN4                                             (RX_PWD_HDCP1X | 0x0099)
  // (ReadOnly, Bits 7:0) 
  // Session random number.   A 64-bit pseudo-random value written from the transmitter during authentication process.  Alternatively; this value may be generated by software or hardware; and then written here.  Eight bytes: 1 is the LSB; 8 is the MSB.  This multi-byte value must be written by the graphics system before the KSV is written.
  #define BIT_MSK__RX_SHD_AN4__HDCP_AN4                                              0xFF

// SHadow AN5 Register
#define REG_ADDR__RX_SHD_AN5                                             (RX_PWD_HDCP1X | 0x009A)
  // (ReadOnly, Bits 7:0) 
  // Session random number.   A 64-bit pseudo-random value written from the transmitter during authentication process.  Alternatively; this value may be generated by software or hardware; and then written here.  Eight bytes: 1 is the LSB; 8 is the MSB.  This multi-byte value must be written by the graphics system before the KSV is written.
  #define BIT_MSK__RX_SHD_AN5__HDCP_AN5                                              0xFF

// Shadow AN6 Register
#define REG_ADDR__RX_SHD_AN6                                             (RX_PWD_HDCP1X | 0x009B)
  // (ReadOnly, Bits 7:0) 
  // Session random number.   A 64-bit pseudo-random value written from the transmitter during authentication process.  Alternatively; this value may be generated by software or hardware; and then written here.  Eight bytes: 1 is the LSB; 8 is the MSB.  This multi-byte value must be written by the graphics system before the KSV is written.
  #define BIT_MSK__RX_SHD_AN6__HDCP_AN6                                              0xFF

// Shadow AN7 Register
#define REG_ADDR__RX_SHD_AN7                                             (RX_PWD_HDCP1X | 0x009C)
  // (ReadOnly, Bits 7:0) 
  // Session random number.   A 64-bit pseudo-random value written from the transmitter during authentication process.  Alternatively; this value may be generated by software or hardware; and then written here.  Eight bytes: 1 is the LSB; 8 is the MSB.  This multi-byte value must be written by the graphics system before the KSV is written.
  #define BIT_MSK__RX_SHD_AN7__HDCP_AN7                                              0xFF

// Shadow AN8 Register
#define REG_ADDR__RX_SHD_AN8                                             (RX_PWD_HDCP1X | 0x009D)
  // (ReadOnly, Bits 7:0) 
  // Session random number.   A 64-bit pseudo-random value written from the transmitter during authentication process.  Alternatively; this value may be generated by software or hardware; and then written here.  Eight bytes: 1 is the LSB; 8 is the MSB.  This multi-byte value must be written by the graphics system before the KSV is written.
  #define BIT_MSK__RX_SHD_AN8__HDCP_AN8                                              0xFF

// BCAPS Setting Register
#define REG_ADDR__RX_BCAPS_SET                                           (RX_PWD_HDCP1X | 0x009E)
  // (ReadWrite, Bits 4) 
  // I2C transfers speed.  This bit is 0 when 100 KHz is the maximum 
  #define BIT_MSK__RX_BCAPS_SET__REG_FAST                                              0x10
  // (ReadWrite, Bits 5) 
  // Set by software; cleared by hardware (write to last AKSV clears)
  #define BIT_MSK__RX_BCAPS_SET__REG_FIFO_RDY                                          0x20
  // (ReadWrite, Bits 6) 
  // Video repeater capability.  This bit is set to 0 describing the device as a DVI end point.
  #define BIT_MSK__RX_BCAPS_SET__REG_REPEATER                                          0x40
  // (ReadWrite, Bits 7) 
  // 1- chip is HDMI capable - shadowed on the DDC side in BCAPS register.
  #define BIT_MSK__RX_BCAPS_SET__REG_HDMI_CAPABLE                                      0x80

// Shadow BSTATUS #1 Register
#define REG_ADDR__RX_SHD_BSTATUS1                                        (RX_PWD_HDCP1X | 0x009F)
  // (ReadWrite, Bits 6:0) 
  //    HDCP Rev 1.1 compatable count range; although this device only supports 16 attached devices
  #define BIT_MSK__RX_SHD_BSTATUS1__REG_DEV_CNT                                           0x7F
  // (ReadWrite, Bits 7) 
  // 
  #define BIT_MSK__RX_SHD_BSTATUS1__REG_DEV_EXCEED                                        0x80

// Shadow BSTATUS #2 Register
#define REG_ADDR__RX_SHD_BSTATUS2                                        (RX_PWD_HDCP1X | 0x00A0)
  // (ReadWrite, Bits 2:0) 
  // Depth -  HDCP Rev1.1  compatible max depth =7
  #define BIT_MSK__RX_SHD_BSTATUS2__REG_DEPTH                                             0x07
  // (ReadWrite, Bits 3) 
  // Max cascade exceeded - status bit indicating that the device count exceeds  the number of entries the KSV FIFO can support; i.e. 16 devices.
  #define BIT_MSK__RX_SHD_BSTATUS2__RPT_CASC_EXCEED                                       0x08
  // (ReadOnly, Bits 4) 
  // HDMI Mode Detected with software override: This signal indicates the Mode of the connection as detected by the hardware with software override. 0 - DVI 1 - HDMI  This status detected fro Hardware can be overridden by the software through programming appropriate values into reg_hdmi_mode_overwrite and reg_hdmi_mode_sw_value bits of RX_SW_HDMI_MODE register.
  #define BIT_MSK__RX_SHD_BSTATUS2__HDMI_MODE                                             0x10
  // (ReadWrite, Bits 7:5) 
  // Bstatus bits
  #define BIT_MSK__RX_SHD_BSTATUS2__REG_BSTATUS                                           0xE0

// HDCP Debug Register
#define REG_ADDR__RX_HDCP_DEBUG                                          (RX_PWD_HDCP1X | 0x00A1)
  // (ReadWrite, Bits 7:0) 
  // For internal use only  Write strobe to do HDCP debug. Data in this register would be used by HDCP. Write 1 into bit #7 is equal to the former stop_en (force upstream Tx to stop encryption by returning wrong ri0 values. ) Read of this register - HDCP debug value : bit 0 - sw_reset; bit 1 - sw_decrpt; bit 5:2 - cphst; bit 6 - stop_en ; bit 7 - stop_en.
  #define BIT_MSK__RX_HDCP_DEBUG__REG_WR_DEBUG                                          0xFF

// HDCP Status Register
#define REG_ADDR__RX_HDCP_STAT                                           (RX_PWD_HDCP1X | 0x00A2)
  // (ReadOnly, Bits 3:0) 
  // Cipher State Machine: 0000 = IDLE - IDLE; waiting for authentication 0001 = AUTH0 - Authentication Period 0; run BLKM 0011 = AUTH1 - Authentication Period 1; run BLKM and LFSR 0010 =  AUTHD - Authentication done 1010 = AUTHW - Authentication done; but Vsyn comes before cntl3 0110 = VBLK0 - Vertical Blank Period 0; run BLKM  0111 = VBLK1 - Vertical Blank Period 1; run BLKM and LFSR 0101 = ACTIV - authenticated; waiting for ide 1101 = DEHI - ide output decryt keys for each pixel 1100 = DELO - ide low; re-key 1001 = ADEHI - didenogb output decryt keys for each Aux pixel 1000 = ADELO - didenogb low; Do not rekey.
  #define BIT_MSK__RX_HDCP_STAT__HDCP_SPHST                                            0x0F
  // (ReadOnly, Bits 4) 
  // Authentication status bit: 1 - authenticated
  #define BIT_MSK__RX_HDCP_STAT__HDCP_AUTHENTICATED                                    0x10
  // (ReadOnly, Bits 5) 
  // HDCP is decripting
  #define BIT_MSK__RX_HDCP_STAT__HDCP_DECRYPTING                                       0x20

// HDCP Repeater KSV/SHA Start Register
#define REG_ADDR__RX_KSV_SHA_START1                                      (RX_PWD_HDCP1X | 0x00A3)
  // (ReadWrite, Bits 7:0) 
  // Bits [7:0] of the  KSV FIFO start pointer or pointer to the SHA stack: Pointer to the address  within KSV FIFO. When I2C transaction starts with offset address of 38h then HDCP repeater takes over decoding instead of register block. Firmware from the local side allowed to read or write from  any location within KSV FIFO. The value in KSV_FIFO_start register points to the start address of the read or write I2C transaction.
  #define BIT_MSK__RX_KSV_SHA_START1__REG_START_ADDR                                        0xFF

// HDCP Repeater KSV/SHA start Register
#define REG_ADDR__RX_KSV_SHA_START2                                      (RX_PWD_HDCP1X | 0x00A4)
  // (ReadWrite, Bits 1:0) 
  // Bits [9:8] of  KSV FIFO start pointer or pointer to the SHA stack
  #define BIT_MSK__RX_KSV_SHA_START2__REG_REP_START_ADDR                                    0x03

// HDCP SHA length Register
#define REG_ADDR__RX_SHA_LENGTH1                                         (RX_PWD_HDCP1X | 0x00A5)
  // (ReadWrite, Bits 7:0) 
  // Lower 8 bits value: number of KSVs to process; in Bytes.The range is compatible to HDCP 1.1 however this device has KSV FIFO only large enough for 16 KSVs = 5x16 =80 bytes
  #define BIT_MSK__RX_SHA_LENGTH1__REG_SHA_LENGTH_B7_B0                                  0xFF

// HDCP SHA length #2 Register
#define REG_ADDR__RX_SHA_LENGTH2                                         (RX_PWD_HDCP1X | 0x00A6)
  // (ReadWrite, Bits 1:0) 
  // Upper 2 bits value: number of KSVs  to process in Bytes.The range is compatible to HDCP 1.1 however this device has KSV FIFO only large enough for 16 KSVs = 5x16 =80 bytes
  #define BIT_MSK__RX_SHA_LENGTH2__REG_SHA_LENGTH_B9_B8                                  0x03

// HDCP Repater Control Register
#define REG_ADDR__RX_SHA_CTRL                                            (RX_PWD_HDCP1X | 0x00A7)
  // (ReadWrite, Bits 0) 
  // SHA generation. Firmware starts the SHA generation by writing 1; which generates 1 clock strobe. After that firmware should keep reading this bit untill it gets 1 ; which means that SHA hardware is done.
  #define BIT_MSK__RX_SHA_CTRL__REG_SHA_GO_STAT                                       0x01
  // (ReadWrite, Bits 2) 
  // Choose SHA mode:  0 internal use;  1 downstream use.
  #define BIT_MSK__RX_SHA_CTRL__REG_SHA_MODE                                          0x04

// HDCP Repeater KSV FIFO Register
#define REG_ADDR__RX_KSV_FIFO                                            (RX_PWD_HDCP1X | 0x00A8)
  // (ReadOnly, Bits 7:0) 
  // This Address is a port for access to the KSV FIFO. When the firmware starts an I2C transaction with this offset address, the access control will be transferred to the KSV FIFO. The address located inside the KSV Start Address register acts as the start offset within the KSV FIFO space. Consecutive I2C transactions this offset address will be auto-incremented in the KSV FIFO Address space.
  #define BIT_MSK__RX_KSV_FIFO__REG_KSV_FIFO_OUT                                      0xFF

// HDCP1x Interrupt Status #0 Register
#define REG_ADDR__RX_HDCP1X_INTR0                                        (RX_PWD_HDCP1X | 0x00A9)
  // (ReadWrite, Bits 0) 
  // HDCP1x Frame Encryption State Changed Interrupt: This Interrupt indicates a change in the Encryption State of the incoming Frames. The State of Encryption can be obtained by reading hdcp_decrypting bit of RX_HDCP_STAT register.  Write 1 to Clear the Interrupt.
  #define BIT_MSK__RX_HDCP1X_INTR0__REG_HDCP1X_INTR0_STAT0                                0x01
  // (ReadWrite, Bits 1) 
  // This interrupt is asserted when the number of ecc errors received exceed the programmed threshold value in the ri_frame_ecc_err_thr register. Write 1 to Clear.
  #define BIT_MSK__RX_HDCP1X_INTR0__REG_HDCP1X_INTR0_STAT1                                0x02

// HDCP1x Interrupt #0 Mask Register
#define REG_ADDR__RX_HDCP1X_INTR0_MASK                                   (RX_PWD_HDCP1X | 0x00AA)
  // (ReadWrite, Bits 0) 
  // Enable INTR0[0]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_HDCP1X_INTR0_MASK__REG_HDCP1X_INTR0_MASK0                                0x01
  // (ReadWrite, Bits 1) 
  // Enable INTR0[1]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_HDCP1X_INTR0_MASK__REG_HDCP1X_INTR0_MASK1                                0x02

// HDCP M0 #0 Register
#define REG_ADDR__HDCP_M0_0                                              (RX_PWD_HDCP1X | 0x00B7)
  // (ReadOnly, Bits 7:0) 
  // Rx HDCP M0 bits [7:0]
  #define BIT_MSK__HDCP_M0_0__HDCP_M0_B7_B0                                         0xFF

// HDCP M0 #1 Register
#define REG_ADDR__HDCP_M0_1                                              (RX_PWD_HDCP1X | 0x00B8)
  // (ReadOnly, Bits 7:0) 
  // Rx HDCP M0 bits [15:8]
  #define BIT_MSK__HDCP_M0_1__HDCP_M0_B15_B8                                        0xFF

// HDCP  M0 #2 Register
#define REG_ADDR__HDCP_M0_2                                              (RX_PWD_HDCP1X | 0x00B9)
  // (ReadOnly, Bits 7:0) 
  // Rx HDCP M0 bits [23:16]
  #define BIT_MSK__HDCP_M0_2__HDCP_M0_B23_B16                                       0xFF

// HDCP M0 #3 Register
#define REG_ADDR__HDCP_M0_3                                              (RX_PWD_HDCP1X | 0x00BA)
  // (ReadOnly, Bits 7:0) 
  // Rx HDCP M0 bits [31:24]
  #define BIT_MSK__HDCP_M0_3__HDCP_M0_B31_B24                                       0xFF

// HDCP M0 #4 Register
#define REG_ADDR__HDCP_M0_4                                              (RX_PWD_HDCP1X | 0x00BB)
  // (ReadOnly, Bits 7:0) 
  // Rx HDCP M0 bits [39:32]
  #define BIT_MSK__HDCP_M0_4__HDCP_M0_B39_B32                                       0xFF

// HDCP M0 #5 Register
#define REG_ADDR__HDCP_M0_5                                              (RX_PWD_HDCP1X | 0x00BC)
  // (ReadOnly, Bits 7:0) 
  // Rx HDCP M0 bits [47:40]
  #define BIT_MSK__HDCP_M0_5__HDCP_M0_B47_B40                                       0xFF

// HDCP M0 #6 Register
#define REG_ADDR__HDCP_M0_6                                              (RX_PWD_HDCP1X | 0x00BD)
  // (ReadOnly, Bits 7:0) 
  // Rx HDCP M0 bits [55:48]
  #define BIT_MSK__HDCP_M0_6__HDCP_M0_B55_B48                                       0xFF

// HDCP M0 #7 Register
#define REG_ADDR__HDCP_M0_7                                              (RX_PWD_HDCP1X | 0x00BE)
  // (ReadOnly, Bits 7:0) 
  // Rx HDCP M0 bits [63:56]
  #define BIT_MSK__HDCP_M0_7__HDCP_M0_B63_B56                                       0xFF

// Down Stream BSTATUS #1 Register
#define REG_ADDR__RX_DS_BSTATUS1                                         (RX_PWD_HDCP1X | 0x00D5)
  // (ReadWrite, Bits 6:0) 
  // need description
  #define BIT_MSK__RX_DS_BSTATUS1__REG_DS_DEV_CNT                                        0x7F
  // (ReadWrite, Bits 7) 
  // need description
  #define BIT_MSK__RX_DS_BSTATUS1__REG_DS_DEV_EXCEED                                     0x80

// Down Stream BSTATUS #2 Register
#define REG_ADDR__RX_DS_BSTATUS2                                         (RX_PWD_HDCP1X | 0x00D6)
  // (ReadWrite, Bits 2:0) 
  // Depth - need description
  #define BIT_MSK__RX_DS_BSTATUS2__REG_DS_DEPTH                                          0x07
  // (ReadWrite, Bits 3) 
  // Max cascade exceeded - need description
  #define BIT_MSK__RX_DS_BSTATUS2__REG_DS_CASC_EXCEED                                    0x08
  // (ReadWrite, Bits 4) 
  // HDMI Mode. (controlled through the I2C local side) 1 - receiver is in HDMI Mode; 0 - receiver is in DVI mode.
  #define BIT_MSK__RX_DS_BSTATUS2__REG_DS_HDMI_MODE                                      0x10
  // (ReadWrite, Bits 7:5) 
  // Bstatus bits
  #define BIT_MSK__RX_DS_BSTATUS2__REG_DS_BSTATUS                                        0xE0

// HDCP Repeater Down Stream M0 #0 Register
#define REG_ADDR__RX_DS_M0_0                                             (RX_PWD_HDCP1X | 0x00D7)
  // (ReadWrite, Bits 7:0) 
  // Down Stream M0 bits [7:0]
  #define BIT_MSK__RX_DS_M0_0__REG_MO_B7_B0                                          0xFF

// HDCP Repeater Down Stream M0 #1 Register
#define REG_ADDR__RX_DS_M0_1                                             (RX_PWD_HDCP1X | 0x00D8)
  // (ReadWrite, Bits 7:0) 
  // Down Stream M0 bits [15:8]
  #define BIT_MSK__RX_DS_M0_1__REG_MO_B15_B8                                         0xFF

// HDCP Repeater Down Stream M0 #2 Register
#define REG_ADDR__RX_DS_M0_2                                             (RX_PWD_HDCP1X | 0x00D9)
  // (ReadWrite, Bits 7:0) 
  // Down Stream M0 bits [23:16]
  #define BIT_MSK__RX_DS_M0_2__REG_MO_B23_B16                                        0xFF

// HDCP Repeater Down Stream M0 #3 Register
#define REG_ADDR__RX_DS_M0_3                                             (RX_PWD_HDCP1X | 0x00DA)
  // (ReadWrite, Bits 7:0) 
  // Down Stream M0 bits [31:24]
  #define BIT_MSK__RX_DS_M0_3__REG_MO_B31_B24                                        0xFF

// HDCP Repeater Down Stream M0 #4 Register
#define REG_ADDR__RX_DS_M0_4                                             (RX_PWD_HDCP1X | 0x00DB)
  // (ReadWrite, Bits 7:0) 
  // Down Stream M0 bits [39:32]
  #define BIT_MSK__RX_DS_M0_4__REG_MO_B39_B32                                        0xFF

// HDCP Repeater Down Stream M0 #5 Register
#define REG_ADDR__RX_DS_M0_5                                             (RX_PWD_HDCP1X | 0x00DC)
  // (ReadWrite, Bits 7:0) 
  // Down Stream M0 bits [47:40]
  #define BIT_MSK__RX_DS_M0_5__REG_MO_B47_B40                                        0xFF

// HDCP Repeater Down Stream M0 #6 Register
#define REG_ADDR__RX_DS_M0_6                                             (RX_PWD_HDCP1X | 0x00DD)
  // (ReadWrite, Bits 7:0) 
  // Down Stream M0 bits [55:48]
  #define BIT_MSK__RX_DS_M0_6__REG_MO_B55_B48                                        0xFF

// HDCP Repeater Down Stream M0 #7 Register
#define REG_ADDR__RX_DS_M0_7                                             (RX_PWD_HDCP1X | 0x00DE)
  // (ReadWrite, Bits 7:0) 
  // Down Stream M0 bits [63:56]
  #define BIT_MSK__RX_DS_M0_7__REG_MO_B63_B56                                        0xFF

// HDCP Repeater V.H0 #0 Register
#define REG_ADDR__RX_VH0_0                                               (RX_PWD_HDCP1X | 0x00DF)
  // (ReadWrite, Bits 7:0) 
  // V.H0 bits [7:0]
  #define BIT_MSK__RX_VH0_0__REG_V_H0_B7_B0                                        0xFF

// HDCP Repeater V.H0 #1 Register
#define REG_ADDR__RX_VH0_1                                               (RX_PWD_HDCP1X | 0x00E0)
  // (ReadWrite, Bits 7:0) 
  // V.H0 bits [15:8]
  #define BIT_MSK__RX_VH0_1__REG_V_H0_B15_B8                                       0xFF

// HDCP Repeater V.H0 #2 Register
#define REG_ADDR__RX_VH0_2                                               (RX_PWD_HDCP1X | 0x00E1)
  // (ReadWrite, Bits 7:0) 
  // V.H0 bits [23:16]
  #define BIT_MSK__RX_VH0_2__REG_V_H0_B23_B16                                      0xFF

// HDCP Repeater V.H0 #3 Register
#define REG_ADDR__RX_VH0_3                                               (RX_PWD_HDCP1X | 0x00E2)
  // (ReadWrite, Bits 7:0) 
  // V.H0 bits [31:24]
  #define BIT_MSK__RX_VH0_3__REG_V_H0_B31_B24                                      0xFF

// HDCP Repeater V.H1 #0 Register
#define REG_ADDR__RX_VH1_0                                               (RX_PWD_HDCP1X | 0x00E3)
  // (ReadWrite, Bits 7:0) 
  // V.H1 bits [7:0]
  #define BIT_MSK__RX_VH1_0__REG_V_H1_B7_B0                                        0xFF

// HDCP Repeater V.H1 #1 Register
#define REG_ADDR__RX_VH1_1                                               (RX_PWD_HDCP1X | 0x00E4)
  // (ReadWrite, Bits 7:0) 
  // V.H1 bits [15:8]
  #define BIT_MSK__RX_VH1_1__REG_V_H1_B15_B8                                       0xFF

// HDCP Repeater V.H1 #2 Register
#define REG_ADDR__RX_VH1_2                                               (RX_PWD_HDCP1X | 0x00E5)
  // (ReadWrite, Bits 7:0) 
  // V.H1 bits [23:16]
  #define BIT_MSK__RX_VH1_2__REG_V_H1_B23_B16                                      0xFF

// HDCP Repeater V.H1 #3 Register
#define REG_ADDR__RX_VH1_3                                               (RX_PWD_HDCP1X | 0x00E6)
  // (ReadWrite, Bits 7:0) 
  // V.H1 bits [31:24]
  #define BIT_MSK__RX_VH1_3__REG_V_H1_B31_B24                                      0xFF

// HDCP Repeater V.H2 #0 Register
#define REG_ADDR__RX_VH2_0                                               (RX_PWD_HDCP1X | 0x00E7)
  // (ReadWrite, Bits 7:0) 
  // V.H2 bits [7:0]
  #define BIT_MSK__RX_VH2_0__REG_V_H2_B7_B0                                        0xFF

// HDCP Repeater V.H2 #1 Register
#define REG_ADDR__RX_VH2_1                                               (RX_PWD_HDCP1X | 0x00E8)
  // (ReadWrite, Bits 7:0) 
  // V.H2 bits [15:8]
  #define BIT_MSK__RX_VH2_1__REG_V_H2_B15_B8                                       0xFF

// HDCP Repeater V.H2 #2 Register
#define REG_ADDR__RX_VH2_2                                               (RX_PWD_HDCP1X | 0x00E9)
  // (ReadWrite, Bits 7:0) 
  // V.H2 bits [23:16]
  #define BIT_MSK__RX_VH2_2__REG_V_H2_B23_B16                                      0xFF

// HDCP Repeater V.H2 #3 Register
#define REG_ADDR__RX_VH2_3                                               (RX_PWD_HDCP1X | 0x00EA)
  // (ReadWrite, Bits 7:0) 
  // V.H2 bits [31:24]
  #define BIT_MSK__RX_VH2_3__REG_V_H2_B31_B24                                      0xFF

// HDCP Repeater V.H3 #0 Register
#define REG_ADDR__RX_VH3_0                                               (RX_PWD_HDCP1X | 0x00EB)
  // (ReadWrite, Bits 7:0) 
  // V.H3 bits [7:0]
  #define BIT_MSK__RX_VH3_0__REG_V_H3_B7_B0                                        0xFF

// HDCP Repeater V.H3 #1 Register
#define REG_ADDR__RX_VH3_1                                               (RX_PWD_HDCP1X | 0x00EC)
  // (ReadWrite, Bits 7:0) 
  // V.H3 bits [15:8]
  #define BIT_MSK__RX_VH3_1__REG_V_H3_B15_B8                                       0xFF

// HDCP Repeater V.H3 #2 Register
#define REG_ADDR__RX_VH3_2                                               (RX_PWD_HDCP1X | 0x00ED)
  // (ReadWrite, Bits 7:0) 
  // V.H3 bits [23:16]
  #define BIT_MSK__RX_VH3_2__REG_V_H3_B23_B16                                      0xFF

// HDCP Repeater V.H3 #3 Register
#define REG_ADDR__RX_VH3_3                                               (RX_PWD_HDCP1X | 0x00EE)
  // (ReadWrite, Bits 7:0) 
  // V.H3 bits [31:24]
  #define BIT_MSK__RX_VH3_3__REG_V_H3_B31_B24                                      0xFF

// HDCP Repeater V.H4 #0 Register
#define REG_ADDR__RX_VH4_0                                               (RX_PWD_HDCP1X | 0x00EF)
  // (ReadWrite, Bits 7:0) 
  // V.H4 bits [7:0]
  #define BIT_MSK__RX_VH4_0__REG_V_H4_B7_B0                                        0xFF

// HDCP Repeater V.H4 #1 Register
#define REG_ADDR__RX_VH4_1                                               (RX_PWD_HDCP1X | 0x00F0)
  // (ReadWrite, Bits 7:0) 
  // V.H4 bits [15:8]
  #define BIT_MSK__RX_VH4_1__REG_V_H4_B15_B8                                       0xFF

// HDCP Repeater V.H4 #2 Register
#define REG_ADDR__RX_VH4_2                                               (RX_PWD_HDCP1X | 0x00F1)
  // (ReadWrite, Bits 7:0) 
  // V.H4 bits [23:16]
  #define BIT_MSK__RX_VH4_2__REG_V_H4_B23_B16                                      0xFF

// HDCP Repeater V.H4 #3 Register
#define REG_ADDR__RX_VH4_3                                               (RX_PWD_HDCP1X | 0x00F2)
  // (ReadWrite, Bits 7:0) 
  // V.H4 bits [31:24]  By writing into this register the 1 clock write strobe is generated and data in reg. 0x0DF-0x0F2 is loaded into the HDCP repeater.
  #define BIT_MSK__RX_VH4_3__REG_V_H4_B31_B24                                      0xFF

// OTP Status Register
#define REG_ADDR__RX_EPST                                                (RX_PWD_HDCP1X | 0x00F9)
  // (ReadWrite, Bits 0) 
  // Last command had been completed; For the status of this command please check error status bits in this register. Write 0 to clear. 
  #define BIT_MSK__RX_EPST__REG_CMD_DONE_CLR                                      0x01
  // (ReadWrite, Bits 1) 
  // CRC error if  set to 1; Write 0 to clear
  #define BIT_MSK__RX_EPST__REG_BIST_ERR_CLR                                      0x02
  // (ReadWrite, Bits 2) 
  // sda error (EPROM still driving sda line) if set to 1; Write 0 to clear
  #define BIT_MSK__RX_EPST__REG_SDA_ERR_CLR                                       0x04
  // (ReadWrite, Bits 3) 
  // acknowldge error (didn't got one from EPROM) if set to 1; Write 0 to clear
  #define BIT_MSK__RX_EPST__REG_ACK_ERR_CLR                                       0x08
  // (ReadWrite, Bits 4) 
  // load KSV is done if set to 1: Write 0 to clear
  #define BIT_MSK__RX_EPST__REG_LD_KSV_CLR                                        0x10
  // (ReadWrite, Bits 5) 
  // self-authentication #1 error if set to 1; Write 0 to clear
  #define BIT_MSK__RX_EPST__REG_BIST1_ERR_CLR                                     0x20
  // (ReadWrite, Bits 6) 
  // self-authentication #2 error if set to 1; Write 0 to clear
  #define BIT_MSK__RX_EPST__REG_BIST2_ERR_CLR                                     0x40
  // (ReadOnly, Bits 7) 
  // Unlock
  #define BIT_MSK__RX_EPST__OTP_UNLOCKED                                          0x80

// OTP Command Register
#define REG_ADDR__RX_EPCM                                                (RX_PWD_HDCP1X | 0x00FA)
  // (ReadWrite, Bits 4:0) 
  // I2C Master commands: 00000 - Clear command register; no action will be taken xxx01 - rsvd xxx10 - Write data to EPROM (applies only in the MCM mode); ignored if locked xxx11 - will enable all BIST: CRC; self-authentication #1 and self_authentication #2 xx100 - will enable individual CRC  x1x00 - will enable individual self-authentication #1  1xx00 - will enable individual self_authentication #2   New value can be safely written into this register only after getting command done bit (reg. 0x0F9[0]) or waiting at least 0.125s. That means that new value can be safely written into this register only after previous command has been completed. Otherwise; it is possible to get either self-authentication #1 error status bit or to get BIST done bit without actually performing one of the new enabled BIST test.
  #define BIT_MSK__RX_EPCM__REG_EPCM                                              0x1F
  // (ReadWrite, Bits 5) 
  // Enable Load of the KSV from OTP : 1 - enable.  Write 0 before enabling again. 
  #define BIT_MSK__RX_EPCM__REG_LD_KSV                                            0x20

//***************************************************************************
// RX_TBIST. Address: 60
// Config Register
#define REG_ADDR__RX_TBIST_CTRL_1                                        (RX_TBIST | 0x0001)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_1__REG_BIST_CTRL_1                                       0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_2                                        (RX_TBIST | 0x0002)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_2__REG_BIST_CTRL_2                                       0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_3                                        (RX_TBIST | 0x0003)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_3__REG_BIST_CTRL_3                                       0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_4                                        (RX_TBIST | 0x0004)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_4__REG_BIST_CTRL_4                                       0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_5                                        (RX_TBIST | 0x0005)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_5__REG_BIST_CTRL_5                                       0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_6                                        (RX_TBIST | 0x0006)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_6__REG_BIST_CTRL_6                                       0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_7                                        (RX_TBIST | 0x0007)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_7__REG_BIST_CTRL_7                                       0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_8                                        (RX_TBIST | 0x0008)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_8__REG_BIST_CTRL_8                                       0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_9                                        (RX_TBIST | 0x0009)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_9__REG_BIST_CTRL_9                                       0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_10                                       (RX_TBIST | 0x000A)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_10__REG_BIST_CTRL_10                                      0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_11                                       (RX_TBIST | 0x000B)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_11__REG_BIST_CTRL_11                                      0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_12                                       (RX_TBIST | 0x000C)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_12__REG_BIST_CTRL_12                                      0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_13                                       (RX_TBIST | 0x000D)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_13__REG_BIST_CTRL_13                                      0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_14                                       (RX_TBIST | 0x000E)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_14__REG_BIST_CTRL_14                                      0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_15                                       (RX_TBIST | 0x000F)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_15__REG_BIST_CTRL_15                                      0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_16                                       (RX_TBIST | 0x0010)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_16__REG_BIST_CTRL_16                                      0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_17                                       (RX_TBIST | 0x0011)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_17__REG_BIST_CTRL_17                                      0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_18                                       (RX_TBIST | 0x0012)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_18__REG_BIST_CTRL_18                                      0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_19                                       (RX_TBIST | 0x0013)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_19__REG_BIST_CTRL_19                                      0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_20                                       (RX_TBIST | 0x0014)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__RX_TBIST_CTRL_20__REG_BIST_CTRL_20                                      0xFF

// Config Register
#define REG_ADDR__RX_TBIST_CTRL_21                                       (RX_TBIST | 0x0015)
  // (ReadWrite, Bits 7:0) 
  // bit #0 - reg_rxbist_vgb_en bit #1 - reg_tmds0_bist_vgb_mask bit #2 - enbaled tx tbist bit #3 - enable txbist_vgb
  #define BIT_MSK__RX_TBIST_CTRL_21__REG_BIST_CTRL_21                                      0xFF

// HANA BIST BLUE CONTROL0 Register
#define REG_ADDR__RX_CONFIG_BIST_10BIT_B_1ST_0                              (RX_TBIST | 0x0017)
  // (ReadWrite, Bits 7:0) 
  // Hana Bist blue 
  #define BIT_MSK__RX_CONFIG_BIST_10BIT_B_1ST_0__REG_BIST_10BIT_BLUE_1ST_B7_B0                         0xFF

// HANA BIST BLUE CONTROL1 Register
#define REG_ADDR__RX_CONFIG_BIST_10BIT_B_1ST_1                              (RX_TBIST | 0x0018)
  // (ReadWrite, Bits 1:0) 
  // Hana Bist blue 
  #define BIT_MSK__RX_CONFIG_BIST_10BIT_B_1ST_1__REG_BIST_10BIT_BLUE_1ST_B9_B8                         0x03

// HANA BIST BLUE CONTROL 2 Register
#define REG_ADDR__RX_CONFIG_BIST_10BIT_B_2ND_0                              (RX_TBIST | 0x0019)
  // (ReadWrite, Bits 7:0) 
  // Hana Bist blue 
  #define BIT_MSK__RX_CONFIG_BIST_10BIT_B_2ND_0__REG_BIST_10BIT_BLUE_2ND_B7_B0                         0xFF

// HANA BIST BLUE CONTROL3 Register
#define REG_ADDR__RX_CONFIG_BIST_10BIT_B_2ND_1                              (RX_TBIST | 0x001A)
  // (ReadWrite, Bits 1:0) 
  // Hana Bist blue 
  #define BIT_MSK__RX_CONFIG_BIST_10BIT_B_2ND_1__REG_BIST_10BIT_BLUE_2ND_B9_B8                         0x03

// HANA BIST Green CONTROL0 Register
#define REG_ADDR__RX_CONFIG_BIST_10BIT_G_1ST_0                              (RX_TBIST | 0x001B)
  // (ReadWrite, Bits 7:0) 
  // Hana Bist Green
  #define BIT_MSK__RX_CONFIG_BIST_10BIT_G_1ST_0__REG_BIST_10BIT_GREEN_1ST_B7_B0                        0xFF

// HANA BIST Green CONTROL1 Register
#define REG_ADDR__RX_CONFIG_BIST_10BIT_G_1ST_1                              (RX_TBIST | 0x001C)
  // (ReadWrite, Bits 1:0) 
  // Hana Bist Green
  #define BIT_MSK__RX_CONFIG_BIST_10BIT_G_1ST_1__REG_BIST_10BIT_GREEN_1ST_B9_B8                        0x03

// HANA BIST Green CONTROL2 Register
#define REG_ADDR__RX_CONFIG_BIST_10BIT_G_2ND_0                              (RX_TBIST | 0x001D)
  // (ReadWrite, Bits 7:0) 
  // Hana Bist Green
  #define BIT_MSK__RX_CONFIG_BIST_10BIT_G_2ND_0__REG_BIST_10BIT_GREEN_2ND_B7_B0                        0xFF

// HANA BIST Green CONTROL3 Register
#define REG_ADDR__RX_CONFIG_BIST_10BIT_G_2ND_1                              (RX_TBIST | 0x001E)
  // (ReadWrite, Bits 1:0) 
  // Hana Bist Green
  #define BIT_MSK__RX_CONFIG_BIST_10BIT_G_2ND_1__REG_BIST_10BIT_GREEN_2ND_B9_B8                        0x03

// HANA BIST Red CONTROL0 Register
#define REG_ADDR__RX_CONFIG_BIST_10BIT_R_1ST_0                              (RX_TBIST | 0x001F)
  // (ReadWrite, Bits 7:0) 
  // Hana Bist Red
  #define BIT_MSK__RX_CONFIG_BIST_10BIT_R_1ST_0__REG_BIST_10BIT_RED_1ST_B7_B0                          0xFF

// HANA BIST Red CONTROL1 Register
#define REG_ADDR__RX_CONFIG_BIST_10BIT_R_1ST_1                              (RX_TBIST | 0x0020)
  // (ReadWrite, Bits 1:0) 
  // Hana Bist Red
  #define BIT_MSK__RX_CONFIG_BIST_10BIT_R_1ST_1__REG_BIST_10BIT_RED_1ST_B9_B8                          0x03

// HANA BIST Red CONTROL2 Register
#define REG_ADDR__RX_CONFIG_BIST_10BIT_R_2ND_0                              (RX_TBIST | 0x0021)
  // (ReadWrite, Bits 7:0) 
  // Hana Bist Red
  #define BIT_MSK__RX_CONFIG_BIST_10BIT_R_2ND_0__REG_BIST_10BIT_RED_2ND_B7_B0                          0xFF

// HANA BIST Red CONTROL3 Register
#define REG_ADDR__RX_CONFIG_BIST_10BIT_R_2ND_1                              (RX_TBIST | 0x0022)
  // (ReadWrite, Bits 1:0) 
  // Hana Bist Red
  #define BIT_MSK__RX_CONFIG_BIST_10BIT_R_2ND_1__REG_BIST_10BIT_RED_2ND_B9_B8                          0x03

// TMDS STPG LUM #0 Register
#define REG_ADDR__RX_STPG_LUM0                                              (RX_TBIST | 0x0024)
  // (ReadWrite, Bits 7:0) 
  // Programmable value for channel R  for STPG Simp92 with Zone ID V5_H4 - V5_H13
  #define BIT_MSK__RX_STPG_LUM0__V5_H4TO13_R                                           0xFF

// TMDS STPG LUM #1 Register
#define REG_ADDR__RX_STPG_LUM1                                              (RX_TBIST | 0x0025)
  // (ReadWrite, Bits 7:0) 
  // Programmable value for channel G  for STPG Simp92 with Zone ID V5_H4 - V5_H13
  #define BIT_MSK__RX_STPG_LUM1__V5_H4TO13_G                                           0xFF

// TMDS STPG LUM #2 Register
#define REG_ADDR__RX_STPG_LUM2                                              (RX_TBIST | 0x0026)
  // (ReadWrite, Bits 7:0) 
  // Programmable value for channel B  for STPG Simp92 with Zone ID V5_H4 - V5_H13
  #define BIT_MSK__RX_STPG_LUM2__V5_H4TO13_B                                           0xFF

// TMDS STPG LUM #3 Register
#define REG_ADDR__RX_STPG_LUM0B                                             (RX_TBIST | 0x0027)
  // (ReadWrite, Bits 7:0) 
  // Programmable value for channel R for STPG Simp92 with Zone V7_H4 - V7_H13
  #define BIT_MSK__RX_STPG_LUM0B__V7_H4TO13_R                                           0xFF

// TMDS STPG LUM #4 Register
#define REG_ADDR__RX_STPG_LUM1B                                             (RX_TBIST | 0x0028)
  // (ReadWrite, Bits 7:0) 
  // Programmable value for channel G for STPG Simp92 with Zone V7_H4 - V7_H13
  #define BIT_MSK__RX_STPG_LUM1B__V7_H4TO13_G                                           0xFF

// TMDS STPG LUM #5 Register
#define REG_ADDR__RX_STPG_LUM2B                                             (RX_TBIST | 0x0029)
  // (ReadWrite, Bits 7:0) 
  // Programmable value for channel B for STPG Simp92 with Zone V7_H4 - V7_H13
  #define BIT_MSK__RX_STPG_LUM2B__V7_H4TO13_B                                           0xFF

// TMDS STPG #0 Register
#define REG_ADDR__RX_REG_V5_H4TO13                                          (RX_TBIST | 0x002A)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V5H4TO13
  #define BIT_MSK__RX_REG_V5_H4TO13__V5_H4TO13                                             0xFF

// TMDS STPG #1 Register
#define REG_ADDR__RX_REG_V6_H2                                              (RX_TBIST | 0x002B)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H2
  #define BIT_MSK__RX_REG_V6_H2__V6_H2                                                 0xFF

// TMDS STPG #2 Register
#define REG_ADDR__RX_REG_V6_H3                                              (RX_TBIST | 0x002C)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H3
  #define BIT_MSK__RX_REG_V6_H3__V6_H3                                                 0xFF

// TMDS STPG #3 Register
#define REG_ADDR__RX_REG_V6_H4                                              (RX_TBIST | 0x002D)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H4
  #define BIT_MSK__RX_REG_V6_H4__V6_H4                                                 0xFF

// TMDS STPG #4 Register
#define REG_ADDR__RX_REG_V6_H5                                              (RX_TBIST | 0x002E)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H5
  #define BIT_MSK__RX_REG_V6_H5__V6_H5                                                 0xFF

// TMDS STPG #5 Register
#define REG_ADDR__RX_REG_V6_H6                                              (RX_TBIST | 0x002F)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H6
  #define BIT_MSK__RX_REG_V6_H6__V6_H6                                                 0xFF

// TMDS STPG #6 Register
#define REG_ADDR__RX_REG_V6_H7                                              (RX_TBIST | 0x0030)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H7
  #define BIT_MSK__RX_REG_V6_H7__V6_H7                                                 0xFF

// TMDS STPG #7 Register
#define REG_ADDR__RX_REG_V6_H8                                              (RX_TBIST | 0x0031)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H8
  #define BIT_MSK__RX_REG_V6_H8__V6_H8                                                 0xFF

// TMDS STPG #8 Register
#define REG_ADDR__RX_REG_V6_H9                                              (RX_TBIST | 0x0032)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H9
  #define BIT_MSK__RX_REG_V6_H9__V6_H9                                                 0xFF

// TMDS STPG #9 Register
#define REG_ADDR__RX_REG_V6_H10                                             (RX_TBIST | 0x0033)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H10
  #define BIT_MSK__RX_REG_V6_H10__V6_H10                                                0xFF

// TMDS STPG #10 Register
#define REG_ADDR__RX_REG_V6_H11                                             (RX_TBIST | 0x0034)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H11
  #define BIT_MSK__RX_REG_V6_H11__V6_H11                                                0xFF

// TMDS STPG #11 Register
#define REG_ADDR__RX_REG_V6_H12                                             (RX_TBIST | 0x0035)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H12
  #define BIT_MSK__RX_REG_V6_H12__V6_H12                                                0xFF

// TMDS STPG #12 Register
#define REG_ADDR__RX_REG_V6_H13                                             (RX_TBIST | 0x0036)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H13
  #define BIT_MSK__RX_REG_V6_H13__V6_H13                                                0xFF

// TMDS STPG #13 Register
#define REG_ADDR__RX_REG_V6_H14                                             (RX_TBIST | 0x0037)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H14
  #define BIT_MSK__RX_REG_V6_H14__V6_H14                                                0xFF

// TMDS STPG #14 Register
#define REG_ADDR__RX_REG_V6_H15                                             (RX_TBIST | 0x0038)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H15
  #define BIT_MSK__RX_REG_V6_H15__V6_H15                                                0xFF

// TMDS STPG #15 Register
#define REG_ADDR__RX_REG_V6_H16                                             (RX_TBIST | 0x0039)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H16
  #define BIT_MSK__RX_REG_V6_H16__V6_H16                                                0xFF

// TMDS STPG #16 Register
#define REG_ADDR__RX_REG_V7_CONST61                                         (RX_TBIST | 0x003A)
  // (ReadWrite, Bits 7:0) 
  // data for V7
  #define BIT_MSK__RX_REG_V7_CONST61__V7_CONST61                                            0xFF

// TMDS STPG #17 Register
#define REG_ADDR__RX_REG_V7_CONST50                                         (RX_TBIST | 0x003B)
  // (ReadWrite, Bits 7:0) 
  // data for V7
  #define BIT_MSK__RX_REG_V7_CONST50__V7_CONST50                                            0xFF

// TMDS STPG #18 Register
#define REG_ADDR__RX_REG_V7_CONST102                                        (RX_TBIST | 0x003C)
  // (ReadWrite, Bits 7:0) 
  // data for V7
  #define BIT_MSK__RX_REG_V7_CONST102__V7_CONST102                                           0xFF

// TMDS STPG #19 Register
#define REG_ADDR__RX_REG_V9_CONST204                                        (RX_TBIST | 0x003D)
  // (ReadWrite, Bits 7:0) 
  // data for V9
  #define BIT_MSK__RX_REG_V9_CONST204__V9_CONST204                                           0xFF

// TMDS STPG #20 Register
#define REG_ADDR__RX_REG_V9_CONST205                                        (RX_TBIST | 0x003E)
  // (ReadWrite, Bits 7:0) 
  // data for V9
  #define BIT_MSK__RX_REG_V9_CONST205__V9_CONST205                                           0xFF

// TMDS STPG #21 Register
#define REG_ADDR__RX_REG_V9_CONST209                                        (RX_TBIST | 0x003F)
  // (ReadWrite, Bits 7:0) 
  // data for V9
  #define BIT_MSK__RX_REG_V9_CONST209__V9_CONST209                                           0xFF

// TMDS STPG #22 Register
#define REG_ADDR__RX_REG_V9_CONST229                                        (RX_TBIST | 0x0040)
  // (ReadWrite, Bits 7:0) 
  // data for V9
  #define BIT_MSK__RX_REG_V9_CONST229__V9_CONST229                                           0xFF

// TMDS STPG #23 Register
#define REG_ADDR__RX_REG_V9_CONST231                                        (RX_TBIST | 0x0041)
  // (ReadWrite, Bits 7:0) 
  // data for V9
  #define BIT_MSK__RX_REG_V9_CONST231__V9_CONST231                                           0xFF

// TMDS STPG #24 Register
#define REG_ADDR__RX_REG_V10_H3TO4                                          (RX_TBIST | 0x0042)
  // (ReadWrite, Bits 7:0) 
  // V10_H3TO4
  #define BIT_MSK__RX_REG_V10_H3TO4__V10_H3TO4                                             0xFF

// TMDS STPG #25 Register
#define REG_ADDR__RX_REG_V10_H5TO6                                          (RX_TBIST | 0x0043)
  // (ReadWrite, Bits 7:0) 
  // V10_H5TO6
  #define BIT_MSK__RX_REG_V10_H5TO6__V10_H5TO6                                             0xFF

// TMDS STPG #26 Register
#define REG_ADDR__RX_REG_V10_H7TO8                                          (RX_TBIST | 0x0044)
  // (ReadWrite, Bits 7:0) 
  // V10_H7TO8
  #define BIT_MSK__RX_REG_V10_H7TO8__V10_H7TO8                                             0xFF

// TMDS STPG #27 Register
#define REG_ADDR__RX_REG_V10_H9TO10                                         (RX_TBIST | 0x0045)
  // (ReadWrite, Bits 7:0) 
  // V10_H9TO10
  #define BIT_MSK__RX_REG_V10_H9TO10__V10_H9TO10                                            0xFF

// TMDS STPG #28 Register
#define REG_ADDR__RX_REG_V10_H11TO12                                        (RX_TBIST | 0x0046)
  // (ReadWrite, Bits 7:0) 
  // V10_H11TO12
  #define BIT_MSK__RX_REG_V10_H11TO12__V10_H11TO12                                           0xFF

// TMDS STPG #29 Register
#define REG_ADDR__RX_REG_V10_H13TO14                                        (RX_TBIST | 0x0047)
  // (ReadWrite, Bits 7:0) 
  // V10_H13TO14
  #define BIT_MSK__RX_REG_V10_H13TO14__V10_H13TO14                                           0xFF

// TMDS 1 BIST CNTL Register
#define REG_ADDR__RX_BIST_CTRL                                              (RX_TBIST | 0x0048)
  // (ReadWrite, Bits 0) 
  // 0  bist is disabled       1 -  bist is enabled        Whenever bist is enabled normal operation of the chip ceases and the chip goes into bist mode. 
  #define BIT_MSK__RX_BIST_CTRL__REG_BIST_ENABLE                                       0x01
  // (ReadWrite, Bits 1) 
  // 0  the bist module is out of  reset state      1  the bist module is  forced to be in the reset state.         The Bist reset bit is provided as a backup. Normal operation of Bist does not require any toggling of this bit. This is used only for lab debug.
  #define BIT_MSK__RX_BIST_CTRL__REG_BIST_RESET                                        0x02
  // (ReadWrite, Bits 2) 
  // The enable bit for Samsung Test Pattern Generator. When set it have higher priority than other BIST settings and reg_stpg_sel[3:0] will decide which pattern to generate. When clear STPG is disabled. 1'b 0 -- clear (default) 1'b 1 -- set
  #define BIT_MSK__RX_BIST_CTRL__REG_STPG_EN                                           0x04
  // (ReadWrite, Bits 3) 
  // 1b 0  The bist module runs the pattern check  for programmed number of frames. 1b 1  The bist module runs continuously till the bist is disabled.
  #define BIT_MSK__RX_BIST_CTRL__REG_BIST_CONT_PROG_DURAT                              0x08
  // (ReadWrite, Bits 4) 
  // Bist start register is a write only  register. To start a Bist sequence 1 to this register. This will generate a pulse. The falling edge of the pulse triggers the bist. Read to this register will provide unknown value.All bist control logic gets reset at the start of a bist including the read only status registers.  Other configuration registers do not get reset.
  #define BIT_MSK__RX_BIST_CTRL__REG_BIST_START                                        0x10

// TMDS 1 BIST DURATION0 Register
#define REG_ADDR__RX_BIST_DURATION0                                         (RX_TBIST | 0x0049)
  // (ReadWrite, Bits 7:0) 
  // BIST Duration register is used to specify the duration of a test in frames. Counting of frames starts with the first vsync falling edge detected after the bist has been enabled. Also a programmed value of n results in n+1 frames. (If zero is programmed; the bist/tx is active for 1 frame)
  #define BIT_MSK__RX_BIST_DURATION0__REG_BIST_DURATION_B7_B0                               0xFF

// TMDS 1 BIST DURATION1 Register
#define REG_ADDR__RX_BIST_DURATION1                                         (RX_TBIST | 0x004A)
  // (ReadWrite, Bits 7:0) 
  // Bist duration[15:8]; total is 23 bits.
  #define BIT_MSK__RX_BIST_DURATION1__REG_BIST_DURATION_B15_B8                              0xFF

// TMDS 1 BIST DURATION2 Register
#define REG_ADDR__RX_BIST_DURATION2                                         (RX_TBIST | 0x004B)
  // (ReadWrite, Bits 7:0) 
  // Bist duration[23:16]; total is 24 bits.
  #define BIT_MSK__RX_BIST_DURATION2__REG_BIST_DURATION_B23_B16                             0xFF

// TMDS 1 BIST TEST_SEL Register
#define REG_ADDR__RX_BIST_TEST_SEL                                          (RX_TBIST | 0x004C)
  // (ReadWrite, Bits 4:0) 
  // 5b 0000X  Walking one pattern: lsb must be set to 1 for Tx and 0 for Rx 5b 0001X   Ramping pattern       5b 0010X  LFSR pattern1         5b 0011X  LFSR pattern 2          5b 0100X  Static pattern 1           5b 0101X  Static pattern 2             5b 0110X  Max switching pattern            5b 0111X  Two column max- switching pattern            5b 1000X  SDVO/TMDS half clock pattern       5b 1001X  SDVO/TMDS 8 bit  static  pattern         5b 1010X  TMDS 10 bit static  pattern.  5'b 1011X - Enable all 4 TMDS patterns at one time      The pattern corresponding to 4h 10  is applicable only to TMDS transmit and are not applicable for SDVO receive test.
  #define BIT_MSK__RX_BIST_TEST_SEL__REG_BIST_PATTERN_SELECT                               0x1F
  // (ReadWrite, Bits 6:5) 
  // 00-CTL lines[3:0] are static (00);  01-CTL lines[3:0] follow a ramp pattern where each count is valid for 2 clocks;  10-CTL line[3:0] follow a random pattern where each pattern is valid for 2 clocks;  11-reserved (do not use)
  #define BIT_MSK__RX_BIST_TEST_SEL__REG_BIST_TEST_SELECT                                  0x60

// TMDS 1 BIST VIDEO_MODE Register
#define REG_ADDR__RX_BIST_VIDEO_MODE                                        (RX_TBIST | 0x004D)
  // (ReadWrite, Bits 3) 
  // Setting this bit 1 forces the DE going to the TMDS core to be forced to be 1.
  #define BIT_MSK__RX_BIST_VIDEO_MODE__REG_BIST_VIDEO_MODE                                   0x08
  // (ReadWrite, Bits 7:4) 
  // Samsung Test Pattern select. This only takes effect when the enable bit (reg_stpg_en) is set. 4b 0000  Full screen red (default)   4b 0001  Full screen green    4b 0010  Full screen blue                   4b 0011  Full screen black 4b 0100  Full screen white   4b 0101  Ramp from (0  0  0) to (255  255  255)  each color repeats 5 pixels 4b 0110  Chess. The screen is divided into 8x6 blocks - with the size of 160x120. Black and white blocks alternate horizontally and vertically. 4b 0111  Color bar. 8 color strips with the width of 160 pixels. 4b 1000  Simp92. Simplified version of Master Pattern Generator #92 others      reserved
  #define BIT_MSK__RX_BIST_VIDEO_MODE__REG_STPG_SEL                                          0xF0

// TMDS 1 BIST 8BIT_PATTERN Register
#define REG_ADDR__RX_BIST_8BIT_PATTERN                                      (RX_TBIST | 0x004E)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__RX_BIST_8BIT_PATTERN__REG_BIST_8BIT_PATTERN                                 0xFF

// TMDS 1 BIST 10BIT_PATTERN_L Register
#define REG_ADDR__RX_BIST_10BIT_PATTERN_L                                   (RX_TBIST | 0x004F)
  // (ReadWrite, Bits 7:0) 
  // Lower 8 bits of the static 10-bit pattern to be provided to the TMDS transmitter
  #define BIT_MSK__RX_BIST_10BIT_PATTERN_L__REG_BIST_10BIT_PATTERN_B7_B0                          0xFF

// TMDS 1 BIST 10BIT_PATTERN_U Register
#define REG_ADDR__RX_BIST_10BIT_PATTERN_U                                   (RX_TBIST | 0x0050)
  // (ReadWrite, Bits 1:0) 
  // Upper 2 bits of the static 10-bit pattern to be provided to the TMDS transmitter
  #define BIT_MSK__RX_BIST_10BIT_PATTERN_U__REG_BIST_10BIT_PATTERN_B9_B8                          0x03

// TMDS 1 BIST status Register
#define REG_ADDR__RX_BIST_STATUS                                            (RX_TBIST | 0x0051)
  // (ReadOnly, Bits 1:0) 
  // [1:0]  Bist idle/busy/complete bits 00 b  Bist is idle 01 b  Bist is busy (test in           progress) 10 b  Bist is complete and result is ready in the BIST_RESULT  register
  #define BIT_MSK__RX_BIST_STATUS__BIST_CONFIG_STATUS                                    0x03

// TMDS 1 BIST RESULT Register
#define REG_ADDR__RX_BIST_RESULT                                            (RX_TBIST | 0x0052)
  // (ReadOnly, Bits 0) 
  // Bist pass/fail bit        0  bist test passed        1  bist test failed
  #define BIT_MSK__RX_BIST_RESULT__BIST_CONFIG_FAIL                                      0x01
  // (ReadOnly, Bits 1) 
  // SDVO receive. hsync error
  #define BIT_MSK__RX_BIST_RESULT__BIST_CONFIG_HSYNC_ERROR                               0x02
  // (ReadOnly, Bits 2) 
  // SDVO receive. vsync error
  #define BIT_MSK__RX_BIST_RESULT__BIST_CONFIG_VSYNC_ERROR                               0x04
  // (ReadOnly, Bits 3) 
  // SDVO receive. de error  
  #define BIT_MSK__RX_BIST_RESULT__BIST_CONFIG_DE_ERROR                                  0x08
  // (ReadOnly, Bits 4) 
  // SDVO receive. error count overflow . This bit gets set if  any of the error counters         overflows the max 16 bit count. If this bit is set it may  not be possible to pinpoint  which counter overflowed.All the error bits are valid only if the bit 0 indicates that bist test failed.
  #define BIT_MSK__RX_BIST_RESULT__BIST_CONFIG_OVERFLOW                                  0x10
  // (ReadOnly, Bits 5) 
  // SDVO receive ctl error.
  #define BIT_MSK__RX_BIST_RESULT__BIST_CONFIG_CTL_ERROR                                 0x20

// TMDS 1 BIST P_ERROR_COUNT_0 Register
#define REG_ADDR__RX_BIST_P_ERR_CNT_0                                       (RX_TBIST | 0x0053)
  // (ReadOnly, Bits 7:0) 
  // Lower 8 bits of the pixel error count. This register is a read only register. Its contents are valid only if the bist test failed.A received pixel is in error if any of the 3 channels (Red. Green. Blue) have a value mismatch between generated value and received value.
  #define BIT_MSK__RX_BIST_P_ERR_CNT_0__BIST_P_ERROR_COUNT_0                                  0xFF

// TMDS 1 BIST P_ERROR_COUNT_1 Register
#define REG_ADDR__RX_BIST_P_ERR_CNT_1                                       (RX_TBIST | 0x0054)
  // (ReadOnly, Bits 7:0) 
  // Upper 8 bits of the pixel error count. This register is a read only register. Its contents are valid only if the bist test failed.A received pixel is in error if any of the 3 channels (Red. Green. Blue) have a value mismatch between generated value and received value.If the any of the error count registers exceeds the max 16 bit count then the overflow bit is set in BIST_status register.
  #define BIT_MSK__RX_BIST_P_ERR_CNT_1__BIST_P_ERROR_COUNT_1                                  0xFF

// TMDS 1 BIST R_ERROR_COUNT_0 Register
#define REG_ADDR__RX_BIST_R_ERR_CNT_0                                       (RX_TBIST | 0x0055)
  // (ReadOnly, Bits 7:0) 
  // Lower 8 bits of the red channel error count. This register is a read only register. Its contents are valid only if the bist test failed.A channel is in error if   there is a mismatch between   generated 8 bit value and received 8 bit value
  #define BIT_MSK__RX_BIST_R_ERR_CNT_0__BIST_R_ERROR_COUNT_0                                  0xFF

// TMDS 1 BIST R_ERROR_COUNT_1 Register
#define REG_ADDR__RX_BIST_R_ERR_CNT_1                                       (RX_TBIST | 0x0056)
  // (ReadOnly, Bits 7:0) 
  // Upper 8 bits of the red channel error count. This register is a read only register. Its contents are valid only if the bist test failed. A channel is in error if there is a mismatch between generated 8-bit values and received 8-bit value.If the any of the error count registers exceeds the max 16 bit count then the overflow bit is set in BIST_status register.
  #define BIT_MSK__RX_BIST_R_ERR_CNT_1__BIST_R_ERROR_COUNT_1                                  0xFF

// TMDS 1 BIST G_ERROR_COUNT_0 Register
#define REG_ADDR__RX_BIST_G_ERR_CNT_0                                       (RX_TBIST | 0x0057)
  // (ReadOnly, Bits 7:0) 
  // Lower 8 bits of the green channel error count. This register is a read only register. Its contents are valid only if the bist test failed.A channel is in error if   there is a mismatch between   generated 8-bit values and received 8-bit value.
  #define BIT_MSK__RX_BIST_G_ERR_CNT_0__BIST_G_ERROR_COUNT_0                                  0xFF

// TMDS 1 BIST G_ERROR_COUNT_1 Register
#define REG_ADDR__RX_BIST_G_ERR_CNT_1                                       (RX_TBIST | 0x0058)
  // (ReadOnly, Bits 7:0) 
  // Upper 8 bits of the green channel error count. This register is a read only register. Its contents are valid only if the bist test failed.A channel is in error if there is a mismatch between generated 8-bit values and received 8-bit value.If the any of the error count registers exceeds the max 16 bit count then the overflow bit is set in BIST_status register.
  #define BIT_MSK__RX_BIST_G_ERR_CNT_1__BIST_G_ERROR_COUNT_1                                  0xFF

// TMDS 1 BIST B_ERROR_COUNT_0 Register
#define REG_ADDR__RX_BIST_B_ERR_CNT_0                                       (RX_TBIST | 0x0059)
  // (ReadOnly, Bits 7:0) 
  // Lower 8 bits of the blue channel error count. This register is a read only register. Its contents are valid only if the bist test failed.A channel is in error if   there is a mismatch between   generated 8 bit value and receive
  #define BIT_MSK__RX_BIST_B_ERR_CNT_0__BIST_B_ERROR_COUNT_0                                  0xFF

// TMDS 1 BIST B_ERROR_COUNT_1 Register
#define REG_ADDR__RX_BIST_B_ERR_CNT_1                                       (RX_TBIST | 0x005A)
  // (ReadOnly, Bits 7:0) 
  // Upper 8 bits of the blue channel error count. This register is a read only register. Its contents are valid only if the bist test failed.A channel is in error if there is a mismatch between generated 8-bit values and received 8-bit value.If the any of the error count registers exceeds the max 16 bit count then the overflow bit is set in BIST_status register.
  #define BIT_MSK__RX_BIST_B_ERR_CNT_1__BIST_B_ERROR_COUNT_1                                  0xFF

// TMDS 1 BIST CNTL_ERROR_COUNT Register
#define REG_ADDR__RX_BIST_CNTL_ERR_CNT                                      (RX_TBIST | 0x005B)
  // (ReadOnly, Bits 7:0) 
  // 8 bit counter for counting the number of control erros.  This register is a read only register. Its contents are valid only if the bist test failed.A channel is in error if there is a mismatch between generated control[3:0] values and received control[3:0] values.
  #define BIT_MSK__RX_BIST_CNTL_ERR_CNT__BIST_CNTL_ERROR_COUNT                                 0xFF

// BIST STPG Size1 Register
#define REG_ADDR__RX_STPG_SIZE1                                             (RX_TBIST | 0x005C)
  // (ReadWrite, Bits 7:0) 
  // This register byte defines the height of V1 and V6 and V10 for Simp92. Default is 8'h3C. STPG_SIZE1x3 + STPG_SIZE2x5 + STPG_SIZE3x2 must be equal to 720.
  #define BIT_MSK__RX_STPG_SIZE1__REG_V1610_HEIGHT                                      0xFF

// BIST STPG Size2 Register
#define REG_ADDR__RX_STPG_SIZE2                                             (RX_TBIST | 0x005D)
  // (ReadWrite, Bits 7:0) 
  // This register byte defines the height of V2 and V3 and  V4 and V8 and V9 for Simp92. Default is 8'h1E. STPG_SIZE1x3 + STPG_SIZE2x5 + STPG_SIZE3x2 must be equal to 720.
  #define BIT_MSK__RX_STPG_SIZE2__REG_V23489_HEIGHT                                     0xFF

// BIST STPG Size3 Register
#define REG_ADDR__RX_STPG_SIZE3                                             (RX_TBIST | 0x005E)
  // (ReadWrite, Bits 7:0) 
  // This register byte defines the height of V5 and V7 for Simp92. Default is 8'hC3. STPG_SIZE1x3 + STPG_SIZE2x5 + STPG_SIZE3x2 must be equal to 720.
  #define BIT_MSK__RX_STPG_SIZE3__REG_V57_HEIGHT                                        0xFF

// Fake Vid Ctrl Register
#define REG_ADDR__RX_BIST_CTRL2                                             (RX_TBIST | 0x0065)
  // (ReadWrite, Bits 0) 
  // if 1 invert hsync
  #define BIT_MSK__RX_BIST_CTRL2__REG_INV_HSYNC_EN                                      0x01
  // (ReadWrite, Bits 1) 
  // if 1 invert vsync
  #define BIT_MSK__RX_BIST_CTRL2__REG_INV_VSYNC_EN                                      0x02
  // (ReadWrite, Bits 2) 
  // if 0 enable STPG out, else Tx BIST
  #define BIT_MSK__RX_BIST_CTRL2__REG_OUT_SEL                                           0x04

// Fake Vid Ctrl Register
#define REG_ADDR__RX_BIST_TIMING_CTRL                                       (RX_TBIST | 0x0066)
  // (ReadWrite, Bits 1:0) 
  // select # of bits: 00 - 8bpp 01 - 10bpp 10 - 12bpp
  #define BIT_MSK__RX_BIST_TIMING_CTRL__REG_DEPTH                                             0x03
  // (ReadWrite, Bits 3:2) 
  // select refresh rate:     for 4k2k:         00 - 30         01 - 25         10 - 24         11 - 24SMPTE    for 1080p:          00 - 50           01 - 60
  #define BIT_MSK__RX_BIST_TIMING_CTRL__REG_REFRESH                                           0x0C
  // (ReadWrite, Bits 7:4) 
  // This register controls BIST timing including video timing.           8'b0000:                    //720p60 case           8'b0001:                     //576p case           8'b0010:                     //480p case           8'b0011:                     //1080p@50 8bpp case           8'b0100:                     //4k2k@30           8'b0101:                     //fully programmable           8'b1000:                     //vga            8'b1001:                     //svga           8'b1010:                     //xga           8'b1011:                      //sxga           8'b1100:                     //uxga           8'b1101:                      //4k2k@30 case
  #define BIT_MSK__RX_BIST_TIMING_CTRL__REG_TIME_MODE                                         0xF0

// TMDS 1 BIST B_ERROR_COUNT_0 Register
#define REG_ADDR__BIST_EXTD_CNT_ERR_CNT_0                                (RX_TBIST | 0x0067)
  // (ReadOnly, Bits 7:0) 
  // Lower 8 bits of the extended count error count. This register is a read only register. Its contents are valid only if the bist test failed.A channel is in error if   there is a mismatch between   generated 8 bit value and receive
  #define BIT_MSK__BIST_EXTD_CNT_ERR_CNT_0__BIST_EXTD_CNT_ERROR_COUNT_0                           0xFF

// TMDS 1 BIST B_ERROR_COUNT_1 Register
#define REG_ADDR__BIST_EXTD_CNT_ERR_CNT_1                                (RX_TBIST | 0x0068)
  // (ReadOnly, Bits 7:0) 
  // Upper 8 bits of the extended count  error count. This register is a read only register. Its contents are valid only if the bist test failed.A channel is in error if there is a mismatch between generated 8-bit values and received 8-bit value.If the any of the error count registers exceeds the max 16 bit count then the overflow bit is set in BIST_status register.
  #define BIT_MSK__BIST_EXTD_CNT_ERR_CNT_1__BIST_EXTD_CNT_ERROR_COUNT_1                           0xFF

// TMDS 1 BIST STPG Extd color pattern select Register
#define REG_ADDR__BIST_EXTD_COLOR_MODE                                   (RX_TBIST | 0x0069)
  // (ReadWrite, Bits 7:4) 
  // Extended stpg color pattern select. This only takes effect when the enable bit (reg_stpg_en) is set.  The specified data come when de is active. 4b 0000   Increment by one for every clock cycle  4b 0001   Constant zero  4b 0010  Static value from config registers                  others      reserved
  #define BIT_MSK__BIST_EXTD_COLOR_MODE__REG_STPG_EXTD_COLOR_SEL                               0xF0

// TMDS STPG Extended color Register for Red
#define REG_ADDR__STPG_EXTD_RED                                          (RX_TBIST | 0x006A)
  // (ReadWrite, Bits 7:0) 
  // Programmable value for channel R  for STPG Extended Color
  #define BIT_MSK__STPG_EXTD_RED__REG_STPG_STATIC_EXTD_RED                              0xFF

// TMDS STPG Extended color Register for Blue
#define REG_ADDR__STPG_EXTD_BLUE                                         (RX_TBIST | 0x006B)
  // (ReadWrite, Bits 7:0) 
  // Programmable value for channel B  for STPG Extended Color
  #define BIT_MSK__STPG_EXTD_BLUE__REG_STPG_STATIC_EXTD_BLUE                             0xFF

// TMDS STPG Extended color Register for Red
#define REG_ADDR__STPG_EXTD_GREEN                                        (RX_TBIST | 0x006C)
  // (ReadWrite, Bits 7:0) 
  // Programmable value for channel G  for STPG Extended Color
  #define BIT_MSK__STPG_EXTD_GREEN__REG_STPG_STATIC_EXTD_GREEN                            0xFF

// TMDS 1 BIST STPG Extd color pattern select Register
#define REG_ADDR__BIST_STPG_EXTD_BUS_CNT_MODE                            (RX_TBIST | 0x006D)
  // (ReadWrite, Bits 7:4) 
  // Extended stpg cnt pattern select. This bus is required if design needs a bist on  data other than RGB. For example Vx1 2 bitCTL. This extd cnt mimic that CTL data. This only takes effect when the enable bit (reg_stpg_en) is set.  The specified data come when de is active. 4b 0000   Constant zero  4b 0001   Increment by one for every clock cycle  4b 0010  Static value from config registers                  others      reserved
  #define BIT_MSK__BIST_STPG_EXTD_BUS_CNT_MODE__REG_STPG_EXTD_BUS_CNT_SEL                             0xF0

// TMDS STPG Extended bus cnt Static pattern Register
#define REG_ADDR__STPG_EXTD_CNT_STATIC                                   (RX_TBIST | 0x006E)
  // (ReadWrite, Bits 7:0) 
  // Programmable value  for STPG Extended Cnt
  #define BIT_MSK__STPG_EXTD_CNT_STATIC__REG_STPG_STATIC_EXTD_CNT                              0xFF

// TMDS 1 BIST STPG Extd color pattern select Register
#define REG_ADDR__BIST_PGEN_EXTD_BUS_CNT_MODE                            (RX_TBIST | 0x006F)
  // (ReadWrite, Bits 7:4) 
  // Extended bus cnt pgen pattern select. This bus is required if design needs a bist on  data other than RGB. For example Vx1 2 bitCTL. This extd cnt mimic that CTL data. This only takes effect when the enable bit (reg_stpg_en) is set.  The specified data come when de is active. 4b 0000   Constant zero  4b 0001   Increment by one for every clock cycle  4b 0010  Static value from config registers                  others      reserved
  #define BIT_MSK__BIST_PGEN_EXTD_BUS_CNT_MODE__REG_PGEN_EXTD_BUS_CNT_SEL                             0xF0

// TMDS PGEN Extended bus cnt Static pattern Register
#define REG_ADDR__PGEN_EXTD_CNT_STATIC                                   (RX_TBIST | 0x0070)
  // (ReadWrite, Bits 7:0) 
  // Programmable value  for PGEN Extended Cnt
  #define BIT_MSK__PGEN_EXTD_CNT_STATIC__REG_PGEN_STATIC_EXTD_CNT                              0xFF

//***************************************************************************
// RX_DEPACK_1. Address: 60
// ECC Control Register
#define REG_ADDR__RX_ECC_CTRL                                            (RX_DEPACK_1 | 0x0000)
  // (ReadWrite, Bits 0) 
  // clearing T4/BCH error registers:  0 - keep acumulating T4 and BCH errors (default); 1 - capture all the values inside counters and clear them.
  #define BIT_MSK__RX_ECC_CTRL__REG_CAPTURE_CNT                                       0x01
  // (ReadWrite, Bits 1) 
  // Enable control to ignore the packet which contains uncorrected ECC erros in the header. 0 - will not ignore the packet; 1 - ignores the packet (default).
  #define BIT_MSK__RX_ECC_CTRL__REG_IGNORE_ECC_ERR_PKT_EN                             0x02

// ECC BCH Threshold Register
#define REG_ADDR__RX_BCH_THRES                                           (RX_DEPACK_1 | 0x0001)
  // (ReadWrite, Bits 4:0) 
  // BCH threshold
  #define BIT_MSK__RX_BCH_THRES__REG_BCH_THRESH                                        0x1F

// ECC HDMI Packet Received Threshold Register
#define REG_ADDR__RX_PKT_THRESH                                          (RX_DEPACK_1 | 0x0004)
  // (ReadWrite, Bits 7:0) 
  // Number of the HDMI Packet received after the last clear during current or previuos frame; depends on the reg_err_mode value. If number of errors exceed 256 then number of errors will be clipped at 256. 
  #define BIT_MSK__RX_PKT_THRESH__REG_HDMI_PKT_THRESH__B7_B0                            0xFF

// ECC HDMI Packet Received Threshold #2 Register
#define REG_ADDR__RX_PKT_THRESH2                                         (RX_DEPACK_1 | 0x0005)
  // (ReadWrite, Bits 7:0) 
  // bits [15:8] of the reg_hdmi_pkt_thresh.
  #define BIT_MSK__RX_PKT_THRESH2__REG_HDMI_PKT_THRESH__B15_B8                           0xFF

// ECC T4 per packet threshold Register
#define REG_ADDR__RX_T4_PKT_THRES                                        (RX_DEPACK_1 | 0x0006)
  // (ReadWrite, Bits 7:0) 
  // Threshold for number of the T4 errors per packet to set the interrupt.
  #define BIT_MSK__RX_T4_PKT_THRES__REG_T4_PKT_THRESH__B7_B0                              0xFF

// ECC T4 per packet threshold #2 Register
#define REG_ADDR__RX_T4_PKT_THRES2                                       (RX_DEPACK_1 | 0x0007)
  // (ReadWrite, Bits 7:0) 
  // bits [15:8] of the reg_t4_pkt_thresh
  #define BIT_MSK__RX_T4_PKT_THRES2__REG_T4_PKT_THRESH__B15_B8                             0xFF

// ECC BCH per packet threshold Register
#define REG_ADDR__RX_BCH_PKT_THRES                                       (RX_DEPACK_1 | 0x0008)
  // (ReadWrite, Bits 7:0) 
  // Threshold for number of the BCH errors per packet to set the interrupt.
  #define BIT_MSK__RX_BCH_PKT_THRES__REG_BCH_PKT_THRESH__B7_B0                             0xFF

// ECC BCH per packet threshold #2 Register
#define REG_ADDR__RX_BCH_PKT_THRES2                                      (RX_DEPACK_1 | 0x0009)
  // (ReadWrite, Bits 7:0) 
  // bits [15:8] of the reg_BCH_pkt_thresh
  #define BIT_MSK__RX_BCH_PKT_THRES2__REG_BCH_PKT_THRESH__B15_B8                            0xFF

// ECC HDCP per packet threshold Register
#define REG_ADDR__RX_HDCP_THRES                                          (RX_DEPACK_1 | 0x000A)
  // (ReadWrite, Bits 7:0) 
  // Threshold for number of the HDCP errors per packet to set the interrupt.
  #define BIT_MSK__RX_HDCP_THRES__REG_HDCP_PKT_THRESH__B7_B0                            0xFF

// ECC HDCP per packet threshold #2 Register
#define REG_ADDR__RX_HDCP_THRES2                                         (RX_DEPACK_1 | 0x000B)
  // (ReadWrite, Bits 7:0) 
  // bits [15:8] of the reg_HDCP_pkt_thresh
  #define BIT_MSK__RX_HDCP_THRES2__REG_HDCP_PKT_THRESH__B15_B8                           0xFF

// ECC HDMI Packet Received Count Register
#define REG_ADDR__RX_PKT_CNT                                             (RX_DEPACK_1 | 0x000C)
  // (ReadOnly, Bits 7:0) 
  // Number of the HDMI Packet received after the last clear during current or previuos frame; depends on the reg_err_mode value. If number of errors exceed 256 then number of errors will be clipped at 256. 
  #define BIT_MSK__RX_PKT_CNT__RHDMI_PKT_CNT__B7_B0                                  0xFF

// ECC HDMI Packet Received Count #2 Register
#define REG_ADDR__RX_PKT_CNT2                                            (RX_DEPACK_1 | 0x000D)
  // (ReadOnly, Bits 7:0) 
  // bits [15:8] of the rhdmi_pkt_cnt.
  #define BIT_MSK__RX_PKT_CNT2__RHDMI_PKT_CNT__B15_B8                                 0xFF

// ECC HDMI T4 related error count Register
#define REG_ADDR__RX_T4_ERR                                              (RX_DEPACK_1 | 0x000E)
  // (ReadOnly, Bits 7:0) 
  // Number of the T4 errors during current or previuos frame; depends on the reg_err_mode value. If number of errors exceed 256 then number of errors will be clipped at 256. 
  #define BIT_MSK__RX_T4_ERR__RHDMI_T4_ERR_CNT__B7_B0                               0xFF

// ECC HDMI T4 related error count #2 Register
#define REG_ADDR__RX_T4_ERR2                                             (RX_DEPACK_1 | 0x000F)
  // (ReadOnly, Bits 7:0) 
  // bits [15:8] of the rhdmi_t4_err_cnt
  #define BIT_MSK__RX_T4_ERR2__RHDMI_T4_ERR_CNT_B15_B8                               0xFF

// ECC HDMI BCH related error count Register
#define REG_ADDR__RX_BCH_ERR                                             (RX_DEPACK_1 | 0x0010)
  // (ReadOnly, Bits 7:0) 
  // Number of the BCH errors during current or previuos frame; depends on the reg_err_mode value. If number of errors exceed 256 then number of errors will be clipped at 256. 
  #define BIT_MSK__RX_BCH_ERR__RHDMI_BCH_ERR_CNT_B7_B0                               0xFF

// ECC HDMI BCH related error count #2 Register
#define REG_ADDR__RX_BCH_ERR2                                            (RX_DEPACK_1 | 0x0011)
  // (ReadOnly, Bits 7:0) 
  // bits [15:8] of the rhdmi_bch_err_cnt
  #define BIT_MSK__RX_BCH_ERR2__RHDMI_BCH_ERR_CNT_B15_B8                              0xFF

// ECC HDMI HDCP related error count Register
#define REG_ADDR__RX_HDCP_ERR                                            (RX_DEPACK_1 | 0x0012)
  // (ReadOnly, Bits 7:0) 
  // Number of the HDCP errors during current or previuos frame; depends on the reg_err_mode value. If number of errors exceed 256 then number of errors will be clipped at 256. 
  #define BIT_MSK__RX_HDCP_ERR__RHDMI_HDCP_ERR_CNT_B7_B0                              0xFF

// ECC HDMI HDCP related error count #2 Register
#define REG_ADDR__RX_HDCP_ERR2                                           (RX_DEPACK_1 | 0x0013)
  // (ReadOnly, Bits 7:0) 
  // bits [15:8] of the rhdmi_hdcp_err_cnt
  #define BIT_MSK__RX_HDCP_ERR2__RHDMI_HDCP_ERR_CNT_B15_B8                             0xFF

// Interrupt InfoFrame Control Register
#define REG_ADDR__RX_INT_IF_CTRL                                         (RX_DEPACK_1 | 0x0020)
  // (ReadWrite, Bits 0) 
  // Select when to set interrupts for the AVI InfoFrames: 0 - interrupt is set only if new AVI InfoFrame is received (default); 1 - interrupt is set  if any AVI InfoFrame received .
  #define BIT_MSK__RX_INT_IF_CTRL__REG_NEW_AVI_ONLY                                      0x01
  // (ReadWrite, Bits 1) 
  // Select when to set interrupts for the SPD InfoFrames: 0 - interrupt is set only if new SPD InfoFrame is received (default); 1 - interrupt is set if any SPD InfoFrame arrives.
  #define BIT_MSK__RX_INT_IF_CTRL__REG_NEW_SPD_ONLY                                      0x02
  // (ReadWrite, Bits 2) 
  // Select when to set interrupts for the AUD InfoFrames: 0 - interrupt is set only if new AUD InfoFrame is received (default); 1 - interrupt is set if any AUD InfoFrame arrives.
  #define BIT_MSK__RX_INT_IF_CTRL__REG_NEW_AUD_ONLY                                      0x04
  // (ReadWrite, Bits 3) 
  // Select when to set interrupts for the MPEG InfoFrames: 0 - interrupt is set only if new MPEG InfoFrame is received (default); 1 - interrupt is set if any MPEG InfoFrame arrives
  #define BIT_MSK__RX_INT_IF_CTRL__REG_NEW_MPEG_ONLY                                     0x08
  // (ReadWrite, Bits 4) 
  // Select when to set interrupts for the Unrecognized InfoFrames: 0 - interrupt is set only if new Unrecognized InfoFrame is received (default); 1 - interrupt is set if any Unrecognized InfoFrame arrives
  #define BIT_MSK__RX_INT_IF_CTRL__REG_NEW_UNREC_ONLY                                    0x10
  // (ReadWrite, Bits 5) 
  // Select when to set interrupts for the ACP InfoFrames: 0 - interrupt is set only if new ACP InfoFrame is received (default); 1 - interrupt is set if any ACP InfoFrame arrives
  #define BIT_MSK__RX_INT_IF_CTRL__REG_NEW_ACP_ONLY                                      0x20
  // (ReadWrite, Bits 6) 
  // Select when to set interrupts for the VSIF InfoFrames: 0 - interrupt is set only if new VSIF InfoFrame is received (default); 1 - interrupt is set if any VSIF InfoFrame arrives
  #define BIT_MSK__RX_INT_IF_CTRL__REG_NEW_VSI_ONLY                                      0x40
  // (ReadWrite, Bits 7) 
  // Enable to use AIF for VSI storage.  If it is set then VSIF ID should not match ID 24'h030C00 and instead it should match ID programmed in reg. 0xD01-0xD04 To update VSI info frames in AIF registers; we need to program the following register bits:     (1) RX_INT_IF_CTRL[7]  =  1  (i.e  reg_use_aif4vsi  = 1)     (2) VSI_CTRL2[0]  =  1  (i.e  reg_vsi_ieee_id_chk_en  = 1)
  #define BIT_MSK__RX_INT_IF_CTRL__REG_USE_AIF4VSI                                       0x80

// Interrupt InfoFrame Control Register#2
#define REG_ADDR__RX_INT_IF_CTRL2                                        (RX_DEPACK_1 | 0x0021)
  // (ReadWrite, Bits 0) 
  // Select when to set interrupts for the ISRC1 InfoFrames: 0 - interrupt is set only if new ISRC1 InfoFrame is received (default); 1 - interrupt is set  if any ISRC1 InfoFrame received .
  #define BIT_MSK__RX_INT_IF_CTRL2__REG_NEW_ISRC1_ONLY                                    0x01
  // (ReadWrite, Bits 1) 
  // Select when to set interrupts for the ISRC2 InfoFrames: 0 - interrupt is set only if new ISRC2 InfoFrame is received (default); 1 - interrupt is set if any ISRC2 InfoFrame arrives.
  #define BIT_MSK__RX_INT_IF_CTRL2__REG_NEW_ISRC2_ONLY                                    0x02
  // (ReadWrite, Bits 2) 
  // Select when to set interrupts for the GCP InfoFrames: 0 - interrupt is set only if new GCP InfoFrame is received (default); 1 - interrupt is set if any GCP InfoFrame arrives.
  #define BIT_MSK__RX_INT_IF_CTRL2__REG_NEW_GCP_ONLY                                      0x04
  // (ReadWrite, Bits 3) 
  // Select when to set interrupts for the ACR Packet: 0 - interrupt is set only if new ACR Packet is received (default); 1 - interrupt is set if any ACR Packet arrives.
  #define BIT_MSK__RX_INT_IF_CTRL2__REG_NEW_ACR_ONLY                                      0x08

// Decode AV Mute Register
#define REG_ADDR__DEC_AV_MUTE                                            (RX_DEPACK_1 | 0x0022)
  // (ReadWrite, Bits 0) 
  // Video mute (ground output): 1 - mute; 0 - not mute (default).
  #define BIT_MSK__DEC_AV_MUTE__REG_VIDEO_MUTE                                        0x01
  // (ReadWrite, Bits 5) 
  // 
  #define BIT_MSK__DEC_AV_MUTE__REG_CLEAR_AV_MUTE                                     0x20

// Deep Color Header Register
#define REG_ADDR__RX_DC_HEADER                                           (RX_DEPACK_1 | 0x0023)
  // (ReadWrite, Bits 7:0) 
  // Deep color packet header
  #define BIT_MSK__RX_DC_HEADER__REG_DC_HEADER                                         0xFF

// Deep Color Phase LUT Register
#define REG_ADDR__RX_PHASE_LUT                                           (RX_DEPACK_1 | 0x0024)
  // (ReadWrite, Bits 1:0) 
  // LUT for phase 0
  #define BIT_MSK__RX_PHASE_LUT__REG_PHASE0_LUT                                        0x03
  // (ReadWrite, Bits 3:2) 
  // LUT for phase 1
  #define BIT_MSK__RX_PHASE_LUT__REG_PHASE1_LUT                                        0x0C
  // (ReadWrite, Bits 5:4) 
  // LUT for phase 2
  #define BIT_MSK__RX_PHASE_LUT__REG_PHASE2_LUT                                        0x30
  // (ReadWrite, Bits 7:6) 
  // LUT for phase 3
  #define BIT_MSK__RX_PHASE_LUT__REG_PHASE3_LUT                                        0xC0

// Audio PATH Status Register
#define REG_ADDR__RX_AUDP_STAT                                           (RX_DEPACK_1 | 0x0027)
  // (ReadOnly, Bits 0) 
  // HDMI Mode Detected by Hardware: This signal indicates the Mode of the connection as detected by the hardware. 0 - DVI 1 - HDMI
  #define BIT_MSK__RX_AUDP_STAT__HDMI_MODE_DET                                         0x01
  // (ReadOnly, Bits 1) 
  // HDMI Mode Detected with software override: This signal indicates the Mode of the connection as detected by the hardware with software override. 0 - DVI 1 - HDMI  This status detected fro Hardware can be overridden by the software through programming appropriate values into reg_hdmi_mode_overwrite and reg_hdmi_mode_sw_value bits of RX_SW_HDMI_MODE register.
  #define BIT_MSK__RX_AUDP_STAT__HDMI_MODE_EN                                          0x02
  // (ReadOnly, Bits 2) 
  // State of AVMute;  the state of the internal AVMute state machine. 
  #define BIT_MSK__RX_AUDP_STAT__HDMI_MUTE                                             0x04
  // (ReadOnly, Bits 4:3) 
  // HDMI Audio Packet layout indicator: 0 - Layout 0 (2-channel) (default) 1 - Layout 1 (Up to 8-channel)
  #define BIT_MSK__RX_AUDP_STAT__HDMI_LAYOUT                                           0x18
  // (ReadOnly, Bits 5) 
  // dsd status: when 1 means that Rx decoded that input stream is DSD
  #define BIT_MSK__RX_AUDP_STAT__HDMI_AUD_DSD_ON                                       0x20
  // (ReadOnly, Bits 6) 
  // High Bit Rate audio flag: when 1 means that Rx decoded that audio stream is High bitrate audio
  #define BIT_MSK__RX_AUDP_STAT__HDMI_HBRA_ON                                          0x40

// Auto Clear Packets Register1
#define REG_ADDR__RX_AUTO_CLR_PKT1                                       (RX_DEPACK_1 | 0x0028)
  // (ReadWrite, Bits 0) 
  // Auto Clear Stored AVI Packet: This bit controls the automated clearing of Stored AVI Packet by the hardware. 0 - Disabled 1 - Enabled  If this bit is set HIGH, Stored AVI Packet is cleared by the hardware if any of the following conditions are true: 1. Cable Unplugged 2. Sync Detection lost
  #define BIT_MSK__RX_AUTO_CLR_PKT1__REG_AUTOCLR_AVI_PKT                                   0x01
  // (ReadWrite, Bits 1) 
  // Auto Clear Stored SPD Packet: This bit controls the automated clearing of Stored SPD Packet by the hardware. 0 - Disabled 1 - Enabled  If this bit is set HIGH, Stored SPD Packet is cleared by the hardware if any of the following conditions are true: 1. Cable Unplugged 2. Sync Detection lost
  #define BIT_MSK__RX_AUTO_CLR_PKT1__REG_AUTOCLR_SPD_PKT                                   0x02
  // (ReadWrite, Bits 2) 
  // Auto Clear Stored AIF Packet: This bit controls the automated clearing of Stored AIF Packet by the hardware. 0 - Disabled 1 - Enabled  If this bit is set HIGH, Stored AIF Packet is cleared by the hardware if any of the following conditions are true: 1. Cable Unplugged 2. Sync Detection lost
  #define BIT_MSK__RX_AUTO_CLR_PKT1__REG_AUTOCLR_AIF_PKT                                   0x04
  // (ReadWrite, Bits 3) 
  // Auto Clear Stored MPEG Packet: This bit controls the automated clearing of Stored MPEG Packet by the hardware. 0 - Disabled 1 - Enabled  If this bit is set HIGH, Stored MPEG Packet is cleared by the hardware if any of the following conditions are true: 1. Cable Unplugged 2. Sync Detection lost
  #define BIT_MSK__RX_AUTO_CLR_PKT1__REG_AUTOCLR_MPEG_PKT                                  0x08
  // (ReadWrite, Bits 4) 
  // Auto Clear Stored Unrecognized Packet: This bit controls the automated clearing of Stored Unrecognized Packet by the hardware. 0 - Disabled 1 - Enabled  If this bit is set HIGH, Stored Unrecognized Packet is cleared by the hardware if any of the following conditions are true: 1. Cable Unplugged 2. Sync Detection lost
  #define BIT_MSK__RX_AUTO_CLR_PKT1__REG_AUTOCLR_UNREC_PKT                                 0x10
  // (ReadWrite, Bits 5) 
  // Auto Clear Stored ACP Packet: This bit controls the automated clearing of Stored ACP Packet by the hardware. 0 - Disabled 1 - Enabled  If this bit is set HIGH, Stored ACP Packet is cleared by the hardware if any of the following conditions are true: 1. Cable Unplugged 2. Sync Detection lost
  #define BIT_MSK__RX_AUTO_CLR_PKT1__REG_AUTOCLR_ACP_PKT                                   0x20
  // (ReadWrite, Bits 6) 
  // Auto Clear Stored VSI Packet: This bit controls the automated clearing of Stored VSI Packet by the hardware. 0 - Disabled 1 - Enabled  If this bit is set HIGH, Stored VSI Packet is cleared by the hardware if any of the following conditions are true: 1. Cable Unplugged 2. Sync Detection lost
  #define BIT_MSK__RX_AUTO_CLR_PKT1__REG_AUTOCLR_VSI_PKT                                   0x40
  // (ReadWrite, Bits 7) 
  // Auto Clear Stored GCP Packet: This bit controls the automated clearing of Stored GCP Packet by the hardware. 0 - Disabled 1 - Enabled  If this bit is set HIGH, Stored GCP Packet is cleared by the hardware if any of the following conditions are true: 1. Cable Unplugged 2. Sync Detection lost
  #define BIT_MSK__RX_AUTO_CLR_PKT1__REG_AUTOCLR_GCP_PKT                                   0x80

// Interrupt InfoFrame Control Register#2
#define REG_ADDR__RX_AUTO_CLR_PKT2                                       (RX_DEPACK_1 | 0x0029)
  // (ReadWrite, Bits 0) 
  // Auto Clear Stored ISRC1 Packet: This bit controls the automated clearing of Stored ISRC1 Packet by the hardware. 0 - Disabled 1 - Enabled  If this bit is set HIGH, Stored ISRC1 Packet is cleared by the hardware if any of the following conditions are true: 1. Cable Unplugged 2. Sync Detection lost
  #define BIT_MSK__RX_AUTO_CLR_PKT2__REG_AUTOCLR_ISRC1_PKT                                 0x01
  // (ReadWrite, Bits 1) 
  // Auto Clear Stored ISRC2 Packet: This bit controls the automated clearing of Stored ISRC2 Packet by the hardware. 0 - Disabled 1 - Enabled  If this bit is set HIGH, Stored ISRC2 Packet is cleared by the hardware if any of the following conditions are true: 1. Cable Unplugged 2. Sync Detection lost
  #define BIT_MSK__RX_AUTO_CLR_PKT2__REG_AUTOCLR_ISRC2_PKT                                 0x02
  // (ReadWrite, Bits 2) 
  // Auto Clear Stored Metadata Packet: This bit controls the automated clearing of Stored Metadata Packet by the hardware. 0 - Disabled 1 - Enabled  If this bit is set HIGH, Stored Metadata Packet is cleared by the hardware if any of the following conditions are true: 1. Cable Unplugged 2. Sync Detection lost
  #define BIT_MSK__RX_AUTO_CLR_PKT2__REG_AUTOCLR_METADATA_PKT                              0x04
  // (ReadWrite, Bits 3) 
  // Auto Clear Stored ACR Packet: This bit controls the automated clearing of Stored ACR Packet by the hardware. 0 - Disabled 1 - Enabled  If this bit is set HIGH, Stored ACR Packet is cleared by the hardware if any of the following conditions are true: 1. Cable Unplugged 2. Sync Detection lost
  #define BIT_MSK__RX_AUTO_CLR_PKT2__REG_AUTOCLR_ACR_PKT                                   0x08

// Interrupt Status #0 Register
#define REG_ADDR__RX_DEPACK_INTR0                                        (RX_DEPACK_1 | 0x0030)
  // (ReadWrite, Bits 0) 
  // Audio ECC Error. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR0__REG_INTR0_STAT0                                       0x01
  // (ReadWrite, Bits 1) 
  // T4 interrupt; set if number of the T4 erros exceeds threshold;   Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR0__REG_INTR0_STAT1                                       0x02
  // (ReadWrite, Bits 2) 
  // HDCP interrupt; set if number of the HDCP erros exceeds threshold;   Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR0__REG_INTR0_STAT2                                       0x04
  // (ReadWrite, Bits 3) 
  // Packet received interrupt; set if number of the received HDMI packets exceeds threshold;   Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR0__REG_INTR0_STAT3                                       0x08
  // (ReadWrite, Bits 4) 
  // Deep-color packet error interrupt
  #define BIT_MSK__RX_DEPACK_INTR0__REG_INTR0_STAT4                                       0x10
  // (ReadWrite, Bits 5) 
  // This Interrupt indicates a change in the Deep Color mode. This Interrupt is asserted HIGH when a change is noticed on the Colour Depth of the Video as indicated through the GCP packet. NOTE: When CD field of GCP is changed to All Zeros, this Interrupt is asserted only if the GCP is consecutively transmitted for more than 4 times. This is as per HDMI specification. Write 1 to clear.
  #define BIT_MSK__RX_DEPACK_INTR0__REG_INTR0_STAT5                                       0x20

// Interrupt Status #0 Mask Register
#define REG_ADDR__RX_DEPACK_INTR0_MASK                                   (RX_DEPACK_1 | 0x0031)
  // (ReadWrite, Bits 0) 
  // Enable INTR0[0]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR0_MASK__REG_INTR0_MASK0                                       0x01
  // (ReadWrite, Bits 1) 
  // Enable INTR0[1]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR0_MASK__REG_INTR0_MASK1                                       0x02
  // (ReadWrite, Bits 2) 
  // Enable INTR0[2]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR0_MASK__REG_INTR0_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // Enable INTR0[3]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR0_MASK__REG_INTR0_MASK3                                       0x08
  // (ReadWrite, Bits 4) 
  // Enable INTR0[4]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR0_MASK__REG_INTR0_MASK4                                       0x10
  // (ReadWrite, Bits 5) 
  // Enable INTR0[5]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR0_MASK__REG_INTR0_MASK5                                       0x20

// Interrupt Status #1 Register
#define REG_ADDR__RX_DEPACK_INTR1                                        (RX_DEPACK_1 | 0x0032)
  // (ReadWrite, Bits 0) 
  // No Audio Packet. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR1__REG_INTR1_STAT0                                       0x01
  // (ReadWrite, Bits 2) 
  // CP InforFrame is set to Mute.  Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR1__REG_INTR1_STAT2                                       0x04
  // (ReadWrite, Bits 3) 
  // Audio Link error. Happens only when there are ECC errors and no TERC4 errors. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR1__REG_INTR1_STAT3                                       0x08
  // (ReadWrite, Bits 4) 
  // This Interrupt indicates a change in the Audio Layout. This Interrupt is asserted HIGH when a change is noticed in the Audio Layout, indicated by the source. Write 1 to clear.
  #define BIT_MSK__RX_DEPACK_INTR1__REG_INTR1_STAT4                                       0x10
  // (ReadWrite, Bits 5) 
  // DSD on status had changed: Asserted if DSD on status had changed. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR1__REG_INTR1_STAT5                                       0x20
  // (ReadWrite, Bits 6) 
  // HBRA on status had changed: Asserted if HBRA on status had changed. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR1__REG_INTR1_STAT6                                       0x40

// Interrupt Status #1 Mask Register
#define REG_ADDR__RX_DEPACK_INTR1_MASK                                   (RX_DEPACK_1 | 0x0033)
  // (ReadWrite, Bits 0) 
  // Enable INTR1[0]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR1_MASK__REG_INTR1_MASK0                                       0x01
  // (ReadWrite, Bits 2) 
  // Enable INTR1[2]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR1_MASK__REG_INTR1_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // Enable INTR1[3]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR1_MASK__REG_INTR1_MASK3                                       0x08
  // (ReadWrite, Bits 4) 
  // Enable INTR1[4]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR1_MASK__REG_INTR1_MASK4                                       0x10
  // (ReadWrite, Bits 5) 
  // Enable INTR1[5]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR1_MASK__REG_INTR1_MASK5                                       0x20
  // (ReadWrite, Bits 6) 
  // Enable INTR1[6]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR1_MASK__REG_INTR1_MASK6                                       0x40

// Interrupt Status #2 Register
#define REG_ADDR__RX_DEPACK_INTR2                                        (RX_DEPACK_1 | 0x0034)
  // (ReadWrite, Bits 0) 
  // New AVI Info packet. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR2__REG_INTR2_STAT0                                       0x01
  // (ReadWrite, Bits 1) 
  // New SP Info packet. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR2__REG_INTR2_STAT1                                       0x02
  // (ReadWrite, Bits 2) 
  // New AUD Info packet. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR2__REG_INTR2_STAT2                                       0x04
  // (ReadWrite, Bits 3) 
  // New MPEG Info packet. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR2__REG_INTR2_STAT3                                       0x08
  // (ReadWrite, Bits 4) 
  // New Unrecognized packet. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR2__REG_INTR2_STAT4                                       0x10
  // (ReadWrite, Bits 5) 
  // New CP packet. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR2__REG_INTR2_STAT5                                       0x20
  // (ReadWrite, Bits 6) 
  // New ACP packet. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR2__REG_INTR2_STAT6                                       0x40
  // (ReadWrite, Bits 7) 
  // New GCP packet. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR2__REG_INTR2_STAT7                                       0x80

// Interrupt Status #2 Mask Register
#define REG_ADDR__RX_DEPACK_INTR2_MASK                                   (RX_DEPACK_1 | 0x0035)
  // (ReadWrite, Bits 0) 
  // Enable INTR2[0]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR2_MASK__REG_INTR2_MASK0                                       0x01
  // (ReadWrite, Bits 1) 
  // Enable INTR2[1]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR2_MASK__REG_INTR2_MASK1                                       0x02
  // (ReadWrite, Bits 2) 
  // Enable INTR2[2]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR2_MASK__REG_INTR2_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // Enable INTR2[3]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR2_MASK__REG_INTR2_MASK3                                       0x08
  // (ReadWrite, Bits 4) 
  // Enable INTR2[4]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR2_MASK__REG_INTR2_MASK4                                       0x10
  // (ReadWrite, Bits 5) 
  // Enable INTR2[5]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR2_MASK__REG_INTR2_MASK5                                       0x20
  // (ReadWrite, Bits 6) 
  // Enable INTR2[6]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR2_MASK__REG_INTR2_MASK6                                       0x40
  // (ReadWrite, Bits 7) 
  // Enable INTR2[7]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR2_MASK__REG_INTR2_MASK7                                       0x80

// Interrupt Status #3 Register
#define REG_ADDR__RX_DEPACK_INTR3                                        (RX_DEPACK_1 | 0x0036)
  // (ReadWrite, Bits 0) 
  // New ISRC1 packet. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR3__REG_INTR3_STAT0                                       0x01
  // (ReadWrite, Bits 1) 
  // New ISRC2 packet. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR3__REG_INTR3_STAT1                                       0x02
  // (ReadWrite, Bits 2) 
  // New VSI packet. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR3__REG_INTR3_STAT2                                       0x04
  // (ReadWrite, Bits 3) 
  // new HF_VSI infoframe is received
  #define BIT_MSK__RX_DEPACK_INTR3__REG_INTR3_STAT3                                       0x08
  // (ReadWrite, Bits 4) 
  // same HF_VSI infoframe is repeated
  #define BIT_MSK__RX_DEPACK_INTR3__REG_INTR3_STAT4                                       0x10
  // (ReadWrite, Bits 5) 
  // New ACR packet. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR3__REG_INTR3_STAT5                                       0x20

// Interrupt Status #3 Mask Register
#define REG_ADDR__RX_DEPACK_INTR3_MASK                                   (RX_DEPACK_1 | 0x0037)
  // (ReadWrite, Bits 0) 
  // Enable INTR3[0]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR3_MASK__REG_INTR3_MASK0                                       0x01
  // (ReadWrite, Bits 1) 
  // Enable INTR3[1]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR3_MASK__REG_INTR3_MASK1                                       0x02
  // (ReadWrite, Bits 2) 
  // Enable INTR3[2]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR3_MASK__REG_INTR3_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // Enable INTR3[3]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR3_MASK__REG_INTR3_MASK3                                       0x08
  // (ReadWrite, Bits 4) 
  // Enable INTR3[4]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR3_MASK__REG_INTR3_MASK4                                       0x10
  // (ReadWrite, Bits 5) 
  // Enable INTR3[5]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR3_MASK__REG_INTR3_MASK5                                       0x20

// Interrupt Status #4 Register
#define REG_ADDR__RX_DEPACK_INTR4                                        (RX_DEPACK_1 | 0x0038)
  // (ReadWrite, Bits 0) 
  // new 3D-Audio pkt is received
  #define BIT_MSK__RX_DEPACK_INTR4__REG_INTR4_STAT0                                       0x01
  // (ReadWrite, Bits 1) 
  // new onebit 3D-Audio pkt is received
  #define BIT_MSK__RX_DEPACK_INTR4__REG_INTR4_STAT1                                       0x02
  // (ReadWrite, Bits 2) 
  // meata-data audio pkt is received
  #define BIT_MSK__RX_DEPACK_INTR4__REG_INTR4_STAT2                                       0x04
  // (ReadWrite, Bits 3) 
  // new multi-stream audio pkt is received
  #define BIT_MSK__RX_DEPACK_INTR4__REG_INTR4_STAT3                                       0x08
  // (ReadWrite, Bits 4) 
  // new one-bit multi-stream audio pkt is received
  #define BIT_MSK__RX_DEPACK_INTR4__REG_INTR4_STAT4                                       0x10
  // (ReadWrite, Bits 5) 
  // new meta data packet is received
  #define BIT_MSK__RX_DEPACK_INTR4__REG_INTR4_STAT5                                       0x20
  // (ReadWrite, Bits 6) 
  // 3d22d or 2d23d change of transmission 
  #define BIT_MSK__RX_DEPACK_INTR4__REG_INTR4_STAT6                                       0x40

// Interrupt Status #4 Mask Register
#define REG_ADDR__RX_DEPACK_INTR4_MASK                                   (RX_DEPACK_1 | 0x0039)
  // (ReadWrite, Bits 0) 
  // Enable INTR4[0]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR4_MASK__REG_INTR4_MASK0                                       0x01
  // (ReadWrite, Bits 1) 
  // Enable INTR4[1]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR4_MASK__REG_INTR4_MASK1                                       0x02
  // (ReadWrite, Bits 2) 
  // Enable INTR4[2]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR4_MASK__REG_INTR4_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // Enable INTR4[3]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR4_MASK__REG_INTR4_MASK3                                       0x08
  // (ReadWrite, Bits 4) 
  // Enable INTR4[4]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR4_MASK__REG_INTR4_MASK4                                       0x10
  // (ReadWrite, Bits 5) 
  // Enable INTR4[5]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR4_MASK__REG_INTR4_MASK5                                       0x20
  // (ReadWrite, Bits 6) 
  // Enable INTR4[6]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR4_MASK__REG_INTR4_MASK6                                       0x40

// Interrupt Status #5 Register
#define REG_ADDR__RX_DEPACK_INTR5                                        (RX_DEPACK_1 | 0x003A)
  // (ReadWrite, Bits 0) 
  // Interrupt indicating the AVI InfoFrame did not arrived for more then 4 frames. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR5__REG_INTR5_STAT0                                       0x01
  // (ReadWrite, Bits 1) 
  // No Deep-color packet has been received for 4 frames.
  #define BIT_MSK__RX_DEPACK_INTR5__REG_INTR5_STAT1                                       0x02
  // (ReadWrite, Bits 2) 
  // Interrupt indicating the VSI InfoFrame did not arrived for more then 4 frames. Write 1 to clear depends on the setting in VSI_CTRL1[4:2]
  #define BIT_MSK__RX_DEPACK_INTR5__REG_INTR5_STAT2                                       0x04
  // (ReadWrite, Bits 3) 
  // Interrupt indicating the AIF InfoFrame did not arrived for more then 4 frames. Write 1 to clear depends on the setting in VSI_CTRL1[4:2]
  #define BIT_MSK__RX_DEPACK_INTR5__REG_INTR5_STAT3                                       0x08
  // (ReadWrite, Bits 4) 
  // Interrupt indicating the SPD InfoFrame did not arrived for more then 4 frames. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR5__REG_INTR5_STAT4                                       0x10
  // (ReadWrite, Bits 5) 
  // Interrupt indicating the MPEG InfoFrame did not arrived for more then 4 frames. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR5__REG_INTR5_STAT5                                       0x20
  // (ReadWrite, Bits 6) 
  // Interrupt indicating the UNREC InfoFrame did not arrived for more then 4 frames. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR5__REG_INTR5_STAT6                                       0x40
  // (ReadWrite, Bits 7) 
  // Interrupt indicating the ACP InfoFrame did not arrived for more then 4 frames. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR5__REG_INTR5_STAT7                                       0x80

// Interrupt Status #5 Mask Register
#define REG_ADDR__RX_DEPACK_INTR5_MASK                                   (RX_DEPACK_1 | 0x003B)
  // (ReadWrite, Bits 0) 
  // Enable INTR5[0]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR5_MASK__REG_INTR5_MASK0                                       0x01
  // (ReadWrite, Bits 1) 
  // Enable INTR5[1]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR5_MASK__REG_INTR5_MASK1                                       0x02
  // (ReadWrite, Bits 2) 
  // Enable INTR5[2]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR5_MASK__REG_INTR5_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // Enable INTR5[3]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR5_MASK__REG_INTR5_MASK3                                       0x08
  // (ReadWrite, Bits 4) 
  // Enable INTR5[4]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR5_MASK__REG_INTR5_MASK4                                       0x10
  // (ReadWrite, Bits 5) 
  // Enable INTR5[5]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR5_MASK__REG_INTR5_MASK5                                       0x20
  // (ReadWrite, Bits 6) 
  // Enable INTR5[6]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR5_MASK__REG_INTR5_MASK6                                       0x40
  // (ReadWrite, Bits 7) 
  // Enable INTR5[7]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR5_MASK__REG_INTR5_MASK7                                       0x80

// Interrupt Status #6 Register
#define REG_ADDR__RX_DEPACK_INTR6                                        (RX_DEPACK_1 | 0x003C)
  // (ReadWrite, Bits 0) 
  // Interrupt indicating the ISRC1 InfoFrame did not arrived for more then 4 frames. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR6__REG_INTR6_STAT0                                       0x01
  // (ReadWrite, Bits 1) 
  // Interrupt indicating the ISRC2 InfoFrame did not arrived for more then 4 frames. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR6__REG_INTR6_STAT1                                       0x02
  // (ReadWrite, Bits 2) 
  // Interrupt indicating the GCP InfoFrame did not arrived for more then 4 frames. Write 1 to clear
  #define BIT_MSK__RX_DEPACK_INTR6__REG_INTR6_STAT2                                       0x04
  // (ReadWrite, Bits 3) 
  // No HF_VSI infoframe is received
  #define BIT_MSK__RX_DEPACK_INTR6__REG_INTR6_STAT3                                       0x08
  // (ReadWrite, Bits 4) 
  // no metadata packet is revceived
  #define BIT_MSK__RX_DEPACK_INTR6__REG_INTR6_STAT4                                       0x10

// Interrupt Status #6 Mask Register
#define REG_ADDR__RX_DEPACK_INTR6_MASK                                   (RX_DEPACK_1 | 0x003D)
  // (ReadWrite, Bits 0) 
  // Enable INTR6[0]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR6_MASK__REG_INTR6_MASK0                                       0x01
  // (ReadWrite, Bits 1) 
  // Enable INTR6[1]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR6_MASK__REG_INTR6_MASK1                                       0x02
  // (ReadWrite, Bits 2) 
  // Enable INTR6[2]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR6_MASK__REG_INTR6_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // Enable INTR6[3]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR6_MASK__REG_INTR6_MASK3                                       0x08
  // (ReadWrite, Bits 4) 
  // Enable INTR6[4]: 0 - Disable (defualt) 1 - Enable
  #define BIT_MSK__RX_DEPACK_INTR6_MASK__REG_INTR6_MASK4                                       0x10

// CEA-861 AVI InfoFrame Type Code Register
#define REG_ADDR__AVIRX_TYPE                                             (RX_DEPACK_1 | 0x0040)
  // (ReadOnly, Bits 7:0) 
  // bits [7:0] of 2 byte AVI Header. This byte defines the AVI InfoFrame Type Code. Follows the latest CEA-861 spec.
  #define BIT_MSK__AVIRX_TYPE__CEA_AVI_HEADER_B7_B0                                  0xFF

// CEA-861 AVI InfoFrame Version Number Register
#define REG_ADDR__AVIRX_VERS                                             (RX_DEPACK_1 | 0x0041)
  // (ReadOnly, Bits 7:0) 
  // bits [15:8] of 2 byte AVI Header. This byte defines the AVI InfoFrame Version Number. Follows the latest CEA-861 spec.
  #define BIT_MSK__AVIRX_VERS__CEA_AVI_HEADER_B15_B8                                 0xFF

// CEA-861 AVI InfoFrame Length Register
#define REG_ADDR__AVIRX_LENGTH                                           (RX_DEPACK_1 | 0x0042)
  // (ReadOnly, Bits 7:0) 
  // Length of Auxilary Video InfoFrame
  #define BIT_MSK__AVIRX_LENGTH__CEA_AVI_LENGTH                                        0xFF

// CEA-861 AVI InfoFrame HDMI Checksum Register
#define REG_ADDR__AVIRX_CHSUM                                            (RX_DEPACK_1 | 0x0043)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__AVIRX_CHSUM__CEA_AVI_CHECKSUM                                      0xFF

// CEA-861 AVI InfoFrame Data Byte #1 Register
#define REG_ADDR__AVIRX_DBYTE1                                           (RX_DEPACK_1 | 0x0044)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AVIRX_DBYTE1__CEA_AVI_DBYTE1                                        0xFF

// CEA-861 AVI InfoFrame Data Byte #2 Register
#define REG_ADDR__AVIRX_DBYTE2                                           (RX_DEPACK_1 | 0x0045)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AVIRX_DBYTE2__CEA_AVI_DBYTE2                                        0xFF

// CEA-861 AVI InfoFrame Data Byte #3 Register
#define REG_ADDR__AVIRX_DBYTE3                                           (RX_DEPACK_1 | 0x0046)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AVIRX_DBYTE3__CEA_AVI_DBYTE3                                        0xFF

// CEA-861 AVI InfoFrame Data Byte #4 Register
#define REG_ADDR__AVIRX_DBYTE4                                           (RX_DEPACK_1 | 0x0047)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AVIRX_DBYTE4__CEA_AVI_DBYTE4                                        0xFF

// CEA-861 AVI InfoFrame Data Byte #5 Register
#define REG_ADDR__AVIRX_DBYTE5                                           (RX_DEPACK_1 | 0x0048)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AVIRX_DBYTE5__CEA_AVI_DBYTE5                                        0xFF

// CEA-861 AVI InfoFrame Data Byte #6 Register
#define REG_ADDR__AVIRX_DBYTE6                                           (RX_DEPACK_1 | 0x0049)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AVIRX_DBYTE6__CEA_AVI_DBYTE6                                        0xFF

// CEA-861 AVI InfoFrame Data Byte #7 Register
#define REG_ADDR__AVIRX_DBYTE7                                           (RX_DEPACK_1 | 0x004A)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AVIRX_DBYTE7__CEA_AVI_DBYTE7                                        0xFF

// CEA-861 AVI InfoFrame Data Byte #8 Register
#define REG_ADDR__AVIRX_DBYTE8                                           (RX_DEPACK_1 | 0x004B)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AVIRX_DBYTE8__CEA_AVI_DBYTE8                                        0xFF

// CEA-861 AVI InfoFrame Data Byte #9 Register
#define REG_ADDR__AVIRX_DBYTE9                                           (RX_DEPACK_1 | 0x004C)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AVIRX_DBYTE9__CEA_AVI_DBYTE9                                        0xFF

// CEA-861 AVI InfoFrame Data Byte #10 Register
#define REG_ADDR__AVIRX_DBYTE10                                          (RX_DEPACK_1 | 0x004D)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AVIRX_DBYTE10__CEA_AVI_DBYTE10                                       0xFF

// CEA-861 AVI InfoFrame Data Byte #11 Register
#define REG_ADDR__AVIRX_DBYTE11                                          (RX_DEPACK_1 | 0x004E)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AVIRX_DBYTE11__CEA_AVI_DBYTE11                                       0xFF

// CEA-861 AVI InfoFrame Data Byte #12 Register
#define REG_ADDR__AVIRX_DBYTE12                                          (RX_DEPACK_1 | 0x004F)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AVIRX_DBYTE12__CEA_AVI_DBYTE12                                       0xFF

// CEA-861 AVI InfoFrame Data Byte #13 Register
#define REG_ADDR__AVIRX_DBYTE13                                          (RX_DEPACK_1 | 0x0050)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AVIRX_DBYTE13__CEA_AVI_DBYTE13                                       0xFF

// CEA-861 AVI InfoFrame Data Byte #14 Register
#define REG_ADDR__AVIRX_DBYTE14                                          (RX_DEPACK_1 | 0x0051)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AVIRX_DBYTE14__CEA_AVI_DBYTE14                                       0xFF

// CEA-861 AVI InfoFrame Data Byte #15 Register
#define REG_ADDR__AVIRX_DBYTE15                                          (RX_DEPACK_1 | 0x0052)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AVIRX_DBYTE15__CEA_AVI_DBYTE15                                       0xFF

// Unrecognized Packet  Control Register
#define REG_ADDR__RX_UNREC_CTRL                                          (RX_DEPACK_1 | 0x005E)
  // (ReadWrite, Bits 0) 
  // Store Specific Unrecognized Packets: This register bit controls the packet loading behaviour for Unrecognized packet. 0 - Depacketizer does not check for the packet header programmed in 0xC5F to load an Unrecognized packets into the generic packet registers. 1 - Depacketizer checks for the packet header programmed in 0xC5F to load an Unrecognized packets into the generic packet registers. This register bit when HIGH validates the Unrecognized packet header programmed in 0xC5F to catch(route) specific InfoFrame into the generic packet registers else drop the Unrecognized packets.  NOTE: Setting this bit HIGH does not change the priority of decoding packet headers. Ex.: If an Audio Infoframe packet header is programmed into Unrecognized packet header in 0xC5F and this bit HIGH, does not route the Audio Infoframe packet into Unrecognized packet since the priority for unrecognized packets is the least. If a packet doesn't match any of the pre-determined packet types then this check is initiated.
  #define BIT_MSK__RX_UNREC_CTRL__REG_CATCH_SPECIFIC_PKT_EN                             0x01

// Unrecognized Packet  Header Decoder Register
#define REG_ADDR__RX_UNREC_DEC                                           (RX_DEPACK_1 | 0x005F)
  // (ReadWrite, Bits 7:0) 
  // SPD packet decode address: default is 0xFF. By changing this address the specified packet can be stored in the location of Unrecognized packet.
  #define BIT_MSK__RX_UNREC_DEC__REG_UNREC_DEC                                         0xFF

// CEA-861 SPD InfoFrame Type Code Register
#define REG_ADDR__SPDRX_TYPE                                             (RX_DEPACK_1 | 0x0060)
  // (ReadOnly, Bits 7:0) 
  // bits [7:0] of 2 byte SPD Header. This byte defines the SPD InfoFrame Type Code. Follows the latest CEA-861 spec.
  #define BIT_MSK__SPDRX_TYPE__CEA_SPD_HEADER_B7_B0                                  0xFF

// CEA-861 SPD InfoFrame Version Number Register
#define REG_ADDR__SPDRX_VERS                                             (RX_DEPACK_1 | 0x0061)
  // (ReadOnly, Bits 7:0) 
  // bits [15:8] of 2 byte SPD Header. This byte defines the SPD InfoFrame Version Number. Follows the latest CEA-861 spec.
  #define BIT_MSK__SPDRX_VERS__CEA_SPD_HEADER_B15_B8                                 0xFF

// CEA-861 SPD InfoFrame Length Register
#define REG_ADDR__SPDRX_LENGTH                                           (RX_DEPACK_1 | 0x0062)
  // (ReadOnly, Bits 7:0) 
  // Length of SPD InfoFrame
  #define BIT_MSK__SPDRX_LENGTH__CEA_SPD_LENGTH                                        0xFF

// CEA-861 SPD InfoFrame HDMI Checksum Register
#define REG_ADDR__SPDRX_CHSUM                                            (RX_DEPACK_1 | 0x0063)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__SPDRX_CHSUM__CEA_SPD_CHECKSUM                                      0xFF

// CEA-861 SPD Data Byte #1 Register
#define REG_ADDR__SPDRX_DBYTE1                                           (RX_DEPACK_1 | 0x0064)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE1__CEA_SPD_DBYTE1                                        0xFF

// CEA-861 SPD Data Byte #2 Register
#define REG_ADDR__SPDRX_DBYTE2                                           (RX_DEPACK_1 | 0x0065)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE2__CEA_SPD_DBYTE2                                        0xFF

// CEA-861 SPD Data Byte #3 Register
#define REG_ADDR__SPDRX_DBYTE3                                           (RX_DEPACK_1 | 0x0066)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE3__CEA_SPD_DBYTE3                                        0xFF

// CEA-861 SPD Data Byte #4 Register
#define REG_ADDR__SPDRX_DBYTE4                                           (RX_DEPACK_1 | 0x0067)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE4__CEA_SPD_DBYTE4                                        0xFF

// CEA-861 SPD Data Byte #5 Register
#define REG_ADDR__SPDRX_DBYTE5                                           (RX_DEPACK_1 | 0x0068)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE5__CEA_SPD_DBYTE5                                        0xFF

// CEA-861 SPD Data Byte #6 Register
#define REG_ADDR__SPDRX_DBYTE6                                           (RX_DEPACK_1 | 0x0069)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE6__CEA_SPD_DBYTE6                                        0xFF

// CEA-861 SPD Data Byte #7 Register
#define REG_ADDR__SPDRX_DBYTE7                                           (RX_DEPACK_1 | 0x006A)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE7__CEA_SPD_DBYTE7                                        0xFF

// CEA-861 SPD Data Byte #8 Register
#define REG_ADDR__SPDRX_DBYTE8                                           (RX_DEPACK_1 | 0x006B)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE8__CEA_SPD_DBYTE8                                        0xFF

// CEA-861 SPD Data Byte #9 Register
#define REG_ADDR__SPDRX_DBYTE9                                           (RX_DEPACK_1 | 0x006C)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE9__CEA_SPD_DBYTE9                                        0xFF

// CEA-861 SPD Data Byte #10 Register
#define REG_ADDR__SPDRX_DBYTE10                                          (RX_DEPACK_1 | 0x006D)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE10__CEA_SPD_DBYTE10                                       0xFF

// CEA-861 SPD Data Byte #11 Register
#define REG_ADDR__SPDRX_DBYTE11                                          (RX_DEPACK_1 | 0x006E)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE11__CEA_SPD_DBYTE11                                       0xFF

// CEA-861 SPD Data Byte #12 Register
#define REG_ADDR__SPDRX_DBYTE12                                          (RX_DEPACK_1 | 0x006F)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE12__CEA_SPD_DBYTE12                                       0xFF

// CEA-861 SPD Data Byte #13 Register
#define REG_ADDR__SPDRX_DBYTE13                                          (RX_DEPACK_1 | 0x0070)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE13__CEA_SPD_DBYTE13                                       0xFF

// CEA-861 SPD Data Byte #14 Register
#define REG_ADDR__SPDRX_DBYTE14                                          (RX_DEPACK_1 | 0x0071)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE14__CEA_SPD_DBYTE14                                       0xFF

// CEA-861 SPD Data Byte #15 Register
#define REG_ADDR__SPDRX_DBYTE15                                          (RX_DEPACK_1 | 0x0072)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE15__CEA_SPD_DBYTE15                                       0xFF

// CEA-861 SPD Data Byte #16 Register
#define REG_ADDR__SPDRX_DBYTE16                                          (RX_DEPACK_1 | 0x0073)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE16__CEA_SPD_DBYTE16                                       0xFF

// CEA-861 SPD Data Byte #17 Register
#define REG_ADDR__SPDRX_DBYTE17                                          (RX_DEPACK_1 | 0x0074)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE17__CEA_SPD_DBYTE17                                       0xFF

// CEA-861 SPD Data Byte #18 Register
#define REG_ADDR__SPDRX_DBYTE18                                          (RX_DEPACK_1 | 0x0075)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE18__CEA_SPD_DBYTE18                                       0xFF

// CEA-861 SPD Data Byte #19 Register
#define REG_ADDR__SPDRX_DBYTE19                                          (RX_DEPACK_1 | 0x0076)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE19__CEA_SPD_DBYTE19                                       0xFF

// CEA-861 SPD Data Byte #20 Register
#define REG_ADDR__SPDRX_DBYTE20                                          (RX_DEPACK_1 | 0x0077)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE20__CEA_SPD_DBYTE20                                       0xFF

// CEA-861 SPD Data Byte #21 Register
#define REG_ADDR__SPDRX_DBYTE21                                          (RX_DEPACK_1 | 0x0078)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE21__CEA_SPD_DBYTE21                                       0xFF

// CEA-861 SPD Data Byte #22 Register
#define REG_ADDR__SPDRX_DBYTE22                                          (RX_DEPACK_1 | 0x0079)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE22__CEA_SPD_DBYTE22                                       0xFF

// CEA-861 SPD Data Byte #23 Register
#define REG_ADDR__SPDRX_DBYTE23                                          (RX_DEPACK_1 | 0x007A)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE23__CEA_SPD_DBYTE23                                       0xFF

// CEA-861 SPD Data Byte #24 Register
#define REG_ADDR__SPDRX_DBYTE24                                          (RX_DEPACK_1 | 0x007B)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE24__CEA_SPD_DBYTE24                                       0xFF

// CEA-861 SPD Data Byte #25 Register
#define REG_ADDR__SPDRX_DBYTE25                                          (RX_DEPACK_1 | 0x007C)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE25__CEA_SPD_DBYTE25                                       0xFF

// CEA-861 SPD Data Byte #26 Register
#define REG_ADDR__SPDRX_DBYTE26                                          (RX_DEPACK_1 | 0x007D)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE26__CEA_SPD_DBYTE26                                       0xFF

// CEA-861 SPD Data Byte #27 Register
#define REG_ADDR__SPDRX_DBYTE27                                          (RX_DEPACK_1 | 0x007E)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__SPDRX_DBYTE27__CEA_SPD_DBYTE27                                       0xFF

// CEA-861 SPD Packet decode address Register
#define REG_ADDR__SPD_DEC                                                (RX_DEPACK_1 | 0x007F)
  // (ReadWrite, Bits 7:0) 
  // SPD packet decode address: default is 0x83. By changing this address the SPD packet can be stored in the location of any other InfoFrame
  #define BIT_MSK__SPD_DEC__REG_SPD_DEC                                           0xFF

// CEA-861 Audio InfoFrame Type Code Register
#define REG_ADDR__AUDRX_TYPE                                             (RX_DEPACK_1 | 0x0080)
  // (ReadOnly, Bits 7:0) 
  // bits [7:0] of 2 byte Audio Header. This byte defines the Audio InfoFrame Type Code. Follows the latest CEA-861 spec.
  #define BIT_MSK__AUDRX_TYPE__CEA_AUD_HEADER_B7_B0                                  0xFF

// CEA-861 Audio InfoFrame Version Number Register
#define REG_ADDR__AUDRX_VERS                                             (RX_DEPACK_1 | 0x0081)
  // (ReadOnly, Bits 7:0) 
  // bits [15:8] of 2 byte Audio Header. This byte defines the Audio InfoFrame Version Number. Follows the latest CEA-861 spec.
  #define BIT_MSK__AUDRX_VERS__CEA_AUD_HEADER_B15_B8                                 0xFF

// CEA-861 Audio InfoFrame Length Register
#define REG_ADDR__AUDRX_LENGTH                                           (RX_DEPACK_1 | 0x0082)
  // (ReadOnly, Bits 7:0) 
  // Length of Audio InfoFrame
  #define BIT_MSK__AUDRX_LENGTH__CEA_AUD_LENGTH                                        0xFF

// CEA-861 Audio InfoFrame HDMI Checksum Register
#define REG_ADDR__AUDRX_CHSUM                                            (RX_DEPACK_1 | 0x0083)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__AUDRX_CHSUM__CEA_AUD_CHECKSUM                                      0xFF

// CEA-861 Audio InfoFrame Data Byte #1 Register
#define REG_ADDR__AUDRX_DBYTE1                                           (RX_DEPACK_1 | 0x0084)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE1__CEA_AUD_DBYTE1                                        0xFF

// CEA-861 Audio InfoFrame Data Byte #2 Register
#define REG_ADDR__AUDRX_DBYTE2                                           (RX_DEPACK_1 | 0x0085)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE2__CEA_AUD_DBYTE2                                        0xFF

// CEA-861 Audio InfoFrame Data Byte #3 Register
#define REG_ADDR__AUDRX_DBYTE3                                           (RX_DEPACK_1 | 0x0086)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE3__CEA_AUD_DBYTE3                                        0xFF

// CEA-861 Audio InfoFrame Data Byte #4 Register
#define REG_ADDR__AUDRX_DBYTE4                                           (RX_DEPACK_1 | 0x0087)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE4__CEA_AUD_DBYTE4                                        0xFF

// CEA-861 Audio InfoFrame Data Byte #5 Register
#define REG_ADDR__AUDRX_DBYTE5                                           (RX_DEPACK_1 | 0x0088)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE5__CEA_AUD_DBYTE5                                        0xFF

// CEA-861 Audio InfoFrame Data Byte #6 Register
#define REG_ADDR__AUDRX_DBYTE6                                           (RX_DEPACK_1 | 0x0089)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE6__CEA_AUD_DBYTE6                                        0xFF

// CEA-861 Audio InfoFrame Data Byte #7 Register
#define REG_ADDR__AUDRX_DBYTE7                                           (RX_DEPACK_1 | 0x008A)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE7__CEA_AUD_DBYTE7                                        0xFF

// CEA-861 Audio InfoFrame Data Byte #8 Register
#define REG_ADDR__AUDRX_DBYTE8                                           (RX_DEPACK_1 | 0x008B)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE8__CEA_AUD_DBYTE8                                        0xFF

// CEA-861 Audio InfoFrame Data Byte #9 Register
#define REG_ADDR__AUDRX_DBYTE9                                           (RX_DEPACK_1 | 0x008C)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE9__CEA_AUD_DBYTE9                                        0xFF

// CEA-861 Audio InfoFrame Data Byte #10 Register
#define REG_ADDR__AUDRX_DBYTE10                                          (RX_DEPACK_1 | 0x008D)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE10__CEA_AUD_DBYTE10                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #11 Register
#define REG_ADDR__AUDRX_DBYTE11                                          (RX_DEPACK_1 | 0x008E)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE11__CEA_AUD_DBYTE11                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #12 Register
#define REG_ADDR__AUDRX_DBYTE12                                          (RX_DEPACK_1 | 0x008F)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE12__CEA_AUD_DBYTE12                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #13 Register
#define REG_ADDR__AUDRX_DBYTE13                                          (RX_DEPACK_1 | 0x0090)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE13__CEA_AUD_DBYTE13                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #14 Register
#define REG_ADDR__AUDRX_DBYTE14                                          (RX_DEPACK_1 | 0x0091)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE14__CEA_AUD_DBYTE14                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #15 Register
#define REG_ADDR__AUDRX_DBYTE15                                          (RX_DEPACK_1 | 0x0092)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE15__CEA_AUD_DBYTE15                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #16 Register
#define REG_ADDR__AUDRX_DBYTE16                                          (RX_DEPACK_1 | 0x0093)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE16__CEA_AUD_DBYTE16                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #17 Register
#define REG_ADDR__AUDRX_DBYTE17                                          (RX_DEPACK_1 | 0x0094)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE17__CEA_AUD_DBYTE17                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #18 Register
#define REG_ADDR__AUDRX_DBYTE18                                          (RX_DEPACK_1 | 0x0095)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE18__CEA_AUD_DBYTE18                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #19 Register
#define REG_ADDR__AUDRX_DBYTE19                                          (RX_DEPACK_1 | 0x0096)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE19__CEA_AUD_DBYTE19                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #20 Register
#define REG_ADDR__AUDRX_DBYTE20                                          (RX_DEPACK_1 | 0x0097)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE20__CEA_AUD_DBYTE20                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #21 Register
#define REG_ADDR__AUDRX_DBYTE21                                          (RX_DEPACK_1 | 0x0098)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE21__CEA_AUD_DBYTE21                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #22 Register
#define REG_ADDR__AUDRX_DBYTE22                                          (RX_DEPACK_1 | 0x0099)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE22__CEA_AUD_DBYTE22                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #23 Register
#define REG_ADDR__AUDRX_DBYTE23                                          (RX_DEPACK_1 | 0x009A)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE23__CEA_AUD_DBYTE23                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #24 Register
#define REG_ADDR__AUDRX_DBYTE24                                          (RX_DEPACK_1 | 0x009B)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE24__CEA_AUD_DBYTE24                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #25 Register
#define REG_ADDR__AUDRX_DBYTE25                                          (RX_DEPACK_1 | 0x009C)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE25__CEA_AUD_DBYTE25                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #26 Register
#define REG_ADDR__AUDRX_DBYTE26                                          (RX_DEPACK_1 | 0x009D)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE26__CEA_AUD_DBYTE26                                       0xFF

// CEA-861 Audio InfoFrame Data Byte #27 Register
#define REG_ADDR__AUDRX_DBYTE27                                          (RX_DEPACK_1 | 0x009E)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__AUDRX_DBYTE27__CEA_AUD_DBYTE27                                       0xFF

// CEA-861 MPEG InfoFrame Type Code Register
#define REG_ADDR__MPEGRX_TYPE                                            (RX_DEPACK_1 | 0x00A0)
  // (ReadOnly, Bits 7:0) 
  // bits [7:0] of 2 byte MPEG Header. This byte defines the MPEG InfoFrame Type Code. Follows the latest CEA-861 spec.
  #define BIT_MSK__MPEGRX_TYPE__CEA_MPEG_HEADER_B7_B0                                 0xFF

// CEA-861 MPEG InfoFrame Version Number Register
#define REG_ADDR__MPEGRX_VERS                                            (RX_DEPACK_1 | 0x00A1)
  // (ReadOnly, Bits 7:0) 
  // bits [15:8] of 2 byte MPEG Header. This byte defines the MPEG InfoFrame Version Number. Follows the latest CEA-861 spec.
  #define BIT_MSK__MPEGRX_VERS__CEA_MPEG_HEADER_B15_B8                                0xFF

// CEA-861 MPEG InfoFrame Length Register
#define REG_ADDR__MPEGRX_LENGTH                                          (RX_DEPACK_1 | 0x00A2)
  // (ReadOnly, Bits 7:0) 
  // Length of MPEG InfoFrame
  #define BIT_MSK__MPEGRX_LENGTH__CEA_MPEG_LENGTH                                       0xFF

// CEA-861 MPEG InfoFrame HDMI Checksum Register
#define REG_ADDR__MPEGRX_CHSUM                                           (RX_DEPACK_1 | 0x00A3)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__MPEGRX_CHSUM__CEA_MPEG_CHECKSUM                                     0xFF

// CEA-861 MPEG Data Byte #1 Register
#define REG_ADDR__MPEGRX_DBYTE1                                          (RX_DEPACK_1 | 0x00A4)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE1__CEA_MPEG_DBYTE1                                       0xFF

// CEA-861 MPEG Data Byte #2 Register
#define REG_ADDR__MPEGRX_DBYTE2                                          (RX_DEPACK_1 | 0x00A5)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE2__CEA_MPEG_DBYTE2                                       0xFF

// CEA-861 MPEG Data Byte #3 Register
#define REG_ADDR__MPEGRX_DBYTE3                                          (RX_DEPACK_1 | 0x00A6)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE3__CEA_MPEG_DBYTE3                                       0xFF

// CEA-861 MPEG Data Byte #4 Register
#define REG_ADDR__MPEGRX_DBYTE4                                          (RX_DEPACK_1 | 0x00A7)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE4__CEA_MPEG_DBYTE4                                       0xFF

// CEA-861 MPEG Data Byte #5 Register
#define REG_ADDR__MPEGRX_DBYTE5                                          (RX_DEPACK_1 | 0x00A8)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE5__CEA_MPEG_DBYTE5                                       0xFF

// CEA-861 MPEG Data Byte #6 Register
#define REG_ADDR__MPEGRX_DBYTE6                                          (RX_DEPACK_1 | 0x00A9)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE6__CEA_MPEG_DBYTE6                                       0xFF

// CEA-861 MPEG Data Byte #7 Register
#define REG_ADDR__MPEGRX_DBYTE7                                          (RX_DEPACK_1 | 0x00AA)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE7__CEA_MPEG_DBYTE7                                       0xFF

// CEA-861 MPEG Data Byte #8 Register
#define REG_ADDR__MPEGRX_DBYTE8                                          (RX_DEPACK_1 | 0x00AB)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE8__CEA_MPEG_DBYTE8                                       0xFF

// CEA-861 MPEG Data Byte #9 Register
#define REG_ADDR__MPEGRX_DBYTE9                                          (RX_DEPACK_1 | 0x00AC)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE9__CEA_MPEG_DBYTE9                                       0xFF

// CEA-861 MPEG Data Byte #10 Register
#define REG_ADDR__MPEGRX_DBYTE10                                         (RX_DEPACK_1 | 0x00AD)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE10__CEA_MPEG_DBYTE10                                      0xFF

// CEA-861 MPEG Data Byte #11 Register
#define REG_ADDR__MPEGRX_DBYTE11                                         (RX_DEPACK_1 | 0x00AE)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE11__CEA_MPEG_DBYTE11                                      0xFF

// CEA-861 MPEG Data Byte #12 Register
#define REG_ADDR__MPEGRX_DBYTE12                                         (RX_DEPACK_1 | 0x00AF)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE12__CEA_MPEG_DBYTE12                                      0xFF

// CEA-861 MPEG Data Byte #13 Register
#define REG_ADDR__MPEGRX_DBYTE13                                         (RX_DEPACK_1 | 0x00B0)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE13__CEA_MPEG_DBYTE13                                      0xFF

// CEA-861 MPEG Data Byte #14 Register
#define REG_ADDR__MPEGRX_DBYTE14                                         (RX_DEPACK_1 | 0x00B1)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE14__CEA_MPEG_DBYTE14                                      0xFF

// CEA-861 MPEG Data Byte #15 Register
#define REG_ADDR__MPEGRX_DBYTE15                                         (RX_DEPACK_1 | 0x00B2)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE15__CEA_MPEG_DBYTE15                                      0xFF

// CEA-861 MPEG Data Byte #16 Register
#define REG_ADDR__MPEGRX_DBYTE16                                         (RX_DEPACK_1 | 0x00B3)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE16__CEA_MPEG_DBYTE16                                      0xFF

// CEA-861 MPEG Data Byte #17 Register
#define REG_ADDR__MPEGRX_DBYTE17                                         (RX_DEPACK_1 | 0x00B4)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE17__CEA_MPEG_DBYTE17                                      0xFF

// CEA-861 MPEG Data Byte #18 Register
#define REG_ADDR__MPEGRX_DBYTE18                                         (RX_DEPACK_1 | 0x00B5)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE18__CEA_MPEG_DBYTE18                                      0xFF

// CEA-861 MPEG Data Byte #19 Register
#define REG_ADDR__MPEGRX_DBYTE19                                         (RX_DEPACK_1 | 0x00B6)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE19__CEA_MPEG_DBYTE19                                      0xFF

// CEA-861 MPEG Data Byte #20 Register
#define REG_ADDR__MPEGRX_DBYTE20                                         (RX_DEPACK_1 | 0x00B7)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE20__CEA_MPEG_DBYTE20                                      0xFF

// CEA-861 MPEG Data Byte #21 Register
#define REG_ADDR__MPEGRX_DBYTE21                                         (RX_DEPACK_1 | 0x00B8)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE21__CEA_MPEG_DBYTE21                                      0xFF

// CEA-861 MPEG Data Byte #22 Register
#define REG_ADDR__MPEGRX_DBYTE22                                         (RX_DEPACK_1 | 0x00B9)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE22__CEA_MPEG_DBYTE22                                      0xFF

// CEA-861 MPEG Data Byte #23 Register
#define REG_ADDR__MPEGRX_DBYTE23                                         (RX_DEPACK_1 | 0x00BA)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE23__CEA_MPEG_DBYTE23                                      0xFF

// CEA-861 MPEG Data Byte #24 Register
#define REG_ADDR__MPEGRX_DBYTE24                                         (RX_DEPACK_1 | 0x00BB)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE24__CEA_MPEG_DBYTE24                                      0xFF

// CEA-861 MPEG Data Byte #25 Register
#define REG_ADDR__MPEGRX_DBYTE25                                         (RX_DEPACK_1 | 0x00BC)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE25__CEA_MPEG_DBYTE25                                      0xFF

// CEA-861 MPEG Data Byte #26 Register
#define REG_ADDR__MPEGRX_DBYTE26                                         (RX_DEPACK_1 | 0x00BD)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE26__CEA_MPEG_DBYTE26                                      0xFF

// CEA-861 MPEG Data Byte #27 Register
#define REG_ADDR__MPEGRX_DBYTE27                                         (RX_DEPACK_1 | 0x00BE)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__MPEGRX_DBYTE27__CEA_MPEG_DBYTE27                                      0xFF

// CEA-861 MPEG Packet decode address Register
#define REG_ADDR__MPEG_DEC                                               (RX_DEPACK_1 | 0x00BF)
  // (ReadWrite, Bits 7:0) 
  // MPEG packet decode address: default is 0x85. By changing this address the MPEG packet can be stored in the location of any other InfoFrame
  #define BIT_MSK__MPEG_DEC__REG_MPEG_DEC                                          0xFF

// Unrecognized Packet Byte #1 Register
#define REG_ADDR__RX_UNREC_BYTE1                                         (RX_DEPACK_1 | 0x00C0)
  // (ReadOnly, Bits 7:0) 
  // Byte #1 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE1__CEA_UNREC_BYTE1                                       0xFF

// Unrecognized Packet Byte #2 Register
#define REG_ADDR__RX_UNREC_BYTE2                                         (RX_DEPACK_1 | 0x00C1)
  // (ReadOnly, Bits 7:0) 
  // Byte #2 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE2__CEA_UNREC_BYTE2                                       0xFF

// Unrecognized Packet Byte #3 Register
#define REG_ADDR__RX_UNREC_BYTE3                                         (RX_DEPACK_1 | 0x00C2)
  // (ReadOnly, Bits 7:0) 
  //   Byte #3 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE3__CEA_UNREC_BYTE3                                       0xFF

// Unrecognized Packet Byte #4 Register
#define REG_ADDR__RX_UNREC_BYTE4                                         (RX_DEPACK_1 | 0x00C3)
  // (ReadOnly, Bits 7:0) 
  //  Byte #4 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE4__CEA_UNREC_BYTE4                                       0xFF

// Unrecognized Packet Byte #5 Register
#define REG_ADDR__RX_UNREC_BYTE5                                         (RX_DEPACK_1 | 0x00C4)
  // (ReadOnly, Bits 7:0) 
  //  Byte #5 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE5__CEA_UNREC_BYTE5                                       0xFF

// Unrecognized Packet Byte #6 Register
#define REG_ADDR__RX_UNREC_BYTE6                                         (RX_DEPACK_1 | 0x00C5)
  // (ReadOnly, Bits 7:0) 
  //  Byte #6 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE6__CEA_UNREC_BYTE6                                       0xFF

// Unrecognized Packet Byte #7 Register
#define REG_ADDR__RX_UNREC_BYTE7                                         (RX_DEPACK_1 | 0x00C6)
  // (ReadOnly, Bits 7:0) 
  //  Byte #7 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE7__CEA_UNREC_BYTE7                                       0xFF

// Unrecognized Packet Byte #8 Register
#define REG_ADDR__RX_UNREC_BYTE8                                         (RX_DEPACK_1 | 0x00C7)
  // (ReadOnly, Bits 7:0) 
  //  Byte #8 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE8__CEA_UNREC_BYTE8                                       0xFF

// Unrecognized Packet Byte #9 Register
#define REG_ADDR__RX_UNREC_BYTE9                                         (RX_DEPACK_1 | 0x00C8)
  // (ReadOnly, Bits 7:0) 
  //  Byte #9 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE9__CEA_UNREC_BYTE9                                       0xFF

// Unrecognized Packet Byte #10 Register
#define REG_ADDR__RX_UNREC_BYTE10                                        (RX_DEPACK_1 | 0x00C9)
  // (ReadOnly, Bits 7:0) 
  //  Byte #10 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE10__CEA_UNREC_BYTE10                                      0xFF

// Unrecognized Packet Byte #11 Register
#define REG_ADDR__RX_UNREC_BYTE11                                        (RX_DEPACK_1 | 0x00CA)
  // (ReadOnly, Bits 7:0) 
  //  Byte #11 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE11__CEA_UNREC_BYTE11                                      0xFF

// Unrecognized Packet Byte #12 Register
#define REG_ADDR__RX_UNREC_BYTE12                                        (RX_DEPACK_1 | 0x00CB)
  // (ReadOnly, Bits 7:0) 
  //  Byte #12 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE12__CEA_UNREC_BYTE12                                      0xFF

// Unrecognized Packet Byte #13 Register
#define REG_ADDR__RX_UNREC_BYTE13                                        (RX_DEPACK_1 | 0x00CC)
  // (ReadOnly, Bits 7:0) 
  //  Byte #13 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE13__CEA_UNREC_BYTE13                                      0xFF

// Unrecognized Packet Byte #14 Register
#define REG_ADDR__RX_UNREC_BYTE14                                        (RX_DEPACK_1 | 0x00CD)
  // (ReadOnly, Bits 7:0) 
  //  Byte #14 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE14__CEA_UNREC_BYTE14                                      0xFF

// Unrecognized Packet Byte #15 Register
#define REG_ADDR__RX_UNREC_BYTE15                                        (RX_DEPACK_1 | 0x00CE)
  // (ReadOnly, Bits 7:0) 
  //  Byte #15 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE15__CEA_UNREC_BYTE15                                      0xFF

// Unrecognized Packet Byte #16 Register
#define REG_ADDR__RX_UNREC_BYTE16                                        (RX_DEPACK_1 | 0x00CF)
  // (ReadOnly, Bits 7:0) 
  //  Byte #16 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE16__CEA_UNREC_BYTE16                                      0xFF

// Unrecognized Packet Byte #17 Register
#define REG_ADDR__RX_UNREC_BYTE17                                        (RX_DEPACK_1 | 0x00D0)
  // (ReadOnly, Bits 7:0) 
  //  Byte #17 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE17__CEA_UNREC_BYTE17                                      0xFF

// Unrecognized Packet Byte #18 Register
#define REG_ADDR__RX_UNREC_BYTE18                                        (RX_DEPACK_1 | 0x00D1)
  // (ReadOnly, Bits 7:0) 
  //  Byte #18 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE18__CEA_UNREC_BYTE18                                      0xFF

// Unrecognized Packet Byte #19 Register
#define REG_ADDR__RX_UNREC_BYTE19                                        (RX_DEPACK_1 | 0x00D2)
  // (ReadOnly, Bits 7:0) 
  //  Byte #19 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE19__CEA_UNREC_BYTE19                                      0xFF

// Unrecognized Packet Byte #20 Register
#define REG_ADDR__RX_UNREC_BYTE20                                        (RX_DEPACK_1 | 0x00D3)
  // (ReadOnly, Bits 7:0) 
  //  Byte #20 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE20__CEA_UNREC_BYTE20                                      0xFF

// Unrecognized Packet Byte #21 Register
#define REG_ADDR__RX_UNREC_BYTE21                                        (RX_DEPACK_1 | 0x00D4)
  // (ReadOnly, Bits 7:0) 
  //  Byte #21 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE21__CEA_UNREC_BYTE21                                      0xFF

// Unrecognized Packet Byte #22 Register
#define REG_ADDR__RX_UNREC_BYTE22                                        (RX_DEPACK_1 | 0x00D5)
  // (ReadOnly, Bits 7:0) 
  //  Byte #22 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE22__CEA_UNREC_BYTE22                                      0xFF

// Unrecognized Packet Byte #23 Register
#define REG_ADDR__RX_UNREC_BYTE23                                        (RX_DEPACK_1 | 0x00D6)
  // (ReadOnly, Bits 7:0) 
  //  Byte #23 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE23__CEA_UNREC_BYTE23                                      0xFF

// Unrecognized Packet  Byte #24 Register
#define REG_ADDR__RX_UNREC_BYTE24                                        (RX_DEPACK_1 | 0x00D7)
  // (ReadOnly, Bits 7:0) 
  //  Byte #24 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE24__CEA_UNREC_BYTE24                                      0xFF

// Unrecognized Packet  Byte #25 Register
#define REG_ADDR__RX_UNREC_BYTE25                                        (RX_DEPACK_1 | 0x00D8)
  // (ReadOnly, Bits 7:0) 
  //  Byte #25 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE25__CEA_UNREC_BYTE25                                      0xFF

// Unrecognized Packet  Byte #26 Register
#define REG_ADDR__RX_UNREC_BYTE26                                        (RX_DEPACK_1 | 0x00D9)
  // (ReadOnly, Bits 7:0) 
  //  Byte #26 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE26__CEA_UNREC_BYTE26                                      0xFF

// Unrecognized Packet  Byte #27 Register
#define REG_ADDR__RX_UNREC_BYTE27                                        (RX_DEPACK_1 | 0x00DA)
  // (ReadOnly, Bits 7:0) 
  //  Byte #27 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE27__CEA_UNREC_BYTE27                                      0xFF

// Unrecognized Packet  Byte #28 Register
#define REG_ADDR__RX_UNREC_BYTE28                                        (RX_DEPACK_1 | 0x00DB)
  // (ReadOnly, Bits 7:0) 
  //  Byte #28 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE28__CEA_UNREC_BYTE28                                      0xFF

// Unrecognized Packet  Byte #29 Register
#define REG_ADDR__RX_UNREC_BYTE29                                        (RX_DEPACK_1 | 0x00DC)
  // (ReadOnly, Bits 7:0) 
  //  Byte #29 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE29__CEA_UNREC_BYTE29                                      0xFF

// Unrecognized Packet  Byte #30 Register
#define REG_ADDR__RX_UNREC_BYTE30                                        (RX_DEPACK_1 | 0x00DD)
  // (ReadOnly, Bits 7:0) 
  //  Byte #30 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE30__CEA_UNREC_BYTE30                                      0xFF

// Unrecognized Packet  Byte #31 Register
#define REG_ADDR__RX_UNREC_BYTE31                                        (RX_DEPACK_1 | 0x00DE)
  // (ReadOnly, Bits 7:0) 
  //  Byte #31 of Unrecognized Packet 
  #define BIT_MSK__RX_UNREC_BYTE31__CEA_UNREC_BYTE31                                      0xFF

// CP Packet  Byte #1 Register
#define REG_ADDR__CPRX_BYTE1                                             (RX_DEPACK_1 | 0x00DF)
  // (ReadOnly, Bits 0) 
  // Set the AVMUTE flag
  #define BIT_MSK__CPRX_BYTE1__REG_CP_SET_MUTE                                       0x01
  // (ReadOnly, Bits 4) 
  // Clear the AVMUTE flag
  #define BIT_MSK__CPRX_BYTE1__REG_CP_CLR_MUTE                                       0x10

// ACP Packet Byte #1 Register
#define REG_ADDR__RX_ACP_BYTE1                                           (RX_DEPACK_1 | 0x00E0)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE1__CEA_ACP_BYTE1                                         0xFF

// ACP Packet Byte #2 Register
#define REG_ADDR__RX_ACP_BYTE2                                           (RX_DEPACK_1 | 0x00E1)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE2__CEA_ACP_BYTE2                                         0xFF

// ACP Packet Byte #3 Register
#define REG_ADDR__RX_ACP_BYTE3                                           (RX_DEPACK_1 | 0x00E2)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE3__CEA_ACP_BYTE3                                         0xFF

// ACP Packet Byte #4 Register
#define REG_ADDR__RX_ACP_BYTE4                                           (RX_DEPACK_1 | 0x00E3)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE4__CEA_ACP_BYTE4                                         0xFF

// ACP Packet Byte #5 Register
#define REG_ADDR__RX_ACP_BYTE5                                           (RX_DEPACK_1 | 0x00E4)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE5__CEA_ACP_BYTE5                                         0xFF

// ACP Packet Byte #6 Register
#define REG_ADDR__RX_ACP_BYTE6                                           (RX_DEPACK_1 | 0x00E5)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE6__CEA_ACP_BYTE6                                         0xFF

// ACP Packet Byte #7 Register
#define REG_ADDR__RX_ACP_BYTE7                                           (RX_DEPACK_1 | 0x00E6)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE7__CEA_ACP_BYTE7                                         0xFF

// ACP Packet Byte #8 Register
#define REG_ADDR__RX_ACP_BYTE8                                           (RX_DEPACK_1 | 0x00E7)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE8__CEA_ACP_BYTE8                                         0xFF

// ACP Packet Byte #9 Register
#define REG_ADDR__RX_ACP_BYTE9                                           (RX_DEPACK_1 | 0x00E8)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE9__CEA_ACP_BYTE9                                         0xFF

// ACP Packet Byte #10 Register
#define REG_ADDR__RX_ACP_BYTE10                                          (RX_DEPACK_1 | 0x00E9)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE10__CEA_ACP_BYTE10                                        0xFF

// ACP Packet Byte #11 Register
#define REG_ADDR__RX_ACP_BYTE11                                          (RX_DEPACK_1 | 0x00EA)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE11__CEA_ACP_BYTE11                                        0xFF

// ACP Packet Byte #12 Register
#define REG_ADDR__RX_ACP_BYTE12                                          (RX_DEPACK_1 | 0x00EB)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE12__CEA_ACP_BYTE12                                        0xFF

// ACP Packet Byte #13 Register
#define REG_ADDR__RX_ACP_BYTE13                                          (RX_DEPACK_1 | 0x00EC)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE13__CEA_ACP_BYTE13                                        0xFF

// ACP Packet Byte #14 Register
#define REG_ADDR__RX_ACP_BYTE14                                          (RX_DEPACK_1 | 0x00ED)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE14__CEA_ACP_BYTE14                                        0xFF

// ACP Packet Byte #15 Register
#define REG_ADDR__RX_ACP_BYTE15                                          (RX_DEPACK_1 | 0x00EE)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE15__CEA_ACP_BYTE15                                        0xFF

// ACP Packet Byte #16 Register
#define REG_ADDR__RX_ACP_BYTE16                                          (RX_DEPACK_1 | 0x00EF)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE16__CEA_ACP_BYTE16                                        0xFF

// ACP Packet Byte #17 Register
#define REG_ADDR__RX_ACP_BYTE17                                          (RX_DEPACK_1 | 0x00F0)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE17__CEA_ACP_BYTE17                                        0xFF

// ACP Packet Byte #18 Register
#define REG_ADDR__RX_ACP_BYTE18                                          (RX_DEPACK_1 | 0x00F1)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE18__CEA_ACP_BYTE18                                        0xFF

// ACP Packet Byte #19 Register
#define REG_ADDR__RX_ACP_BYTE19                                          (RX_DEPACK_1 | 0x00F2)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE19__CEA_ACP_BYTE19                                        0xFF

// ACP Packet Byte #20 Register
#define REG_ADDR__RX_ACP_BYTE20                                          (RX_DEPACK_1 | 0x00F3)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE20__CEA_ACP_BYTE20                                        0xFF

// ACP Packet Byte #21 Register
#define REG_ADDR__RX_ACP_BYTE21                                          (RX_DEPACK_1 | 0x00F4)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE21__CEA_ACP_BYTE21                                        0xFF

// ACP Packet Byte #22 Register
#define REG_ADDR__RX_ACP_BYTE22                                          (RX_DEPACK_1 | 0x00F5)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE22__CEA_ACP_BYTE22                                        0xFF

// ACP Packet Byte #23 Register
#define REG_ADDR__RX_ACP_BYTE23                                          (RX_DEPACK_1 | 0x00F6)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE23__CEA_ACP_BYTE23                                        0xFF

// ACP Packet Byte #24 Register
#define REG_ADDR__RX_ACP_BYTE24                                          (RX_DEPACK_1 | 0x00F7)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE24__CEA_ACP_BYTE24                                        0xFF

// ACP Packet Byte #25 Register
#define REG_ADDR__RX_ACP_BYTE25                                          (RX_DEPACK_1 | 0x00F8)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE25__CEA_ACP_BYTE25                                        0xFF

// ACP Packet Byte #26 Register
#define REG_ADDR__RX_ACP_BYTE26                                          (RX_DEPACK_1 | 0x00F9)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE26__CEA_ACP_BYTE26                                        0xFF

// ACP Packet Byte #27 Register
#define REG_ADDR__RX_ACP_BYTE27                                          (RX_DEPACK_1 | 0x00FA)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE27__CEA_ACP_BYTE27                                        0xFF

// ACP Packet Byte #28 Register
#define REG_ADDR__RX_ACP_BYTE28                                          (RX_DEPACK_1 | 0x00FB)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE28__CEA_ACP_BYTE28                                        0xFF

// ACP Packet Byte #29 Register
#define REG_ADDR__RX_ACP_BYTE29                                          (RX_DEPACK_1 | 0x00FC)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE29__CEA_ACP_BYTE29                                        0xFF

// ACP Packet Byte #30 Register
#define REG_ADDR__RX_ACP_BYTE30                                          (RX_DEPACK_1 | 0x00FD)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE30__CEA_ACP_BYTE30                                        0xFF

// ACP Packet Byte #31 Register
#define REG_ADDR__RX_ACP_BYTE31                                          (RX_DEPACK_1 | 0x00FE)
  // (ReadOnly, Bits 7:0) 
  // Byte of ACP Packet 
  #define BIT_MSK__RX_ACP_BYTE31__CEA_ACP_BYTE31                                        0xFF

// ACP Packet Decode Address Register
#define REG_ADDR__RX_ACP_DEC                                             (RX_DEPACK_1 | 0x00FF)
  // (ReadWrite, Bits 7:0) 
  // ACP Packet decode address: default is 0xFO. +A2107 E2162
  #define BIT_MSK__RX_ACP_DEC__REG_ACP_DEC                                           0xFF

//***************************************************************************
// RX_DEPACK_2. Address: 60
// VSI ctrl #1 Register
#define REG_ADDR__VSI_CTRL1                                              (RX_DEPACK_2 | 0x0000)
  // (ReadWrite, Bits 0) 
  // enable swap of VSI ID 
  #define BIT_MSK__VSI_CTRL1__REG_SWAP_VSI_IEEE_ID                                  0x01
  // (ReadWrite, Bits 1) 
  // Enable to clear AIF if did not get update
  #define BIT_MSK__VSI_CTRL1__REG_AIF_CLR_EN                                        0x02
  // (ReadWrite, Bits 4:2) 
  // # of packet to wait before enable clear. Min number must be 3. 
  #define BIT_MSK__VSI_CTRL1__REG_NO_PKT_CNT                                        0x1C
  // (ReadWrite, Bits 6:5) 
  // Enable comparision of AIF 1st 4 byte against VSI ID: bit 5 enables comparison of first 3 bytes bit 6 enables comparison of fourth byte
  #define BIT_MSK__VSI_CTRL1__REG_AIF4VSI_CMP                                       0x60
  // (ReadWrite, Bits 7) 
  // Enable clear of the VSI if did not get it for # of vsync defianed in  reg_no_pkt_cnt
  #define BIT_MSK__VSI_CTRL1__REG_VSI_CLR_EN                                        0x80

// VSI ID #1 Register
#define REG_ADDR__VSI_ID1                                                (RX_DEPACK_2 | 0x0001)
  // (ReadWrite, Bits 7:0) 
  // Alternative VSI ID byte #1
  #define BIT_MSK__VSI_ID1__REG_ALT_VSI_PB1                                       0xFF

// VSI ID #2 Register
#define REG_ADDR__VSI_ID2                                                (RX_DEPACK_2 | 0x0002)
  // (ReadWrite, Bits 7:0) 
  // Alternative VSI ID byte #2
  #define BIT_MSK__VSI_ID2__REG_ALT_VSI_PB2                                       0xFF

// VSI ID #3 Register
#define REG_ADDR__VSI_ID3                                                (RX_DEPACK_2 | 0x0003)
  // (ReadWrite, Bits 7:0) 
  // Alternative VSI ID byte #3
  #define BIT_MSK__VSI_ID3__REG_ALT_VSI_PB3                                       0xFF

// VSI ID #4 Register
#define REG_ADDR__VSI_ID4                                                (RX_DEPACK_2 | 0x0004)
  // (ReadWrite, Bits 7:0) 
  // Alternative VSI ID byte #4
  #define BIT_MSK__VSI_ID4__REG_ALT_VSI_PB4                                       0xFF

// VSI packet ID Register
#define REG_ADDR__VSI_PKT_ID                                             (RX_DEPACK_2 | 0x0005)
  // (ReadWrite, Bits 7:0) 
  // VSI packet header
  #define BIT_MSK__VSI_PKT_ID__REG_VSI_HEADER                                        0xFF

// AIF packet ID Register
#define REG_ADDR__AIF_PKT_ID                                             (RX_DEPACK_2 | 0x0006)
  // (ReadWrite, Bits 7:0) 
  // AIF packet header
  #define BIT_MSK__AIF_PKT_ID__REG_AIF_HEADER                                        0xFF

// VSI ctrl #2 Register
#define REG_ADDR__VSI_CTRL2                                              (RX_DEPACK_2 | 0x0007)
  // (ReadWrite, Bits 0) 
  // enable check of the VSIF ID before storing of the VSIF data in registers; if fail will not store
  #define BIT_MSK__VSI_CTRL2__REG_VSI_IEEE_ID_CHK_EN                                0x01

// IF ctrl #1 Register
#define REG_ADDR__IF_CTRL1                                               (RX_DEPACK_2 | 0x0008)
  // (ReadWrite, Bits 0) 
  // Enable to clear AVI if did not get update
  #define BIT_MSK__IF_CTRL1__REG_AVI_CLR_EN                                        0x01
  // (ReadWrite, Bits 1) 
  // Enable to clear SPD if did not get update
  #define BIT_MSK__IF_CTRL1__REG_SPD_CLR_EN                                        0x02
  // (ReadWrite, Bits 2) 
  // Enable to clear MPEG if did not get update
  #define BIT_MSK__IF_CTRL1__REG_MPEG_CLR_EN                                       0x04
  // (ReadWrite, Bits 3) 
  // Enable to clear UNREC if did not get update
  #define BIT_MSK__IF_CTRL1__REG_UNREC_CLR_EN                                      0x08
  // (ReadWrite, Bits 4) 
  // Enable to clear ACP if did not get update
  #define BIT_MSK__IF_CTRL1__REG_ACP_CLR_EN                                        0x10
  // (ReadWrite, Bits 5) 
  // enable check of checksum before storage of Avi packet for AVC
  #define BIT_MSK__IF_CTRL1__REG_EN_CHECKSUM_CHECK                                 0x20
  // (ReadWrite, Bits 6) 
  // Enable to clear ISRC1 if did not get update
  #define BIT_MSK__IF_CTRL1__REG_ISRC1_CLR_EN                                      0x40
  // (ReadWrite, Bits 7) 
  // Enable to clear ISRC2 if did not get update
  #define BIT_MSK__IF_CTRL1__REG_ISRC2_CLR_EN                                      0x80

// IF ctrl #2 Register
#define REG_ADDR__IF_CTRL2                                               (RX_DEPACK_2 | 0x0009)
  // (ReadWrite, Bits 0) 
  // Enable to clear GCP if did not get update
  #define BIT_MSK__IF_CTRL2__REG_GCP_CLR_EN                                        0x01
  // (ReadWrite, Bits 1) 
  // Enable to clear meta data packet if did not get update
  #define BIT_MSK__IF_CTRL2__REG_META_DATA_PKT_CLR_EN                              0x02

// VSI ID #1 Register
#define REG_ADDR__VSIF_ID1                                               (RX_DEPACK_2 | 0x000A)
  // (ReadWrite, Bits 7:0) 
  // VSI ID byte #1
  #define BIT_MSK__VSIF_ID1__REG_VSI_PB1                                           0xFF

// VSI ID #2 Register
#define REG_ADDR__VSIF_ID2                                               (RX_DEPACK_2 | 0x000B)
  // (ReadWrite, Bits 7:0) 
  // VSI ID byte #2
  #define BIT_MSK__VSIF_ID2__REG_VSI_PB2                                           0xFF

// VSI ID #3 Register
#define REG_ADDR__VSIF_ID3                                               (RX_DEPACK_2 | 0x000C)
  // (ReadWrite, Bits 7:0) 
  // VSI ID byte #3
  #define BIT_MSK__VSIF_ID3__REG_VSI_PB3                                           0xFF

// VSI ID #4 Register
#define REG_ADDR__VSIF_ID4                                               (RX_DEPACK_2 | 0x000D)
  // (ReadWrite, Bits 7:0) 
  // VSI ID byte #4
  #define BIT_MSK__VSIF_ID4__REG_VSI_PB4                                           0xFF

// VSI ctrl #2 Register
#define REG_ADDR__VSI_CTRL3                                              (RX_DEPACK_2 | 0x000E)
  // (ReadWrite, Bits 0) 
  // enable to catch of VSIF in AIF buffer even if VSIF buffer is not enabled
  #define BIT_MSK__VSI_CTRL3__REG_AIF4VSI_IND_EN                                    0x01

// CEA-861 VSI InfoFrame Type Code Register
#define REG_ADDR__VSIRX_TYPE                                             (RX_DEPACK_2 | 0x0020)
  // (ReadOnly, Bits 7:0) 
  // bits [7:0] of 2 byte VSI Header. This byte defines the VSI InfoFrame Type Code. Follows the latest CEA-861 spec.
  #define BIT_MSK__VSIRX_TYPE__CEA_VSI_HEADER_B7_B0                                  0xFF

// CEA-861 VSI InfoFrame Version Number Register
#define REG_ADDR__VSIRX_VERS                                             (RX_DEPACK_2 | 0x0021)
  // (ReadOnly, Bits 7:0) 
  // bits [15:8] of 2 byte VSI Header. This byte defines the VSI InfoFrame Version Number. Follows the latest CEA-861 spec.
  #define BIT_MSK__VSIRX_VERS__CEA_VSI_HEADER_B15_B8                                 0xFF

// CEA-861 VSI InfoFrame Length Register
#define REG_ADDR__VSIRX_LENGTH                                           (RX_DEPACK_2 | 0x0022)
  // (ReadOnly, Bits 7:0) 
  // Length of VSI InfoFrame
  #define BIT_MSK__VSIRX_LENGTH__CEA_VSI_LENGTH                                        0xFF

// CEA-861 VSI InfoFrame HDMI Checksum Register
#define REG_ADDR__VSIRX_DBYTE0                                           (RX_DEPACK_2 | 0x0023)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE0__CEA_VSI_PB_0                                          0xFF

// CEA-861 VSI InfoFrame Data Byte #1 Register
#define REG_ADDR__VSIRX_DBYTE1                                           (RX_DEPACK_2 | 0x0024)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE1__CEA_VSI_PB_1                                          0xFF

// CEA-861 VSI InfoFrame Data Byte #2 Register
#define REG_ADDR__VSIRX_DBYTE2                                           (RX_DEPACK_2 | 0x0025)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE2__CEA_VSI_PB_2                                          0xFF

// CEA-861 VSI InfoFrame Data Byte #3 Register
#define REG_ADDR__VSIRX_DBYTE3                                           (RX_DEPACK_2 | 0x0026)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE3__CEA_VSI_PB_3                                          0xFF

// CEA-861 VSI InfoFrame Data Byte #4 Register
#define REG_ADDR__VSIRX_DBYTE4                                           (RX_DEPACK_2 | 0x0027)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE4__CEA_VSI_PB_4                                          0xFF

// CEA-861 VSI InfoFrame Data Byte #5 Register
#define REG_ADDR__VSIRX_DBYTE5                                           (RX_DEPACK_2 | 0x0028)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE5__CEA_VSI_PB_5                                          0xFF

// CEA-861 VSI InfoFrame Data Byte #6 Register
#define REG_ADDR__VSIRX_DBYTE6                                           (RX_DEPACK_2 | 0x0029)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE6__CEA_VSI_PB_6                                          0xFF

// CEA-861 VSI InfoFrame Data Byte #7 Register
#define REG_ADDR__VSIRX_DBYTE7                                           (RX_DEPACK_2 | 0x002A)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE7__CEA_VSI_PB_7                                          0xFF

// CEA-861 VSI InfoFrame Data Byte #8 Register
#define REG_ADDR__VSIRX_DBYTE8                                           (RX_DEPACK_2 | 0x002B)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE8__CEA_VSI_PB_8                                          0xFF

// CEA-861 VSI InfoFrame Data Byte #9 Register
#define REG_ADDR__VSIRX_DBYTE9                                           (RX_DEPACK_2 | 0x002C)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE9__CEA_VSI_PB_9                                          0xFF

// CEA-861 VSI InfoFrame Data Byte #10 Register
#define REG_ADDR__VSIRX_DBYTE10                                          (RX_DEPACK_2 | 0x002D)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE10__CEA_VSI_PB_10                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #11 Register
#define REG_ADDR__VSIRX_DBYTE11                                          (RX_DEPACK_2 | 0x002E)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE11__CEA_VSI_PB_11                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #12 Register
#define REG_ADDR__VSIRX_DBYTE12                                          (RX_DEPACK_2 | 0x002F)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE12__CEA_VSI_PB_12                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #13 Register
#define REG_ADDR__VSIRX_DBYTE13                                          (RX_DEPACK_2 | 0x0030)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE13__CEA_VSI_PB_13                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #14 Register
#define REG_ADDR__VSIRX_DBYTE14                                          (RX_DEPACK_2 | 0x0031)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE14__CEA_VSI_PB_14                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #15 Register
#define REG_ADDR__VSIRX_DBYTE15                                          (RX_DEPACK_2 | 0x0032)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE15__CEA_VSI_PB_15                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #16 Register
#define REG_ADDR__VSIRX_DBYTE16                                          (RX_DEPACK_2 | 0x0033)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE16__CEA_VSI_PB_16                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #17 Register
#define REG_ADDR__VSIRX_DBYTE17                                          (RX_DEPACK_2 | 0x0034)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE17__CEA_VSI_PB_17                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #18 Register
#define REG_ADDR__VSIRX_DBYTE18                                          (RX_DEPACK_2 | 0x0035)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE18__CEA_VSI_PB_18                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #19 Register
#define REG_ADDR__VSIRX_DBYTE19                                          (RX_DEPACK_2 | 0x0036)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE19__CEA_VSI_PB_19                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #20 Register
#define REG_ADDR__VSIRX_DBYTE20                                          (RX_DEPACK_2 | 0x0037)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE20__CEA_VSI_PB_20                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #21 Register
#define REG_ADDR__VSIRX_DBYTE21                                          (RX_DEPACK_2 | 0x0038)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE21__CEA_VSI_PB_21                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #22 Register
#define REG_ADDR__VSIRX_DBYTE22                                          (RX_DEPACK_2 | 0x0039)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE22__CEA_VSI_PB_22                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #23 Register
#define REG_ADDR__VSIRX_DBYTE23                                          (RX_DEPACK_2 | 0x003A)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE23__CEA_VSI_PB_23                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #24 Register
#define REG_ADDR__VSIRX_DBYTE24                                          (RX_DEPACK_2 | 0x003B)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE24__CEA_VSI_PB_24                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #25 Register
#define REG_ADDR__VSIRX_DBYTE25                                          (RX_DEPACK_2 | 0x003C)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE25__CEA_VSI_PB_25                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #26 Register
#define REG_ADDR__VSIRX_DBYTE26                                          (RX_DEPACK_2 | 0x003D)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE26__CEA_VSI_PB_26                                         0xFF

// CEA-861 VSI InfoFrame Data Byte #27 Register
#define REG_ADDR__VSIRX_DBYTE27                                          (RX_DEPACK_2 | 0x003E)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__VSIRX_DBYTE27__CEA_VSI_PB_27                                         0xFF

// ISRC1 Packet Type Code Register
#define REG_ADDR__RX_ISRC1_TYPE                                          (RX_DEPACK_2 | 0x0040)
  // (ReadOnly, Bits 7:0) 
  // bits [7:0] of 2 byte ISRC1 Header. This byte defines the ISRC1 Type Code. Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_TYPE__CEA_ISRC1_HEADER_B7_B0                                0xFF

// ISRC1 Packet Version Number Register
#define REG_ADDR__RX_ISRC1_VERS                                          (RX_DEPACK_2 | 0x0041)
  // (ReadOnly, Bits 7:0) 
  // bits [15:8] of 2 byte ISRC1 Header. This byte defines the ISRC1 Type Code. Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_VERS__CEA_ISRC1_HEADER_B15_B8                               0xFF

// ISRC1 Packet Length Register
#define REG_ADDR__RX_ISRC1_LENGTH                                        (RX_DEPACK_2 | 0x0042)
  // (ReadOnly, Bits 7:0) 
  // Length of ISRC1 Packet
  #define BIT_MSK__RX_ISRC1_LENGTH__CEA_ISRC1_LENGTH                                      0xFF

// ISRC1 Packet Data Byte#0 Register
#define REG_ADDR__RX_ISRC1_DBYTE0                                        (RX_DEPACK_2 | 0x0043)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_DBYTE0__CEA_ISRC1_PB_0                                        0xFF

// ISRC1 Packet Data Byte #1 Register
#define REG_ADDR__RX_ISRC1_DBYTE1                                        (RX_DEPACK_2 | 0x0044)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_DBYTE1__CEA_ISRC1_PB_1                                        0xFF

// ISRC1 Packet Data Byte #2 Register
#define REG_ADDR__RX_ISRC1_DBYTE2                                        (RX_DEPACK_2 | 0x0045)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_DBYTE2__CEA_ISRC1_PB_2                                        0xFF

// ISRC1 Packet Data Byte #3 Register
#define REG_ADDR__RX_ISRC1_DBYTE3                                        (RX_DEPACK_2 | 0x0046)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_DBYTE3__CEA_ISRC1_PB_3                                        0xFF

// ISRC1 Packet Data Byte #4 Register
#define REG_ADDR__RX_ISRC1_DBYTE4                                        (RX_DEPACK_2 | 0x0047)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_DBYTE4__CEA_ISRC1_PB_4                                        0xFF

// ISRC1 Packet Data Byte #5 Register
#define REG_ADDR__RX_ISRC1_DBYTE5                                        (RX_DEPACK_2 | 0x0048)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_DBYTE5__CEA_ISRC1_PB_5                                        0xFF

// ISRC1 Packet Data Byte #6 Register
#define REG_ADDR__RX_ISRC1_DBYTE6                                        (RX_DEPACK_2 | 0x0049)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_DBYTE6__CEA_ISRC1_PB_6                                        0xFF

// ISRC1 Packet Data Byte #7 Register
#define REG_ADDR__RX_ISRC1_DBYTE7                                        (RX_DEPACK_2 | 0x004A)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_DBYTE7__CEA_ISRC1_PB_7                                        0xFF

// ISRC1 Packet Data Byte #8 Register
#define REG_ADDR__RX_ISRC1_DBYTE8                                        (RX_DEPACK_2 | 0x004B)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_DBYTE8__CEA_ISRC1_PB_8                                        0xFF

// ISRC1 Packet Data Byte #9 Register
#define REG_ADDR__RX_ISRC1_DBYTE9                                        (RX_DEPACK_2 | 0x004C)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_DBYTE9__CEA_ISRC1_PB_9                                        0xFF

// ISRC1 Packet Data Byte #10 Register
#define REG_ADDR__RX_ISRC1_DBYTE10                                       (RX_DEPACK_2 | 0x004D)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_DBYTE10__CEA_ISRC1_PB_10                                       0xFF

// ISRC1 Packet Data Byte #11 Register
#define REG_ADDR__RX_ISRC1_DBYTE11                                       (RX_DEPACK_2 | 0x004E)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_DBYTE11__CEA_ISRC1_PB_11                                       0xFF

// ISRC1 Packet Data Byte #12 Register
#define REG_ADDR__RX_ISRC1_DBYTE12                                       (RX_DEPACK_2 | 0x004F)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_DBYTE12__CEA_ISRC1_PB_12                                       0xFF

// ISRC1 Packet Data Byte #13 Register
#define REG_ADDR__RX_ISRC1_DBYTE13                                       (RX_DEPACK_2 | 0x0050)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_DBYTE13__CEA_ISRC1_PB_13                                       0xFF

// ISRC1 Packet Data Byte #14 Register
#define REG_ADDR__RX_ISRC1_DBYTE14                                       (RX_DEPACK_2 | 0x0051)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_DBYTE14__CEA_ISRC1_PB_14                                       0xFF

// ISRC1 Packet Data Byte #15 Register
#define REG_ADDR__RX_ISRC1_DBYTE15                                       (RX_DEPACK_2 | 0x0052)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC1_DBYTE15__CEA_ISRC1_PB_15                                       0xFF

// ISRC1 Packet decode address Register
#define REG_ADDR__RX_ISRC1_DEC                                           (RX_DEPACK_2 | 0x005F)
  // (ReadWrite, Bits 7:0) 
  // ISRC1 packet decode address: default is 0x05. By changing this address the ISRC1 packet can be stored in the location of any other InfoFrame
  #define BIT_MSK__RX_ISRC1_DEC__REG_ISRC1_DEC                                         0xFF

// ISRC2 Packet Type Code Register
#define REG_ADDR__RX_ISRC2_TYPE                                          (RX_DEPACK_2 | 0x0060)
  // (ReadOnly, Bits 7:0) 
  // bits [7:0] of 2 byte ISRC2 Header. This byte defines the ISRC2 Type Code. Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_TYPE__CEA_ISRC2_HEADER_B7_B0                                0xFF

// ISRC2 Packet Version Number Register
#define REG_ADDR__RX_ISRC2_VERS                                          (RX_DEPACK_2 | 0x0061)
  // (ReadOnly, Bits 7:0) 
  // bits [15:8] of 2 byte ISRC2 Header. This byte defines the ISRC2 Type Code. Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_VERS__CEA_ISRC2_HEADER_B15_B8                               0xFF

// ISRC2 Packet Length Register
#define REG_ADDR__RX_ISRC2_LENGTH                                        (RX_DEPACK_2 | 0x0062)
  // (ReadOnly, Bits 7:0) 
  // Length of ISRC2 Packet
  #define BIT_MSK__RX_ISRC2_LENGTH__CEA_ISRC2_LENGTH                                      0xFF

// ISRC2 Packet Data Byte#0 Register
#define REG_ADDR__RX_ISRC2_DBYTE0                                        (RX_DEPACK_2 | 0x0063)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_DBYTE0__CEA_ISRC2_PB_0                                        0xFF

// ISRC2 Packet Data Byte #1 Register
#define REG_ADDR__RX_ISRC2_DBYTE1                                        (RX_DEPACK_2 | 0x0064)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_DBYTE1__CEA_ISRC2_PB_1                                        0xFF

// ISRC2 Packet Data Byte #2 Register
#define REG_ADDR__RX_ISRC2_DBYTE2                                        (RX_DEPACK_2 | 0x0065)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_DBYTE2__CEA_ISRC2_PB_2                                        0xFF

// ISRC2 Packet Data Byte #3 Register
#define REG_ADDR__RX_ISRC2_DBYTE3                                        (RX_DEPACK_2 | 0x0066)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_DBYTE3__CEA_ISRC2_PB_3                                        0xFF

// ISRC2 Packet Data Byte #4 Register
#define REG_ADDR__RX_ISRC2_DBYTE4                                        (RX_DEPACK_2 | 0x0067)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_DBYTE4__CEA_ISRC2_PB_4                                        0xFF

// ISRC2 Packet Data Byte #5 Register
#define REG_ADDR__RX_ISRC2_DBYTE5                                        (RX_DEPACK_2 | 0x0068)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_DBYTE5__CEA_ISRC2_PB_5                                        0xFF

// ISRC2 Packet Data Byte #6 Register
#define REG_ADDR__RX_ISRC2_DBYTE6                                        (RX_DEPACK_2 | 0x0069)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_DBYTE6__CEA_ISRC2_PB_6                                        0xFF

// ISRC2 Packet Data Byte #7 Register
#define REG_ADDR__RX_ISRC2_DBYTE7                                        (RX_DEPACK_2 | 0x006A)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_DBYTE7__CEA_ISRC2_PB_7                                        0xFF

// ISRC2 Packet Data Byte #8 Register
#define REG_ADDR__RX_ISRC2_DBYTE8                                        (RX_DEPACK_2 | 0x006B)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_DBYTE8__CEA_ISRC2_PB_8                                        0xFF

// ISRC2 Packet Data Byte #9 Register
#define REG_ADDR__RX_ISRC2_DBYTE9                                        (RX_DEPACK_2 | 0x006C)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_DBYTE9__CEA_ISRC2_PB_9                                        0xFF

// ISRC2 Packet Data Byte #10 Register
#define REG_ADDR__RX_ISRC2_DBYTE10                                       (RX_DEPACK_2 | 0x006D)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_DBYTE10__CEA_ISRC2_PB_10                                       0xFF

// ISRC2 Packet Data Byte #11 Register
#define REG_ADDR__RX_ISRC2_DBYTE11                                       (RX_DEPACK_2 | 0x006E)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_DBYTE11__CEA_ISRC2_PB_11                                       0xFF

// ISRC2 Packet Data Byte #12 Register
#define REG_ADDR__RX_ISRC2_DBYTE12                                       (RX_DEPACK_2 | 0x006F)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_DBYTE12__CEA_ISRC2_PB_12                                       0xFF

// ISRC2 Packet Data Byte #13 Register
#define REG_ADDR__RX_ISRC2_DBYTE13                                       (RX_DEPACK_2 | 0x0070)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_DBYTE13__CEA_ISRC2_PB_13                                       0xFF

// ISRC2 Packet Data Byte #14 Register
#define REG_ADDR__RX_ISRC2_DBYTE14                                       (RX_DEPACK_2 | 0x0071)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_DBYTE14__CEA_ISRC2_PB_14                                       0xFF

// ISRC2 Packet Data Byte #15 Register
#define REG_ADDR__RX_ISRC2_DBYTE15                                       (RX_DEPACK_2 | 0x0072)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ISRC2_DBYTE15__CEA_ISRC2_PB_15                                       0xFF

// ISRC2 Packet decode address Register
#define REG_ADDR__RX_ISRC2_DEC                                           (RX_DEPACK_2 | 0x007F)
  // (ReadWrite, Bits 7:0) 
  // ISRC2 packet decode address: default is 0x06. By changing this address the ISRC2 packet can be stored in the location of any other InfoFrame
  #define BIT_MSK__RX_ISRC2_DEC__REG_ISRC2_DEC                                         0xFF

// GCP Packet Type Code Register
#define REG_ADDR__RX_GCP_TYPE                                            (RX_DEPACK_2 | 0x0080)
  // (ReadOnly, Bits 7:0) 
  // bits [7:0] of 2 byte GCP Header. This byte defines the GCP Type Code. Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_GCP_TYPE__CEA_GCP_HEADER_B7_B0                                  0xFF

// GCP Packet Version Number Register
#define REG_ADDR__RX_GCP_VERS                                            (RX_DEPACK_2 | 0x0081)
  // (ReadOnly, Bits 7:0) 
  // bits [15:8] of 2 byte GCP Header. This byte defines the GCP Type Code. Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_GCP_VERS__CEA_GCP_HEADER_B15_B8                                 0xFF

// GCP Packet Length Register
#define REG_ADDR__RX_GCP_LENGTH                                          (RX_DEPACK_2 | 0x0082)
  // (ReadOnly, Bits 7:0) 
  // Length of GCP Packet
  #define BIT_MSK__RX_GCP_LENGTH__CEA_GCP_LENGTH                                        0xFF

// GCP Packet Data Byte#0 Register
#define REG_ADDR__RX_GCP_DBYTE0                                          (RX_DEPACK_2 | 0x0083)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_GCP_DBYTE0__CEA_GCP_PB_0                                          0xFF

// GCP Packet Data Byte #1 Register
#define REG_ADDR__RX_GCP_DBYTE1                                          (RX_DEPACK_2 | 0x0084)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_GCP_DBYTE1__CEA_GCP_PB_1                                          0xFF

// GCP Packet Data Byte #2 Register
#define REG_ADDR__RX_GCP_DBYTE2                                          (RX_DEPACK_2 | 0x0085)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_GCP_DBYTE2__CEA_GCP_PB_2                                          0xFF

// GCP Packet Data Byte #3 Register
#define REG_ADDR__RX_GCP_DBYTE3                                          (RX_DEPACK_2 | 0x0086)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_GCP_DBYTE3__CEA_GCP_PB_3                                          0xFF

// GCP Packet Data Byte #4 Register
#define REG_ADDR__RX_GCP_DBYTE4                                          (RX_DEPACK_2 | 0x0087)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_GCP_DBYTE4__CEA_GCP_PB_4                                          0xFF

// GCP Packet Data Byte #5 Register
#define REG_ADDR__RX_GCP_DBYTE5                                          (RX_DEPACK_2 | 0x0088)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_GCP_DBYTE5__CEA_GCP_PB_5                                          0xFF

// GCP Packet Data Byte #6 Register
#define REG_ADDR__RX_GCP_DBYTE6                                          (RX_DEPACK_2 | 0x0089)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_GCP_DBYTE6__CEA_GCP_PB_6                                          0xFF

// CEA-861 HF_VSI InfoFrame Type Code Register
#define REG_ADDR__HF_VSIRX_TYPE                                          (RX_DEPACK_2 | 0x0090)
  // (ReadOnly, Bits 7:0) 
  // bits [7:0] of 2 byte HF_VSI Header. This byte defines the HF_VSI InfoFrame Type Code. Follows the latest CEA-861 spec.
  #define BIT_MSK__HF_VSIRX_TYPE__CEA_HF_VSI_HEADER_B7_B0                               0xFF

// CEA-861 HF_VSI InfoFrame Version Number Register
#define REG_ADDR__HF_VSIRX_VERS                                          (RX_DEPACK_2 | 0x0091)
  // (ReadOnly, Bits 7:0) 
  // bits [15:8] of 2 byte HF_VSI Header. This byte defines the HF_VSI InfoFrame Version Number. Follows the latest CEA-861 spec.
  #define BIT_MSK__HF_VSIRX_VERS__CEA_HF_VSI_HEADER_B15_B8                              0xFF

// CEA-861 HF_VSI InfoFrame Length Register
#define REG_ADDR__HF_VSIRX_LENGTH                                        (RX_DEPACK_2 | 0x0092)
  // (ReadOnly, Bits 7:0) 
  // Length of HF_VSI InfoFrame
  #define BIT_MSK__HF_VSIRX_LENGTH__CEA_HF_VSI_LENGTH                                     0xFF

// CEA-861 HF_VSI InfoFrame HDMI Checksum Register
#define REG_ADDR__HF_VSIRX_DBYTE0                                        (RX_DEPACK_2 | 0x0093)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE0__CEA_HF_VSI_PB_0                                       0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #1 Register
#define REG_ADDR__HF_VSIRX_DBYTE1                                        (RX_DEPACK_2 | 0x0094)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE1__CEA_HF_VSI_PB_1                                       0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #2 Register
#define REG_ADDR__HF_VSIRX_DBYTE2                                        (RX_DEPACK_2 | 0x0095)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE2__CEA_HF_VSI_PB_2                                       0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #3 Register
#define REG_ADDR__HF_VSIRX_DBYTE3                                        (RX_DEPACK_2 | 0x0096)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE3__CEA_HF_VSI_PB_3                                       0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #4 Register
#define REG_ADDR__HF_VSIRX_DBYTE4                                        (RX_DEPACK_2 | 0x0097)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE4__CEA_HF_VSI_PB_4                                       0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #5 Register
#define REG_ADDR__HF_VSIRX_DBYTE5                                        (RX_DEPACK_2 | 0x0098)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE5__CEA_HF_VSI_PB_5                                       0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #6 Register
#define REG_ADDR__HF_VSIRX_DBYTE6                                        (RX_DEPACK_2 | 0x0099)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE6__CEA_HF_VSI_PB_6                                       0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #7 Register
#define REG_ADDR__HF_VSIRX_DBYTE7                                        (RX_DEPACK_2 | 0x009A)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE7__CEA_HF_VSI_PB_7                                       0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #8 Register
#define REG_ADDR__HF_VSIRX_DBYTE8                                        (RX_DEPACK_2 | 0x009B)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE8__CEA_HF_VSI_PB_8                                       0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #9 Register
#define REG_ADDR__HF_VSIRX_DBYTE9                                        (RX_DEPACK_2 | 0x009C)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE9__CEA_HF_VSI_PB_9                                       0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #10 Register
#define REG_ADDR__HF_VSIRX_DBYTE10                                       (RX_DEPACK_2 | 0x009D)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE10__CEA_HF_VSI_PB_10                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #11 Register
#define REG_ADDR__HF_VSIRX_DBYTE11                                       (RX_DEPACK_2 | 0x009E)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE11__CEA_HF_VSI_PB_11                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #12 Register
#define REG_ADDR__HF_VSIRX_DBYTE12                                       (RX_DEPACK_2 | 0x009F)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE12__CEA_HF_VSI_PB_12                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #13 Register
#define REG_ADDR__HF_VSIRX_DBYTE13                                       (RX_DEPACK_2 | 0x00A0)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE13__CEA_HF_VSI_PB_13                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #14 Register
#define REG_ADDR__HF_VSIRX_DBYTE14                                       (RX_DEPACK_2 | 0x00A1)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE14__CEA_HF_VSI_PB_14                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #15 Register
#define REG_ADDR__HF_VSIRX_DBYTE15                                       (RX_DEPACK_2 | 0x00A2)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE15__CEA_HF_VSI_PB_15                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #16 Register
#define REG_ADDR__HF_VSIRX_DBYTE16                                       (RX_DEPACK_2 | 0x00A3)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE16__CEA_HF_VSI_PB_16                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #17 Register
#define REG_ADDR__HF_VSIRX_DBYTE17                                       (RX_DEPACK_2 | 0x00A4)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE17__CEA_HF_VSI_PB_17                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #18 Register
#define REG_ADDR__HF_VSIRX_DBYTE18                                       (RX_DEPACK_2 | 0x00A5)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE18__CEA_HF_VSI_PB_18                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #19 Register
#define REG_ADDR__HF_VSIRX_DBYTE19                                       (RX_DEPACK_2 | 0x00A6)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE19__CEA_HF_VSI_PB_19                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #20 Register
#define REG_ADDR__HF_VSIRX_DBYTE20                                       (RX_DEPACK_2 | 0x00A7)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE20__CEA_HF_VSI_PB_20                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #21 Register
#define REG_ADDR__HF_VSIRX_DBYTE21                                       (RX_DEPACK_2 | 0x00A8)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE21__CEA_HF_VSI_PB_21                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #22 Register
#define REG_ADDR__HF_VSIRX_DBYTE22                                       (RX_DEPACK_2 | 0x00A9)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE22__CEA_HF_VSI_PB_22                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #23 Register
#define REG_ADDR__HF_VSIRX_DBYTE23                                       (RX_DEPACK_2 | 0x00AA)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE23__CEA_HF_VSI_PB_23                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #24 Register
#define REG_ADDR__HF_VSIRX_DBYTE24                                       (RX_DEPACK_2 | 0x00AB)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE24__CEA_HF_VSI_PB_24                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #25 Register
#define REG_ADDR__HF_VSIRX_DBYTE25                                       (RX_DEPACK_2 | 0x00AC)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE25__CEA_HF_VSI_PB_25                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #26 Register
#define REG_ADDR__HF_VSIRX_DBYTE26                                       (RX_DEPACK_2 | 0x00AD)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE26__CEA_HF_VSI_PB_26                                      0xFF

// CEA-861 HF_VSI InfoFrame Data Byte #27 Register
#define REG_ADDR__HF_VSIRX_DBYTE27                                       (RX_DEPACK_2 | 0x00AE)
  // (ReadOnly, Bits 7:0) 
  // Read CEA-861 for detailed description of this register
  #define BIT_MSK__HF_VSIRX_DBYTE27__CEA_HF_VSI_PB_27                                      0xFF

// HF_VSI packet ID Register
#define REG_ADDR__HF_VSI_PKT_ID                                          (RX_DEPACK_2 | 0x00AF)
  // (ReadWrite, Bits 7:0) 
  // VSI packet header
  #define BIT_MSK__HF_VSI_PKT_ID__REG_HF_VSI_HEADER                                     0xFF

// HF_VSI ID #1 Register
#define REG_ADDR__HF_VSIF_ID1                                            (RX_DEPACK_2 | 0x00B0)
  // (ReadWrite, Bits 7:0) 
  // HF_VSI ID byte #1
  #define BIT_MSK__HF_VSIF_ID1__REG_HF_VSI_PB1                                        0xFF

// HF_VSI ID #2 Register
#define REG_ADDR__HF_VSIF_ID2                                            (RX_DEPACK_2 | 0x00B1)
  // (ReadWrite, Bits 7:0) 
  // HF_VSI ID byte #2
  #define BIT_MSK__HF_VSIF_ID2__REG_HF_VSI_PB2                                        0xFF

// HF_VSI ID #3 Register
#define REG_ADDR__HF_VSIF_ID3                                            (RX_DEPACK_2 | 0x00B2)
  // (ReadWrite, Bits 7:0) 
  // HF_VSI ID byte #3
  #define BIT_MSK__HF_VSIF_ID3__REG_HF_VSI_PB3                                        0xFF

// HF_VSI Control Register
#define REG_ADDR__HF_VSIF_CTRL                                           (RX_DEPACK_2 | 0x00B3)
  // (ReadWrite, Bits 0) 
  // Select when to set interrupts for the HF_VSIF InfoFrames: 0 - interrupt is set only if new HF_VSIF InfoFrame is received (default); 1 - interrupt is set if any HF_VSIF InfoFrame arrives
  #define BIT_MSK__HF_VSIF_CTRL__REG_NEW_HF_VSI_ONLY                                   0x01
  // (ReadWrite, Bits 1) 
  // enable swap of HF_VSI ID 
  #define BIT_MSK__HF_VSIF_CTRL__REG_SWAP_HF_VSI_IEEE_ID                               0x02
  // (ReadWrite, Bits 2) 
  // Enable clear of the HF_VSI if did not get it for # of vsync defianed in  reg_no_pkt_cnt
  #define BIT_MSK__HF_VSIF_CTRL__REG_HF_VSI_CLR_EN                                     0x04
  // (ReadWrite, Bits 3) 
  // enable check of the HF_VSIF ID before storing of the HF_VSIF data in registers; if fail will not store
  #define BIT_MSK__HF_VSIF_CTRL__REG_HF_VSI_IEEE_ID_CHK_EN                             0x08

// METADATA HEADER #0 Register
#define REG_ADDR__METADATA_HEADER_BYTE0                                  (RX_DEPACK_2 | 0x00BE)
  // (ReadOnly, Bits 7:0) 
  // bits [7:0] of metadata packet header, For more indormation see table 8.4 of hdmi2.0 spec
  #define BIT_MSK__METADATA_HEADER_BYTE0__META_DATA_HEADER_B7_B0                                0xFF

// METADATA HEADER #1 Register
#define REG_ADDR__METADATA_HEADER_BYTE1                                  (RX_DEPACK_2 | 0x00BF)
  // (ReadOnly, Bits 7:0) 
  // bits [15:8] of metadata packet header, For more indormation see table 8.4 of hdmi2.0 spec
  #define BIT_MSK__METADATA_HEADER_BYTE1__META_DATA_HEADER_B15_B8                               0xFF

// METADATA HEADER #2 Register
#define REG_ADDR__METADATA_HEADER_BYTE2                                  (RX_DEPACK_2 | 0x00C0)
  // (ReadOnly, Bits 7:0) 
  // bits [23:16] of metadata packet header, For more indormation see table 8.4 of hdmi2.0 spec
  #define BIT_MSK__METADATA_HEADER_BYTE2__META_DATA_HEADER_B23_B16                              0xFF

// METADATA Data Byte #0 Register
#define REG_ADDR__METADATA_DBYTE0                                        (RX_DEPACK_2 | 0x00C1)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #0
  #define BIT_MSK__METADATA_DBYTE0__METADATA_PB_0                                         0xFF

// METADATA Data Byte #1 Register
#define REG_ADDR__METADATA_DBYTE1                                        (RX_DEPACK_2 | 0x00C2)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #1
  #define BIT_MSK__METADATA_DBYTE1__METADATA_PB_1                                         0xFF

// METADATA Data Byte #2 Register
#define REG_ADDR__METADATA_DBYTE2                                        (RX_DEPACK_2 | 0x00C3)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #2
  #define BIT_MSK__METADATA_DBYTE2__METADATA_PB_2                                         0xFF

// METADATA Data Byte #3 Register
#define REG_ADDR__METADATA_DBYTE3                                        (RX_DEPACK_2 | 0x00C4)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #3
  #define BIT_MSK__METADATA_DBYTE3__METADATA_PB_3                                         0xFF

// METADATA Data Byte #4 Register
#define REG_ADDR__METADATA_DBYTE4                                        (RX_DEPACK_2 | 0x00C5)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #4
  #define BIT_MSK__METADATA_DBYTE4__METADATA_PB_4                                         0xFF

// METADATA Data Byte #5 Register
#define REG_ADDR__METADATA_DBYTE5                                        (RX_DEPACK_2 | 0x00C6)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #5
  #define BIT_MSK__METADATA_DBYTE5__METADATA_PB_5                                         0xFF

// METADATA Data Byte #6 Register
#define REG_ADDR__METADATA_DBYTE6                                        (RX_DEPACK_2 | 0x00C7)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #6
  #define BIT_MSK__METADATA_DBYTE6__METADATA_PB_6                                         0xFF

// METADATA Data Byte #7 Register
#define REG_ADDR__METADATA_DBYTE7                                        (RX_DEPACK_2 | 0x00C8)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #7
  #define BIT_MSK__METADATA_DBYTE7__METADATA_PB_7                                         0xFF

// METADATA Data Byte #8 Register
#define REG_ADDR__METADATA_DBYTE8                                        (RX_DEPACK_2 | 0x00C9)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #8
  #define BIT_MSK__METADATA_DBYTE8__METADATA_PB_8                                         0xFF

// METADATA Data Byte #9 Register
#define REG_ADDR__METADATA_DBYTE9                                        (RX_DEPACK_2 | 0x00CA)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #9
  #define BIT_MSK__METADATA_DBYTE9__METADATA_PB_9                                         0xFF

// METADATA Data Byte #10 Register
#define REG_ADDR__METADATA_DBYTE10                                       (RX_DEPACK_2 | 0x00CB)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #10
  #define BIT_MSK__METADATA_DBYTE10__METADATA_PB_10                                        0xFF

// METADATA Data Byte #11 Register
#define REG_ADDR__METADATA_DBYTE11                                       (RX_DEPACK_2 | 0x00CC)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #11
  #define BIT_MSK__METADATA_DBYTE11__METADATA_PB_11                                        0xFF

// METADATA Data Byte #12 Register
#define REG_ADDR__METADATA_DBYTE12                                       (RX_DEPACK_2 | 0x00CD)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #12
  #define BIT_MSK__METADATA_DBYTE12__METADATA_PB_12                                        0xFF

// METADATA Data Byte #13 Register
#define REG_ADDR__METADATA_DBYTE13                                       (RX_DEPACK_2 | 0x00CE)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #13
  #define BIT_MSK__METADATA_DBYTE13__METADATA_PB_13                                        0xFF

// METADATA Data Byte #14 Register
#define REG_ADDR__METADATA_DBYTE14                                       (RX_DEPACK_2 | 0x00CF)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #14
  #define BIT_MSK__METADATA_DBYTE14__METADATA_PB_14                                        0xFF

// METADATA Data Byte #15 Register
#define REG_ADDR__METADATA_DBYTE15                                       (RX_DEPACK_2 | 0x00D0)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #15
  #define BIT_MSK__METADATA_DBYTE15__METADATA_PB_15                                        0xFF

// METADATA Data Byte #16 Register
#define REG_ADDR__METADATA_DBYTE16                                       (RX_DEPACK_2 | 0x00D1)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #16
  #define BIT_MSK__METADATA_DBYTE16__METADATA_PB_16                                        0xFF

// METADATA Data Byte #17 Register
#define REG_ADDR__METADATA_DBYTE17                                       (RX_DEPACK_2 | 0x00D2)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #17
  #define BIT_MSK__METADATA_DBYTE17__METADATA_PB_17                                        0xFF

// METADATA Data Byte #18 Register
#define REG_ADDR__METADATA_DBYTE18                                       (RX_DEPACK_2 | 0x00D3)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #18
  #define BIT_MSK__METADATA_DBYTE18__METADATA_PB_18                                        0xFF

// METADATA Data Byte #19 Register
#define REG_ADDR__METADATA_DBYTE19                                       (RX_DEPACK_2 | 0x00D4)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #19
  #define BIT_MSK__METADATA_DBYTE19__METADATA_PB_19                                        0xFF

// METADATA Data Byte #20 Register
#define REG_ADDR__METADATA_DBYTE20                                       (RX_DEPACK_2 | 0x00D5)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #20
  #define BIT_MSK__METADATA_DBYTE20__METADATA_PB_20                                        0xFF

// METADATA Data Byte #21 Register
#define REG_ADDR__METADATA_DBYTE21                                       (RX_DEPACK_2 | 0x00D6)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #21
  #define BIT_MSK__METADATA_DBYTE21__METADATA_PB_21                                        0xFF

// METADATA Data Byte #22 Register
#define REG_ADDR__METADATA_DBYTE22                                       (RX_DEPACK_2 | 0x00D7)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #22
  #define BIT_MSK__METADATA_DBYTE22__METADATA_PB_22                                        0xFF

// METADATA Data Byte #23 Register
#define REG_ADDR__METADATA_DBYTE23                                       (RX_DEPACK_2 | 0x00D8)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #23
  #define BIT_MSK__METADATA_DBYTE23__METADATA_PB_23                                        0xFF

// METADATA Data Byte #24 Register
#define REG_ADDR__METADATA_DBYTE24                                       (RX_DEPACK_2 | 0x00D9)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #24
  #define BIT_MSK__METADATA_DBYTE24__METADATA_PB_24                                        0xFF

// METADATA Data Byte #25 Register
#define REG_ADDR__METADATA_DBYTE25                                       (RX_DEPACK_2 | 0x00DA)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #25
  #define BIT_MSK__METADATA_DBYTE25__METADATA_PB_25                                        0xFF

// METADATA Data Byte #26 Register
#define REG_ADDR__METADATA_DBYTE26                                       (RX_DEPACK_2 | 0x00DB)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #26
  #define BIT_MSK__METADATA_DBYTE26__METADATA_PB_26                                        0xFF

// METADATA Data Byte #27 Register
#define REG_ADDR__METADATA_DBYTE27                                       (RX_DEPACK_2 | 0x00DC)
  // (ReadOnly, Bits 7:0) 
  // Meta data packet data byte #27
  #define BIT_MSK__METADATA_DBYTE27__METADATA_PB_27                                        0xFF

// ACR Packet decode address Register
#define REG_ADDR__RX_ACR_DEC                                             (RX_DEPACK_2 | 0x00DD)
  // (ReadWrite, Bits 7:0) 
  // ACR Packet Decode Address: default is 0x01. By changing this address the ACR packet can be stored in the location of any other InfoFrame
  #define BIT_MSK__RX_ACR_DEC__REG_ACR_DEC                                           0xFF

// ACR Packet CTS Mask Register
#define REG_ADDR__RX_ACR_CTS_MASK                                        (RX_DEPACK_2 | 0x00DE)
  // (ReadWrite, Bits 7:0) 
  // ACR Packet CTS threshold: This register field contains CTS threshold value.  If the difference in CTS value in successive two valid ACR Packets is greater than CTS threshold, then it is identified the incoming ACR packet contains new CTS value.  
  #define BIT_MSK__RX_ACR_CTS_MASK__REG_ACR_CTS_THRESHOLD                                 0xFF

// ACR Packet Header Byte0 Register
#define REG_ADDR__RX_ACR_HEADER0                                         (RX_DEPACK_2 | 0x00DF)
  // (ReadOnly, Bits 7:0) 
  // bits [7:0] of ACR Packet Header. Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ACR_HEADER0__CEA_ACR_HEADER_B7_B0                                  0xFF

// ACR Packet Header Byte1 Register
#define REG_ADDR__RX_ACR_HEADER1                                         (RX_DEPACK_2 | 0x00E0)
  // (ReadOnly, Bits 7:0) 
  // bits [15:8] of ACR Packet Header. Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ACR_HEADER1__CEA_ACR_HEADER_B15_B8                                 0xFF

// ACR Packet Header Byte2 Register
#define REG_ADDR__RX_ACR_HEADER2                                         (RX_DEPACK_2 | 0x00E1)
  // (ReadOnly, Bits 7:0) 
  // bits [23:16] of ACR Packet Header. Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ACR_HEADER2__CEA_ACR_HEADER_B23_B16                                0xFF

// ACR Packet Data Byte #0 Register
#define REG_ADDR__RX_ACR_DBYTE0                                          (RX_DEPACK_2 | 0x00E2)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ACR_DBYTE0__CEA_ACR_PB_0                                          0xFF

// ACR Packet Data Byte #1 Register
#define REG_ADDR__RX_ACR_DBYTE1                                          (RX_DEPACK_2 | 0x00E3)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ACR_DBYTE1__CEA_ACR_PB_1                                          0xFF

// ACR Packet Data Byte #2 Register
#define REG_ADDR__RX_ACR_DBYTE2                                          (RX_DEPACK_2 | 0x00E4)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ACR_DBYTE2__CEA_ACR_PB_2                                          0xFF

// ACR Packet Data Byte #3 Register
#define REG_ADDR__RX_ACR_DBYTE3                                          (RX_DEPACK_2 | 0x00E5)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ACR_DBYTE3__CEA_ACR_PB_3                                          0xFF

// ACR Packet Data Byte #4 Register
#define REG_ADDR__RX_ACR_DBYTE4                                          (RX_DEPACK_2 | 0x00E6)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ACR_DBYTE4__CEA_ACR_PB_4                                          0xFF

// ACR Packet Data Byte #5 Register
#define REG_ADDR__RX_ACR_DBYTE5                                          (RX_DEPACK_2 | 0x00E7)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ACR_DBYTE5__CEA_ACR_PB_5                                          0xFF

// ACR Packet Data Byte #6 Register
#define REG_ADDR__RX_ACR_DBYTE6                                          (RX_DEPACK_2 | 0x00E8)
  // (ReadOnly, Bits 7:0) 
  // Read HDMI spec. for detailed description of this register
  #define BIT_MSK__RX_ACR_DBYTE6__CEA_ACR_PB_6                                          0xFF

//***************************************************************************
// RX_HDCP2. Address: 60
// HDCP General Control 0 Register
#define REG_ADDR__RX_HDCP2X_CTRL_0                                          (RX_HDCP2 | 0x0000)
  // (ReadWrite, Bits 0) 
  // Constant: 1 for TX 0 for RX
  #define BIT_MSK__RX_HDCP2X_CTRL_0__RI_HDCP2_HDCPTX                                       0x01
  // (ReadWrite, Bits 1) 
  // Valid only for Rx. Don't care for Tx. Constant: 1 for Repeater 0 for Receiver
  #define BIT_MSK__RX_HDCP2X_CTRL_0__RI_HDCP2RX_REPEATER                                   0x02
  // (ReadWrite, Bits 2) 
  // Constant: 1 for HDMI 0 for MHL
  #define BIT_MSK__RX_HDCP2X_CTRL_0__RI_HDCP2_HDMIMODE                                     0x04

// HDCP General Control 1 Register
#define REG_ADDR__RX_HDCP2X_CTRL_1                                          (RX_HDCP2 | 0x0001)
  // (ReadWrite, Bits 0) 
  // Active high long pulse
  #define BIT_MSK__RX_HDCP2X_CTRL_1__RI_HDCP2_REAUTH_SW                                    0x01
  // (ReadWrite, Bits 1) 
  // Valid only for Tx. Don't care for Rx. 1 to mask auth_done to link (No CTL3) . Default is 0 - unmaked.
  #define BIT_MSK__RX_HDCP2X_CTRL_1__RI_HDCP2TX_CTL3MSK                                    0x02
  // (ReadWrite, Bits 7:4) 
  // {mask_ecc mask_hpd mask_req mask_sw}  1 to mask(off) . 0 to unmask(on)
  #define BIT_MSK__RX_HDCP2X_CTRL_1__RI_HDCP2_REAUTH_MSK                                   0xF0

// HDCP General Control 2 Register
#define REG_ADDR__RX_HDCP2X_CTRL_2                                          (RX_HDCP2 | 0x0002)
  // (ReadWrite, Bits 0) 
  // Active high long pulse Write 1 to this register to start patch code check. Write back to 0 after code check finishes.
  #define BIT_MSK__RX_HDCP2X_CTRL_2__RI_HDCP2_CUPD_DONE                                    0x01
  // (ReadWrite, Bits 1) 
  // Active high long pulse Write 1 to this register to gain write access to PRAM for patch.
  #define BIT_MSK__RX_HDCP2X_CTRL_2__RI_HDCP2_CUPD_START                                   0x02
  // (ReadWrite, Bits 2) 
  // 1(default): Use i_hw_cupd_start/i_hw_cupd_done. 0: Use ri_hdcp2_cupd_start/ri_hdcp2_cupd_done.
  #define BIT_MSK__RX_HDCP2X_CTRL_2__RI_HDCP2_CUPD_HW                                      0x04
  // (ReadWrite, Bits 7:4) 
  // 4'hA for HDCP 2.2 for HDMI or MHL. Do not change this regiseter.
  #define BIT_MSK__RX_HDCP2X_CTRL_2__RI_HDCP2_CPVER_B3_B0                                  0xF0

// HDCP Interrupt0 Status Register
#define REG_ADDR__RX_HDCP2X_INTR0                                           (RX_HDCP2 | 0x0003)
  // (ReadWrite, Bits 0) 
  // ro_hdcp2_auth_stat[0] : auth_done
  #define BIT_MSK__RX_HDCP2X_INTR0__INTR0_STAT0                                           0x01
  // (ReadWrite, Bits 1) 
  // ro_hdcp2_auth_stat[1] : auth_fail
  #define BIT_MSK__RX_HDCP2X_INTR0__INTR0_STAT1                                           0x02
  // (ReadWrite, Bits 2) 
  // ro_hdcp2_auth_stat[2] : rpt_ready
  #define BIT_MSK__RX_HDCP2X_INTR0__INTR0_STAT2                                           0x04
  // (ReadWrite, Bits 3) 
  // ro_hdcp2_auth_stat[3] : hash_fail
  #define BIT_MSK__RX_HDCP2X_INTR0__INTR0_STAT3                                           0x08
  // (ReadWrite, Bits 4) 
  // ro_hdcp2_auth_stat[4] : cchk_done
  #define BIT_MSK__RX_HDCP2X_INTR0__INTR0_STAT4                                           0x10
  // (ReadWrite, Bits 5) 
  // ro_hdcp2_auth_stat[5] : cchk_fail
  #define BIT_MSK__RX_HDCP2X_INTR0__INTR0_STAT5                                           0x20
  // (ReadWrite, Bits 6) 
  // ro_hdcp2_auth_stat[6] : reauth_req
  #define BIT_MSK__RX_HDCP2X_INTR0__INTR0_STAT6                                           0x40
  // (ReadWrite, Bits 7) 
  // ro_hdcp2_auth_stat[7]: polling_interval
  #define BIT_MSK__RX_HDCP2X_INTR0__INTR0_STAT7                                           0x80

// HDCP Interrupt1 Status Register
#define REG_ADDR__RX_HDCP2X_INTR1                                           (RX_HDCP2 | 0x0004)
  // (ReadWrite, Bits 0) 
  // ro_rpt_rcvid_changed
  #define BIT_MSK__RX_HDCP2X_INTR1__INTR1_STAT0                                           0x01
  // (ReadWrite, Bits 1) 
  // ro_rpt_smng_changed
  #define BIT_MSK__RX_HDCP2X_INTR1__INTR1_STAT1                                           0x02
  // (ReadWrite, Bits 2) 
  // ro_ake_sent_rcvd
  #define BIT_MSK__RX_HDCP2X_INTR1__INTR1_STAT2                                           0x04
  // (ReadWrite, Bits 3) 
  // ro_ske_sent_rcvd
  #define BIT_MSK__RX_HDCP2X_INTR1__INTR1_STAT3                                           0x08
  // (ReadWrite, Bits 4) 
  // ro_rpt_rcvid_xfer_done
  #define BIT_MSK__RX_HDCP2X_INTR1__INTR1_STAT4                                           0x10
  // (ReadWrite, Bits 5) 
  // ro_rpt_smng_xfer_done
  #define BIT_MSK__RX_HDCP2X_INTR1__INTR1_STAT5                                           0x20
  // (ReadWrite, Bits 6) 
  // ro_cert_sent_rcvd
  #define BIT_MSK__RX_HDCP2X_INTR1__INTR1_STAT6                                           0x40
  // (ReadWrite, Bits 7) 
  // ro_gp3[7]
  #define BIT_MSK__RX_HDCP2X_INTR1__INTR1_STAT7                                           0x80

// HDCP Interrupt2 Status Register
#define REG_ADDR__RX_HDCP2X_INTR2                                           (RX_HDCP2 | 0x0005)
  // (ReadWrite, Bits 0) 
  // ro_msg_intr[0]:ro_km_sent_rcvd
  #define BIT_MSK__RX_HDCP2X_INTR2__INTR2_STAT0                                           0x01
  // (ReadWrite, Bits 1) 
  // ro_msg_intr[1]:ro_ekhkm_sent_rcvd
  #define BIT_MSK__RX_HDCP2X_INTR2__INTR2_STAT1                                           0x02
  // (ReadWrite, Bits 2) 
  // ro_msg_intr[2]:ro_h_sent_rcvd
  #define BIT_MSK__RX_HDCP2X_INTR2__INTR2_STAT2                                           0x04
  // (ReadWrite, Bits 3) 
  // ro_msg_intr[3]:ro_pair_sent_rcvd
  #define BIT_MSK__RX_HDCP2X_INTR2__INTR2_STAT3                                           0x08
  // (ReadWrite, Bits 4) 
  // ro_msg_intr[4]:ro_lc_sent_rcvd
  #define BIT_MSK__RX_HDCP2X_INTR2__INTR2_STAT4                                           0x10
  // (ReadWrite, Bits 5) 
  // ro_msg_intr[5]:ro_l_sent_rcvd
  #define BIT_MSK__RX_HDCP2X_INTR2__INTR2_STAT5                                           0x20
  // (ReadWrite, Bits 6) 
  // ro_msg_intr[6]:ro_vack_sent_rcvd
  #define BIT_MSK__RX_HDCP2X_INTR2__INTR2_STAT6                                           0x40
  // (ReadWrite, Bits 7) 
  // ro_msg_intr[7]:ro_mack_sent_rcvd
  #define BIT_MSK__RX_HDCP2X_INTR2__INTR2_STAT7                                           0x80

// HDCP AES Debug Register
#define REG_ADDR__RX_HDCP2X_INTR3                                           (RX_HDCP2 | 0x0006)
  // (ReadWrite, Bits 0) 
  // Underrun in AES FIFO
  #define BIT_MSK__RX_HDCP2X_INTR3__INTR3_STAT0                                           0x01
  // (ReadWrite, Bits 1) 
  // Encryption enable status changed(RX only)
  #define BIT_MSK__RX_HDCP2X_INTR3__INTR3_STAT1                                           0x02

// HDCP Interrupt0 Mask Register
#define REG_ADDR__RX_HDCP2X_INTR0_MASK                                      (RX_HDCP2 | 0x0007)
  // (ReadWrite, Bits 0) 
  // Mask for INTR0[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR0_MASK__INTR0_MASK_B0                                         0x01
  // (ReadWrite, Bits 1) 
  // Mask for INTR0[1]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR0_MASK__INTR0_MASK_B1                                         0x02
  // (ReadWrite, Bits 2) 
  // Mask for INTR0[2]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR0_MASK__INTR0_MASK_B2                                         0x04
  // (ReadWrite, Bits 3) 
  // Mask for INTR0[3]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR0_MASK__INTR0_MASK_B3                                         0x08
  // (ReadWrite, Bits 4) 
  // Mask for INTR0[4]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR0_MASK__INTR0_MASK_B4                                         0x10
  // (ReadWrite, Bits 5) 
  // Mask for INTR0[5]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR0_MASK__INTR0_MASK_B5                                         0x20
  // (ReadWrite, Bits 6) 
  // Mask for INTR0[6]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR0_MASK__INTR0_MASK_B6                                         0x40
  // (ReadWrite, Bits 7) 
  // Mask for INTR0[7]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR0_MASK__INTR0_MASK_B7                                         0x80

// HDCP Interrupt1 MaskRegister
#define REG_ADDR__RX_HDCP2X_INTR1_MASK                                      (RX_HDCP2 | 0x0008)
  // (ReadWrite, Bits 0) 
  // Mask for INTR1[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR1_MASK__INTR1_MASK_B0                                         0x01
  // (ReadWrite, Bits 1) 
  // Mask for INTR1[1]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR1_MASK__INTR1_MASK_B1                                         0x02
  // (ReadWrite, Bits 2) 
  // Mask for INTR1[2]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR1_MASK__INTR1_MASK_B2                                         0x04
  // (ReadWrite, Bits 3) 
  // Mask for INTR1[3]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR1_MASK__INTR1_MASK_B3                                         0x08
  // (ReadWrite, Bits 4) 
  // Mask for INTR1[4]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR1_MASK__INTR1_MASK_B4                                         0x10
  // (ReadWrite, Bits 5) 
  // Mask for INTR1[5]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR1_MASK__INTR1_MASK_B5                                         0x20
  // (ReadWrite, Bits 6) 
  // Mask for INTR1[6]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR1_MASK__INTR1_MASK_B6                                         0x40
  // (ReadWrite, Bits 7) 
  // Mask for INTR1[7]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR1_MASK__INTR1_MASK_B7                                         0x80

// HDCP Interrupt2 Mask Register
#define REG_ADDR__RX_HDCP2X_INTR2_MASK                                      (RX_HDCP2 | 0x0009)
  // (ReadWrite, Bits 0) 
  // Mask for INTR2[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR2_MASK__INTR2_MASK_B0                                         0x01
  // (ReadWrite, Bits 1) 
  // Mask for INTR2[1]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR2_MASK__INTR2_MASK_B1                                         0x02
  // (ReadWrite, Bits 2) 
  // Mask for INTR2[2]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR2_MASK__INTR2_MASK_B2                                         0x04
  // (ReadWrite, Bits 3) 
  // Mask for INTR2[3]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR2_MASK__INTR2_MASK_B3                                         0x08
  // (ReadWrite, Bits 4) 
  // Mask for INTR2[4]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR2_MASK__INTR2_MASK_B4                                         0x10
  // (ReadWrite, Bits 5) 
  // Mask for INTR2[5]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR2_MASK__INTR2_MASK_B5                                         0x20
  // (ReadWrite, Bits 6) 
  // Mask for INTR2[6]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR2_MASK__INTR2_MASK_B6                                         0x40
  // (ReadWrite, Bits 7) 
  // Mask for INTR2[7]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR2_MASK__INTR2_MASK_B7                                         0x80

// HDCP Interrupt3 Mask Register
#define REG_ADDR__RX_HDCP2X_INTR3_MASK                                      (RX_HDCP2 | 0x000A)
  // (ReadWrite, Bits 0) 
  // Mask for INTR3[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR3_MASK__INTR3_MASK_B0                                         0x01
  // (ReadWrite, Bits 1) 
  // Mask for INTR3[1]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR3_MASK__INTR3_MASK_B1                                         0x02

// HDCP Interrupt Status Register
#define REG_ADDR__RX_HDCP2X_INTRSTATUS                                      (RX_HDCP2 | 0x000B)
  // (ReadOnly, Bits 0) 
  // OR of all HDCP interrupts
  #define BIT_MSK__RX_HDCP2X_INTRSTATUS__RO_INTR                                               0x01
  // (ReadOnly, Bits 7:4) 
  // Byte aggregated interrupt stateu Bit 0 for HDCP2X_INTR0 Bit 1 for HDCP2X_INTR1 Bit 2 for HDCP2X_INTR2 Bit 3 for HDCP2X_INTR3
  #define BIT_MSK__RX_HDCP2X_INTRSTATUS__RO_AGGRINTR_B3_B0                                     0xF0

// HDCP Auth Status Register
#define REG_ADDR__RX_HDCP2X_AUTH_STAT                                       (RX_HDCP2 | 0x000C)
  // (ReadOnly, Bits 7:0) 
  // [0]: auth_done [1]: auth_fail [2]: rpt_ready [3]: hash_fail [4]: cchk_done [5]: cchk_fail [6]: reauth_req [7]: polling_inverval
  #define BIT_MSK__RX_HDCP2X_AUTH_STAT__RO_HDCP2_AUTH_STAT_B7_B0                              0xFF

// HDCP State Status Register
#define REG_ADDR__RX_HDCP2X_STATE                                           (RX_HDCP2 | 0x000D)
  // (ReadOnly, Bits 7:0) 
  // State for debugging
  #define BIT_MSK__RX_HDCP2X_STATE__RO_HDCP2_STATE_B7_B0                                  0xFF

// HDCP General Staus Register
#define REG_ADDR__RX_HDCP2X_GEN_STATUS                                      (RX_HDCP2 | 0x000E)
  // (ReadOnly, Bits 0) 
  // Debugging info: 1 if RAM patch code is running 0 if ROM code is running
  #define BIT_MSK__RX_HDCP2X_GEN_STATUS__RO_HDCP2_PRG_SEL                                      0x01
  // (ReadOnly, Bits 1) 
  // Valid only for Rx. Don't care for Tx. Connected to HDCP2X mode detection signal from i2c. Tuns to 0 if DDC offset address 0 ~ 0x4F are accessed. Turns to 1 if DDC offset address 0x50 and above are accessed. Power on default is 0.
  #define BIT_MSK__RX_HDCP2X_GEN_STATUS__RO_HDCP2RX_MODE_SEL                                   0x02
  // (ReadOnly, Bits 2) 
  // For TX set to 1 when connected downstream device is an HDCP2 repeater. For RX set to 1 if ri_hdcp2x_repeater(HDCP2X_CMD_CTRL_0[1]) is set and HDCP2X core is running.
  #define BIT_MSK__RX_HDCP2X_GEN_STATUS__RO_HDCP2_REPEATER                                     0x04
  // (ReadOnly, Bits 7:4) 
  // encryptino enable status for each stream (up to 4) RX only
  #define BIT_MSK__RX_HDCP2X_GEN_STATUS__ENC_EN                                                0xF0

// HDCP TP0  Register
#define REG_ADDR__RX_HDCP2X_TP0                                             (RX_HDCP2 | 0x0010)
  // (ReadWrite, Bits 7:0) 
  // eclk divider selection (2=divide by 8) 0: divide by 2    1: divide by 4    2: divide by 8   other: divide by 16
  #define BIT_MSK__RX_HDCP2X_TP0__RI_HDCP2_TP0_B7_B0                                    0xFF

// HDCP TP1  Register
#define REG_ADDR__RX_HDCP2X_TP1                                             (RX_HDCP2 | 0x0011)
  // (ReadWrite, Bits 7:0) 
  // Coutner to generate base timer tick Value for 12ms timer = 12ms * eclk / divider / 256  24MHz eclk divide by 8 -] 140 20MHz eckl divide by 8 -] 117 For a given eclk frequency bigger value means slower tick For a given tick time faster eclk requires bigger value.
  #define BIT_MSK__RX_HDCP2X_TP1__RI_HDCP2_TP1_B7_B0                                    0xFF

// HDCP TP2 Register
#define REG_ADDR__RX_HDCP2X_TP2                                             (RX_HDCP2 | 0x0012)
  // (ReadWrite, Bits 7:0) 
  // Restart wait time (Default 1=12ms )
  #define BIT_MSK__RX_HDCP2X_TP2__RI_HDCP2_TP2_B7_B0                                    0xFF

// HDCP TP3  Register
#define REG_ADDR__RX_HDCP2X_TP3                                             (RX_HDCP2 | 0x0013)
  // (ReadWrite, Bits 7:0) 
  // DDC hang timeout  (Default 42=0x2A=504ms)
  #define BIT_MSK__RX_HDCP2X_TP3__RI_HDCP2_TP3_B7_B0                                    0xFF

// HDCP TP4  Register
#define REG_ADDR__RX_HDCP2X_TP4                                             (RX_HDCP2 | 0x0014)
  // (ReadWrite, Bits 7:0) 
  // H check timeout (storedkm case)  (Default 17=0x11=204ms)
  #define BIT_MSK__RX_HDCP2X_TP4__RI_HDCP2_TP4_B7_B0                                    0xFF

// HDCP TP5  Register
#define REG_ADDR__RX_HDCP2X_TP5                                             (RX_HDCP2 | 0x0015)
  // (ReadWrite, Bits 7:0) 
  // H check timeout (no-storedkm case)  (Default 100=1.2s)
  #define BIT_MSK__RX_HDCP2X_TP5__RI_HDCP2_TP5_B7_B0                                    0xFF

// HDCP TP6 Register
#define REG_ADDR__RX_HDCP2X_TP6                                             (RX_HDCP2 | 0x0016)
  // (ReadWrite, Bits 7:0) 
  // Locality check timeout  (Default 2=24ms)
  #define BIT_MSK__RX_HDCP2X_TP6__RI_HDCP2_TP6_B7_B0                                    0xFF

// HDCP TP7  Register
#define REG_ADDR__RX_HDCP2X_TP7                                             (RX_HDCP2 | 0x0017)
  // (ReadWrite, Bits 7:0) 
  // M check timeout  (Default 9=108ms)
  #define BIT_MSK__RX_HDCP2X_TP7__RI_HDCP2_TP7_B7_B0                                    0xFF

// HDCP TP8  Register
#define REG_ADDR__RX_HDCP2X_TP8                                             (RX_HDCP2 | 0x0018)
  // (ReadWrite, Bits 7:0) 
  // Certificate read timeout  (Default 9=108ms)
  #define BIT_MSK__RX_HDCP2X_TP8__RI_HDCP2_TP8_B7_B0                                    0xFF

// HDCP TP9  Register
#define REG_ADDR__RX_HDCP2X_TP9                                             (RX_HDCP2 | 0x0019)
  // (ReadWrite, Bits 7:0) 
  // Paring timeout  (Default 17=0x11=204ms)
  #define BIT_MSK__RX_HDCP2X_TP9__RI_HDCP2_TP9_B7_B0                                    0xFF

// HDCP TP10 Register
#define REG_ADDR__RX_HDCP2X_TP10                                            (RX_HDCP2 | 0x001A)
  // (ReadWrite, Bits 7:0) 
  // Authdonen wait time  (Default 17=0x11=204ms)
  #define BIT_MSK__RX_HDCP2X_TP10__RI_HDCP2_TP10_B7_B0                                   0xFF

// HDCP TP11  Register
#define REG_ADDR__RX_HDCP2X_TP11                                            (RX_HDCP2 | 0x001B)
  // (ReadWrite, Bits 7:0) 
  // V check timeout  (Default 167=0xA7=2s)
  #define BIT_MSK__RX_HDCP2X_TP11__RI_HDCP2_TP11_B7_B0                                   0xFF

// HDCP TP12  Register
#define REG_ADDR__RX_HDCP2X_TP12                                            (RX_HDCP2 | 0x001C)
  // (ReadWrite, Bits 7:0) 
  // Retry wait time  (Default 125 = 0x7D=1.5s)
  #define BIT_MSK__RX_HDCP2X_TP12__RI_HDCP2_TP12_B7_B0                                   0xFF

// HDCP TP13  Register
#define REG_ADDR__RX_HDCP2X_TP13                                            (RX_HDCP2 | 0x001D)
  // (ReadWrite, Bits 7:0) 
  // Stream_Ready to ENC_EN wait time. (Default 13 = 0x0D = 156ms)
  #define BIT_MSK__RX_HDCP2X_TP13__RI_HDCP2_TP13_B7_B0                                   0xFF

// HDCP TP14 Register
#define REG_ADDR__RX_HDCP2X_TP14                                            (RX_HDCP2 | 0x001E)
  // (ReadWrite, Bits 7:0) 
  // Wait time for V (Default 250=0xFA=3s)
  #define BIT_MSK__RX_HDCP2X_TP14__RI_HDCP2_TP14_B7_B0                                   0xFF

// HDCP TP15  Register
#define REG_ADDR__RX_HDCP2X_TP15                                            (RX_HDCP2 | 0x001F)
  // (ReadWrite, Bits 7:0) 
  // L check auto retry limit / 8 (Default 0)
  #define BIT_MSK__RX_HDCP2X_TP15__RI_HDCP2_TP15_B7_B0                                   0xFF

// HDCP GP In 0 Register
#define REG_ADDR__RX_HDCP2X_GP_IN0                                          (RX_HDCP2 | 0x0020)
  // (ReadWrite, Bits 7:0) 
  // General purpose input 0
  #define BIT_MSK__RX_HDCP2X_GP_IN0__RI_HDCP2_GP0_B7_B0                                    0xFF

// HDCP GP In 1 Register
#define REG_ADDR__RX_HDCP2X_GP_IN1                                          (RX_HDCP2 | 0x0021)
  // (ReadWrite, Bits 7:0) 
  // General purpose input 1
  #define BIT_MSK__RX_HDCP2X_GP_IN1__RI_HDCP2_GP1_B7_B0                                    0xFF

// HDCP GP In 2 Register
#define REG_ADDR__RX_HDCP2X_GP_IN2                                          (RX_HDCP2 | 0x0022)
  // (ReadWrite, Bits 7:0) 
  // General purpose input 2
  #define BIT_MSK__RX_HDCP2X_GP_IN2__RI_HDCP2_GP2_B7_B0                                    0xFF

// HDCP GP In 3 Register
#define REG_ADDR__RX_HDCP2X_GP_IN3                                          (RX_HDCP2 | 0x0023)
  // (ReadWrite, Bits 7:0) 
  // General purpose input 3
  #define BIT_MSK__RX_HDCP2X_GP_IN3__RI_HDCP2_GP3_B7_B0                                    0xFF

// HDCP GP Out 0 Register
#define REG_ADDR__RX_HDCP2X_GP_OUT0                                         (RX_HDCP2 | 0x0024)
  // (ReadOnly, Bits 7:0) 
  // Version Indicator. 0X: TX ROM                    5X: RX ROM 2X: TX RAM                     1X: RX RAM 8X: TX RAM                     9X: RX RAM 4X: Sydney TX RAM       3X: Sydney RX RAM 6X: RogueES0 TX RAM  7X: RogueES0 RX RAM
  #define BIT_MSK__RX_HDCP2X_GP_OUT0__RO_HDCP2_GP0_B7_B0                                    0xFF

// HDCP GP Out 1 Register
#define REG_ADDR__RX_HDCP2X_GP_OUT1                                         (RX_HDCP2 | 0x0025)
  // (ReadOnly, Bits 7:0) 
  // General purpose output 1
  #define BIT_MSK__RX_HDCP2X_GP_OUT1__RO_HDCP2_GP1_B7_B0                                    0xFF

// HDCP GP Out 2 Register
#define REG_ADDR__RX_HDCP2X_GP_OUT2                                         (RX_HDCP2 | 0x0026)
  // (ReadOnly, Bits 7:0) 
  // General purpose output 2
  #define BIT_MSK__RX_HDCP2X_GP_OUT2__RO_HDCP2_GP2_B7_B0                                    0xFF

// HDCP GP Out 3 Register
#define REG_ADDR__RX_HDCP2X_GP_OUT3                                         (RX_HDCP2 | 0x0027)
  // (ReadOnly, Bits 7:0) 
  // General purpose output 3
  #define BIT_MSK__RX_HDCP2X_GP_OUT3__RO_HDCP2_GP3_B7_B0                                    0xFF

// HDCP2 Rx ID_0 from Core Register
#define REG_ADDR__RX_HDCP2X_RX_ID_CORE_0                                    (RX_HDCP2 | 0x0028)
  // (ReadOnly, Bits 7:0) 
  // hdcp2 receiver ID from core For RX this 40-bit field is filled as soon as HDCP2x core starts running. For TX this 40-bit field is filled when Certification(including Receiver Device ID) is read from Rx.
  #define BIT_MSK__RX_HDCP2X_RX_ID_CORE_0__RO_HDCP2_RCVR_ID_B7_B0                                0xFF

// HDCP2 Rx ID_1 from Core Register
#define REG_ADDR__RX_HDCP2X_RX_ID_CORE_1                                    (RX_HDCP2 | 0x0029)
  // (ReadOnly, Bits 7:0) 
  // hdcp2 receiver ID from core
  #define BIT_MSK__RX_HDCP2X_RX_ID_CORE_1__RO_HDCP2_RCVR_ID_B15_B8                               0xFF

// HDCP2 Rx ID_2 from Core Register
#define REG_ADDR__RX_HDCP2X_RX_ID_CORE_2                                    (RX_HDCP2 | 0x002A)
  // (ReadOnly, Bits 7:0) 
  // hdcp2 receiver ID from core
  #define BIT_MSK__RX_HDCP2X_RX_ID_CORE_2__RO_HDCP2_RCVR_ID_B23_B16                              0xFF

// HDCP2 Rx ID_3 from Core Register
#define REG_ADDR__RX_HDCP2X_RX_ID_CORE_3                                    (RX_HDCP2 | 0x002B)
  // (ReadOnly, Bits 7:0) 
  // hdcp2 receiver ID from core
  #define BIT_MSK__RX_HDCP2X_RX_ID_CORE_3__RO_HDCP2_RCVR_ID_B31_B24                              0xFF

// HDCP2 Rx ID_4 from Core Register
#define REG_ADDR__RX_HDCP2X_RX_ID_CORE_4                                    (RX_HDCP2 | 0x002C)
  // (ReadOnly, Bits 7:0) 
  // hdcp2x receiver ID from core
  #define BIT_MSK__RX_HDCP2X_RX_ID_CORE_4__RO_HDCP2_RCVR_ID_B39_B32                              0xFF

// HDCP Misc Control 1 Register
#define REG_ADDR__RX_HDCP2X_RPT_DETAIL                                      (RX_HDCP2 | 0x002D)
  // (ReadWrite, Bits 0) 
  // For TX use this bit to read HDCP1DEV_DSTRM field of Receiver ID List message For RX use this bit to program HDCP1DEV_DSTRM field of Receiver ID List message
  #define BIT_MSK__RX_HDCP2X_RPT_DETAIL__RI_HDCP2RX_RPT_HDCP1DEV_DSTRM                         0x01
  // (ReadWrite, Bits 1) 
  // For TX use this bit to read HDCP20RPT_DSTRM field of Receiver ID List message For RX use this bit to program HDCP20RPT_DSTRM field of Receiver ID List message
  #define BIT_MSK__RX_HDCP2X_RPT_DETAIL__RI_HDCP2RX_RPT_HDCP20RPT_DSTRM                        0x02
  // (ReadWrite, Bits 2) 
  // For TX use this bit to read MAX_CASCADE_EXCEEDED  field of Receiver ID List message For RX use this bit to program MAX_CASCADE_EXCEEDED field of Receiver ID List message
  #define BIT_MSK__RX_HDCP2X_RPT_DETAIL__RI_HDCP2RX_RPT_MX_CASC_EXC                            0x04
  // (ReadWrite, Bits 3) 
  // For TX use this bit to read MAX_DEVICE_EXCEEDED  field of Receiver ID List message For RX use this bit to program MAX_DEVICE_EXCEEDED field of Receiver ID List message
  #define BIT_MSK__RX_HDCP2X_RPT_DETAIL__RI_HDCP2RX_RPT_MX_DEVS_EXC                            0x08

// HDCP RPT SMNG K Register
#define REG_ADDR__RX_HDCP2X_RPT_SMNG_K                                      (RX_HDCP2 | 0x002E)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to program K  field of Stream Management message For RX use this bit to read K field of Stream Manage message
  #define BIT_MSK__RX_HDCP2X_RPT_SMNG_K__RI_HDCP2TX_RPT_SMNG_K_B7_B0                           0xFF

// HDCP Depth Control Register
#define REG_ADDR__RX_HDCP2X_RPT_DEPTH                                       (RX_HDCP2 | 0x002F)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to read DEPTH  field of Receiver ID List message For RX use this bit to program DEPTH field of Receiver ID List message
  #define BIT_MSK__RX_HDCP2X_RPT_DEPTH__RI_HDCP2RX_RPT_DEPTH_B7_B0                            0xFF

// HDCP Devcnt Control Register
#define REG_ADDR__RX_HDCP2X_RPT_DEVCNT                                      (RX_HDCP2 | 0x0030)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to read DEVICE_COUNT  field of Receiver ID List message For RX use this bit to program DEVICE_COUNT field of Receiver ID List message
  #define BIT_MSK__RX_HDCP2X_RPT_DEVCNT__RI_HDCP2RX_RPT_DEVCNT_B7_B0                           0xFF

// HDCP RPT SEQ NUM V 0 Register
#define REG_ADDR__RX_HDCP2X_RX_SEQ_NUM_V_0                                  (RX_HDCP2 | 0x0031)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to read seq_num_V  field of Receiver ID List message For RX use this bit to program seq_num_V field of Receiver ID List message
  #define BIT_MSK__RX_HDCP2X_RX_SEQ_NUM_V_0__RI_HDCP2RX_RPT_SEQ_NUM_V_B7_B0                        0xFF

// HDCP RPT SEQ NUM V 1 Register
#define REG_ADDR__RX_HDCP2X_RX_SEQ_NUM_V_1                                  (RX_HDCP2 | 0x0032)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to read seq_num_V  field of Receiver ID List message For RX use this bit to program seq_num_V field of Receiver ID List message
  #define BIT_MSK__RX_HDCP2X_RX_SEQ_NUM_V_1__RI_HDCP2RX_RPT_SEQ_NUM_V_B15_B8                       0xFF

// HDCP RPT SEQ NUM V 2 Register
#define REG_ADDR__RX_HDCP2X_RX_SEQ_NUM_V_2                                  (RX_HDCP2 | 0x0033)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to read seq_num_V  field of Receiver ID List message For RX use this bit to program seq_num_V field of Receiver ID List message
  #define BIT_MSK__RX_HDCP2X_RX_SEQ_NUM_V_2__RI_HDCP2RX_RPT_SEQ_NUM_V_B23_B16                      0xFF

// HDCP RPT SEQ NUM M 0 Register
#define REG_ADDR__RX_HDCP2X_RX_SEQ_NUM_M_0                                  (RX_HDCP2 | 0x0034)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to program seq_num_M  field of Stream Management message For RX use this bit to read seq_num_M  field of Stream Manage message
  #define BIT_MSK__RX_HDCP2X_RX_SEQ_NUM_M_0__RI_HDCP2TX_RPT_SEQ_NUM_M_B7_B0                        0xFF

// HDCP RPT SEQ NUM M 1 Register
#define REG_ADDR__RX_HDCP2X_RX_SEQ_NUM_M_1                                  (RX_HDCP2 | 0x0035)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to program seq_num_M  field of Stream Management message For RX use this bit to read seq_num_M  field of Stream Manage message
  #define BIT_MSK__RX_HDCP2X_RX_SEQ_NUM_M_1__RI_HDCP2TX_RPT_SEQ_NUM_M_B15_B8                       0xFF

// HDCP RPT SEQ NUM M 2 Register
#define REG_ADDR__RX_HDCP2X_RX_SEQ_NUM_M_2                                  (RX_HDCP2 | 0x0036)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to program seq_num_M  field of Stream Management message For RX use this bit to read seq_num_M  field of Stream Manage message
  #define BIT_MSK__RX_HDCP2X_RX_SEQ_NUM_M_2__RI_HDCP2TX_RPT_SEQ_NUM_M_B23_B16                      0xFF

// HDCP Input Counter 0 Register
#define REG_ADDR__RX_HDCP2X_IPT_CTR_7TO0                                    (RX_HDCP2 | 0x0037)
  // (ReadOnly, Bits 7:0) 
  // Frame counter (input counter[33:26]) to monitor if input coutner value changes.
  #define BIT_MSK__RX_HDCP2X_IPT_CTR_7TO0__RO_HDCP2_IPT_CTR_B7_B0                                0xFF

// HDCP Input Counter 1 Register
#define REG_ADDR__RX_HDCP2X_IPT_CTR_15TO8                                   (RX_HDCP2 | 0x0038)
  // (ReadOnly, Bits 7:0) 
  // Frame counter (input counter[41:34]) to monitor if input coutner value changes.
  #define BIT_MSK__RX_HDCP2X_IPT_CTR_15TO8__RO_HDCP2_IPT_CTR_B15_B8                               0xFF

// HDCP AES Control Register
#define REG_ADDR__RX_HDCP2X_AESCTL                                          (RX_HDCP2 | 0x0039)
  // (ReadWrite, Bits 0) 
  // Apply manual AES reset
  #define BIT_MSK__RX_HDCP2X_AESCTL__RI_AES_RST_MAN                                        0x01
  // (ReadWrite, Bits 1) 
  // Apply AES reset when authdone=0
  #define BIT_MSK__RX_HDCP2X_AESCTL__RI_AES_RST_AUTHDONE                                   0x02

// HDCP Debug Control Register
#define REG_ADDR__RX_HDCP2X_DBGCTL                                          (RX_HDCP2 | 0x003A)
  // (ReadWrite, Bits 7:0) 
  // Debug control
  #define BIT_MSK__RX_HDCP2X_DBGCTL__RI_HDCP2_DBG_CTL_B7_B0                                0xFF

// HDCP Debug Control 2 Register
#define REG_ADDR__RX_HDCP2X_DBGCTL2                                         (RX_HDCP2 | 0x003B)
  // (ReadWrite, Bits 7:0) 
  // Debug control 2
  #define BIT_MSK__RX_HDCP2X_DBGCTL2__RI_HDCP2_DBG_CTL2_B7_B0                               0xFF

// HDCP Misc Control 0 Register
#define REG_ADDR__RX_HDCP2X_RX_CTRL_0                                       (RX_HDCP2 | 0x0040)
  // (ReadWrite, Bits 0) 
  // Valid only for Rx. Don't care for Tx. Write to Receiver ID List message buffer.
  #define BIT_MSK__RX_HDCP2X_RX_CTRL_0__RI_HDCP2RX_RPT_RCVID_WR                               0x01
  // (ReadWrite, Bits 1) 
  // Valid only for Rx. Don't care for Tx. Write 1 to reset Receiver ID List message buffer pointer to 0.
  #define BIT_MSK__RX_HDCP2X_RX_CTRL_0__RI_HDCP2RX_RPT_RCVID_WR_START                         0x02
  // (ReadWrite, Bits 2) 
  // Valid only for Rx. Don't care for Tx. Write 1 to start transfer of Receiver ID List message.
  #define BIT_MSK__RX_HDCP2X_RX_CTRL_0__RI_HDCP2RX_RPT_RCVID_XFER_START                       0x04
  // (ReadWrite, Bits 3) 
  // Valid only for Rx. Don't care for Tx. Read from Stream Manage message buffer.
  #define BIT_MSK__RX_HDCP2X_RX_CTRL_0__RI_HDCP2RX_RPT_SMNG_RD                                0x08
  // (ReadWrite, Bits 4) 
  // Valid only for Rx. Don't care for Tx. Write 1 to reset Stream Manage message buffer pointer to 0.
  #define BIT_MSK__RX_HDCP2X_RX_CTRL_0__RI_HDCP2RX_RPT_SMNG_RD_START                          0x10
  // (ReadWrite, Bits 5) 
  // Valid only for Rx. Don't care for Tx. 0: Clear reauth_req when RX_STATUS register is read out. 1: Clear reauth_req under internal 8051 control.
  #define BIT_MSK__RX_HDCP2X_RX_CTRL_0__RI_REAUTH_REQ_CLR_OPTION                              0x20
  // (ReadWrite, Bits 6) 
  // Valid only for Rx. Don't care for Tx. 0: Clear rpt_ready when RX_STATUS register is read out. 1: Clear rpt_ready under internal 8051 control.
  #define BIT_MSK__RX_HDCP2X_RX_CTRL_0__RI_RPT_READY_CLR_OPTION                               0x40
  // (ReadWrite, Bits 7) 
  // Valid only for Rx. Don't care for Tx. 0: Clear msg_sz when msg_send_done is asserted. 1: Clear msg_sz under internal 8051 control.
  #define BIT_MSK__RX_HDCP2X_RX_CTRL_0__RI_MSG_SZ_CLR_OPTION                                  0x80

// HDCP Misc Staus Register
#define REG_ADDR__RX_HDCP2X_RX_STATUS                                       (RX_HDCP2 | 0x0041)
  // (ReadOnly, Bits 2) 
  // Valid only for Rx. Don't care for Tx. Indicate that Receiver ID List message transfer is done. (Also connected to INTR1[4])
  #define BIT_MSK__RX_HDCP2X_RX_STATUS__RO_HDCP2RX_RPT_RCVID_XFER_DONE                        0x04

// HDCP RPT SMNG Out Register
#define REG_ADDR__RX_HDCP2X_RX_RPT_SMNG_OUT                                 (RX_HDCP2 | 0x0042)
  // (ReadOnly, Bits 7:0) 
  // Valid only for Rx. Don't care for Tx. Data output port for Stream Manage message buffer.
  #define BIT_MSK__RX_HDCP2X_RX_RPT_SMNG_OUT__RO_HDCP2RX_RPT_SMNG_OUT_B7_B0                         0xFF

// HDCP RPT RCVID In Register
#define REG_ADDR__RX_HDCP2X_RX_RPT_RCVID_IN                                 (RX_HDCP2 | 0x0043)
  // (ReadWrite, Bits 7:0) 
  // Valid only for Rx. Don't care for Tx. Write one byte to Receiver ID List message buffer.
  #define BIT_MSK__RX_HDCP2X_RX_RPT_RCVID_IN__RI_HDCP2RX_RPT_RCVID_IN                               0xFF

// HDCP ECC Control Register
#define REG_ADDR__RX_HDCP2X_RX_ECC_CTRL                                     (RX_HDCP2 | 0x0044)
  // (ReadWrite, Bits 0) 
  // Enable ECC based out-of-sync detection
  #define BIT_MSK__RX_HDCP2X_RX_ECC_CTRL__RI_ECC_CHK_EN                                         0x01
  // (ReadWrite, Bits 2:1) 
  // 00: accumulates ECC errors until it reaches a given threshold. 01: In a given number of consecutive frames in which ECC errors keep reaching the threshold 10: In a given number of consecutive frames we don't get any correct ECC 11: Accumulates ECC errors for a given number of frames
  #define BIT_MSK__RX_HDCP2X_RX_ECC_CTRL__RI_ECC_CHK_MODE                                       0x06
  // (ReadWrite, Bits 3) 
  // Write 1 then 0 to clear counter manually.
  #define BIT_MSK__RX_HDCP2X_RX_ECC_CTRL__RI_ACCM_ERR_MANU_CLR                                  0x08

// HDCP ECC Count for Check 0 Register
#define REG_ADDR__RX_HDCP2X_RX_ECC_CNT2CHK_0                                (RX_HDCP2 | 0x0045)
  // (ReadWrite, Bits 7:0) 
  // VSYNC count to skip before starting ECC check
  #define BIT_MSK__RX_HDCP2X_RX_ECC_CNT2CHK_0__RI_CNT2CHK_ECC_B7_B0                                  0xFF

// HDCP ECC Count for Check 1 Register
#define REG_ADDR__RX_HDCP2X_RX_ECC_CNT2CHK_1                                (RX_HDCP2 | 0x0046)
  // (ReadWrite, Bits 0) 
  // VSYNC count to skip before starting ECC check
  #define BIT_MSK__RX_HDCP2X_RX_ECC_CNT2CHK_1__RI_CNT2CHK_ECC_B8                                     0x01

// HDCP ECC ACCM Error Threshold 0 Register
#define REG_ADDR__RX_HDCP2X_RX_ECC_ACCM_ERR_THR_0                           (RX_HDCP2 | 0x0047)
  // (ReadWrite, Bits 7:0) 
  // Threadshold for accumulated ECC error
  #define BIT_MSK__RX_HDCP2X_RX_ECC_ACCM_ERR_THR_0__RI_ACCM_ERR_THR_B7_B0                                 0xFF

// HDCP ECC ACCM Error Threshold 1 Register
#define REG_ADDR__RX_HDCP2X_RX_ECC_ACCM_ERR_THR_1                           (RX_HDCP2 | 0x0048)
  // (ReadWrite, Bits 7:0) 
  // Threadshold for accumulated ECC error
  #define BIT_MSK__RX_HDCP2X_RX_ECC_ACCM_ERR_THR_1__RI_ACCM_ERR_THR_B15_B8                                0xFF

// HDCP ECC ACCM Error Threshold 2 Register
#define REG_ADDR__RX_HDCP2X_RX_ECC_ACCM_ERR_THR_2                           (RX_HDCP2 | 0x0049)
  // (ReadWrite, Bits 4:0) 
  // Threadshold for accumulated ECC error
  #define BIT_MSK__RX_HDCP2X_RX_ECC_ACCM_ERR_THR_2__RI_ACCM_ERR_THR_B20_B16                               0x1F

// HDCP ECC Frame Error Threshold 0 Register
#define REG_ADDR__RX_HDCP2X_RX_ECC_FRM_ERR_THR_0                            (RX_HDCP2 | 0x004A)
  // (ReadWrite, Bits 7:0) 
  // Threadshold for frame ECC error
  #define BIT_MSK__RX_HDCP2X_RX_ECC_FRM_ERR_THR_0__RI_FRAME_ECC_ERR_THR_B7_B0                            0xFF

// HDCP ECC Frame Error Threshold 1 Register
#define REG_ADDR__RX_HDCP2X_RX_ECC_FRM_ERR_THR_1                            (RX_HDCP2 | 0x004B)
  // (ReadWrite, Bits 7:0) 
  // Threadshold for frame ECC error
  #define BIT_MSK__RX_HDCP2X_RX_ECC_FRM_ERR_THR_1__RI_FRAME_ECC_ERR_THR_B15_B8                           0xFF

// HDCP ECC Consecutive Frames Error Threshold Register
#define REG_ADDR__RX_HDCP2X_RX_CONS_ERR_THR                                 (RX_HDCP2 | 0x004C)
  // (ReadWrite, Bits 7:0) 
  // Number of consecutive frames in which ECC error get threshold
  #define BIT_MSK__RX_HDCP2X_RX_CONS_ERR_THR__RI_CONS_ECC_ERR_THR_B7_B0                             0xFF

// HDCP ECC No Error Threshold Register
#define REG_ADDR__RX_HDCP2X_RX_ECC_NO_ERR_THR                               (RX_HDCP2 | 0x004D)
  // (ReadWrite, Bits 7:0) 
  // Number of consecutive frames that does not get correct ECC
  #define BIT_MSK__RX_HDCP2X_RX_ECC_NO_ERR_THR__RI_NO_ECC_THR_B7_B0                                   0xFF

// HDCP ECC Given Frame Error Register
#define REG_ADDR__RX_HDCP2X_RX_GVN_FRM                                      (RX_HDCP2 | 0x004E)
  // (ReadWrite, Bits 7:0) 
  // Number of consecutive frames in which accumulate ECC error
  #define BIT_MSK__RX_HDCP2X_RX_GVN_FRM__RI_GIVEN_FRAME_B7_B0                                  0xFF

// HDCP ECC Given Frame Error Threshold 0 Register
#define REG_ADDR__RX_HDCP2X_RX_ECC_GVN_FRM_ERR_THR_0                        (RX_HDCP2 | 0x004F)
  // (ReadWrite, Bits 7:0) 
  // Threshold for the number of ECC errors in given frames
  #define BIT_MSK__RX_HDCP2X_RX_ECC_GVN_FRM_ERR_THR_0__RI_GIVEN_FRAME_ERR_THR_B7_B0                          0xFF

// HDCP ECC Given Frame Error Threshold 1 Register
#define REG_ADDR__RX_HDCP2X_RX_ECC_GVN_FRM_ERR_THR_1                        (RX_HDCP2 | 0x0050)
  // (ReadWrite, Bits 7:0) 
  // Threshold for the number of ECC errors in given frames
  #define BIT_MSK__RX_HDCP2X_RX_ECC_GVN_FRM_ERR_THR_1__RI_GIVEN_FRAME_ERR_THR_B15_B8                         0xFF

// HDCP ECC Given Frame Error Threshold 2 Register
#define REG_ADDR__RX_HDCP2X_RX_ECC_GVN_FRM_ERR_THR_2                        (RX_HDCP2 | 0x0051)
  // (ReadWrite, Bits 4:0) 
  // Threshold for the number of ECC errors in given frames
  #define BIT_MSK__RX_HDCP2X_RX_ECC_GVN_FRM_ERR_THR_2__RI_GIVEN_FRAME_ERR_THR_B20_B16                        0x1F

// HDCP Misc Control 0 Register
#define REG_ADDR__RX_HDCP2X_TX_CTRL_0                                       (RX_HDCP2 | 0x0070)
  // (ReadWrite, Bits 0) 
  // Valid only for Tx. Don't care for Rx. Read from Receiver ID List message buffer.
  #define BIT_MSK__RX_HDCP2X_TX_CTRL_0__RI_HDCP2TX_RPT_RCVID_RD                               0x01
  // (ReadWrite, Bits 1) 
  // Valid only for Tx. Don't care for Rx. Write 1 to reset Receiver ID List message buffer pointer to 0.
  #define BIT_MSK__RX_HDCP2X_TX_CTRL_0__RI_HDCP2TX_RPT_RCVID_RD_START                         0x02
  // (ReadWrite, Bits 2) 
  // Valid only for Tx. Don't care for Rx. Write 1 to start transfer of Stream Manage message.
  #define BIT_MSK__RX_HDCP2X_TX_CTRL_0__RI_HDCP2TX_RPT_SMNG_XFER_START                        0x04
  // (ReadWrite, Bits 3) 
  // Valid only for Tx. Don't care for Rx. Write to Stream Manage message buffer.
  #define BIT_MSK__RX_HDCP2X_TX_CTRL_0__RI_HDCP2TX_RPT_SMNG_WR                                0x08
  // (ReadWrite, Bits 4) 
  // Valid only for Tx. Don't care for Rx. Write 1 to reset Stream Manage message buffer pointer to 0.
  #define BIT_MSK__RX_HDCP2X_TX_CTRL_0__RI_HDCP2TX_RPT_SMNG_WR_START                          0x10

// HDCP Misc Staus Register
#define REG_ADDR__RX_HDCP2X_TX_STATUS                                       (RX_HDCP2 | 0x0071)
  // (ReadOnly, Bits 2) 
  // Valid only for Tx. Don't care for Rx. Indicate that Stream Manage message transfer is done. (Also connected to INTR1[5])
  #define BIT_MSK__RX_HDCP2X_TX_STATUS__RO_HDCP2TX_RPT_SMNG_XFER_DONE                         0x04

// HDCP RPT SMNG In Register
#define REG_ADDR__RX_HDCP2X_TX_RPT_SMNG_IN                                  (RX_HDCP2 | 0x0072)
  // (ReadWrite, Bits 7:0) 
  // Valid only for Tx. Don't care for Rx. Write one byte to Stream Manage message buffer.
  #define BIT_MSK__RX_HDCP2X_TX_RPT_SMNG_IN__RI_HDCP2TX_RPT_SMNG_IN                                0xFF

// HDCP RPT RCVID Out Register
#define REG_ADDR__RX_HDCP2X_TX_RPT_RCVID_OUT                                (RX_HDCP2 | 0x0073)
  // (ReadOnly, Bits 7:0) 
  // Valid only for Tx. Don't care for Rx. Data output port for Receiver ID List message buffer.
  #define BIT_MSK__RX_HDCP2X_TX_RPT_RCVID_OUT__RO_HDCP2TX_RPT_RCVID_OUT_B7_B0                        0xFF

// HDCP Stream Count 0a Register
#define REG_ADDR__RX_HDCP2X_STM_CTR_0A                                      (RX_HDCP2 | 0x0080)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__RX_HDCP2X_STM_CTR_0A__RI_HDCP2TX_STM_CTR_B7_B0                              0xFF

// HDCP Stream Count 0b Register
#define REG_ADDR__RX_HDCP2X_STM_CTR_0B                                      (RX_HDCP2 | 0x0081)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__RX_HDCP2X_STM_CTR_0B__RI_HDCP2TX_STM_CTR_B15_B8                             0xFF

// HDCP Stream Count 0c Register
#define REG_ADDR__RX_HDCP2X_STM_CTR_0C                                      (RX_HDCP2 | 0x0082)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__RX_HDCP2X_STM_CTR_0C__RI_HDCP2TX_STM_CTR_B23_B16                            0xFF

// HDCP Stream Count 0d Register
#define REG_ADDR__RX_HDCP2X_STM_CTR_0D                                      (RX_HDCP2 | 0x0083)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__RX_HDCP2X_STM_CTR_0D__RI_HDCP2TX_STM_CTR_B31_B24                            0xFF

// HDCP Stream Count 1a Register
#define REG_ADDR__RX_HDCP2X_STM_CTR_1A                                      (RX_HDCP2 | 0x0084)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__RX_HDCP2X_STM_CTR_1A__RI_HDCP2TX_STM_CTR_B39_B32                            0xFF

// HDCP Stream Count 1b Register
#define REG_ADDR__RX_HDCP2X_STM_CTR_1B                                      (RX_HDCP2 | 0x0085)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__RX_HDCP2X_STM_CTR_1B__RI_HDCP2TX_STM_CTR_B47_B40                            0xFF

// HDCP Stream Count 1c Register
#define REG_ADDR__RX_HDCP2X_STM_CTR_1C                                      (RX_HDCP2 | 0x0086)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__RX_HDCP2X_STM_CTR_1C__RI_HDCP2TX_STM_CTR_B55_B48                            0xFF

// HDCP Stream Count 1d Register
#define REG_ADDR__RX_HDCP2X_STM_CTR_1D                                      (RX_HDCP2 | 0x0087)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__RX_HDCP2X_STM_CTR_1D__RI_HDCP2TX_STM_CTR_B63_B56                            0xFF

// HDCP Stream Count 2a Register
#define REG_ADDR__RX_HDCP2X_STM_CTR_2A                                      (RX_HDCP2 | 0x0088)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__RX_HDCP2X_STM_CTR_2A__RI_HDCP2TX_STM_CTR_B71_B64                            0xFF

// HDCP Stream Count 2b Register
#define REG_ADDR__RX_HDCP2X_STM_CTR_2B                                      (RX_HDCP2 | 0x0089)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__RX_HDCP2X_STM_CTR_2B__RI_HDCP2TX_STM_CTR_B79_B72                            0xFF

// HDCP Stream Count 2c Register
#define REG_ADDR__RX_HDCP2X_STM_CTR_2C                                      (RX_HDCP2 | 0x008A)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__RX_HDCP2X_STM_CTR_2C__RI_HDCP2TX_STM_CTR_B87_B80                            0xFF

// HDCP Stream Count 2d Register
#define REG_ADDR__RX_HDCP2X_STM_CTR_2D                                      (RX_HDCP2 | 0x008B)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__RX_HDCP2X_STM_CTR_2D__RI_HDCP2TX_STM_CTR_B95_B88                            0xFF

// HDCP Stream Count 3a Register
#define REG_ADDR__RX_HDCP2X_STM_CTR_3A                                      (RX_HDCP2 | 0x008C)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__RX_HDCP2X_STM_CTR_3A__RI_HDCP2TX_STM_CTR_B103_B96                           0xFF

// HDCP Stream Count 3b Register
#define REG_ADDR__RX_HDCP2X_STM_CTR_3B                                      (RX_HDCP2 | 0x008D)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__RX_HDCP2X_STM_CTR_3B__RI_HDCP2TX_STM_CTR_B111_B104                          0xFF

// HDCP Stream Count 3c Register
#define REG_ADDR__RX_HDCP2X_STM_CTR_3C                                      (RX_HDCP2 | 0x008E)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__RX_HDCP2X_STM_CTR_3C__RI_HDCP2TX_STM_CTR_B119_B112                          0xFF

// HDCP Stream Count 3d Register
#define REG_ADDR__RX_HDCP2X_STM_CTR_3D                                      (RX_HDCP2 | 0x008F)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__RX_HDCP2X_STM_CTR_3D__RI_HDCP2TX_STM_CTR_B127_B120                          0xFF

// 1FBF
#define REG_ADDR__RX_HDCP2_RX_ID_0                                          (RX_HDCP2 | 0x00A0)
  // (ReadOnly, Bits 7:0) 
  // hdcp2x receiver ID from otp
  #define BIT_MSK__RX_HDCP2_RX_ID_0__RO_RCV_ID_B7_B0                                       0xFF

// HDCP2 Rx ID1 Register
#define REG_ADDR__RX_HDCP2_RX_ID_1                                          (RX_HDCP2 | 0x00A1)
  // (ReadOnly, Bits 7:0) 
  // hdcp2x receiver ID from otp
  #define BIT_MSK__RX_HDCP2_RX_ID_1__RO_RCV_ID_B15_B8                                      0xFF

// HDCP2 Rx ID2 Register
#define REG_ADDR__RX_HDCP2_RX_ID_2                                          (RX_HDCP2 | 0x00A2)
  // (ReadOnly, Bits 7:0) 
  // hdcp2x receiver ID from otp
  #define BIT_MSK__RX_HDCP2_RX_ID_2__RO_RCV_ID_B23_B16                                     0xFF

// HDCP2 Rx ID3 Register
#define REG_ADDR__RX_HDCP2_RX_ID_3                                          (RX_HDCP2 | 0x00A3)
  // (ReadOnly, Bits 7:0) 
  // hdcp2x receiver ID from otp
  #define BIT_MSK__RX_HDCP2_RX_ID_3__RO_RCV_ID_B31_B24                                     0xFF

// HDCP2 Rx ID4 Register
#define REG_ADDR__RX_HDCP2_RX_ID_4                                          (RX_HDCP2 | 0x00A4)
  // (ReadOnly, Bits 7:0) 
  // hdcp2x receiver ID from otp
  #define BIT_MSK__RX_HDCP2_RX_ID_4__RO_RCV_ID_B39_B32                                     0xFF

// HDCP2x MBIST Control Register
#define REG_ADDR__RX_HDCP2X_MISC_CTRL                                    (RX_HDCP2 | 0x00A5)
  // (ReadWrite, Bits 0) 
  // Set HPD to HDCP2x Core. This field when HIGH set the HPD HIGH else drives the HPD Pad state to HDCP2x.
  #define BIT_MSK__RX_HDCP2X_MISC_CTRL__RI_HDCP2X_SET_HPD                                     0x01

// HDCP2X Interrupt Status Register
#define REG_ADDR__RX_HDCP2X_INTR                                         (RX_HDCP2 | 0x00B6)
  // (ReadWrite, Bits 0) 
  // This interrupt is asserted when the number of ecc errors received exceed the programmed threshold value in the regiser ri_frame_ecc_err_thr. Write 1 to clear
  #define BIT_MSK__RX_HDCP2X_INTR__REG_ECC_OUT_OF_SYNC_INTR                              0x01

// HDCP2X Interrupt Status Mask Register
#define REG_ADDR__RX_HDCP2X_INTR_MASK                                    (RX_HDCP2 | 0x00B7)
  // (ReadWrite, Bits 0) 
  // Enable RX_HDCP2X_INTR[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__RX_HDCP2X_INTR_MASK__REG_HDCP2X_INTR_MASK0                                 0x01

// HDCP Ring OSC Bist Mode Register
#define REG_ADDR__RX_HDCP2X_ROSC_BIST                                    (RX_HDCP2 | 0x00B8)
  // (ReadWrite, Bits 0) 
  // ringosc bist start
  #define BIT_MSK__RX_HDCP2X_ROSC_BIST__RI_HDCP2X_RINGOSC_BIST_START                          0x01
  // (ReadOnly, Bits 1) 
  // ringosc bist done
  #define BIT_MSK__RX_HDCP2X_ROSC_BIST__RO_HDCP2X_RINGOSC_BIST_DONE                           0x02
  // (ReadOnly, Bits 2) 
  // Check this bit when ringosc bist done. 1: bist fail 0: bist success
  #define BIT_MSK__RX_HDCP2X_ROSC_BIST__RO_HDCP2X_RINGOSC_BIST_FAIL                           0x04

// HDCP2x MBIST Control Register
#define REG_ADDR__RX_HDCP2X_MBIST_CTRL                                   (RX_HDCP2 | 0x00B9)
  // (ReadWrite, Bits 0) 
  // HDCP2x Bist Mode control for internal memories.
  #define BIT_MSK__RX_HDCP2X_MBIST_CTRL__RI_HDCP2X_BIST_MODE                                   0x01

// HDCP2x MBIST Status Register
#define REG_ADDR__RX_HDCP2X_MBIST_STS                                    (RX_HDCP2 | 0x00BA)
  // (ReadOnly, Bits 0) 
  // MBIST Fail Status of HDCP2x internal ROM 32768x8.
  #define BIT_MSK__RX_HDCP2X_MBIST_STS__MBIST_FAIL_ROM32768X8                                 0x01
  // (ReadOnly, Bits 1) 
  // MBIST Finish Status of HDCP2x internal ROM 32768x8.
  #define BIT_MSK__RX_HDCP2X_MBIST_STS__MBIST_FINISH_ROM32768X8                               0x02
  // (ReadOnly, Bits 2) 
  // MBIST Fail Status of HDCP2x internal SPRAM 16384x8.
  #define BIT_MSK__RX_HDCP2X_MBIST_STS__MBIST_FAIL_SPRAM16384X8                               0x04
  // (ReadOnly, Bits 3) 
  // MBIST Finish Status of HDCP2x internal SPRAM 16384x8.
  #define BIT_MSK__RX_HDCP2X_MBIST_STS__MBIST_FINISH_SPRAM16384X8                             0x08
  // (ReadOnly, Bits 4) 
  // MBIST Fail Status of HDCP2x internal SPRAM 1024x32.
  #define BIT_MSK__RX_HDCP2X_MBIST_STS__MBIST_FAIL_SPRAM1024X32                               0x10
  // (ReadOnly, Bits 5) 
  // MBIST Finish Status of HDCP2x internal SPRAM 1024x32
  #define BIT_MSK__RX_HDCP2X_MBIST_STS__MBIST_FINISH_SPRAM1024X32                             0x20
  // (ReadOnly, Bits 6) 
  // MBIST Fail Status of HDCP2x internal SPRAM 256x8.
  #define BIT_MSK__RX_HDCP2X_MBIST_STS__MBIST_FAIL_SPRAM256X8                                 0x40
  // (ReadOnly, Bits 7) 
  // MBIST Finish Status of HDCP2x internal SPRAM 256x8.
  #define BIT_MSK__RX_HDCP2X_MBIST_STS__MBIST_FINISH_SPRAM256X8                               0x80

// HDCP2x NVM BIST Control Register
#define REG_ADDR__RX_HDCP2X_NVM_BIST_CTRL                                (RX_HDCP2 | 0x00BE)
  // (ReadWrite, Bits 0) 
  // NVM BIST Enable This field controls the enabling of the NVM BIST. 0 - NVM BIST Disabled 1 - NVM BIST Enabled
  #define BIT_MSK__RX_HDCP2X_NVM_BIST_CTRL__RI_HDCP2X_NVM_BIST_EN                                 0x01
  // (ReadWrite, Bits 7:4) 
  // NVM BIST Mode [4] - Controls OTP0 CRC BIST [5] - Controls OTP1 CRC BIST [6] - Controls OTP0 SHA BIST [7] - Controls OTP1 SHA BIST Value per bit is interpreted as below 0 - NVM BIST Disabled 1 - NVM BIST Enabled
  #define BIT_MSK__RX_HDCP2X_NVM_BIST_CTRL__RI_HDCP2X_NVM_BIST_MODE                               0xF0

//***************************************************************************
// DSC_ENC_CORE. Address: 60
// DSC PPS(Picture Parameter Set) Byte8192 Register
#define REG_ADDR__DSC_PPS_8192                                           (DSC_ENC_CORE | 0x0000)
  // (ReadWrite, Bits 3:0) 
  // This value contains the minor version of DSC. It shall be equal to 0 for encoders that implement this specification.
  #define BIT_MSK__DSC_PPS_8192__PPS_DSC_VER_MINOR                                     0x0F
  // (ReadWrite, Bits 7:4) 
  // This value contains the major version of DSC. It shall be equal to 1 for encoders that implement this specification.
  #define BIT_MSK__DSC_PPS_8192__PPS_DSC_VER_MAJOR                                     0xF0

// DSC PPS(Picture Parameter Set) Byte8193 Register
#define REG_ADDR__DSC_PPS_8193                                           (DSC_ENC_CORE | 0x0001)
  // (ReadWrite, Bits 7:0) 
  // This value is an application-specific identifier that can be used to differentiate between different PPS tables. If the application specification does not specify an application-specific means of PPS transmission (see section 8.1.2); this value shall be equal to 0.
  #define BIT_MSK__DSC_PPS_8193__PPS_IDENTIFIER                                        0xFF

// DSC PPS(Picture Parameter Set) Byte8194 Register
#define REG_ADDR__DSC_PPS_8194                                           (DSC_ENC_CORE | 0x0002)

// DSC PPS(Picture Parameter Set) Byte8195 Register
#define REG_ADDR__DSC_PPS_8195                                           (DSC_ENC_CORE | 0x0003)
  // (ReadWrite, Bits 3:0) 
  // This value contains the line buffer bit depth used to generate the stream. If the bit depth of a component (after color-space conversion; see section 10.1) is greater than this value; the line storage rounds the reconstructed values to this number of bits. It shall be in the range of 8 to 13 inclusive.
  #define BIT_MSK__DSC_PPS_8195__PPS_LINEBUF_DEPTH                                     0x0F
  // (ReadWrite, Bits 7:4) 
  // This value indicates the number of bits per component for the original pixels of the encoded picture. It shall be equal to 8 10 or 12.
  #define BIT_MSK__DSC_PPS_8195__PPS_BITS_PER_COMPONENT                                0xF0

// DSC PPS(Picture Parameter Set) Byte8196 Register
#define REG_ADDR__DSC_PPS_8196                                           (DSC_ENC_CORE | 0x0004)
  // (ReadWrite, Bits 1:0) 
  // This value specifies the target bits/pixel (bpp) rate that was used by the encoder in steps of 1/16 of a bit per pixel. Only values greater than or equal to 6 bpp are allowed. If vbr_enable is set to 0; this value must be less than or equal to the sustained rate that would apply if MPP were always selected; which is a function of bits_per_component; convert_rgb; and rc_range_parameters[0].
  #define BIT_MSK__DSC_PPS_8196__PPS_BITS_PER_PIXEL_B9B8                               0x03
  // (ReadWrite, Bits 2) 
  // This flag enables on/off VBR mode if it is supported by the decoder and the transport (see section 7.7.2). Encoders are required to support any mode that is supported by the transport. (Not Supported)
  #define BIT_MSK__DSC_PPS_8196__PPS_VBR_ENABLE                                        0x04
  // (ReadWrite, Bits 3) 
  // This flag indicates whether or not the input uses 4:2:2 sampling. (Not Supported)
  #define BIT_MSK__DSC_PPS_8196__PPS_ENABLE_422                                        0x08
  // (ReadWrite, Bits 4) 
  // This flag indicates whether the compressed stream encodes RGB that was converted to YCoCg. If it is set to 0; the color space is YCbCr. If it is set to 1; the decoder performs a color space conversion from YCoCg to RGB.
  #define BIT_MSK__DSC_PPS_8196__PPS_CONVERT_RGB                                       0x10
  // (ReadWrite, Bits 5) 
  // This flag indicates that the decoder needs to select between block prediction and MMAP using the method described in section 10.4.4.1. If it is set to 0; no BP is used to code the picture. (Not Supported)
  #define BIT_MSK__DSC_PPS_8196__PPS_BLOCK_PRED_ENABLE                                 0x20

// DSC PPS(Picture Parameter Set) Byte8197 Register
#define REG_ADDR__DSC_PPS_8197                                           (DSC_ENC_CORE | 0x0005)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the target bits/pixel (bpp) rate that was used by the encoder in steps of 1/16 of a bit per pixel. Only values greater than or equal to 6 bpp are allowed. If vbr_enable is set to 0; this value must be less than or equal to the sustained rate that would apply if MPP were always selected; which is a function of bits_per_component; convert_rgb; and rc_range_parameters[0].
  #define BIT_MSK__DSC_PPS_8197__PPS_BITS_PER_PIXEL_B7B0                               0xFF

// DSC PPS(Picture Parameter Set) Byte8198 Register
#define REG_ADDR__DSC_PPS_8198                                           (DSC_ENC_CORE | 0x0006)
  // (ReadWrite, Bits 7:0) 
  // pic_height specifies the number of rows of pixels in the raster. Although not required; it is suggested that pic_height be close to integer multiples of slice_height.
  #define BIT_MSK__DSC_PPS_8198__PPS_PIC_HEIGHT_B15B8                                  0xFF

// DSC PPS(Picture Parameter Set) Byte8199 Register
#define REG_ADDR__DSC_PPS_8199                                           (DSC_ENC_CORE | 0x0007)
  // (ReadWrite, Bits 7:0) 
  // pic_height specifies the number of rows of pixels in the raster. Although not required; it is suggested that pic_height be close to integer multiples of slice_height.
  #define BIT_MSK__DSC_PPS_8199__PPS_PIC_HEIGHT_B7B0                                   0xFF

// DSC PPS(Picture Parameter Set) Byte8200 Register
#define REG_ADDR__DSC_PPS_8200                                           (DSC_ENC_CORE | 0x0008)
  // (ReadWrite, Bits 7:0) 
  // pic_width specifies the number of columns of pixels. Although not required; it is suggested that pic_width be close to integer multiples of slice_width.
  #define BIT_MSK__DSC_PPS_8200__PPS_PIC_WIDTH_B15B8                                   0xFF

// DSC PPS(Picture Parameter Set) Byte8201 Register
#define REG_ADDR__DSC_PPS_8201                                           (DSC_ENC_CORE | 0x0009)
  // (ReadWrite, Bits 7:0) 
  // pic_width specifies the number of columns of pixels. Although not required; it is suggested that pic_width be close to integer multiples of slice_width.
  #define BIT_MSK__DSC_PPS_8201__PPS_PIC_WIDTH_B7B0                                    0xFF

// DSC PPS(Picture Parameter Set) Byte8202 Register
#define REG_ADDR__DSC_PPS_8202                                           (DSC_ENC_CORE | 0x000A)
  // (ReadWrite, Bits 7:0) 
  // These values specify the slice size for each slice. All slices that comprise a single picture are required to have an identical size. If the pic_height is not evenly divisible by the slice_height; the bottom row of pixels is replicated to pad the bottom-most slice(s) to be the same height as the other slices. The transport must allocate transmission time for sending the compressed bits corresponding to any replicated pixels.
  #define BIT_MSK__DSC_PPS_8202__PPS_SLICE_HEIGHT_B15B8                                0xFF

// DSC PPS(Picture Parameter Set) Byte8203 Register
#define REG_ADDR__DSC_PPS_8203                                           (DSC_ENC_CORE | 0x000B)
  // (ReadWrite, Bits 7:0) 
  // These values specify the slice size for each slice. All slices that comprise a single picture are required to have an identical size. If the pic_height is not evenly divisible by the slice_height; the bottom row of pixels is replicated to pad the bottom-most slice(s) to be the same height as the other slices. The transport must allocate transmission time for sending the compressed bits corresponding to any replicated pixels.
  #define BIT_MSK__DSC_PPS_8203__PPS_SLICE_HEIGHT_B7B0                                 0xFF

// DSC PPS(Picture Parameter Set) Byte8204 Register
#define REG_ADDR__DSC_PPS_8204                                           (DSC_ENC_CORE | 0x000C)
  // (ReadWrite, Bits 7:0) 
  // These values specify the slice size for each slice. All slices that comprise a single picture are required to have an identical size. If the pic_width is not evenly divisible by the slice_width; the rightmost column of pixels is replicated to pad the rightmost slices to be the same width as the other slices. The transport must allocate transmission time for sending the compressed bits corresponding to any replicated pixels.
  #define BIT_MSK__DSC_PPS_8204__PPS_SLICE_WIDTH_B15B8                                 0xFF

// DSC PPS(Picture Parameter Set) Byte8205 Register
#define REG_ADDR__DSC_PPS_8205                                           (DSC_ENC_CORE | 0x000D)
  // (ReadWrite, Bits 7:0) 
  // These values specify the slice size for each slice. All slices that comprise a single picture are required to have an identical size. If the pic_width is not evenly divisible by the slice_width; the rightmost column of pixels is replicated to pad the rightmost slices to be the same width as the other slices. The transport must allocate transmission time for sending the compressed bits corresponding to any replicated pixels.
  #define BIT_MSK__DSC_PPS_8205__PPS_SLICE_WIDTH_B7B0                                  0xFF

// DSC PPS(Picture Parameter Set) Byte8206 Register
#define REG_ADDR__DSC_PPS_8206                                           (DSC_ENC_CORE | 0x000E)
  // (ReadWrite, Bits 7:0) 
  // This value indicates the size in bytes of the chunks that are used for slice multiplexing (see section 8.2.2). If vbr_enable is set to 1; this is the maximum size of the chunks. This value shall be set to ceil(bits_per_pixel * slice_width / 8).
  #define BIT_MSK__DSC_PPS_8206__PPS_CHUNK_SIZE_B15B8                                  0xFF

// DSC PPS(Picture Parameter Set) Byte8207 Register
#define REG_ADDR__DSC_PPS_8207                                           (DSC_ENC_CORE | 0x000F)
  // (ReadWrite, Bits 7:0) 
  // This value indicates the size in bytes of the chunks that are used for slice multiplexing (see section 8.2.2). If vbr_enable is set to 1; this is the maximum size of the chunks. This value shall be set to ceil(bits_per_pixel * slice_width / 8).
  #define BIT_MSK__DSC_PPS_8207__PPS_CHUNK_SIZE_B7B0                                   0xFF

// DSC PPS(Picture Parameter Set) Byte8208 Register
#define REG_ADDR__DSC_PPS_8208                                           (DSC_ENC_CORE | 0x0010)
  // (ReadWrite, Bits 1:0) 
  // This value specifies the number of pixel times that the decoder accumulates data in its rate buffer before starting to decode and output pixels.
  #define BIT_MSK__DSC_PPS_8208__PPS_INITIAL_XMIT_DELAY_B9B8                           0x03

// DSC PPS(Picture Parameter Set) Byte8209 Register
#define REG_ADDR__DSC_PPS_8209                                           (DSC_ENC_CORE | 0x0011)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the number of pixel times that the decoder accumulates data in its rate buffer before starting to decode and output pixels.
  #define BIT_MSK__DSC_PPS_8209__PPS_INITIAL_XMIT_DELAY_B7B0                           0xFF

// DSC PPS(Picture Parameter Set) Byte8210 Register
#define REG_ADDR__DSC_PPS_8210                                           (DSC_ENC_CORE | 0x0012)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the number of pixel times that the decoder accumulates data in its rate buffer before starting to decode and output pixels.
  #define BIT_MSK__DSC_PPS_8210__PPS_INITIAL_DEC_DELAY_B15B8                           0xFF

// DSC PPS(Picture Parameter Set) Byte8211 Register
#define REG_ADDR__DSC_PPS_8211                                           (DSC_ENC_CORE | 0x0013)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the number of pixel times that the decoder accumulates data in its rate buffer before starting to decode and output pixels.
  #define BIT_MSK__DSC_PPS_8211__PPS_INITIAL_DEC_DELAY_B7B0                            0xFF

// DSC PPS(Picture Parameter Set) Byte8212 Register
#define REG_ADDR__DSC_PPS_8212                                           (DSC_ENC_CORE | 0x0014)

// DSC PPS(Picture Parameter Set) Byte8213 Register
#define REG_ADDR__DSC_PPS_8213                                           (DSC_ENC_CORE | 0x0015)
  // (ReadWrite, Bits 5:0) 
  // This value specifies the initial value for rcXformScale used at the beginning of a slice (see section 10.8.2).
  #define BIT_MSK__DSC_PPS_8213__PPS_INITIAL_SCALE_VALUE                               0x3F

// DSC PPS(Picture Parameter Set) Byte8214 Register
#define REG_ADDR__DSC_PPS_8214                                           (DSC_ENC_CORE | 0x0016)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the number of group times between incrementing the rcXformScale factor at the end of a slice (see section 10.8.2).
  #define BIT_MSK__DSC_PPS_8214__PPS_SCALE_INCREMENT_INTERVAL_B15B8                    0xFF

// DSC PPS(Picture Parameter Set) Byte8215 Register
#define REG_ADDR__DSC_PPS_8215                                           (DSC_ENC_CORE | 0x0017)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the number of group times between incrementing the rcXformScale factor at the end of a slice (see section 10.8.2).
  #define BIT_MSK__DSC_PPS_8215__PPS_SCALE_INCREMENT_INTERVAL_B7B0                     0xFF

// DSC PPS(Picture Parameter Set) Byte8216 Register
#define REG_ADDR__DSC_PPS_8216                                           (DSC_ENC_CORE | 0x0018)
  // (ReadWrite, Bits 3:0) 
  // This value specifies the number of group times between decrementing the rcXformScale factor at the beginning of a slice (see section 10.8.2).
  #define BIT_MSK__DSC_PPS_8216__PPS_SCALE_DECREMENT_INTERVAL_B11B8                    0x0F

// DSC PPS(Picture Parameter Set) Byte8217 Register
#define REG_ADDR__DSC_PPS_8217                                           (DSC_ENC_CORE | 0x0019)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the number of group times between decrementing the rcXformScale factor at the beginning of a slice (see section 10.8.2).
  #define BIT_MSK__DSC_PPS_8217__PPS_SCALE_DECREMENT_INTERVAL_B7B0                     0xFF

// DSC PPS(Picture Parameter Set) Byte8218 Register
#define REG_ADDR__DSC_PPS_8218                                           (DSC_ENC_CORE | 0x001A)

// DSC PPS(Picture Parameter Set) Byte8219 Register
#define REG_ADDR__DSC_PPS_8219                                           (DSC_ENC_CORE | 0x001B)
  // (ReadWrite, Bits 4:0) 
  // This value specifies the number of additional bits that are allocated for each group on the first line of a slice.
  #define BIT_MSK__DSC_PPS_8219__PPS_FIRST_LINE_BPG_OFS                                0x1F

// DSC PPS(Picture Parameter Set) Byte8220 Register
#define REG_ADDR__DSC_PPS_8220                                           (DSC_ENC_CORE | 0x001C)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the number of bits (including fractional bits) that are de-allocated for each group for groups after the first line of a slice. If the first line has an additional bit budget; the additional bits that were allocated need to come out of the budget for coding the rest of the slice. Therefore; the nfl_bpg_offset parameter must be set to first_line_bpg_offset / (slice_height  1) rounded up to 16 fractional bits.
  #define BIT_MSK__DSC_PPS_8220__PPS_NFL_BPG_OFFSET_B15B8                              0xFF

// DSC PPS(Picture Parameter Set) Byte8221 Register
#define REG_ADDR__DSC_PPS_8221                                           (DSC_ENC_CORE | 0x001D)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the number of bits (including fractional bits) that are de-allocated for each group for groups after the first line of a slice. If the first line has an additional bit budget; the additional bits that were allocated need to come out of the budget for coding the rest of the slice. Therefore; the nfl_bpg_offset parameter must be set to first_line_bpg_offset / (slice_height  1) rounded up to 16 fractional bits.
  #define BIT_MSK__DSC_PPS_8221__PPS_NFL_BPG_OFFSET_B7B0                               0xFF

// DSC PPS(Picture Parameter Set) Byte8222 Register
#define REG_ADDR__DSC_PPS_8222                                           (DSC_ENC_CORE | 0x001E)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the number of bits (including fractional bits) that are de-allocated for each group in order to enforce the slice constraint (i.e. that the final fullness cannot exceed the initial transmission delay * bits per group) while allowing a programmable initial_offset. If the initial RC model condition is not completely full the difference between the initial RC model offset (initial_offset) and the RC model size (rc_model_size) must be accounted for. The slice_bpg_offset provides a means to make up this difference. In addition the slice_bpg_offset allows the rate control to account for bits that may be lost to SSM at the end of a slice. The value must be set to (rc_model_size . initial_offset + numExtraMuxBits) / groupsTotal (rounded up to 16 fractional bits) where numExtraMuxBits and groupsTotal are defined in Annex E . Derivation of rate control parameters (informative).
  #define BIT_MSK__DSC_PPS_8222__PPS_SLICE_BPG_OFFSET_B15B8                            0xFF

// DSC PPS(Picture Parameter Set) Byte8223 Register
#define REG_ADDR__DSC_PPS_8223                                           (DSC_ENC_CORE | 0x001F)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the number of bits (including fractional bits) that are de-allocated for each group in order to enforce the slice constraint (i.e. that the final fullness cannot exceed the initial transmission delay * bits per group) while allowing a programmable initial_offset. If the initial RC model condition is not completely full the difference between the initial RC model offset (initial_offset) and the RC model size (rc_model_size) must be accounted for. The slice_bpg_offset provides a means to make up this difference. In addition the slice_bpg_offset allows the rate control to account for bits that may be lost to SSM at the end of a slice. The value must be set to (rc_model_size . initial_offset + numExtraMuxBits) / groupsTotal (rounded up to 16 fractional bits) where numExtraMuxBits and groupsTotal are defined in Annex E . Derivation of rate control parameters (informative).
  #define BIT_MSK__DSC_PPS_8223__PPS_SLICE_BPG_OFFSET_B7B0                             0xFF

// DSC PPS(Picture Parameter Set) Byte8224 Register
#define REG_ADDR__DSC_PPS_8224                                           (DSC_ENC_CORE | 0x0020)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the initial value for rcXformOffset which is initial_offset - rc_model_size at the start of a slice (see section 10.8.2).
  #define BIT_MSK__DSC_PPS_8224__PPS_INITIAL_OFFSET_B15B8                              0xFF

// DSC PPS(Picture Parameter Set) Byte8225 Register
#define REG_ADDR__DSC_PPS_8225                                           (DSC_ENC_CORE | 0x0021)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the initial value for rcXformOffset which is initial_offset - rc_model_size at the start of a slice (see section 10.8.2).
  #define BIT_MSK__DSC_PPS_8225__PPS_INITIAL_OFFSET_B7B0                               0xFF

// DSC PPS(Picture Parameter Set) Byte8226 Register
#define REG_ADDR__DSC_PPS_8226                                           (DSC_ENC_CORE | 0x0022)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the maximum end-of-slice value for rcXformOffset which is final_offset  rc_model_size (see section 10.8.2). The final_offset must be equal to rc_model_size  initial_xmit_delay * bits_per_pixel + numExtraMuxBits in order to ensure HRD compliance where numExtraMuxBits is defined in Annex E  Derivation of rate control parameters (informative).
  #define BIT_MSK__DSC_PPS_8226__PPS_FINAL_OFFSET_B15B8                                0xFF

// DSC PPS(Picture Parameter Set) Byte8227 Register
#define REG_ADDR__DSC_PPS_8227                                           (DSC_ENC_CORE | 0x0023)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the maximum end-of-slice value for rcXformOffset which is final_offset  rc_model_size (see section 10.8.2). The final_offset must be equal to rc_model_size  initial_xmit_delay * bits_per_pixel + numExtraMuxBits in order to ensure HRD compliance where numExtraMuxBits is defined in Annex E  Derivation of rate control parameters (informative).
  #define BIT_MSK__DSC_PPS_8227__PPS_FINAL_OFFSET_B7B0                                 0xFF

// DSC PPS(Picture Parameter Set) Byte8228 Register
#define REG_ADDR__DSC_PPS_8228                                           (DSC_ENC_CORE | 0x0024)
  // (ReadWrite, Bits 4:0) 
  // This value specifies the minimum QP where flatness is signaled and the flatness QP adjustment is made.
  #define BIT_MSK__DSC_PPS_8228__PPS_FLATNESS_MIN_QP                                   0x1F

// DSC PPS(Picture Parameter Set) Byte8229 Register
#define REG_ADDR__DSC_PPS_8229                                           (DSC_ENC_CORE | 0x0025)
  // (ReadWrite, Bits 4:0) 
  // This value specifies the maximum QP where flatness is signaled and the flatness QP adjustment is made.
  #define BIT_MSK__DSC_PPS_8229__PPS_FLATNESS_MAX_QP                                   0x1F

// DSC PPS(Picture Parameter Set) Byte8230 Register
#define REG_ADDR__DSC_PPS_8230                                           (DSC_ENC_CORE | 0x0026)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the number of bits in the RC model which is described in section 10.8.2.
  #define BIT_MSK__DSC_PPS_8230__PPS_RC_MODEL_SIZE_B15B8                               0xFF

// DSC PPS(Picture Parameter Set) Byte8231 Register
#define REG_ADDR__DSC_PPS_8231                                           (DSC_ENC_CORE | 0x0027)
  // (ReadWrite, Bits 7:0) 
  // This value specifies the number of bits in the RC model which is described in section 10.8.2.
  #define BIT_MSK__DSC_PPS_8231__PPS_RC_MODEL_SIZE_B7B0                                0xFF

// DSC PPS(Picture Parameter Set) Byte8232 Register
#define REG_ADDR__DSC_PPS_8232                                           (DSC_ENC_CORE | 0x0028)
  // (ReadWrite, Bits 3:0) 
  // This value is compared to the ratio of current activity to previous activity in order to determine the presence of an edge which in turn determines whether or not the QP is incremented in the short-term rate control (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8232__PPS_RC_EDGE_FACTOR                                    0x0F

// DSC PPS(Picture Parameter Set) Byte8233 Register
#define REG_ADDR__DSC_PPS_8233                                           (DSC_ENC_CORE | 0x0029)
  // (ReadWrite, Bits 4:0) 
  // This value is a QP threshold that is used in the short-term rate control (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8233__PPS_RC_QUANT_INCR_LIMIT0                              0x1F

// DSC PPS(Picture Parameter Set) Byte8234 Register
#define REG_ADDR__DSC_PPS_8234                                           (DSC_ENC_CORE | 0x002A)
  // (ReadWrite, Bits 4:0) 
  // This value is a QP threshold that is used in the short-term rate control (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8234__PPS_RC_QUANT_INCR_LIMIT1                              0x1F

// DSC PPS(Picture Parameter Set) Byte8235 Register
#define REG_ADDR__DSC_PPS_8235                                           (DSC_ENC_CORE | 0x002B)
  // (ReadWrite, Bits 3:0) 
  // This value specifies the lower end of the range of variability around the target bits per group that is allowed by the short-term rate control (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8235__PPS_RC_TGT_OFFSET_LO                                  0x0F
  // (ReadWrite, Bits 7:4) 
  // This value specifies the upper end of the range of variability around the target bits per group that is allowed by the short-term rate control (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8235__PPS_RC_TGT_OFFSET_HI                                  0xF0

// DSC PPS(Picture Parameter Set) Byte8236 Register
#define REG_ADDR__DSC_PPS_8236                                           (DSC_ENC_CORE | 0x002C)
  // (ReadWrite, Bits 7:0) 
  // These values specify the thresholds in the RC model for the 15 ranges (see section 10.8.3). There are 6 LSBs appended to each value.
  #define BIT_MSK__DSC_PPS_8236__PPS_RC_BUF_THRESH0                                    0xFF

// DSC PPS(Picture Parameter Set) Byte8237 Register
#define REG_ADDR__DSC_PPS_8237                                           (DSC_ENC_CORE | 0x002D)
  // (ReadWrite, Bits 7:0) 
  // These values specify the thresholds in the RC model for the 15 ranges (see section 10.8.3). There are 6 LSBs appended to each value.
  #define BIT_MSK__DSC_PPS_8237__PPS_RC_BUF_THRESH1                                    0xFF

// DSC PPS(Picture Parameter Set) Byte8238 Register
#define REG_ADDR__DSC_PPS_8238                                           (DSC_ENC_CORE | 0x002E)
  // (ReadWrite, Bits 7:0) 
  // These values specify the thresholds in the RC model for the 15 ranges (see section 10.8.3). There are 6 LSBs appended to each value.
  #define BIT_MSK__DSC_PPS_8238__PPS_RC_BUF_THRESH2                                    0xFF

// DSC PPS(Picture Parameter Set) Byte8239 Register
#define REG_ADDR__DSC_PPS_8239                                           (DSC_ENC_CORE | 0x002F)
  // (ReadWrite, Bits 7:0) 
  // These values specify the thresholds in the RC model for the 15 ranges (see section 10.8.3). There are 6 LSBs appended to each value.
  #define BIT_MSK__DSC_PPS_8239__PPS_RC_BUF_THRESH3                                    0xFF

// DSC PPS(Picture Parameter Set) Byte8240 Register
#define REG_ADDR__DSC_PPS_8240                                           (DSC_ENC_CORE | 0x0030)
  // (ReadWrite, Bits 7:0) 
  // These values specify the thresholds in the RC model for the 15 ranges (see section 10.8.3). There are 6 LSBs appended to each value.
  #define BIT_MSK__DSC_PPS_8240__PPS_RC_BUF_THRESH4                                    0xFF

// DSC PPS(Picture Parameter Set) Byte8241 Register
#define REG_ADDR__DSC_PPS_8241                                           (DSC_ENC_CORE | 0x0031)
  // (ReadWrite, Bits 7:0) 
  // These values specify the thresholds in the RC model for the 15 ranges (see section 10.8.3). There are 6 LSBs appended to each value.
  #define BIT_MSK__DSC_PPS_8241__PPS_RC_BUF_THRESH5                                    0xFF

// DSC PPS(Picture Parameter Set) Byte8242 Register
#define REG_ADDR__DSC_PPS_8242                                           (DSC_ENC_CORE | 0x0032)
  // (ReadWrite, Bits 7:0) 
  // These values specify the thresholds in the RC model for the 15 ranges (see section 10.8.3). There are 6 LSBs appended to each value.
  #define BIT_MSK__DSC_PPS_8242__PPS_RC_BUF_THRESH6                                    0xFF

// DSC PPS(Picture Parameter Set) Byte8243 Register
#define REG_ADDR__DSC_PPS_8243                                           (DSC_ENC_CORE | 0x0033)
  // (ReadWrite, Bits 7:0) 
  // These values specify the thresholds in the RC model for the 15 ranges (see section 10.8.3). There are 6 LSBs appended to each value.
  #define BIT_MSK__DSC_PPS_8243__PPS_RC_BUF_THRESH7                                    0xFF

// DSC PPS(Picture Parameter Set) Byte8244 Register
#define REG_ADDR__DSC_PPS_8244                                           (DSC_ENC_CORE | 0x0034)
  // (ReadWrite, Bits 7:0) 
  // These values specify the thresholds in the RC model for the 15 ranges (see section 10.8.3). There are 6 LSBs appended to each value.
  #define BIT_MSK__DSC_PPS_8244__PPS_RC_BUF_THRESH8                                    0xFF

// DSC PPS(Picture Parameter Set) Byte8245 Register
#define REG_ADDR__DSC_PPS_8245                                           (DSC_ENC_CORE | 0x0035)
  // (ReadWrite, Bits 7:0) 
  // These values specify the thresholds in the RC model for the 15 ranges (see section 10.8.3). There are 6 LSBs appended to each value.
  #define BIT_MSK__DSC_PPS_8245__PPS_RC_BUF_THRESH9                                    0xFF

// DSC PPS(Picture Parameter Set) Byte8246 Register
#define REG_ADDR__DSC_PPS_8246                                           (DSC_ENC_CORE | 0x0036)
  // (ReadWrite, Bits 7:0) 
  // These values specify the thresholds in the RC model for the 15 ranges (see section 10.8.3). There are 6 LSBs appended to each value.
  #define BIT_MSK__DSC_PPS_8246__PPS_RC_BUF_THRESH10                                   0xFF

// DSC PPS(Picture Parameter Set) Byte8247 Register
#define REG_ADDR__DSC_PPS_8247                                           (DSC_ENC_CORE | 0x0037)
  // (ReadWrite, Bits 7:0) 
  // These values specify the thresholds in the RC model for the 15 ranges (see section 10.8.3). There are 6 LSBs appended to each value.
  #define BIT_MSK__DSC_PPS_8247__PPS_RC_BUF_THRESH11                                   0xFF

// DSC PPS(Picture Parameter Set) Byte8248 Register
#define REG_ADDR__DSC_PPS_8248                                           (DSC_ENC_CORE | 0x0038)
  // (ReadWrite, Bits 7:0) 
  // These values specify the thresholds in the RC model for the 15 ranges (see section 10.8.3). There are 6 LSBs appended to each value.
  #define BIT_MSK__DSC_PPS_8248__PPS_RC_BUF_THRESH12                                   0xFF

// DSC PPS(Picture Parameter Set) Byte8249 Register
#define REG_ADDR__DSC_PPS_8249                                           (DSC_ENC_CORE | 0x0039)
  // (ReadWrite, Bits 7:0) 
  // These values specify the thresholds in the RC model for the 15 ranges (see section 10.8.3). There are 6 LSBs appended to each value.
  #define BIT_MSK__DSC_PPS_8249__PPS_RC_BUF_THRESH13                                   0xFF

// DSC PPS(Picture Parameter Set) Byte8250 Register
#define REG_ADDR__DSC_PPS_8250                                           (DSC_ENC_CORE | 0x003A)
  // (ReadWrite, Bits 2:0) 
  // This value specifies the maximum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8250__PPS_RANGE_MAX_QP0_B4B2                                0x07
  // (ReadWrite, Bits 7:3) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8250__PPS_RANGE_MIN_QP0                                     0xF8

// DSC PPS(Picture Parameter Set) Byte8251 Register
#define REG_ADDR__DSC_PPS_8251                                           (DSC_ENC_CORE | 0x003B)
  // (ReadWrite, Bits 5:0) 
  // This value specifies the target bits per group adjustment that is performed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8251__PPS_RANGE_BPG_OFFSET0                                 0x3F
  // (ReadWrite, Bits 7:6) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8251__PPS_RANGE_MAX_QP0_B1B0                                0xC0

// DSC PPS(Picture Parameter Set) Byte8252 Register
#define REG_ADDR__DSC_PPS_8252                                           (DSC_ENC_CORE | 0x003C)
  // (ReadWrite, Bits 2:0) 
  // This value specifies the maximum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8252__PPS_RANGE_MAX_QP1_B4B2                                0x07
  // (ReadWrite, Bits 7:3) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8252__PPS_RANGE_MIN_QP1                                     0xF8

// DSC PPS(Picture Parameter Set) Byte8253 Register
#define REG_ADDR__DSC_PPS_8253                                           (DSC_ENC_CORE | 0x003D)
  // (ReadWrite, Bits 5:0) 
  // This value specifies the target bits per group adjustment that is performed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8253__PPS_RANGE_BPG_OFFSET1                                 0x3F
  // (ReadWrite, Bits 7:6) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8253__PPS_RANGE_MAX_QP1_B1B0                                0xC0

// DSC PPS(Picture Parameter Set) Byte8254 Register
#define REG_ADDR__DSC_PPS_8254                                           (DSC_ENC_CORE | 0x003E)
  // (ReadWrite, Bits 2:0) 
  // This value specifies the maximum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8254__PPS_RANGE_MAX_QP2_B4B2                                0x07
  // (ReadWrite, Bits 7:3) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8254__PPS_RANGE_MIN_QP2                                     0xF8

// DSC PPS(Picture Parameter Set) Byte8255 Register
#define REG_ADDR__DSC_PPS_8255                                           (DSC_ENC_CORE | 0x003F)
  // (ReadWrite, Bits 5:0) 
  // This value specifies the target bits per group adjustment that is performed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8255__PPS_RANGE_BPG_OFFSET2                                 0x3F
  // (ReadWrite, Bits 7:6) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8255__PPS_RANGE_MAX_QP2_B1B0                                0xC0

// DSC PPS(Picture Parameter Set) Byte8256 Register
#define REG_ADDR__DSC_PPS_8256                                           (DSC_ENC_CORE | 0x0040)
  // (ReadWrite, Bits 2:0) 
  // This value specifies the maximum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8256__PPS_RANGE_MAX_QP3_B4B2                                0x07
  // (ReadWrite, Bits 7:3) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8256__PPS_RANGE_MIN_QP3                                     0xF8

// DSC PPS(Picture Parameter Set) Byte8257 Register
#define REG_ADDR__DSC_PPS_8257                                           (DSC_ENC_CORE | 0x0041)
  // (ReadWrite, Bits 5:0) 
  // This value specifies the target bits per group adjustment that is performed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8257__PPS_RANGE_BPG_OFFSET3                                 0x3F
  // (ReadWrite, Bits 7:6) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8257__PPS_RANGE_MAX_QP3_B1B0                                0xC0

// DSC PPS(Picture Parameter Set) Byte8258 Register
#define REG_ADDR__DSC_PPS_8258                                           (DSC_ENC_CORE | 0x0042)
  // (ReadWrite, Bits 2:0) 
  // This value specifies the maximum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8258__PPS_RANGE_MAX_QP4_B4B2                                0x07
  // (ReadWrite, Bits 7:3) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8258__PPS_RANGE_MIN_QP4                                     0xF8

// DSC PPS(Picture Parameter Set) Byte8259 Register
#define REG_ADDR__DSC_PPS_8259                                           (DSC_ENC_CORE | 0x0043)
  // (ReadWrite, Bits 5:0) 
  // This value specifies the target bits per group adjustment that is performed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8259__PPS_RANGE_BPG_OFFSET4                                 0x3F
  // (ReadWrite, Bits 7:6) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8259__PPS_RANGE_MAX_QP4_B1B0                                0xC0

// DSC PPS(Picture Parameter Set) Byte8260 Register
#define REG_ADDR__DSC_PPS_8260                                           (DSC_ENC_CORE | 0x0044)
  // (ReadWrite, Bits 2:0) 
  // This value specifies the maximum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8260__PPS_RANGE_MAX_QP5_B4B2                                0x07
  // (ReadWrite, Bits 7:3) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8260__PPS_RANGE_MIN_QP5                                     0xF8

// DSC PPS(Picture Parameter Set) Byte8261 Register
#define REG_ADDR__DSC_PPS_8261                                           (DSC_ENC_CORE | 0x0045)
  // (ReadWrite, Bits 5:0) 
  // This value specifies the target bits per group adjustment that is performed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8261__PPS_RANGE_BPG_OFFSET5                                 0x3F
  // (ReadWrite, Bits 7:6) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8261__PPS_RANGE_MAX_QP5_B1B0                                0xC0

// DSC PPS(Picture Parameter Set) Byte8262 Register
#define REG_ADDR__DSC_PPS_8262                                           (DSC_ENC_CORE | 0x0046)
  // (ReadWrite, Bits 2:0) 
  // This value specifies the maximum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8262__PPS_RANGE_MAX_QP6_B4B2                                0x07
  // (ReadWrite, Bits 7:3) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8262__PPS_RANGE_MIN_QP6                                     0xF8

// DSC PPS(Picture Parameter Set) Byte8263 Register
#define REG_ADDR__DSC_PPS_8263                                           (DSC_ENC_CORE | 0x0047)
  // (ReadWrite, Bits 5:0) 
  // This value specifies the target bits per group adjustment that is performed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8263__PPS_RANGE_BPG_OFFSET6                                 0x3F
  // (ReadWrite, Bits 7:6) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8263__PPS_RANGE_MAX_QP6_B1B0                                0xC0

// DSC PPS(Picture Parameter Set) Byte8264 Register
#define REG_ADDR__DSC_PPS_8264                                           (DSC_ENC_CORE | 0x0048)
  // (ReadWrite, Bits 2:0) 
  // This value specifies the maximum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8264__PPS_RANGE_MAX_QP7_B4B2                                0x07
  // (ReadWrite, Bits 7:3) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8264__PPS_RANGE_MIN_QP7                                     0xF8

// DSC PPS(Picture Parameter Set) Byte8265 Register
#define REG_ADDR__DSC_PPS_8265                                           (DSC_ENC_CORE | 0x0049)
  // (ReadWrite, Bits 5:0) 
  // This value specifies the target bits per group adjustment that is performed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8265__PPS_RANGE_BPG_OFFSET7                                 0x3F
  // (ReadWrite, Bits 7:6) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8265__PPS_RANGE_MAX_QP7_B1B0                                0xC0

// DSC PPS(Picture Parameter Set) Byte8266 Register
#define REG_ADDR__DSC_PPS_8266                                           (DSC_ENC_CORE | 0x004A)
  // (ReadWrite, Bits 2:0) 
  // This value specifies the maximum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8266__PPS_RANGE_MAX_QP8_B4B2                                0x07
  // (ReadWrite, Bits 7:3) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8266__PPS_RANGE_MIN_QP8                                     0xF8

// DSC PPS(Picture Parameter Set) Byte8267 Register
#define REG_ADDR__DSC_PPS_8267                                           (DSC_ENC_CORE | 0x004B)
  // (ReadWrite, Bits 5:0) 
  // This value specifies the target bits per group adjustment that is performed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8267__PPS_RANGE_BPG_OFFSET8                                 0x3F
  // (ReadWrite, Bits 7:6) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8267__PPS_RANGE_MAX_QP8_B1B0                                0xC0

// DSC PPS(Picture Parameter Set) Byte8268 Register
#define REG_ADDR__DSC_PPS_8268                                           (DSC_ENC_CORE | 0x004C)
  // (ReadWrite, Bits 2:0) 
  // This value specifies the maximum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8268__PPS_RANGE_MAX_QP9_B4B2                                0x07
  // (ReadWrite, Bits 7:3) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8268__PPS_RANGE_MIN_QP9                                     0xF8

// DSC PPS(Picture Parameter Set) Byte8269 Register
#define REG_ADDR__DSC_PPS_8269                                           (DSC_ENC_CORE | 0x004D)
  // (ReadWrite, Bits 5:0) 
  // This value specifies the target bits per group adjustment that is performed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8269__PPS_RANGE_BPG_OFFSET9                                 0x3F
  // (ReadWrite, Bits 7:6) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8269__PPS_RANGE_MAX_QP9_B1B0                                0xC0

// DSC PPS(Picture Parameter Set) Byte8270 Register
#define REG_ADDR__DSC_PPS_8270                                           (DSC_ENC_CORE | 0x004E)
  // (ReadWrite, Bits 2:0) 
  // This value specifies the maximum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8270__PPS_RANGE_MAX_QP10_B4B2                               0x07
  // (ReadWrite, Bits 7:3) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8270__PPS_RANGE_MIN_QP10                                    0xF8

// DSC PPS(Picture Parameter Set) Byte8271 Register
#define REG_ADDR__DSC_PPS_8271                                           (DSC_ENC_CORE | 0x004F)
  // (ReadWrite, Bits 5:0) 
  // This value specifies the target bits per group adjustment that is performed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8271__PPS_RANGE_BPG_OFFSET10                                0x3F
  // (ReadWrite, Bits 7:6) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8271__PPS_RANGE_MAX_QP10_B1B0                               0xC0

// DSC PPS(Picture Parameter Set) Byte8272 Register
#define REG_ADDR__DSC_PPS_8272                                           (DSC_ENC_CORE | 0x0050)
  // (ReadWrite, Bits 2:0) 
  // This value specifies the maximum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8272__PPS_RANGE_MAX_QP11_B4B2                               0x07
  // (ReadWrite, Bits 7:3) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8272__PPS_RANGE_MIN_QP11                                    0xF8

// DSC PPS(Picture Parameter Set) Byte8273 Register
#define REG_ADDR__DSC_PPS_8273                                           (DSC_ENC_CORE | 0x0051)
  // (ReadWrite, Bits 5:0) 
  // This value specifies the target bits per group adjustment that is performed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8273__PPS_RANGE_BPG_OFFSET11                                0x3F
  // (ReadWrite, Bits 7:6) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8273__PPS_RANGE_MAX_QP11_B1B0                               0xC0

// DSC PPS(Picture Parameter Set) Byte8274 Register
#define REG_ADDR__DSC_PPS_8274                                           (DSC_ENC_CORE | 0x0052)
  // (ReadWrite, Bits 2:0) 
  // This value specifies the maximum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8274__PPS_RANGE_MAX_QP12_B4B2                               0x07
  // (ReadWrite, Bits 7:3) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8274__PPS_RANGE_MIN_QP12                                    0xF8

// DSC PPS(Picture Parameter Set) Byte8275 Register
#define REG_ADDR__DSC_PPS_8275                                           (DSC_ENC_CORE | 0x0053)
  // (ReadWrite, Bits 5:0) 
  // This value specifies the target bits per group adjustment that is performed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8275__PPS_RANGE_BPG_OFFSET12                                0x3F
  // (ReadWrite, Bits 7:6) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8275__PPS_RANGE_MAX_QP12_B1B0                               0xC0

// DSC PPS(Picture Parameter Set) Byte8276 Register
#define REG_ADDR__DSC_PPS_8276                                           (DSC_ENC_CORE | 0x0054)
  // (ReadWrite, Bits 2:0) 
  // This value specifies the maximum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8276__PPS_RANGE_MAX_QP13_B4B2                               0x07
  // (ReadWrite, Bits 7:3) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8276__PPS_RANGE_MIN_QP13                                    0xF8

// DSC PPS(Picture Parameter Set) Byte8277 Register
#define REG_ADDR__DSC_PPS_8277                                           (DSC_ENC_CORE | 0x0055)
  // (ReadWrite, Bits 5:0) 
  // This value specifies the target bits per group adjustment that is performed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8277__PPS_RANGE_BPG_OFFSET13                                0x3F
  // (ReadWrite, Bits 7:6) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8277__PPS_RANGE_MAX_QP13_B1B0                               0xC0

// DSC PPS(Picture Parameter Set) Byte8278 Register
#define REG_ADDR__DSC_PPS_8278                                           (DSC_ENC_CORE | 0x0056)
  // (ReadWrite, Bits 2:0) 
  // This value specifies the maximum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8278__PPS_RANGE_MAX_QP14_B4B2                               0x07
  // (ReadWrite, Bits 7:3) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8278__PPS_RANGE_MIN_QP14                                    0xF8

// DSC PPS(Picture Parameter Set) Byte8279 Register
#define REG_ADDR__DSC_PPS_8279                                           (DSC_ENC_CORE | 0x0057)
  // (ReadWrite, Bits 5:0) 
  // This value specifies the target bits per group adjustment that is performed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8279__PPS_RANGE_BPG_OFFSET14                                0x3F
  // (ReadWrite, Bits 7:6) 
  // This value specifies the minimum QP that is allowed if the RC model has tracked to the current range (see section 10.8.4).
  #define BIT_MSK__DSC_PPS_8279__PPS_RANGE_MAX_QP14_B1B0                               0xC0

// DSC PPS(Picture Parameter Set) Byte8280 Register
#define REG_ADDR__DSC_PPS_8280                                           (DSC_ENC_CORE | 0x0058)

// DSC PPS(Picture Parameter Set) Byte8281 Register
#define REG_ADDR__DSC_PPS_8281                                           (DSC_ENC_CORE | 0x0059)

// DSC Control 1 Register
#define REG_ADDR__DSC_CTRL_1                                             (DSC_ENC_CORE | 0x0060)
  // (ReadWrite, Bits 7:0) 
  // DSC control register #1
  #define BIT_MSK__DSC_CTRL_1__DSC_CTRL_1                                            0xFF

// DSC H Blank H Register
#define REG_ADDR__DSC_CTRL_2                                             (DSC_ENC_CORE | 0x0061)
  // (ReadWrite, Bits 7:0) 
  // DSC control register #2
  #define BIT_MSK__DSC_CTRL_2__DSC_CTRL_2                                            0xFF

// DSC H Blank L Register
#define REG_ADDR__DSC_CTRL_3                                             (DSC_ENC_CORE | 0x0062)
  // (ReadWrite, Bits 7:0) 
  // DSC control register #3
  #define BIT_MSK__DSC_CTRL_3__DSC_CTRL_3                                            0xFF

//***************************************************************************
// DSC_ENC_WRAP. Address: 60
// DSC Encoder Control Register
#define REG_ADDR__DSC_ENC_CTRL                                           (DSC_ENC_WRAP | 0x0000)
  // (ReadWrite, Bits 0) 
  // hvsync polarity with which stream is receving from sherman to dsc_encoder. If 0; positive polarity. If 1; negative polarity
  #define BIT_MSK__DSC_ENC_CTRL__REG_IIF_HVSYNC_POLARITY                               0x01
  // (ReadWrite, Bits 1) 
  // hvsync DSC Encoder output (VTG) polarity, with which we need to drive to cypress. If 0; positive polarity. If 1; negative polarity
  #define BIT_MSK__DSC_ENC_CTRL__REG_OIF_HVSYNC_POLARITY                               0x02

// DSC encoder Htotal #1 Register
#define REG_ADDR__DSC_ENC_HTOTAL_1                                       (DSC_ENC_WRAP | 0x0001)
  // (ReadWrite, Bits 7:0) 
  // lower byte of H total of timing generator
  #define BIT_MSK__DSC_ENC_HTOTAL_1__REG_H_TOTAL_B7_B0                                     0xFF

// DSC encoder Htotal #2 Register
#define REG_ADDR__DSC_ENC_HTOTAL_2                                       (DSC_ENC_WRAP | 0x0002)
  // (ReadWrite, Bits 4:0) 
  // Higher 5bits of H total of timing generator
  #define BIT_MSK__DSC_ENC_HTOTAL_2__REG_H_TOTAL_B12_B8                                    0x1F

// DSC encoder Hwidth #1 Register
#define REG_ADDR__DSC_ENC_HWIDTH_1                                       (DSC_ENC_WRAP | 0x0003)
  // (ReadWrite, Bits 7:0) 
  // lower byte of H width of timing generator
  #define BIT_MSK__DSC_ENC_HWIDTH_1__REG_HSYNC_WIDTH_B7_B0                                 0xFF

// DSC encoder Hwidth #2 Register
#define REG_ADDR__DSC_ENC_HWIDTH_2                                       (DSC_ENC_WRAP | 0x0004)
  // (ReadWrite, Bits 3:0) 
  // Higher 4bits of H width of timing generator
  #define BIT_MSK__DSC_ENC_HWIDTH_2__REG_HSYNC_WIDTH_B11_B8                                0x0F

// DSC encoder Hsync front porch #1 Register
#define REG_ADDR__DSC_ENC_HS_FRNT_1                                      (DSC_ENC_WRAP | 0x0005)
  // (ReadWrite, Bits 7:0) 
  // lower byte of H front porch of timing generator
  #define BIT_MSK__DSC_ENC_HS_FRNT_1__REG_HSYNC_FRONT_PORCH_B7_B0                           0xFF

// DSC encoder Hsync front porch #2 Register
#define REG_ADDR__DSC_ENC_HS_FRNT_2                                      (DSC_ENC_WRAP | 0x0006)
  // (ReadWrite, Bits 3:0) 
  // Higher 4bits of H front porch of timing generator
  #define BIT_MSK__DSC_ENC_HS_FRNT_2__REG_HSYNC_FRONT_PORCH_B11_B8                          0x0F

// DSC encoder Hsync back porch #1 Register
#define REG_ADDR__DSC_ENC_HS_BACK_1                                      (DSC_ENC_WRAP | 0x0007)
  // (ReadWrite, Bits 7:0) 
  // lower byte of H back porch of timing generator
  #define BIT_MSK__DSC_ENC_HS_BACK_1__REG_HSYNC_BACK_PORCH_B7_B0                            0xFF

// DSC encoder Hsync back porch #2 Register
#define REG_ADDR__DSC_ENC_HS_BACK_2                                      (DSC_ENC_WRAP | 0x0008)
  // (ReadWrite, Bits 3:0) 
  // Higher 4bits of H back porch of timing generator
  #define BIT_MSK__DSC_ENC_HS_BACK_2__REG_HSYNC_BACK_PORCH_B11_B8                           0x0F

// DSC encoder Vtotal #1 Register
#define REG_ADDR__DSC_ENC_VTOTAL_1                                       (DSC_ENC_WRAP | 0x0009)
  // (ReadWrite, Bits 7:0) 
  // lower byte of V total of timing generator
  #define BIT_MSK__DSC_ENC_VTOTAL_1__REG_V_TOTAL_B7_B0                                     0xFF

// DSC encoder Vtotal #2 Register
#define REG_ADDR__DSC_ENC_VTOTAL_2                                       (DSC_ENC_WRAP | 0x000A)
  // (ReadWrite, Bits 3:0) 
  // Higher 4bits of V total of timing generator
  #define BIT_MSK__DSC_ENC_VTOTAL_2__REG_V_TOTAL_B12_B8                                    0x0F

// DSC encoder Vheight #1 Register
#define REG_ADDR__DSC_ENC_VHEIGHT_1                                      (DSC_ENC_WRAP | 0x000B)
  // (ReadWrite, Bits 7:0) 
  // lower byte of V height of timing generator
  #define BIT_MSK__DSC_ENC_VHEIGHT_1__REG_V_HEIGHT_B7_B0                                    0xFF

// DSC encoder Vheight #2 Register
#define REG_ADDR__DSC_ENC_VHEIGHT_2                                      (DSC_ENC_WRAP | 0x000C)
  // (ReadWrite, Bits 3:0) 
  // Higher 4bits of V height of timing generator
  #define BIT_MSK__DSC_ENC_VHEIGHT_2__REG_V_HEIGHT_B11_B8                                   0x0F

// DSC encoder Vsync front porch #1 Register
#define REG_ADDR__DSC_ENC_VS_FRNT_1                                      (DSC_ENC_WRAP | 0x000D)
  // (ReadWrite, Bits 7:0) 
  // lower byte of V front porch of timing generator
  #define BIT_MSK__DSC_ENC_VS_FRNT_1__REG_VSYNC_FRONT_PORCH_B7_B0                           0xFF

// DSC encoder Vsync front porch #2 Register
#define REG_ADDR__DSC_ENC_VS_FRNT_2                                      (DSC_ENC_WRAP | 0x000E)
  // (ReadWrite, Bits 3:0) 
  // Higher 4bits of V front porch of timing generator
  #define BIT_MSK__DSC_ENC_VS_FRNT_2__REG_VSYNC_FRONT_PORCH_B11_B8                          0x0F

// DSC encoder Vsync back porch #1 Register
#define REG_ADDR__DSC_ENC_VS_BACK_1                                      (DSC_ENC_WRAP | 0x000F)
  // (ReadWrite, Bits 7:0) 
  // lower byte of V back porch of timing generator
  #define BIT_MSK__DSC_ENC_VS_BACK_1__REG_VSYNC_BACK_PORCH_B7_B0                            0xFF

// DSC encoder Vsync back porch #2 Register
#define REG_ADDR__DSC_ENC_VS_BACK_2                                      (DSC_ENC_WRAP | 0x0010)
  // (ReadWrite, Bits 3:0) 
  // Higher 4bits of V back porch of timing generator
  #define BIT_MSK__DSC_ENC_VS_BACK_2__REG_VSYNC_BACK_PORCH_B11_B8                           0x0F

// DSC Encoder IIF Color Depth Register
#define REG_ADDR__DSC_ENC_IIF_CLR_DEPTH                                  (DSC_ENC_WRAP | 0x0011)
  // (ReadWrite, Bits 3:0) 
  // color depth of incoming hdmi stream into Input interface 0000 : color depth not indicated 0100 : 24 bits per pixel 0101 : 30 bits per pixel 0110: 36 bits per pixel   - Not valid here 0111 : 48 bits per pixel  - Not valid here all other combinations are reserved
  #define BIT_MSK__DSC_ENC_IIF_CLR_DEPTH__REG_PRE_COMP_CLR_DEPTH                                0x0F

// Pre Compression Half Max Pxl #1 Register
#define REG_ADDR__PRE_COMP_HALF_MAX_PXL_1                                (DSC_ENC_WRAP | 0x0012)
  // (ReadWrite, Bits 7:0) 
  // LSB byte of pre compression max pixel by 2 value.
  #define BIT_MSK__PRE_COMP_HALF_MAX_PXL_1__REG_PRE_COMP_HALF_MAX_PXL_B7_B0                       0xFF

// Pre Compression Half Max Pxl #2 Register
#define REG_ADDR__PRE_COMP_HALF_MAX_PXL_2                                (DSC_ENC_WRAP | 0x0013)
  // (ReadWrite, Bits 3:0) 
  // MSB nibble of pre compression max pixel by 2 value. The default value of PRE_COMP_HALF_MAX_PXL register is 12'b011110000000. Which is equal to 3840p/2.
  #define BIT_MSK__PRE_COMP_HALF_MAX_PXL_2__REG_PRE_COMP_HALF_MAX_PXL_B11_B8                      0x0F

// Post Compression Rd Dly Cnt  Register
#define REG_ADDR__POST_COMP_RD_DLY_CNT                                   (DSC_ENC_WRAP | 0x0014)
  // (ReadWrite, Bits 7:0) 
  // After these many data writes intot output fifo; start reading it. Default value is 8'hA7; default
  #define BIT_MSK__POST_COMP_RD_DLY_CNT__REG_POST_COMP_RD_DLY_CNT                              0xFF

// FIFO Flush #0 Register
#define REG_ADDR__FIFO_FLUSH                                             (DSC_ENC_WRAP | 0x0015)
  // (ReadWrite, Bits 0) 
  // Used to to reset the wr_ptr of oif vsync fifo
  #define BIT_MSK__FIFO_FLUSH__WR_FIFO_FLUSH_OIF                                     0x01
  // (ReadWrite, Bits 1) 
  // Used to to reset the rd_ptr of oif vsync fifo
  #define BIT_MSK__FIFO_FLUSH__RD_FIFO_FLUSH_OIF                                     0x02
  // (ReadWrite, Bits 2) 
  // Used to to reset the wr_ptr of iif eof fifos (iif_0; iif_1)
  #define BIT_MSK__FIFO_FLUSH__WR_FIFO_FLUSH_IIF_EOF                                 0x04
  // (ReadWrite, Bits 3) 
  // Used to to reset the rd_ptr of iif eof fifos (iif_0; iif_1)
  #define BIT_MSK__FIFO_FLUSH__RD_FIFO_FLUSH_IIF_EOF                                 0x08
  // (ReadWrite, Bits 4) 
  // Used to to reset the wr_ptr of iif sof fifos (iif_0;iif_1)
  #define BIT_MSK__FIFO_FLUSH__WR_FIFO_FLUSH_IIF_SOF                                 0x10
  // (ReadWrite, Bits 5) 
  // Used to to reset the rd_ptr of iif sof fifos (iif_0, iif_1)
  #define BIT_MSK__FIFO_FLUSH__RD_FIFO_FLUSH_IIF_SOF                                 0x20

// FIFO STATUS #0 Register
#define REG_ADDR__FIFO_STATUS_0                                          (DSC_ENC_WRAP | 0x0016)
  // (ReadOnly, Bits 0) 
  // overflow status of the oif eof fifo
  #define BIT_MSK__FIFO_STATUS_0__FIFO_OVERFLOW_OIF_EOF                                 0x01
  // (ReadOnly, Bits 1) 
  // underflow status of the oif eof fifo
  #define BIT_MSK__FIFO_STATUS_0__FIFO_UNDERFLOW_OIF_EOF                                0x02
  // (ReadOnly, Bits 2) 
  // overflow status of the iif sof_0 fifo
  #define BIT_MSK__FIFO_STATUS_0__FIFO_OVERFLOW_IIF_SOF_0                               0x04
  // (ReadOnly, Bits 3) 
  // underflow status of the iif sof_0 fifo
  #define BIT_MSK__FIFO_STATUS_0__FIFO_UNDERFLOW_IIF_SOF_0                              0x08
  // (ReadOnly, Bits 4) 
  // overflow status of the iif eof_0 fifo
  #define BIT_MSK__FIFO_STATUS_0__FIFO_OVERFLOW_IIF_EOF_0                               0x10
  // (ReadOnly, Bits 5) 
  // underflow status of the iif eof_0 fifo
  #define BIT_MSK__FIFO_STATUS_0__FIFO_UNDERFLOW_IIF_EOF_0                              0x20

// FIFO STATUS #1 Register
#define REG_ADDR__FIFO_STATUS_1                                          (DSC_ENC_WRAP | 0x0017)
  // (ReadOnly, Bits 2) 
  // overflow status of the iif sof_1 fifo
  #define BIT_MSK__FIFO_STATUS_1__FIFO_OVERFLOW_IIF_SOF_1                               0x04
  // (ReadOnly, Bits 3) 
  // underflow status of the iif sof_1 fifo
  #define BIT_MSK__FIFO_STATUS_1__FIFO_UNDERFLOW_IIF_SOF_1                              0x08
  // (ReadOnly, Bits 4) 
  // overflow status of the iif eof_1 fifo
  #define BIT_MSK__FIFO_STATUS_1__FIFO_OVERFLOW_IIF_EOF_1                               0x10
  // (ReadOnly, Bits 5) 
  // underflow status of the iif eof_1 fifo
  #define BIT_MSK__FIFO_STATUS_1__FIFO_UNDERFLOW_IIF_EOF_1                              0x20

// DSC Wrap Control #0 Register
#define REG_ADDR__DSC_WRAP_CTRL_0                                        (DSC_ENC_WRAP | 0x0018)
  // (ReadWrite, Bits 0) 
  // Config to indicate either 2:1 or 3:1 compression is used by DSC_ENC IP (valid when reg_eof_oif_sel is 1'b0)
  #define BIT_MSK__DSC_WRAP_CTRL_0__REG_2BY1_COMP                                         0x01
  // (ReadWrite, Bits 1) 
  // 
  #define BIT_MSK__DSC_WRAP_CTRL_0__REG_LINK_LOST                                         0x02
  // (ReadWrite, Bits 2) 
  // Ether to select gen_lock logic or vsync fifo logic. If 1'b1: gen_lock logic is used. Else, vsync fifo logic is used.
  #define BIT_MSK__DSC_WRAP_CTRL_0__REG_EOF_OIF_SEL                                       0x04
  // (ReadWrite, Bits 3) 
  // lock enable for resync with vsync.
  #define BIT_MSK__DSC_WRAP_CTRL_0__REG_LOCK_ENABLE                                       0x08
  // (ReadWrite, Bits 5:4) 
  // to delay eof in fpga testing; in ASIC it is 2'b00
  #define BIT_MSK__DSC_WRAP_CTRL_0__REG_DELAY_EOF_FPGA                                    0x30
  // (ReadWrite, Bits 6) 
  // start reading pulse is giving to by2 clock domain from i_pxl_clk for mem1 of 2 slice operation
  #define BIT_MSK__DSC_WRAP_CTRL_0__REG_PRE_MEM1_RD                                       0x40
  // (ReadWrite, Bits 7) 
  // delaying the iif mem0 core0_data; core_data_valid; core0_eol by one cycle to decresse the difference b/w core_valid to core1_valid from 963 to 962
  #define BIT_MSK__DSC_WRAP_CTRL_0__REG_DELAY_CORE0                                       0x80

// DSC Wrap VS PERIOD #0 Register
#define REG_ADDR__DSC_WRAP_VS_PERIOD_0                                   (DSC_ENC_WRAP | 0x0019)
  // (ReadWrite, Bits 7:0) 
  // LSB of vsync period in exact # pixels
  #define BIT_MSK__DSC_WRAP_VS_PERIOD_0__REG_VS_PERIOD_B7_B0                                   0xFF

// DSC Wrap VS PERIOD #1 Register
#define REG_ADDR__DSC_WRAP_VS_PERIOD_1                                   (DSC_ENC_WRAP | 0x001A)
  // (ReadWrite, Bits 7:0) 
  // Middle Byte of vsync period in exact # pixels
  #define BIT_MSK__DSC_WRAP_VS_PERIOD_1__REG_VS_PERIOD_B15_B8                                  0xFF

// DSC Wrap VS PERIOD #2 Register
#define REG_ADDR__DSC_WRAP_VS_PERIOD_2                                   (DSC_ENC_WRAP | 0x001B)
  // (ReadWrite, Bits 7:0) 
  // MSB of vsync period in exact # pixels
  #define BIT_MSK__DSC_WRAP_VS_PERIOD_2__REG_VS_PERIOD_B23_B16                                 0xFF

// DSC Wrap THRESHOLD  Register
#define REG_ADDR__DSC_WRAP_THRESHOLD                                     (DSC_ENC_WRAP | 0x001C)
  // (ReadWrite, Bits 7:0) 
  // vsync threshold
  #define BIT_MSK__DSC_WRAP_THRESHOLD__REG_THRESHOLD                                         0xFF

// DSC Wrap EOF OUT CNT  Register
#define REG_ADDR__DSC_WRAP_EOF_OUT_CNT                                   (DSC_ENC_WRAP | 0x001D)
  // (ReadWrite, Bits 7:0) 
  // How many number of eof's from DSC_ENC IP need to give (reg_eof_out_cnt - reg_eof_after_cycles) to VTG in free running VTG(without Hoon resync logic)
  #define BIT_MSK__DSC_WRAP_EOF_OUT_CNT__REG_EOF_OUT_CNT                                       0xFF

// DSC Wrap EOF AFTER CYCLES  Register
#define REG_ADDR__DSC_WRAP_EOF_AFTR_CYCLES                               (DSC_ENC_WRAP | 0x001E)
  // (ReadWrite, Bits 7:0) 
  // After How many number of cycles eof of DSC_ENC IP need to give to VTG (wihtout Hoon  resync logic)
  #define BIT_MSK__DSC_WRAP_EOF_AFTR_CYCLES__REG_EOF_AFTER_CYCLES                                  0xFF

// DSC iif_mem1_rd_initialize_ctl Register
#define REG_ADDR__DSC_IIF_MEM1_RD_INIT_CTRL                              (DSC_ENC_WRAP | 0x001F)
  // (ReadWrite, Bits 3:0) 
  // Keep 4'b1111 for 8bpc resolution, and 4'b1110 for 10bpc resolution
  #define BIT_MSK__DSC_IIF_MEM1_RD_INIT_CTRL__REG_IIF_MEM1_RD_INITIALIZE_CTRL                       0x0F
  // (ReadWrite, Bits 5:4) 
  // delay of mem1_rd start, it is valid reg_pre_mem1_rd is 1'b0.
  #define BIT_MSK__DSC_IIF_MEM1_RD_INIT_CTRL__REG_MEM1_RD_START_0                                   0x30
  // (ReadWrite, Bits 7:6) 
  // delay of mem1_rd start, it is valid reg_pre_mem1_rd is 1'b1.
  #define BIT_MSK__DSC_IIF_MEM1_RD_INIT_CTRL__REG_MEM1_RD_START_1                                   0xC0

// DSC Soft Reset Register
#define REG_ADDR__DSC_SW_RST                                             (DSC_ENC_WRAP | 0x0030)
  // (ReadWrite, Bits 0) 
  // Soft reset control for DSC IN clock domain 0 : No SW reset (default) 1 : Applies SW resets and HW auto release when VSYNC positive edge is detected.
  #define BIT_MSK__DSC_SW_RST__REG_DSC_IN_SW_RST                                     0x01
  // (ReadWrite, Bits 1) 
  // Soft reset control for DSC Core clock domain 0 : No SW reset (default) 1 : Applies SW resets and HW auto release when VSYNC positive edge is detected.
  #define BIT_MSK__DSC_SW_RST__REG_DSC_CORE_SW_RST                                   0x02
  // (ReadWrite, Bits 2) 
  // Soft reset control for DSC Out clock domain 0 : No SW reset (default) 1 : Applies SW resets and HW auto release when VSYNC positive edge is detected.
  #define BIT_MSK__DSC_SW_RST__REG_DSC_OUT_SW_RST                                    0x04
  // (ReadWrite, Bits 4) 
  // Auto Soft reset control for DSC logic 0 : No SW reset (default) 1 : Applies SW reset to complete DSC wrapper hierarchy when VSYNC positive edge is detected.
  #define BIT_MSK__DSC_SW_RST__REG_DSC_AUTO_SW_RST                                   0x10

// DSC GPIO Control #0 Register
#define REG_ADDR__DSC_GPIO_CTRL0                                         (DSC_ENC_WRAP | 0x0031)
  // (ReadWrite, Bits 7:0) 
  // GPIO Control0 Register
  #define BIT_MSK__DSC_GPIO_CTRL0__REG_DSC_GPIO_CTRL0                                    0xFF

// DSC GPIO Control #1 Register
#define REG_ADDR__DSC_GPIO_CTRL1                                         (DSC_ENC_WRAP | 0x0032)
  // (ReadWrite, Bits 7:0) 
  // GPIO Control1 Register
  #define BIT_MSK__DSC_GPIO_CTRL1__REG_DSC_GPIO_CTRL1                                    0xFF

// DSC Debug Status #0 Register
#define REG_ADDR__DSC_DEBUG_STS0                                         (DSC_ENC_WRAP | 0x0033)
  // (ReadOnly, Bits 7:0) 
  // DSC Debug Status0
  #define BIT_MSK__DSC_DEBUG_STS0__REG_DSC_DEBUG_STS0                                    0xFF

// DSC Debug Status #1 Register
#define REG_ADDR__DSC_DEBUG_STS1                                         (DSC_ENC_WRAP | 0x0034)
  // (ReadOnly, Bits 7:0) 
  // DSC Debug Status1
  #define BIT_MSK__DSC_DEBUG_STS1__REG_DSC_DEBUG_STS1                                    0xFF

// DSC Debug Status #2 Register
#define REG_ADDR__DSC_DEBUG_STS2                                         (DSC_ENC_WRAP | 0x0035)
  // (ReadOnly, Bits 7:0) 
  // DSC Debug Status2
  #define BIT_MSK__DSC_DEBUG_STS2__REG_DSC_DEBUG_STS2                                    0xFF

// DSC Debug Status #3 Register
#define REG_ADDR__DSC_DEBUG_STS3                                         (DSC_ENC_WRAP | 0x0036)
  // (ReadOnly, Bits 7:0) 
  // DSC Debug Status3
  #define BIT_MSK__DSC_DEBUG_STS3__REG_DSC_DEBUG_STS3                                    0xFF

// DSC Debug Status #4 Register
#define REG_ADDR__DSC_DEBUG_STS4                                         (DSC_ENC_WRAP | 0x0037)
  // (ReadOnly, Bits 7:0) 
  // DSC Debug Status4
  #define BIT_MSK__DSC_DEBUG_STS4__REG_DSC_DEBUG_STS4                                    0xFF

// DSC Debug Status #5 Register
#define REG_ADDR__DSC_DEBUG_STS5                                         (DSC_ENC_WRAP | 0x0038)
  // (ReadOnly, Bits 7:0) 
  // DSC Debug Status5
  #define BIT_MSK__DSC_DEBUG_STS5__REG_DSC_DEBUG_STS5                                    0xFF

// DSC 420Wrapper Pixel Capture Line #0 Register
#define REG_ADDR__DSC_420_PIXCAP_LINE0                                   (DSC_ENC_WRAP | 0x0039)
  // (ReadWrite, Bits 7:0) 
  // DSC 420 Pixel Capture Line LS Byte
  #define BIT_MSK__DSC_420_PIXCAP_LINE0__REG_DSC_420_PIXCAP_LINE_B7_B0                         0xFF

// DSC 420Wrapper Pixel Capture Line #1 Register
#define REG_ADDR__DSC_420_PIXCAP_LINE1                                   (DSC_ENC_WRAP | 0x003A)
  // (ReadWrite, Bits 7:0) 
  // DSC 420 Pixel Capture Line MS Byte
  #define BIT_MSK__DSC_420_PIXCAP_LINE1__REG_DSC_420_PIXCAP_LINE_B15_B8                        0xFF

// DSC 420Wrapper Pixel Capture Pixel #0 Register
#define REG_ADDR__DSC_420_PIXCAP_PIX0                                    (DSC_ENC_WRAP | 0x003B)
  // (ReadWrite, Bits 7:0) 
  // DSC 420 Pixel Capture Pixel LS Byte
  #define BIT_MSK__DSC_420_PIXCAP_PIX0__REG_DSC_420_PIXCAP_PIX_B7_B0                          0xFF

// DSC 420Wrapper Pixel Capture Pixel #1 Register
#define REG_ADDR__DSC_420_PIXCAP_PIX1                                    (DSC_ENC_WRAP | 0x003C)
  // (ReadWrite, Bits 7:0) 
  // DSC 420 Pixel Capture Pixel MS Byte
  #define BIT_MSK__DSC_420_PIXCAP_PIX1__REG_DSC_420_PIXCAP_PIX_B15_B8                         0xFF

// DSC 420 Wrapper Captured Pixel #0 Register
#define REG_ADDR__DSC_420_PIXCAP0                                        (DSC_ENC_WRAP | 0x003D)
  // (ReadOnly, Bits 7:0) 
  // DSC 420 Wrapper Captured Pixel LS Byte
  #define BIT_MSK__DSC_420_PIXCAP0__REG_DSC_420_PIXCAP_B7_B0                              0xFF

// DSC 420 Wrapper Captured Pixel #1 Register
#define REG_ADDR__DSC_420_PIXCAP1                                        (DSC_ENC_WRAP | 0x003E)
  // (ReadOnly, Bits 7:0) 
  // DSC 420 Wrapper Captured Pixel Middle Byte
  #define BIT_MSK__DSC_420_PIXCAP1__REG_DSC_420_PIXCAP_B15_B8                             0xFF

// DSC 420 Wrapper Captured Pixel #2 Register
#define REG_ADDR__DSC_420_PIXCAP2                                        (DSC_ENC_WRAP | 0x003F)
  // (ReadOnly, Bits 7:0) 
  // DSC 420 Wrapper Captured Pixel MS Byte
  #define BIT_MSK__DSC_420_PIXCAP2__REG_DSC_420_PIXCAP_B23_B16                            0xFF

//***************************************************************************
// TX_TOP_P0. Address: 60
// IP MISC Register
#define REG_ADDR__DEBUG_MODE_EN                                          (TX_TOP_P0 | 0x0000)
  // (ReadWrite, Bits 0) 
  // Simulation mode. When enabled; time constant used is shortened. 0: disable (default) 1: enable
  #define BIT_MSK__DEBUG_MODE_EN__REG_SIMODE                                            0x01
  // (ReadWrite, Bits 1) 
  // Debug Mode 3 Enable 0: Disable 1: vsync; p_stable; HPD (facing upstream); RSEN; hdcp_ri_rdy; sup_an_stop; hdcp_bksv_err; and hdcp_enc_on are available from registers. 
  #define BIT_MSK__DEBUG_MODE_EN__REG_DBGMODE3_EN                                       0x02
  // (ReadWrite, Bits 2) 
  // Enabled to block DDC access when HPD is low
  #define BIT_MSK__DEBUG_MODE_EN__REG_BLOCK_DDC_BY_HPD                                  0x04
  // (ReadOnly, Bits 3) 
  // The current status of the VSYNC input pin. Monitor this bit with I2C to recognize the arrival of VSYNC pulses.
  #define BIT_MSK__DEBUG_MODE_EN__VSYNCPIN                                              0x08

// System Status Register
#define REG_ADDR__SYS_STAT                                               (TX_TOP_P0 | 0x0001)
  // (ReadOnly, Bits 0) 
  // IDCK to TMDS clock stable.  The state of this internal signal can be read from this bit.  Upon changes to the IDCK and/or TMDS_CTRL register's tclk_sel bits; this bit can go low.  After a low to high transition; a software reset is recommended (unless auto-reset is enabled).  Note: This bit was previously called MDI in earlier Silicon Image transmitters.
  #define BIT_MSK__SYS_STAT__P_STABLE                                              0x01
  // (ReadOnly, Bits 1) 
  // Upstream Hot Plug Detect status. This is the status manipulated by FW based on CBUS HPD and need 
  #define BIT_MSK__SYS_STAT__HPDPIN                                                0x02
  // (ReadOnly, Bits 2) 
  // This bit is HIGH if a powered on receiver is connected to the transmitter outputs; LOW otherwise. This function is only available for use in DC-coupled systems.  Rsen is active even if SYS_CTRL1's PD bit is 0 (in other words; rsen is available during power down).
  #define BIT_MSK__SYS_STAT__RSEN                                                  0x04
  // (ReadWrite, Bits 3) 
  // Set this bit will force IP prif_ready becomes 1 after certain timeout, for register byte located in tclk domain while tclk is not provided by the system.
  #define BIT_MSK__SYS_STAT__REG_FORCERDY_EN                                       0x08
  // (ReadWrite, Bits 7:4) 
  // This register defines a timer. After timer expiration IP prif_ready will be forced high for registers located in tclk domain. 4'h0: reserved    4'h1: 4 cycles;    4'h2: 8 cycles;    4'h3: 16 cyles;  4'h4: 32 cycles;   4'h5: 64 cycles;  4'h6: 128 cycles; 4'h7: 256 cyles; 4'h8: 512 cycles;   4'h9: 1k cycles;  4'hA: 2k cycles; 4'hB: 4k cyles; 4'hC: 8k cycles (default);   4'hD: 16k cycles;  4'hE: 32k cycles; 4'hF: 64k cyles;
  #define BIT_MSK__SYS_STAT__REG_FORCERDY_SEL                                      0xF0

// System Control #3 Register
#define REG_ADDR__SYS_CTRL3                                              (TX_TOP_P0 | 0x0002)
  // (ReadWrite, Bits 0) 
  // When set to 1'b1; 0x61A[0] will decide whether output HDMI or DVI
  #define BIT_MSK__SYS_CTRL3__REG_TX_CONTROL_HDMI                                   0x01
  // (ReadWrite, Bits 2:1) 
  // General Purpose Control. These CTL bit states are transmitted across the TMDS link during blanking times only. DVI 1.0 mode only.A754
  #define BIT_MSK__SYS_CTRL3__REG_CTL                                               0x06
  // (ReadWrite, Bits 5) 
  // 1: system wait counter time of 5000ms(needed for HDCP) and 2000ms(needed for CBUS) will start 0: counter will not start
  #define BIT_MSK__SYS_CTRL3__REG_SYS_CNTR                                          0x20

// System Control DPD Register
#define REG_ADDR__DPD                                                    (TX_TOP_P0 | 0x0003)
  // (ReadWrite, Bits 3) 
  // Power on HSIC
  #define BIT_MSK__DPD__REG_PWRON_HSIC                                        0x08
  // (ReadWrite, Bits 4) 
  // Power Down internal oscillator; effectively disabling Master I2C; Slave I2C; Charge Pump; and preventing uploading of new vectors from EPROM 0 - Power down.   1 - normal operation (default).
  #define BIT_MSK__DPD__REG_OSC_EN                                            0x10
  // (ReadWrite, Bits 5) 
  // Power on ETMDS
  #define BIT_MSK__DPD__REG_PWRON_ETMDS                                       0x20
  // (ReadWrite, Bits 6) 
  // Power on MHL Tx data path
  #define BIT_MSK__DPD__REG_PWRON_DP                                          0x40
  // (ReadWrite, Bits 7) 
  // Power on TX PLL
  #define BIT_MSK__DPD__REG_PWRON_PLL                                         0x80

// System Control #4 Register
#define REG_ADDR__SYS_CTRL4                                              (TX_TOP_P0 | 0x0004)
  // (ReadWrite, Bits 0) 
  // HDMI TransCode Mode enable bit. When set 1; HDMI stream will bypass internal process and  be sent to MHL TX directly. 0 - disable (default) 1 - enable
  #define BIT_MSK__SYS_CTRL4__REG_TRANSCODE                                         0x01
  // (ReadWrite, Bits 1) 
  // 
  #define BIT_MSK__SYS_CTRL4__REG_HSIC_TX_BIST_START_SEL                            0x02
  // (ReadWrite, Bits 2) 
  // This bit can select between Local I2C (including internal DDC master) and DDC port.  0 - Use Local I2C as a source port (default) 1 - Use DDC port as a source port
  #define BIT_MSK__SYS_CTRL4__REG_EXT_DDC_SEL                                       0x04
  // (ReadOnly, Bits 4) 
  // MHL1/2 FIFO Overflow/Underflow status
  #define BIT_MSK__SYS_CTRL4__REG_MHL_FIFO_OF_UF_FLAG                               0x10
  // (ReadOnly, Bits 5) 
  // TCF FIFO Overflow/Underflow status
  #define BIT_MSK__SYS_CTRL4__REG_TCF_OF_UF_FLAG                                    0x20
  // (ReadOnly, Bits 6) 
  // CTS FIFO Overflow/Underflow status
  #define BIT_MSK__SYS_CTRL4__REG_CTS_FIFO_OF_UF_FLAG                               0x40
  // (ReadWrite, Bits 7) 
  // TMDS BIST will go through the tx_hdmi_amixer if this bit is set
  #define BIT_MSK__SYS_CTRL4__REG_TMDS_BIST_B4_AMIXER                               0x80

// MCU Timeout Register
#define REG_ADDR__MCUTOUT                                                (TX_TOP_P0 | 0x0005)
  // (ReadWrite, Bits 7:0) 
  // This register defines in how many OCLK cycles MCU timeout will occur if there is no response for the request. The granularity is 256.
  #define BIT_MSK__MCUTOUT__REG_MCU_TIMEOUT                                       0xFF

// Digital IP RegRST Register 0
#define REG_ADDR__DIGIPREGRST0                                           (TX_TOP_P0 | 0x0006)
  // (ReadWrite, Bits 7:0) 
  // IP specific reset for register and PRIF decoding bit 0: AIP reset bit 1:  bit 2: CBUS_DISC reset bit 3: CBUS reset bit 4:  bit 5:  bit 6: bit 7: eMSC reset
  #define BIT_MSK__DIGIPREGRST0__REG_DIGIPREGRST0                                      0xFF

// Digital IP RegRST Register 1
#define REG_ADDR__DIGIPREGRST1                                           (TX_TOP_P0 | 0x0007)
  // (ReadWrite, Bits 7:0) 
  // IP specific reset for register and PRIF decoding bit 0:  bit 1: HDCP2 reset bit 2: HDMI2 reset bit 3: HDMI2MHL1 reset bit 4: HDMI2MHL3 reset bit 5:  bit 6: bit 7: DS_EDID reset
  #define BIT_MSK__DIGIPREGRST1__REG_DIGIPREGRST1                                      0xFF

// Digital IP RegRST Register 2
#define REG_ADDR__DIGIPREGRST2                                           (TX_TOP_P0 | 0x0008)
  // (ReadWrite, Bits 7:0) 
  // IP specific reset for register and PRIF decoding bit 0: MHL_TX_TOP reset bit 1:  bit 2: PTPI reset bit 3:  Sub TBIST reset bit 4: TDMCORE reset bit 5: USBTCORE reset bit 6: MCU reset bit 7: Main TBIST reset
  #define BIT_MSK__DIGIPREGRST2__REG_DIGIPREGRST2                                      0xFF

// Digital IP RegRST Register 3
#define REG_ADDR__DIGIPREGRST3                                           (TX_TOP_P0 | 0x0009)
  // (ReadWrite, Bits 7:0) 
  // IP specific reset for register and PRIF decoding bit 0: PKTZ_TDD reset 
  #define BIT_MSK__DIGIPREGRST3__REG_DIGIPREGRST3                                      0xFF

// HDCP Control Register
#define REG_ADDR__HDCP_CTRL                                              (TX_TOP_P0 | 0x000F)
  // (ReadWrite, Bits 0) 
  // Encryption Enable.                                               0 - Encryption disabled (default) 1 - Encryption enabled     Note: This bit can now be written to a 0.  If a 1 to 0 transition occurs; appropriate security measures are taken.
  #define BIT_MSK__HDCP_CTRL__REG_ENC_EN                                            0x01
  // (ReadOnly, Bits 1) 
  // Ri Ready.  This bit indicates that the first Ri value is available.  This bit is cleared by a hardware reset; cp_reset (reg. 0x009[2]) or by writing the last byte of the BKSV. It is set when finish loading the last byte of the KEYS.
  #define BIT_MSK__HDCP_CTRL__HDCP_RI_RDY                                           0x02
  // (ReadWrite, Bits 2) 
  // This is the reset bit for the cipher engine.  This bit is asserted by hardware reset or software.  It can be de-asserted (= 1) at any time.
  #define BIT_MSK__HDCP_CTRL__REG_CP_RESETN                                         0x04
  // (ReadWrite, Bits 3) 
  // When cleared; the cipher engine is allowed to free-run; and the WR_AN registers will cycle through a sequence of pseudo-random values.  This bit must be set for normal cipher operation.  When it is; the value read from the WR_AN registers may be used to initialize the AN register in the receiver.                                                This bit is automatically cleared under any of the following conditions:           - Software write 0 into it  - Hardware reset   - BKSV_ERR     - RX_RPTR is changed                                                                                     Note that either external hardware or software should detect when a device is not plugged in; and assert (= 1) this bit in such cases.
  #define BIT_MSK__HDCP_CTRL__REG_AN_STOP                                           0x08
  // (ReadWrite, Bits 4) 
  // Set this bit prior to authentication if the receiver is a repeater.
  #define BIT_MSK__HDCP_CTRL__REG_RX_RPTR                                           0x10
  // (ReadOnly, Bits 5) 
  // BKSV Error.    This bit is cleared (set to 0) when: 1. writing the last byte of the BKSV . 2. Hardware reset through the RESET pin  3. By setting cp_reset bit (reg. 0x00F[2])  It is set when load of the keys is done and BKSV did not had 20 ones.
  #define BIT_MSK__HDCP_CTRL__HDCP_BKSV_ERR                                         0x20
  // (ReadOnly, Bits 6) 
  // This bit is set to 1 whenever the encryption is enabled and encryption is in process.
  #define BIT_MSK__HDCP_CTRL__HDCP_ENC_ON                                           0x40

// Write BKSV1 Register
#define REG_ADDR__WR_BKSV_1                                              (TX_TOP_P0 | 0x0010)
  // (ReadWrite, Bits 7:0) 
  // Reciever's Key Select Vector. It is read from the reciever and then writen to here. When software writes byte #1 of Key Selector Vector in this register the 1 clock write strobe is generated and data is loaded into the bksv1 register located inside HDCP block.  During read get Data of BKSV #1 register. 
  #define BIT_MSK__WR_BKSV_1__REG_BKSV0                                             0xFF

// Write BKSV2 Register
#define REG_ADDR__WR_BKSV_2                                              (TX_TOP_P0 | 0x0011)
  // (ReadWrite, Bits 7:0) 
  // Reciever's Key Select Vector. It is read from the reciever and then writen to here. When software writes byte #2 of Key Selector Vector in this register the 1 clock write strobe is generated and data is loaded into the bksv2 register located inside HDCP block.  During read get Data of BKSV #2 register. 
  #define BIT_MSK__WR_BKSV_2__REG_BKSV1                                             0xFF

// Write BKSV3 Register
#define REG_ADDR__WR_BKSV_3                                              (TX_TOP_P0 | 0x0012)
  // (ReadWrite, Bits 7:0) 
  // Reciever's Key Select Vector. It is read from the reciever and then writen to here. When software writes byte #3 of Key Selector Vector in this register the 1 clock write strobe is generated and data is loaded into the bksv3 register located inside HDCP block.  During read get Data of BKSV #3 register. 
  #define BIT_MSK__WR_BKSV_3__REG_BKSV2                                             0xFF

// Write BKSV4 Register
#define REG_ADDR__WR_BKSV_4                                              (TX_TOP_P0 | 0x0013)
  // (ReadWrite, Bits 7:0) 
  // Reciever's Key Select Vector. It is read from the reciever and then writen to here. When software writes byte #4 of Key Selector Vector in this register the 1 clock write strobe is generated and data is loaded into the bksv4 register located inside HDCP block.  During read get Data of BKSV #4 register. 
  #define BIT_MSK__WR_BKSV_4__REG_BKSV3                                             0xFF

// Write BKSV5 Register
#define REG_ADDR__WR_BKSV_5                                              (TX_TOP_P0 | 0x0014)
  // (ReadWrite, Bits 7:0) 
  // Reciever's Key Select Vector. It is read from the reciever and then writen to here. When software writes byte #5 of Key Selector Vector in this register the 1 clock write strobe is generated and data is loaded into the bksv5 register located inside HDCP block. In addition if HDCP is enabled then by writing into this register the authentication is triggered.  During read get Data of BKSV #5 register. 
  #define BIT_MSK__WR_BKSV_5__REG_BKSV4                                             0xFF

// HDCP AN_1 Register
#define REG_ADDR__AN1                                                    (TX_TOP_P0 | 0x0015)
  // (ReadWrite, Bits 7:0) 
  // Byte #1 of a 64-bit pseudo-random value. May be read from this register and used in the authentication process. Also can write into this register
  #define BIT_MSK__AN1__HDCP_AN0                                              0xFF

// HDCP AN_2 Register
#define REG_ADDR__AN2                                                    (TX_TOP_P0 | 0x0016)
  // (ReadWrite, Bits 7:0) 
  // Byte #2 of a 64-bit pseudo-random value. May be read from this register and used in the authentication process. Also can write into this register
  #define BIT_MSK__AN2__HDCP_AN1                                              0xFF

// HDCP AN_3 Register
#define REG_ADDR__AN3                                                    (TX_TOP_P0 | 0x0017)
  // (ReadWrite, Bits 7:0) 
  // Byte #3 of a 64-bit pseudo-random value. May be read from this register and used in the authentication process. Also can write into this register
  #define BIT_MSK__AN3__HDCP_AN2                                              0xFF

// HDCP AN_4 Register
#define REG_ADDR__AN4                                                    (TX_TOP_P0 | 0x0018)
  // (ReadWrite, Bits 7:0) 
  // Byte #4 of a 64-bit pseudo-random value. May be read from this register and used in the authentication process. Also can write into this register
  #define BIT_MSK__AN4__HDCP_AN3                                              0xFF

// HDCP AN_5 Register
#define REG_ADDR__AN5                                                    (TX_TOP_P0 | 0x0019)
  // (ReadWrite, Bits 7:0) 
  // Byte #5 of a 64-bit pseudo-random value. May be read from this register and used in the authentication process. Also can write into this register
  #define BIT_MSK__AN5__HDCP_AN4                                              0xFF

// HDCP AN_6 Register
#define REG_ADDR__AN6                                                    (TX_TOP_P0 | 0x001A)
  // (ReadWrite, Bits 7:0) 
  // Byte #6 of a 64-bit pseudo-random value. May be read from this register and used in the authentication process. Also can write into this register
  #define BIT_MSK__AN6__HDCP_AN5                                              0xFF

// HDCP AN_7 Register
#define REG_ADDR__AN7                                                    (TX_TOP_P0 | 0x001B)
  // (ReadWrite, Bits 7:0) 
  // Byte #7 of a 64-bit pseudo-random value. May be read from this register and used in the authentication process.  Also can write into this register.
  #define BIT_MSK__AN7__HDCP_AN6                                              0xFF

// HDCP AN_8 Register
#define REG_ADDR__AN8                                                    (TX_TOP_P0 | 0x001C)
  // (ReadWrite, Bits 7:0) 
  // Byte #8 of a 64-bit pseudo-random value. May be read from this register and used in the authentication process. Also can write into this register
  #define BIT_MSK__AN8__HDCP_AN7                                              0xFF

// AKSV_1 Register
#define REG_ADDR__AKSV_1                                                 (TX_TOP_P0 | 0x001D)
  // (ReadOnly, Bits 7:0) 
  // Byte #1 of transmitters key select vector.  Five bytes: 1 is the LSB; 5 is the MSB.  All five bytes should be read from here and then written to the receiver.  Byte 5 should be written last into the receiver; and will trigger the authentication process in the receiver.
  #define BIT_MSK__AKSV_1__REG_AKSV0                                             0xFF

// AKSV_2 Register
#define REG_ADDR__AKSV_2                                                 (TX_TOP_P0 | 0x001E)
  // (ReadOnly, Bits 7:0) 
  // Byte #2 of transmitters key select vector.  Five bytes: 1 is the LSB; 5 is the MSB.  All five bytes should be read from here and then written to the receiver.  Byte 5 should be written last into the receiver; and will trigger the authentication process in the receiver.
  #define BIT_MSK__AKSV_2__REG_AKSV1                                             0xFF

// AKSV_3 Register
#define REG_ADDR__AKSV_3                                                 (TX_TOP_P0 | 0x001F)
  // (ReadOnly, Bits 7:0) 
  // Byte #3 of transmitters key select vector.  Five bytes: 1 is the LSB; 5 is the MSB.  All five bytes should be read from here and then written to the receiver.  Byte 5 should be written last into the receiver; and will trigger the authentication process in the receiver.
  #define BIT_MSK__AKSV_3__REG_AKSV2                                             0xFF

// AKSV_4 Register
#define REG_ADDR__AKSV_4                                                 (TX_TOP_P0 | 0x0020)
  // (ReadOnly, Bits 7:0) 
  // Byte #4 of transmitters key select vector.  Five bytes: 1 is the LSB; 5 is the MSB.  All five bytes should be read from here and then written to the receiver.  Byte 5 should be written last into the receiver; and will trigger the authentication process in the receiver.
  #define BIT_MSK__AKSV_4__REG_AKSV3                                             0xFF

// AKSV_5 Register
#define REG_ADDR__AKSV_5                                                 (TX_TOP_P0 | 0x0021)
  // (ReadOnly, Bits 7:0) 
  // Byte #5 of transmitters key select vector.  Five bytes: 1 is the LSB; 5 is the MSB.  All five bytes should be read from here and then written to the receiver.  Byte 5 should be written last into the receiver; and will trigger the authentication process in the receiver.
  #define BIT_MSK__AKSV_5__REG_AKSV4                                             0xFF

// Ri_1 Register
#define REG_ADDR__RI_1                                                   (TX_TOP_P0 | 0x0022)
  // (ReadOnly, Bits 7:0) 
  // Ri value.  The values of these registers should be read and compared against the Ri value of the receiver to ensure that the encryption process on the transmitter and receiver are synchronized.  with vp_sel = 1 (page 0 0xEC bit 6); the status is from HW TPI; with vp_sel = 0; the status from normal path.
  #define BIT_MSK__RI_1__REG_RI_PRIME0                                         0xFF

// Ri_2 Register
#define REG_ADDR__RI_2                                                   (TX_TOP_P0 | 0x0023)
  // (ReadOnly, Bits 7:0) 
  // Ri value.  The values of these registers should be read and compared against the Ri value of the receiver to ensure that the encryption process on the transmitter and receiver are synchronized. with vp_sel = 1 (page 0 0xEC bit 6); the status is from HW TPI; with vp_sel = 0; the status from normal path.
  #define BIT_MSK__RI_2__REG_RI_PRIME1                                         0xFF

// HDCP Ri 128 Compare Value Register
#define REG_ADDR__RI_128_COMP                                            (TX_TOP_P0 | 0x0024)
  // (ReadWrite, Bits 6:0) 
  // HDCP Ri 128 Compare Value
  #define BIT_MSK__RI_128_COMP__REG_RI_128_COMP                                       0x7F

// HDCP I counter Register
#define REG_ADDR__HDCP_I_CNT                                             (TX_TOP_P0 | 0x0025)
  // (ReadOnly, Bits 6:0) 
  // I counter
  #define BIT_MSK__HDCP_I_CNT__HDCP_I_CNT                                            0x7F

// Ri Status Register
#define REG_ADDR__RI_STAT                                                (TX_TOP_P0 | 0x0026)

// Ri Command Register
#define REG_ADDR__RI_CMD                                                 (TX_TOP_P0 | 0x0027)

// Ri Line Start Register
#define REG_ADDR__RI_START                                               (TX_TOP_P0 | 0x0028)
  // (ReadWrite, Bits 7:0) 
  // Indicates at what line within frame 127 or 0 to start Ri Check. This number is power of 2 - 2 lsb are 0; default is 17.
  #define BIT_MSK__RI_START__REG_RI_LN_NUM                                         0xFF

// Ri from Rx #1 Register
#define REG_ADDR__RI_RX_1                                                (TX_TOP_P0 | 0x0029)

// Ri from Rx #2 Register
#define REG_ADDR__RI_RX_2                                                (TX_TOP_P0 | 0x002A)

//  HDCP Debug Register
#define REG_ADDR__TXHDCP_DEBUG                                           (TX_TOP_P0 | 0x002B)
  // (ReadWrite, Bits 6) 
  // Setting this bit to 1 will force stop update of the Ri values
  #define BIT_MSK__TXHDCP_DEBUG__REG_RI_HOLD                                           0x40
  // (ReadWrite, Bits 7) 
  // Setting this bit to 1 will force trush of Ri values (it will be set to 0)
  #define BIT_MSK__TXHDCP_DEBUG__REG_RI_TRUSH                                          0x80

// CLK Ratio Control Register
#define REG_ADDR__CLKRATIO                                               (TX_TOP_P0 | 0x0035)
  // (ReadWrite, Bits 1:0) 
  // This register defines the ratio between IDCK and PCLK when reg_clkratio_sw_en is set. This is a special SWHR register. SW can write. When read; it is HW value decoded based on video_path_core configuration. 00: IDCK is half rate as PCLK. 01: IDCK is the same rate as PCLK (default) 10: Customized relationship driven by SoC without HW automation 11: reserved
  #define BIT_MSK__CLKRATIO__REG_IDCK2PCLK_RATIO                                   0x03
  // (ReadWrite, Bits 3:2) 
  // This register defines the ratio between PCLKNX and PCLK when reg_clkratio_sw_en is set. This is a special SWHR register. SW can write. When read; it is HW value decoded based on video_path_core configuration. 00: PCLKNX is half rate as PCLK. 01: PCLKNX is the same rate as PCLK (default) 10: PCLKNX is twice as fast as PCLK 11: PCLKNX is four times as fast as PCLK.
  #define BIT_MSK__CLKRATIO__REG_PCLKNX2PCLK_RATIO                                 0x0C
  // (ReadWrite, Bits 7) 
  // This register enables SW clock ratios; reg_idck2pclk_ratio and reg_pclknx2pclk_ratio.  1: enable SW clock ratio (default) 0: enable HW decoded clock ratio
  #define BIT_MSK__CLKRATIO__REG_CLKRATIO_SW_EN                                    0x80

// PCLK2TCLK Control Register
#define REG_ADDR__P2T_CTRL                                               (TX_TOP_P0 | 0x0036)
  // (ReadWrite, Bits 1:0) 
  // PACK Mode 00:  8bpp (default) 01: 10bpp 10: 12bpp 11: 16bpp
  #define BIT_MSK__P2T_CTRL__REG_PACK_MODE                                         0x03
  // (ReadWrite, Bits 2) 
  // Forces the state machine to go to Idle state if no request is there and the state is either di_gb1 or di_gb2
  #define BIT_MSK__P2T_CTRL__REG_FORCE_IDLE                                        0x04
  // (ReadWrite, Bits 5) 
  // Null Packet Enable at VSYNC High 1: enable(default) 0: disable
  #define BIT_MSK__P2T_CTRL__REG_NULL_PKT_EN_VS_HI                                 0x20
  // (ReadWrite, Bits 6) 
  // Null Packet Enable bit 1: enable(default) 0: disable
  #define BIT_MSK__P2T_CTRL__REG_NULL_PKT_EN                                       0x40
  // (ReadWrite, Bits 7) 
  // Deep Color Packet Enable bit 1: enable(default) 0: disable
  #define BIT_MSK__P2T_CTRL__REG_DC_PKT_EN                                         0x80

// Video Blank Data Low Byte Register
#define REG_ADDR__VID_BLANK0                                             (TX_TOP_P0 | 0x0037)
  // (ReadWrite, Bits 7:0) 
  // This byte defines the blank data for channel B/Cb. Default is 0.
  #define BIT_MSK__VID_BLANK0__REG_VIDEO_MUTE_DATA_B0                                0xFF

// Video Blank Data Mid Byte Register
#define REG_ADDR__VID_BLANK1                                             (TX_TOP_P0 | 0x0038)
  // (ReadWrite, Bits 7:0) 
  // This byte defines the blank data for channel G/Y. Default is 0.
  #define BIT_MSK__VID_BLANK1__REG_VIDEO_MUTE_DATA_B1                                0xFF

// Video Blank Data High Byte Register
#define REG_ADDR__VID_BLANK2                                             (TX_TOP_P0 | 0x0039)
  // (ReadWrite, Bits 7:0) 
  // This byte defines the blank data for channel R/Cr. Default is 0.
  #define BIT_MSK__VID_BLANK2__REG_VIDEO_MUTE_DATA_B2                                0xFF

// Video Override Register
#define REG_ADDR__VID_OVRRD                                              (TX_TOP_P0 | 0x003A)
  // (ReadWrite, Bits 4) 
  // Enable MHL 3D fram packing conversion
  #define BIT_MSK__VID_OVRRD__REG_3DCONV_EN                                         0x10
  // (ReadWrite, Bits 5) 
  // Enable the insertion of a mini Vsync when reg_3dconv_en is set
  #define BIT_MSK__VID_OVRRD__REG_MINIVSYNC_ON                                      0x20

// AuxPort DEProc Register
#define REG_ADDR__AP_DEPROC                                              (TX_TOP_P0 | 0x003B)
  // (ReadWrite, Bits 5:0) 
  // The max number of free-count for AP wr_en process. 0 or 1 is not a valid setting when this function enabled.
  #define BIT_MSK__AP_DEPROC__REG_APEN_FCNTMAX                                      0x3F
  // (ReadWrite, Bits 6) 
  // Select the source of ap_force_send. 1 means internal (Vsync leading edge); 0 means external force_send.
  #define BIT_MSK__AP_DEPROC__REG_APFORCE_SEL                                       0x40
  // (ReadWrite, Bits 7) 
  // The enable bit for AP wr_en process. 1 is enable.
  #define BIT_MSK__AP_DEPROC__REG_APENPROC_EN                                       0x80

// Video Sync Polarity Detection Register
#define REG_ADDR__POL_DETECT                                             (TX_TOP_P0 | 0x003F)
  // (ReadOnly, Bits 0) 
  // Internal circuit detected Hsync polarity: 0 - active high 1 - active low
  #define BIT_MSK__POL_DETECT__HSYNCPOLOUT                                           0x01
  // (ReadOnly, Bits 1) 
  // Internal circuit detected Vsync polarity: 0 - active high 1 - active low
  #define BIT_MSK__POL_DETECT__VSYNCPOLOUT                                           0x02
  // (ReadOnly, Bits 2) 
  // A high indicates the detection of interlace video: 1 - interlace video; 0 - noninterlaced. 
  #define BIT_MSK__POL_DETECT__INTERLACEDOUT                                         0x04

// CEA-861 VSI InfoFrame MHL IEEE No #0 Register
#define REG_ADDR__VSI_MHL_IEEE_NO_0                                      (TX_TOP_P0 | 0x0042)
  // (ReadWrite, Bits 7:0) 
  // Read CEA-861 for detailed description of this register OUI=0x7CA61D
  #define BIT_MSK__VSI_MHL_IEEE_NO_0__REG_MHL_IEEE_NO_B7_B0                                 0xFF

// CEA-861 VSI InfoFrame MHL IEEE No #1 Register
#define REG_ADDR__VSI_MHL_IEEE_NO_1                                      (TX_TOP_P0 | 0x0043)
  // (ReadWrite, Bits 7:0) 
  // Read CEA-861 for detailed description of this register OUI=0x7CA61D
  #define BIT_MSK__VSI_MHL_IEEE_NO_1__REG_MHL_IEEE_NO_B15_B8                                0xFF

// CEA-861 VSI InfoFrame MHL IEEE No #2 Register
#define REG_ADDR__VSI_MHL_IEEE_NO_2                                      (TX_TOP_P0 | 0x0044)
  // (ReadWrite, Bits 7:0) 
  // Read CEA-861 for detailed description of this register OUI=0x7CA61D
  #define BIT_MSK__VSI_MHL_IEEE_NO_2__REG_MHL_IEEE_NO_B23_B16                               0xFF

// Packet Filter0 Register
#define REG_ADDR__PKT_FILTER_0                                           (TX_TOP_P0 | 0x0045)
  // (ReadWrite, Bits 0) 
  // GCP Packet pass through disable. 0 - GCP packet received from the active input port is passed through to the output port 1 - disable the pass through
  #define BIT_MSK__PKT_FILTER_0__REG_DROP_GCP_PKT                                      0x01
  // (ReadWrite, Bits 1) 
  // Block ACR packet from pass-through 0 - Pass-through ACR packet from active input pipe 1 - Block ACR packet from active input pipe
  #define BIT_MSK__PKT_FILTER_0__REG_DROP_CTS_PKT                                      0x02
  // (ReadWrite, Bits 2) 
  // Block AVI InfoFrame from pass-through 0 - Pass-through AVI InfoFrame from active input pipe  1 - Block AVI InfoFrame from active input pipe
  #define BIT_MSK__PKT_FILTER_0__REG_DROP_AVI_PKT                                      0x04
  // (ReadWrite, Bits 3) 
  // Block Audio InfoFrame from pass-through 0 - Pass-through Audio InfoFrame from active input pipe 1 - Block Audio InfoFrame from active input pipe
  #define BIT_MSK__PKT_FILTER_0__REG_DROP_AIF_PKT                                      0x08
  // (ReadWrite, Bits 4) 
  // Block SPD InfoFrame from pass-through 0 - Pass-through SPD InfoFrame from active input pipe 1 - Block SPD InfoFrame from active input pipe 
  #define BIT_MSK__PKT_FILTER_0__REG_DROP_SPIF_PKT                                     0x10
  // (ReadWrite, Bits 5) 
  // Block MPEG InfoFrame from pass-through 0 - Pass-through MPEG InfoFrame from active input pipe 1 - Block MPEG InfoFrame from active input pipe
  #define BIT_MSK__PKT_FILTER_0__REG_DROP_MPEG_PKT                                     0x20
  // (ReadWrite, Bits 6) 
  // Block Audio Content Protection packet (0x04) from pass-through 0 - Pass-through Audio Content Protection packet from active input pipe 1 - Block Audio Content Protection packet from active input pipe 
  #define BIT_MSK__PKT_FILTER_0__REG_DROP_CEA_CP_PKT                                   0x40
  // (ReadWrite, Bits 7) 
  // Block Gamut Metadata packet from pass-through 0 - Pass-through Gamut Metadata packet from active input pipe 1 - Block Gamut Metadata packet from active input pipe
  #define BIT_MSK__PKT_FILTER_0__REG_DROP_CEA_GAMUT_PKT                                0x80

// Packet Filter1 Register
#define REG_ADDR__PKT_FILTER_1                                           (TX_TOP_P0 | 0x0046)
  // (ReadWrite, Bits 0) 
  // Block Vendor-Specific InfoFrame from pass-through 0 - Pass-through Vendor-Specific InfoFrame from active input pipe  1 - Block Vendor-Specific InfoFrame from active input pipe
  #define BIT_MSK__PKT_FILTER_1__REG_DROP_VSIF_PKT                                     0x01
  // (ReadWrite, Bits 1) 
  // Block Generic InfoFrame from pass-through 0 - Pass-through Generic InfoFrame from active input pipe 1 - Block Generic InfoFrame from active input pipe The Generic InfoFrame type is decided by the reg_drop_gen_type.
  #define BIT_MSK__PKT_FILTER_1__REG_DROP_GEN_PKT                                      0x02
  // (ReadWrite, Bits 2) 
  // Block Generic (2) InfoFrame from pass-through 0 - Pass-through Generic (2) InfoFrame from active input pipe  1 - Block Generic (2) InfoFrame from active input pipe  The Generic InfoFrame type is decided by the reg_drop_gen2_type.
  #define BIT_MSK__PKT_FILTER_1__REG_DROP_GEN2_PKT                                     0x04
  // (ReadWrite, Bits 3) 
  // Audio Packet pass through enable 0 - Disable the pass through for the Audio packets 1 - Audio packets received from the active input pipe are passed through to the output port 
  #define BIT_MSK__PKT_FILTER_1__REG_DROP_AUDIO_PKT                                    0x08
  // (ReadWrite, Bits 4) 
  // Block Null Packet from pass-through  0 - Pass-through Null Packet from active input pipe  1 - Block Null Packet from active input pipe
  #define BIT_MSK__PKT_FILTER_1__REG_DROP_NULL_PKT                                     0x10
  // (ReadWrite, Bits 6) 
  // Disable AVI override
  #define BIT_MSK__PKT_FILTER_1__REG_AVI_OVERRIDE_DIS                                  0x40
  // (ReadWrite, Bits 7) 
  // Disable VSIF override
  #define BIT_MSK__PKT_FILTER_1__REG_VSI_OVERRIDE_DIS                                  0x80

// DROP GEN PACKET TYPE 0 Register
#define REG_ADDR__DROP_GEN_TYPE_0                                        (TX_TOP_P0 | 0x0047)
  // (ReadWrite, Bits 7:0) 
  // Block packets matched with this packet header type
  #define BIT_MSK__DROP_GEN_TYPE_0__REG_DROP_GEN_TYPE                                     0xFF

// DROP GEN PACKET TYPE 1 Register
#define REG_ADDR__DROP_GEN_TYPE_1                                        (TX_TOP_P0 | 0x0048)
  // (ReadWrite, Bits 7:0) 
  // Block packets matched with this packet header type
  #define BIT_MSK__DROP_GEN_TYPE_1__REG_DROP_GEN2_TYPE                                    0xFF

// DI PASS THROUGH CONTROL Register
#define REG_ADDR__DIPT_CNTL                                              (TX_TOP_P0 | 0x0049)
  // (ReadWrite, Bits 0) 
  // 1 - enable packets pass through function 0 - disable packets pass through function
  #define BIT_MSK__DIPT_CNTL__REG_PKT_BYP_MODE                                      0x01
  // (ReadWrite, Bits 1) 
  // 1 - enable audio packets pass through function 0 - disable audio packets pass through function
  #define BIT_MSK__DIPT_CNTL__REG_AUD_BYP_MODE                                      0x02
  // (ReadWrite, Bits 2) 
  // 1 - split audio packets and other static packets 0 - do not split audio packets and othre static packets
  #define BIT_MSK__DIPT_CNTL__REG_AUD_SPLIT_EN                                      0x04
  // (ReadWrite, Bits 3) 
  // 1 - the contens of deep color control information in General Control Packet are overrided 0 -  the contens of deep color control information in General Control Packet are not overrided
  #define BIT_MSK__DIPT_CNTL__REG_PB_OVR_DC_PKT_EN                                  0x08
  // (ReadWrite, Bits 4) 
  // 1 - the priority of pass through packets is high 0 - the priority of pass through packets is low 
  #define BIT_MSK__DIPT_CNTL__REG_PB_PRIORITY_CTL                                   0x10
  // (ReadWrite, Bits 5) 
  // 1 - the deep color packing mode information is masked 0 - the ddep color packing mode information is not masked This bit is used in bypassing deep color video without unpacking and packing it
  #define BIT_MSK__DIPT_CNTL__REG_DC_PACK_MODE_MASK                                 0x20

// system counter_0 Register
#define REG_ADDR__SYS_CNTR_0                                             (TX_TOP_P0 | 0x004A)
  // (ReadWrite, Bits 7:0) 
  // System counter low with granularity 0x1000 in 2MHz clock domain. This value is to be loaded in the system counter.
  #define BIT_MSK__SYS_CNTR_0__REG_CNTR_VALUE_B7_B0                                  0xFF

// system counter_1 Register
#define REG_ADDR__SYS_CNTR_1                                             (TX_TOP_P0 | 0x004B)
  // (ReadWrite, Bits 7:0) 
  // System counter high
  #define BIT_MSK__SYS_CNTR_1__REG_CNTR_VALUE_B15_B8                                 0xFF

// system counter_0 Status Register
#define REG_ADDR__SYS_CNTR_ST0                                           (TX_TOP_P0 | 0x004C)
  // (ReadOnly, Bits 7:0) 
  // System counter low with granularity 0x1000 in 2MHz clock domain. This is the current value of the system counter.
  #define BIT_MSK__SYS_CNTR_ST0__SYS_CNTR_B7_B0                                        0xFF

// system counter_1 Status Register
#define REG_ADDR__SYS_CNTR_ST1                                           (TX_TOP_P0 | 0x004D)
  // (ReadOnly, Bits 7:0) 
  // System counter high
  #define BIT_MSK__SYS_CNTR_ST1__SYS_CNTR_B15_B8                                       0xFF

// 1st Layer Interrupt Status #1 Register
#define REG_ADDR__L1_INTR_STAT_0                                         (TX_TOP_P0 | 0x004E)
  // (ReadOnly, Bits 0) 
  // Aggregated INTR1 interrupts with masks 
  #define BIT_MSK__L1_INTR_STAT_0__L1_INTR_STAT_B0                                       0x01
  // (ReadOnly, Bits 1) 
  // Aggregated INTR2 interrupts with masks 
  #define BIT_MSK__L1_INTR_STAT_0__L1_INTR_STAT_B1                                       0x02
  // (ReadOnly, Bits 2) 
  // Aggregated INTR3 interrupts with masks 
  #define BIT_MSK__L1_INTR_STAT_0__L1_INTR_STAT_B2                                       0x04
  // (ReadOnly, Bits 3) 
  // Aggregated INTR5 interrupts with masks 
  #define BIT_MSK__L1_INTR_STAT_0__L1_INTR_STAT_B3                                       0x08
  // (ReadOnly, Bits 4) 
  // TPI IP interrupt 
  #define BIT_MSK__L1_INTR_STAT_0__L1_INTR_STAT_B4                                       0x10
  // (ReadOnly, Bits 5) 
  // MHL_TX IP interrupt
  #define BIT_MSK__L1_INTR_STAT_0__L1_INTR_STAT_B5                                       0x20
  // (ReadOnly, Bits 6) 
  // Aggregated SCDC INTR interrupts with masks 
  #define BIT_MSK__L1_INTR_STAT_0__L1_INTR_STAT_B6                                       0x40
  // (ReadOnly, Bits 7) 
  // HDCP2X IP interrupt
  #define BIT_MSK__L1_INTR_STAT_0__L1_INTR_STAT_B7                                       0x80

// 1st Layer Interrupt Status #2 Register
#define REG_ADDR__L1_INTR_STAT_1                                         (TX_TOP_P0 | 0x004F)
  // (ReadOnly, Bits 0) 
  // AIP IP interrupt
  #define BIT_MSK__L1_INTR_STAT_1__L1_INTR_STAT_B8                                       0x01
  // (ReadOnly, Bits 1) 
  // CEC IP interrupt
  #define BIT_MSK__L1_INTR_STAT_1__L1_INTR_STAT_B9                                       0x02
  // (ReadOnly, Bits 2) 
  // Video_Path_Core interrupt
  #define BIT_MSK__L1_INTR_STAT_1__L1_INTR_STAT_B10                                      0x04
  // (ReadOnly, Bits 3) 
  // Downstream EDID interrupt
  #define BIT_MSK__L1_INTR_STAT_1__L1_INTR_STAT_B11                                      0x08

// Hot Plug Connection Debouncing Timer 2 Register
#define REG_ADDR__HTPLG_T2                                               (TX_TOP_P0 | 0x005A)
  // (ReadWrite, Bits 7:0) 
  // Hot Plug Detect debouncing timer counter 2nd stage
  #define BIT_MSK__HTPLG_T2__REG_HPD_T2                                            0xFF

// Hot Plug Connection Debouncing Timer 1 Register
#define REG_ADDR__HTPLG_T1                                               (TX_TOP_P0 | 0x005B)
  // (ReadWrite, Bits 7:0) 
  // Hot Plug Detect debouncing timer counter 1st stage
  #define BIT_MSK__HTPLG_T1__REG_HPD_T1                                            0xFF

// Interrupt State Register
#define REG_ADDR__INTR_STATE                                             (TX_TOP_P0 | 0x005E)
  // (ReadOnly, Bits 0) 
  // Interrupt state bit value.  It shows whether the interrupt is active or not.  It is one gate before the polarity is applied to the interrupt.  In other words; whenever the interrupt is asserted; this bit is high.
  #define BIT_MSK__INTR_STATE__INTR_STATE                                            0x01
  // (ReadWrite, Bits 7) 
  // Set software interrupt INTR2[2] when 1'b1 is written (self resetting) 
  #define BIT_MSK__INTR_STATE__REG_SOFTWARE                                          0x80

// Interrupt Source #1 Register
#define REG_ADDR__INTR1                                                  (TX_TOP_P0 | 0x005F)
  // (ReadWrite, Bits 1) 
  // KSVFIFO pending stuck for too long and PRIF ready is forced back to high.
  #define BIT_MSK__INTR1__REG_INTR1_STAT1                                       0x02
  // (ReadWrite, Bits 2) 
  // Counts frames after encryption is turned on and rolls over after 128 frames. Asserted if set to 1. Write '1' to clear this bit.
  #define BIT_MSK__INTR1__REG_INTR1_STAT2                                       0x04
  // (ReadWrite, Bits 3) 
  // MCU timeout for request. Write '1' to clear this bit.
  #define BIT_MSK__INTR1__REG_INTR1_STAT3                                       0x08
  // (ReadWrite, Bits 4) 
  // P0 PRIF ready stuck low due for too long and is forced back to high.
  #define BIT_MSK__INTR1__REG_INTR1_STAT4                                       0x10
  // (ReadWrite, Bits 5) 
  // Monitor Detect Interrupt. Not applicable for Cypress HDMI Mode. During normal operation: '1' if detection signal (RSEN) has changed logic level.  During power down: '1' if detection signal (RSEN) changes.  Asserted if set to 1. Write 1 to clear.
  #define BIT_MSK__INTR1__REG_INTR1_STAT5                                       0x20
  // (ReadWrite, Bits 6) 
  // Monitor Detect Interrupt; '1' if detection signal (HPD) has changed logic level. Asserted if set to 1. Write '1' to clear this bit.                                                                   
  #define BIT_MSK__INTR1__REG_INTR1_STAT6                                       0x40
  // (ReadWrite, Bits 7) 
  // 5000ms(HDCP); 2000ms(CBUS) wait time counter. Asserted if set to 1. Write '1' to clear this bit
  #define BIT_MSK__INTR1__REG_INTR1_STAT7                                       0x80

// Interrupt Source #2 Register
#define REG_ADDR__INTR2                                                  (TX_TOP_P0 | 0x0060)
  // (ReadWrite, Bits 0) 
  // VSync active edge is recognized.  Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__INTR2__REG_INTR2_STAT0                                       0x01
  // (ReadWrite, Bits 1) 
  // TCLK_STABLE has changed state Interrupt.  '1' if internal signal indicating TCLK_STABLE has changed logic level; indicating a change in the stability of the clock going to TMDS (from stable to non-stable or vice-versa).  Read the SYS_STAT register bit 1 to see the live state of TCLK_STABLE. Asserted if set to 1. Write 1 to clear.
  #define BIT_MSK__INTR2__REG_INTR2_STAT1                                       0x02
  // (ReadWrite, Bits 2) 
  // The interrupt will be asserted when 1'b1 is written into INT_CTRL[7]
  #define BIT_MSK__INTR2__REG_INTR2_STAT2                                       0x04
  // (ReadWrite, Bits 5) 
  // ENC_EN changed from 1 to 0. Write 1 to clear
  #define BIT_MSK__INTR2__REG_INTR2_STAT5                                       0x20
  // (ReadWrite, Bits 6) 
  // Hash Done interrupt. Write 1 to clear.
  #define BIT_MSK__INTR2__REG_INTR2_STAT6                                       0x40

// Interrupt Source #3 Register
#define REG_ADDR__INTR3                                                  (TX_TOP_P0 | 0x0061)
  // (ReadWrite, Bits 0) 
  // DDC FIFO is empty. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__INTR3__REG_INTR3_STAT0                                       0x01
  // (ReadWrite, Bits 1) 
  // DDC FIFO is full interrupt. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__INTR3__REG_INTR3_STAT1                                       0x02
  // (ReadWrite, Bits 2) 
  // DDC FIFO is half-full interrupt. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__INTR3__REG_INTR3_STAT2                                       0x04
  // (ReadWrite, Bits 3) 
  // DDC command is done interrupt. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__INTR3__REG_INTR3_STAT3                                       0x08

// Interrupt Source #5 Register
#define REG_ADDR__INTR5                                                  (TX_TOP_P0 | 0x0062)
  // (ReadWrite, Bits 2) 
  // MHL2 3-] FIFO Overflow/Undeflow. Asserted if set to 1. Write 1 to clear. Not applicable for Cypress HDMI Mode.
  #define BIT_MSK__INTR5__REG_INTR5_STAT2                                       0x04
  // (ReadWrite, Bits 3) 
  // MHL2/3 timing closure FIFO Overflow/Underflow. Asserted if set to 1. Write 1 to clear. Not applicable for Cypress HDMI Mode.
  #define BIT_MSK__INTR5__REG_INTR5_STAT3                                       0x08
  // (ReadWrite, Bits 6) 
  // MHL3 CTS FIFO overflow and underflow. Not applicable for Cypress.
  #define BIT_MSK__INTR5__REG_INTR5_STAT6                                       0x40
  // (ReadWrite, Bits 7) 
  // Packet Queue Overflow
  #define BIT_MSK__INTR5__REG_INTR5_STAT7                                       0x80

// Interrupt #1 Mask Register
#define REG_ADDR__INTR1_MASK                                             (TX_TOP_P0 | 0x0065)
  // (ReadWrite, Bits 1) 
  // Enable INT1[1]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__INTR1_MASK__REG_INTR1_MASK1                                       0x02
  // (ReadWrite, Bits 2) 
  // Enable INT1[2]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__INTR1_MASK__REG_INTR1_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // Enable INT1[3]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__INTR1_MASK__REG_INTR1_MASK3                                       0x08
  // (ReadWrite, Bits 4) 
  // Enable INT1[4]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__INTR1_MASK__REG_INTR1_MASK4                                       0x10
  // (ReadWrite, Bits 5) 
  // Enable INT1[5]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__INTR1_MASK__REG_INTR1_MASK5                                       0x20
  // (ReadWrite, Bits 6) 
  // Enable INT1[6]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__INTR1_MASK__REG_INTR1_MASK6                                       0x40
  // (ReadWrite, Bits 7) 
  // Enable INT1[7]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__INTR1_MASK__REG_INTR1_MASK7                                       0x80

// Interrupt #2 Mask Register
#define REG_ADDR__INTR2_MASK                                             (TX_TOP_P0 | 0x0066)
  // (ReadWrite, Bits 0) 
  // Enable INTR2[0]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__INTR2_MASK__REG_INTR2_MASK0                                       0x01
  // (ReadWrite, Bits 1) 
  // Enable INTR2[1]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__INTR2_MASK__REG_INTR2_MASK1                                       0x02
  // (ReadWrite, Bits 2) 
  // Enable INTR2[2]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__INTR2_MASK__REG_INTR2_MASK2                                       0x04
  // (ReadWrite, Bits 5) 
  // Enable INTR2[5]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__INTR2_MASK__REG_INTR2_MASK5                                       0x20
  // (ReadWrite, Bits 6) 
  // Enable INTR2[6]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__INTR2_MASK__REG_INTR2_MASK6                                       0x40

// Interrupt #3 Mask Register
#define REG_ADDR__INTR3_MASK                                             (TX_TOP_P0 | 0x0067)
  // (ReadWrite, Bits 0) 
  // Enable INTR3[0]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__INTR3_MASK__REG_INTR3_MASK0                                       0x01
  // (ReadWrite, Bits 1) 
  // Enable INTR3[1]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__INTR3_MASK__REG_INTR3_MASK1                                       0x02
  // (ReadWrite, Bits 2) 
  // Enable INTR3[2]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__INTR3_MASK__REG_INTR3_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // Enable INTR3[3]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__INTR3_MASK__REG_INTR3_MASK3                                       0x08

// Interrupt #5 Mask Register
#define REG_ADDR__INTR5_MASK                                             (TX_TOP_P0 | 0x0068)
  // (ReadWrite, Bits 2) 
  // Enable INT5[2]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__INTR5_MASK__REG_INTR5_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // Enable INT5[3]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__INTR5_MASK__REG_INTR5_MASK3                                       0x08
  // (ReadWrite, Bits 5) 
  // Enable INT5[5]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__INTR5_MASK__REG_INTR5_MASK5                                       0x20
  // (ReadWrite, Bits 6) 
  // Enable INT5[6]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__INTR5_MASK__REG_INTR5_MASK6                                       0x40
  // (ReadWrite, Bits 7) 
  // Enable INT5[4]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__INTR5_MASK__REG_INTR5_MASK7                                       0x80

// Hot Plug Connection Control Register
#define REG_ADDR__HPD_CTRL                                               (TX_TOP_P0 | 0x006B)
  // (ReadWrite, Bits 4) 
  // 0 : HPD output = SET_HPD status; 1: HPD output = reg_hpd_out_ovr_val
  #define BIT_MSK__HPD_CTRL__REG_HPD_OUT_OVR_EN                                    0x10
  // (ReadWrite, Bits 5) 
  // 0 : HPD output = LOW (if reg_hpd_out_ovr_en=1); 1: HPD output = HIGH (if reg_hpd_out_ovr_en=1)
  #define BIT_MSK__HPD_CTRL__REG_HPD_OUT_OVR_VAL                                   0x20
  // (ReadWrite, Bits 6) 
  // Open Drain 0: disable 1: enable (default)
  #define BIT_MSK__HPD_CTRL__REG_HPD_OUT_OD_EN                                     0x40
  // (ReadWrite, Bits 7) 
  // This value is ORed with Downstream HPD internally.
  #define BIT_MSK__HPD_CTRL__REG_HPD_DS_SIGNAL                                     0x80

// TMDS Clock Status Register
#define REG_ADDR__TMDS_CSTAT                                             (TX_TOP_P0 | 0x006F)
  // (ReadOnly, Bits 2) 
  // HDMI RPWR5V status 0 - 5V gone and cable disconnected 1 - Cable connected
  #define BIT_MSK__TMDS_CSTAT__RPWR5V                                                0x04

// TMDS Control #4 Register
#define REG_ADDR__TMDS_CTRL4                                             (TX_TOP_P0 | 0x0073)
  // (ReadWrite, Bits 0) 
  // Enable SCDT to control tx_en for MHL TMDS TX 0: Disable ( to default by #23345) 1: Enable (default to non-default by #23345)
  #define BIT_MSK__TMDS_CTRL4__REG_TX_EN_BY_SCDT                                     0x01

// SCDT Holdoff MSB Register
#define REG_ADDR__SCDT_HOLDOFF_MSB                                       (TX_TOP_P0 | 0x0074)
  // (ReadWrite, Bits 7:0) 
  // MSB of 24 bit holdoff counter threshold that deglitches SCDT high active status.
  #define BIT_MSK__SCDT_HOLDOFF_MSB__REG_SCDT_HOLDOFF_MSB_B7_B0                            0xFF

// TMDS Control #7 Register
#define REG_ADDR__TMDS_CTRL7                                             (TX_TOP_P0 | 0x0076)
  // (ReadWrite, Bits 7) 
  // This bit enables/disables MHL TMDS sequence 0 - disable (default) 1 - enable
  #define BIT_MSK__TMDS_CTRL7__REG_TMDS_SWAP_BIT                                     0x80

// HPD In Override Register
#define REG_ADDR__HPD_IN_CTRL                                            (TX_TOP_P0 | 0x0077)
  // (ReadWrite, Bits 0) 
  // HPD input override enable 0:  Auto detect (default) 1:  Software set
  #define BIT_MSK__HPD_IN_CTRL__REG_HPDIN_OVER_EN                                     0x01
  // (ReadWrite, Bits 1) 
  // HPD input override select 0:  HDMI (default) 1:  CBUS
  #define BIT_MSK__HPD_IN_CTRL__REG_HPDIN_OVER_SEL                                    0x02

// LM DDC Register
#define REG_ADDR__LM_DDC                                                 (TX_TOP_P0 | 0x009C)
  // (ReadWrite, Bits 0) 
  // 0 = Not using DDC 1 = Request to use DDC
  #define BIT_MSK__LM_DDC__REG_DDC_GPU_REQUEST                                   0x01
  // (ReadOnly, Bits 1) 
  // DDC Grant 1'b0: TX ownx DDC bus 1'b1: Host is granted DDC bus access
  #define BIT_MSK__LM_DDC__REG_DDC_GRANT                                         0x02
  // (ReadWrite, Bits 2) 
  // Write 1'b1 to flip the switch from DDC to I2C so that I2C can access the downstream DDC slave through CBUS like DDC. The switch will be flipped back after STOP condition.
  #define BIT_MSK__LM_DDC__REG_DDC_TPI_SW                                        0x04
  // (ReadWrite, Bits 5) 
  // Video mute enable
  #define BIT_MSK__LM_DDC__REG_VIDEO_MUTE_EN                                     0x20
  // (ReadWrite, Bits 7) 
  // SW TPI enable
  #define BIT_MSK__LM_DDC__REG_SW_TPI_EN                                         0x80

// TX SHA Control Register
#define REG_ADDR__TXSHA_CTRL                                             (TX_TOP_P0 | 0x00A1)
  // (ReadWrite, Bits 0) 
  // Firmware starts the SHA generation by writing 1; which generates 1 clock strobe.  Reading this bit  will not read what was written; but rather a status of SHA producing  a V value; such as:  If 0 is read then SHA is processing and V is not ready. If 1 is read then SHA is done processing and V is ready.  SHA processes very quickly and will often be finished by the time a read can be performed.  Note: before the above sequence this bit will return a 1 when read. In order to make for sure that SHA picked 1 written to this bit; firmware need to check bit #1 of the same register.
  #define BIT_MSK__TXSHA_CTRL__REG_SHA_GO_STAT                                       0x01
  // (ReadWrite, Bits 1) 
  // If 1 means that SHA picked up the SHA go stat command.  Write 1 to clear; before setting new SHA go stat command.
  #define BIT_MSK__TXSHA_CTRL__REG_SHACTRL_STAT1                                     0x02

// TX KSV FIFO Register
#define REG_ADDR__TXKSV_FIFO                                             (TX_TOP_P0 | 0x00A2)
  // (ReadWrite, Bits 7:0) 
  // This Address  is a port for access to the KSV FIFO. When the firmware starts a  I2C transaction with the offset address set at 38h the access control will be transferred to the KSV FIFO.  The address located inside the KSV Start Address register acts as the start offset within the KSV FIFO space.   Consecutive I2C transactions to address 38h will be auto-incremented in the KSV FIFO Address space.
  #define BIT_MSK__TXKSV_FIFO__REG_KSV_FIFO_OUT                                      0xFF

// HDCP Repeater Down Stream BSTATUS #1 Register
#define REG_ADDR__TXDS_BSTATUS1                                          (TX_TOP_P0 | 0x00A3)
  // (ReadWrite, Bits 6:0) 
  // need description
  #define BIT_MSK__TXDS_BSTATUS1__REG_DS_DEV_CNT                                        0x7F
  // (ReadWrite, Bits 7) 
  // need description
  #define BIT_MSK__TXDS_BSTATUS1__REG_DS_DEV_EXCEED                                     0x80

// HDCP Repeater Down Stream BSTATUS #2 Register
#define REG_ADDR__TXDS_BSTATUS2                                          (TX_TOP_P0 | 0x00A4)
  // (ReadWrite, Bits 2:0) 
  // Depth - need description
  #define BIT_MSK__TXDS_BSTATUS2__REG_DS_DEPTH                                          0x07
  // (ReadWrite, Bits 3) 
  // Max cascade exceeded - need description
  #define BIT_MSK__TXDS_BSTATUS2__REG_DS_CASC_EXCEED                                    0x08
  // (ReadWrite, Bits 4) 
  // HDMI Mode. (controlled through the I2C local side) 1 - receiver is in HDMI Mode; 0 - receiver is in DVI mode.
  #define BIT_MSK__TXDS_BSTATUS2__REG_DS_HDMI_MODE                                      0x10
  // (ReadWrite, Bits 7:5) 
  // Bstatus bits
  #define BIT_MSK__TXDS_BSTATUS2__REG_DS_BSTATUS                                        0xE0

// HDCP Repeater V.H0 #0 Register
#define REG_ADDR__TXVH0_0                                                (TX_TOP_P0 | 0x00A8)
  // (ReadWrite, Bits 7:0) 
  // Vp.H0 bits [7:0] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH0_0__REG_VP_H0_W_B0                                        0xFF

// HDCP Repeater V.H0 #1 Register
#define REG_ADDR__TXVH0_1                                                (TX_TOP_P0 | 0x00A9)
  // (ReadWrite, Bits 7:0) 
  // Vp.H0 bits [15:8] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config
  #define BIT_MSK__TXVH0_1__REG_VP_H0_W_B1                                        0xFF

// HDCP Repeater V.H0 #2 Register
#define REG_ADDR__TXVH0_2                                                (TX_TOP_P0 | 0x00AA)
  // (ReadWrite, Bits 7:0) 
  // Vp.H0 bits [23:16] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH0_2__REG_VP_H0_W_B2                                        0xFF

// HDCP Repeater V.H0 #3 Register
#define REG_ADDR__TXVH0_3                                                (TX_TOP_P0 | 0x00AB)
  // (ReadWrite, Bits 7:0) 
  // Vp.H0 bits [31:24] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH0_3__REG_VP_H0_W_B3                                        0xFF

// HDCP Repeater V.H1 #0 Register
#define REG_ADDR__TXVH1_0                                                (TX_TOP_P0 | 0x00AC)
  // (ReadWrite, Bits 7:0) 
  // Vp.H1 bits [7:0] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH1_0__REG_VP_H1_W_B0                                        0xFF

// HDCP Repeater V.H1 #1 Register
#define REG_ADDR__TXVH1_1                                                (TX_TOP_P0 | 0x00AD)
  // (ReadWrite, Bits 7:0) 
  // Vp.H1 bits [15:8] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH1_1__REG_VP_H1_W_B1                                        0xFF

// HDCP Repeater V.H1 #2 Register
#define REG_ADDR__TXVH1_2                                                (TX_TOP_P0 | 0x00AE)
  // (ReadWrite, Bits 7:0) 
  // Vp.H1 bits [23:16] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH1_2__REG_VP_H1_W_B2                                        0xFF

// HDCP Repeater V.H1 #3 Register
#define REG_ADDR__TXVH1_3                                                (TX_TOP_P0 | 0x00AF)
  // (ReadWrite, Bits 7:0) 
  // Vp.H1 bits [31:24] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH1_3__REG_VP_H1_W_B3                                        0xFF

// HDCP Repeater V.H2 #0 Register
#define REG_ADDR__TXVH2_0                                                (TX_TOP_P0 | 0x00B0)
  // (ReadWrite, Bits 7:0) 
  // Vp.H2 bits [7:0] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH2_0__REG_VP_H2_W_B0                                        0xFF

// HDCP Repeater V.H2 #1 Register
#define REG_ADDR__TXVH2_1                                                (TX_TOP_P0 | 0x00B1)
  // (ReadWrite, Bits 7:0) 
  // Vp.H2 bits [15:8] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH2_1__REG_VP_H2_W_B1                                        0xFF

// HDCP Repeater V.H2 #2 Register
#define REG_ADDR__TXVH2_2                                                (TX_TOP_P0 | 0x00B2)
  // (ReadWrite, Bits 7:0) 
  // Vp.H2 bits [23:16] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH2_2__REG_VP_H2_W_B2                                        0xFF

// HDCP Repeater V.H2 #3 Register
#define REG_ADDR__TXVH2_3                                                (TX_TOP_P0 | 0x00B3)
  // (ReadWrite, Bits 7:0) 
  // Vp.H2 bits [31:24] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH2_3__REG_VP_H2_W_B3                                        0xFF

// HDCP Repeater V.H3 #0 Register
#define REG_ADDR__TXVH3_0                                                (TX_TOP_P0 | 0x00B4)
  // (ReadWrite, Bits 7:0) 
  // Vp.H3 bits [7:0] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH3_0__REG_VP_H3_W_B0                                        0xFF

// HDCP Repeater V.H3 #1 Register
#define REG_ADDR__TXVH3_1                                                (TX_TOP_P0 | 0x00B5)
  // (ReadWrite, Bits 7:0) 
  // Vp.H3 bits [15:8] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH3_1__REG_VP_H3_W_B1                                        0xFF

// HDCP Repeater V.H3 #2 Register
#define REG_ADDR__TXVH3_2                                                (TX_TOP_P0 | 0x00B6)
  // (ReadWrite, Bits 7:0) 
  // Vp.H3 bits [23:16] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH3_2__REG_VP_H3_W_B2                                        0xFF

// HDCP Repeater V.H3 #3 Register
#define REG_ADDR__TXVH3_3                                                (TX_TOP_P0 | 0x00B7)
  // (ReadWrite, Bits 7:0) 
  // Vp.H3 bits [31:24] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH3_3__REG_VP_H3_W_B3                                        0xFF

// HDCP Repeater V.H4 #0 Register
#define REG_ADDR__TXVH4_0                                                (TX_TOP_P0 | 0x00B8)
  // (ReadWrite, Bits 7:0) 
  // Vp.H4 bits [7:0] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH4_0__REG_VP_H4_W_B0                                        0xFF

// HDCP Repeater V.H4 #1 Register
#define REG_ADDR__TXVH4_1                                                (TX_TOP_P0 | 0x00B9)
  // (ReadWrite, Bits 7:0) 
  // Vp.H4 bits [15:8] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH4_1__REG_VP_H4_W_B1                                        0xFF

// HDCP Repeater V.H4 #2 Register
#define REG_ADDR__TXVH4_2                                                (TX_TOP_P0 | 0x00BA)
  // (ReadWrite, Bits 7:0) 
  // Vp.H4 bits [23:16] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH4_2__REG_VP_H4_W_B2                                        0xFF

// HDCP Repeater V.H4 #3 Register
#define REG_ADDR__TXVH4_3                                                (TX_TOP_P0 | 0x00BB)
  // (ReadWrite, Bits 7:0) 
  // Vp.H4 bits [31:24] with vp_sel = 1 (page 0 0xEC bit 6). When vp_sel = 0 it is config type
  #define BIT_MSK__TXVH4_3__REG_VP_H4_W_B3                                        0xFF

// DDC I2C Manual Register
#define REG_ADDR__DDC_MANUAL                                             (TX_TOP_P0 | 0x00BC)
  // (ReadOnly, Bits 0) 
  // DSCL input status.  This bit reflects the live status of the DSCL pin.
  #define BIT_MSK__DDC_MANUAL__IO_DSCL                                               0x01
  // (ReadOnly, Bits 1) 
  // DSDA input status.  This bit reflects the live status of the DSDA pin.
  #define BIT_MSK__DDC_MANUAL__IO_DSDA                                               0x02
  // (ReadWrite, Bits 2) 
  // Write 1 to abort DDC master. Self-clearing
  #define BIT_MSK__DDC_MANUAL__REG_DDCM_ABORT                                        0x04
  // (ReadWrite, Bits 3) 
  // Set to allow HW to drop the incoming GCP packets and automatically send downstream GCP packets
  #define BIT_MSK__DDC_MANUAL__REG_GCP_HW_CTL_EN                                     0x08
  // (ReadWrite, Bits 4) 
  // DSCL manual output value.  Only enabled onto the DSCL output if reg_man_ddc = 1.
  #define BIT_MSK__DDC_MANUAL__REG_DSCL                                              0x10
  // (ReadWrite, Bits 5) 
  // DSDA manual output value.  Only enabled onto the DSDA output if reg_man_ddc = 1.
  #define BIT_MSK__DDC_MANUAL__REG_DSDA                                              0x20
  // (ReadWrite, Bits 6) 
  // 1'b1: select V prime from TPI 1'b0: select V prime from downstream (read through DDC)
  #define BIT_MSK__DDC_MANUAL__VP_SEL                                                0x40
  // (ReadWrite, Bits 7) 
  // manual override of scl and sda output
  #define BIT_MSK__DDC_MANUAL__REG_MAN_DDC                                           0x80

// DDC I2C Target Slave Address Register
#define REG_ADDR__DDC_ADDR                                               (TX_TOP_P0 | 0x00BD)
  // (ReadWrite, Bits 7:1) 
  // DDC target Slave address 
  #define BIT_MSK__DDC_ADDR__REG_DDC_ADDR                                          0xFE

// DDC I2C Target Segment Address Register
#define REG_ADDR__DDC_SEGM                                               (TX_TOP_P0 | 0x00BE)
  // (ReadWrite, Bits 7:0) 
  // DDC Target Segment address 
  #define BIT_MSK__DDC_SEGM__REG_DDC_SEGMENT                                       0xFF

// DDC I2C Target Offset Adress Register
#define REG_ADDR__DDC_OFFSET                                             (TX_TOP_P0 | 0x00BF)
  // (ReadWrite, Bits 7:0) 
  // target slave register offset
  #define BIT_MSK__DDC_OFFSET__REG_DDC_OFFSET                                        0xFF

// DDC I2C Data In count #1 Register
#define REG_ADDR__DDC_DIN_CNT1                                           (TX_TOP_P0 | 0x00C0)
  // (ReadWrite, Bits 7:0) 
  // Bits [7:0] of the number of bytes to transfer in
  #define BIT_MSK__DDC_DIN_CNT1__REG_DDC_DIN_CNT_B7_B0                                 0xFF

// DDC I2C Data In count #2 Register
#define REG_ADDR__DDC_DIN_CNT2                                           (TX_TOP_P0 | 0x00C1)
  // (ReadWrite, Bits 1:0) 
  // Bits [9:8] of the number of bytes to transfer in
  #define BIT_MSK__DDC_DIN_CNT2__REG_DDC_DIN_CNT_B9_B8                                 0x03

// DDC I2C Status Register
#define REG_ADDR__DDC_STATUS                                             (TX_TOP_P0 | 0x00C2)
  // (ReadOnly, Bits 0) 
  // DDC fifo write in use
  #define BIT_MSK__DDC_STATUS__DDC_FIFO_WRITE_IN_USE                                 0x01
  // (ReadOnly, Bits 1) 
  // DDC fifo read in use
  #define BIT_MSK__DDC_STATUS__DDC_FIFO_READ_IN_SUE                                  0x02
  // (ReadOnly, Bits 2) 
  // DDC FIFO is empty
  #define BIT_MSK__DDC_STATUS__DDC_FIFO_EMPTY                                        0x04
  // (ReadOnly, Bits 3) 
  // DDC fifo full
  #define BIT_MSK__DDC_STATUS__DDC_FIFO_FULL                                         0x08
  // (ReadOnly, Bits 4) 
  // DDC in programming mode
  #define BIT_MSK__DDC_STATUS__DDC_I2C_IN_PROG                                       0x10
  // (ReadWrite, Bits 5) 
  // When read get the status from hardware: to clear write 0
  #define BIT_MSK__DDC_STATUS__REG_DDC_NO_ACK                                        0x20
  // (ReadWrite, Bits 6) 
  // When read get the status from hardware: to clear write 0
  #define BIT_MSK__DDC_STATUS__REG_DDC_BUS_LOW                                       0x40

// DDC I2C Command Register
#define REG_ADDR__DDC_CMD                                                (TX_TOP_P0 | 0x00C3)
  // (ReadWrite, Bits 3:0) 
  // DDC Command[3:0]: 1111 - Abort transaction 1001 - Clear FIFO 1010 - Clock SCL 0000 - Current address read with no ACK on last byte 0001 - Current address read with ACK on last byte 0010 - Sequential read with no ACK on last byte 0011 - Sequential read with ACK on last byte 0100 - Enhanced DDC read with no ACK on last byte 0101 - Enhanced DDC read with ACK on last byte 0110 - Sequential write ignoring ACK on last byte 0111 - Sequential write requiring ACK on last byte  write to this register generates 1 clock strobe; which will force decoding of the ddc command
  #define BIT_MSK__DDC_CMD__REG_DDC_CMD                                           0x0F
  // (ReadWrite, Bits 4) 
  // Enable 3ns glitch filtering on the DDC clock and data line. 0 - is enabled (default). Filtering is done using Ring Oscillator.
  #define BIT_MSK__DDC_CMD__REG_DDC_FLT_EN                                        0x10
  // (ReadWrite, Bits 5) 
  // Enable the DDC del: 0 - is enable (default). DDC delay has been inserted into the SDA line to create 300ns delay for the falling edge of the DDC SDA signal in order to avoid erroneous I2C START condition.  The real start condition must have setup time of the 600ns and therefore this delay of 300ns will not remove the real START condition.  Filtering is done using Ring Oscillator.
  #define BIT_MSK__DDC_CMD__REG_SDA_DEL_EN                                        0x20
  // (ReadWrite, Bits 6) 
  // Enable short Ri read for DDC
  #define BIT_MSK__DDC_CMD__REG_HDCP_DDC_EN                                       0x40

// DDC I2C FIFO Data In/Out Register
#define REG_ADDR__DDC_DATA                                               (TX_TOP_P0 | 0x00C4)
  // (ReadOnly, Bits 7:0) 
  // DDC FIFO register.  During write to FIFO write data into his register. During the read from FIFO this register will have the FIFO data. FW needs to wait 500ns to access this register when switching from other address.
  #define BIT_MSK__DDC_DATA__DDC_DATA_OUT                                          0xFF

// DDC I2C Data Out Counter Register
#define REG_ADDR__DDC_DOUT_CNT                                           (TX_TOP_P0 | 0x00C5)
  // (ReadOnly, Bits 4:0) 
  // Data out counter register
  #define BIT_MSK__DDC_DOUT_CNT__DDC_DATA_OUT_CNT                                      0x1F
  // (ReadWrite, Bits 7) 
  // DDC I2C delay counter register 9-bit of 9
  #define BIT_MSK__DDC_DOUT_CNT__REG_DDC_DELAY_CNT_B1                                  0x80

// DDC I2C Delay Count Register
#define REG_ADDR__DDC_DELAY_CNT                                          (TX_TOP_P0 | 0x00C6)
  // (ReadWrite, Bits 7:0) 
  // DDC I2C delay counter register 9-bit of 8
  #define BIT_MSK__DDC_DELAY_CNT__REG_DDC_DELAY_CNT_B0                                  0xFF

// Test Control Register
#define REG_ADDR__TEST_TXCTRL                                            (TX_TOP_P0 | 0x00C7)
  // (ReadWrite, Bits 0) 
  // Test TMDS PLL Clocks. 0 - Test TMDS PLL Clocks disabled (default) 1 - TMDS filter PLL and main PLL Clocks muxed to test output pins.
  #define BIT_MSK__TEST_TXCTRL__REG_TST_PLLCK                                         0x01
  // (ReadWrite, Bits 1) 
  // Enable HDMI/MHL mode for output when  set 1. Output DVI mode when set 0.
  #define BIT_MSK__TEST_TXCTRL__REG_HDMI_MODE                                         0x02

// I2C Status Register
#define REG_ADDR__EPST                                                   (TX_TOP_P0 | 0x00C8)
  // (ReadWrite, Bits 0) 
  // Last command had been completed; For the status of this command please check error status bits in this register. Write 0 to clear. 
  #define BIT_MSK__EPST__REG_CMD_DONE_CLR                                      0x01
  // (ReadWrite, Bits 1) 
  // CRC error if  set to 1; Write 0 to clear
  #define BIT_MSK__EPST__REG_BIST_ERR_CLR                                      0x02
  // (ReadWrite, Bits 5) 
  // self-authentication #1 error if set to 1; Write 0 to clear
  #define BIT_MSK__EPST__REG_BIST1_ERR_CLR                                     0x20
  // (ReadWrite, Bits 6) 
  // self-authentication #2 error if set to 1; Write 0 to clear
  #define BIT_MSK__EPST__REG_BIST2_ERR_CLR                                     0x40
  // (ReadOnly, Bits 7) 
  // Status of the OTP programming: 1 - OTP has not been locked and can be programmed again.  The OTP is based on the Jet City fuse based memory and once the fuse has been blown it can be changed. That why every consequent write to the OTP memory will be the OR of the previous ones.
  #define BIT_MSK__EPST__OTP_UNLOCKED                                          0x80

// I2C Command Register
#define REG_ADDR__EPCM                                                   (TX_TOP_P0 | 0x00C9)
  // (ReadWrite, Bits 4:0) 
  // I2C Master commands: Five bits are SA2_en : SA1_en : CRC_en : 2 bit Command 00000 - Clear command register; no action will be taken xxx01 - rsvd xxx10 - rsvd xxx11 - will enable all BIST: CRC; self-authentication #1 and self_authentication #2 xx100 - will enable individual CRC  x1x00 - will enable individual self-authentication #1  1xx00 - will enable individual self_authentication #2   New value can be safely written into this register only after getting command done bit (reg. 0x0F9[0]) or waiting at least 0.125s. That means that new value can be safely written into this register only after previous command has been completed. Otherwise; it is possible to get either self-authentication #1 error status bit or to get BIST done bit without actually performing one of the new enabled BIST test.
  #define BIT_MSK__EPCM__REG_EPCM                                              0x1F
  // (ReadWrite, Bits 5) 
  // Enable Load of the KSV from OTP : 1 - enable.  Write 0 before enabling again. 
  #define BIT_MSK__EPCM__REG_LD_KSV                                            0x20

// I2C Command Register
#define REG_ADDR__OTP_CLK                                                (TX_TOP_P0 | 0x00CA)
  // (ReadWrite, Bits 5) 
  // 1: enabled the writing of protect byte (xff) in otp rom.  Default value 0: protect byte will not be written to otp rom.
  #define BIT_MSK__OTP_CLK__REG_OTP_PROTECT_EN                                    0x20

//***************************************************************************
// TX_DSEDID_HDMI2MHL1. Address: 60
// EDID Interrupt Source Register
#define REG_ADDR__EDID_INTR                                              (TX_DSEDID_HDMI2MHL1 | 0x0000)
  // (ReadWrite, Bits 0) 
  // EDID is available in EDID FIFO
  #define BIT_MSK__EDID_INTR__REG_INTR_STAT0                                        0x01
  // (ReadWrite, Bits 1) 
  // EDID read error
  #define BIT_MSK__EDID_INTR__REG_INTR_STAT1                                        0x02

// EDID Interrupt Mask Register
#define REG_ADDR__EDID_INTR_MASK                                         (TX_DSEDID_HDMI2MHL1 | 0x0001)
  // (ReadWrite, Bits 0) 
  // Enable INT[0]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__EDID_INTR_MASK__REG_INTR_MASK0                                        0x01
  // (ReadWrite, Bits 1) 
  // Enable INT[1]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__EDID_INTR_MASK__REG_INTR_MASK1                                        0x02

// EDID Control Register
#define REG_ADDR__EDID_CTRL                                              (TX_DSEDID_HDMI2MHL1 | 0x0002)
  // (ReadWrite, Bits 0) 
  // 0: Disable EDID function 1: Enable EDID function
  #define BIT_MSK__EDID_CTRL__REG_EDID_MODE_EN                                      0x01
  // (ReadWrite, Bits 2:1) 
  // 00: Downstream-retrived EDID data will be written into FIFO from 0x000 - 0x07F (1st half)  01: Downstream-retrived EDID data will be written into FIFO from 0x080 - 0x0FF (2nd half) 10: Downstream-retrived EDID data will be written into FIFO from 0x100 - 0x17F (3rd half)  11: Downstream-retrived EDID data will be written into FIFO from 0x180 - 0x1FF (4th half) If only 256 byte FIFO is used always tie Bit[2] to zero
  #define BIT_MSK__EDID_CTRL__REG_EDID_FIFO_BLOCK_SEL                               0x06
  // (ReadWrite, Bits 3) 
  // 1: Enable EDID FIFO access all the time 0: I2C can only access EDID FIFO after MHL established
  #define BIT_MSK__EDID_CTRL__REG_EDID_FIFO_ACCESS_ALWAYS_EN                        0x08
  // (ReadWrite, Bits 4) 
  // 0: Do not increment EDID FIFO address pointer  1: Increment EDID FIFO address pointer automatically
  #define BIT_MSK__EDID_CTRL__REG_EDID_FIFO_ADDR_AUTO                               0x10
  // (ReadWrite, Bits 5) 
  // the Most Singnificant Bit of reg_edid_fifo_addr If more than 256 Bytes EDID is required this bit is combined with reg_edid_fifo_addr[7:0] to generate 9 bits address for EDID FIFO access. The 9 bit address will be: {reg_edid_fifo_addr_msb reg_edid_fifo_addr[7:0]}.  Otherwise set this bit as 0
  #define BIT_MSK__EDID_CTRL__REG_EDID_FIFO_ADDR_MSB                                0x20
  // (ReadWrite, Bits 6) 
  // This bit need to be 1 for HDMI mode and 0 for MHL
  #define BIT_MSK__EDID_CTRL__REG_EDID_HDMI_MHL_MODE                                0x40

// EDID FIFO Addr Register
#define REG_ADDR__EDID_FIFO_ADDR                                         (TX_DSEDID_HDMI2MHL1 | 0x0003)
  // (ReadWrite, Bits 7:0) 
  // EDID FIFO Address
  #define BIT_MSK__EDID_FIFO_ADDR__REG_EDID_FIFO_ADDR                                    0xFF

// EDID FIFO Write Data Register
#define REG_ADDR__EDID_FIFO_WR_DATA                                      (TX_DSEDID_HDMI2MHL1 | 0x0004)
  // (ReadWrite, Bits 7:0) 
  // EDID FIFO Write Data
  #define BIT_MSK__EDID_FIFO_WR_DATA__REG_EDID_FIFO_WR_DATA                                 0xFF

// EDID FIFO Internal msb Addr Register
#define REG_ADDR__EDID_FIFO_ADDR_MON_MSB                                 (TX_DSEDID_HDMI2MHL1 | 0x0005)
  // (ReadOnly, Bits 0) 
  // EDID FIFO msb Internal Address Monitor (First read EDID_FIFO_ADDR_MON_LSB to update)
  #define BIT_MSK__EDID_FIFO_ADDR_MON_MSB__REG_EDID_FIFO_ADDR_MON_MSB                            0x01

// EDID FIFO Internal lsb Addr Register
#define REG_ADDR__EDID_FIFO_ADDR_MON_LSB                                 (TX_DSEDID_HDMI2MHL1 | 0x0006)
  // (ReadOnly, Bits 7:0) 
  // EDID FIFO lsb Internal Address Monitor
  #define BIT_MSK__EDID_FIFO_ADDR_MON_LSB__REG_EDID_FIFO_ADDR_MON_LSB                            0xFF

// EDID FIFO Read Data Register
#define REG_ADDR__EDID_FIFO_RD_DATA                                      (TX_DSEDID_HDMI2MHL1 | 0x0007)
  // (ReadOnly, Bits 7:0) 
  // EDID FIFO Read Data
  #define BIT_MSK__EDID_FIFO_RD_DATA__REG_EDID_FIFO_RD_DATA                                 0xFF

// EDID DDC Segment Pointer 0  Register
#define REG_ADDR__EDID_START_EXT0                                        (TX_DSEDID_HDMI2MHL1 | 0x0008)
  // (ReadWrite, Bits 0) 
  // Start to get EDID block 0. Self-resetting to 0. 
  #define BIT_MSK__EDID_START_EXT0__REG_GET_EDID_START_0                                  0x01

// EDID DDC Segment Pointer 1 Register
#define REG_ADDR__EDID_START_EXT1                                        (TX_DSEDID_HDMI2MHL1 | 0x0009)
  // (ReadWrite, Bits 0) 
  // Start to get EDID block 1. Self-resetting to 0. 
  #define BIT_MSK__EDID_START_EXT1__REG_GET_EDID_START_1                                  0x01
  // (ReadWrite, Bits 1) 
  // Start to get EDID block 2. Self-resetting to 0. 
  #define BIT_MSK__EDID_START_EXT1__REG_GET_EDID_START_2                                  0x02
  // (ReadWrite, Bits 2) 
  // Start to get EDID block 3. Self-resetting to 0. 
  #define BIT_MSK__EDID_START_EXT1__REG_GET_EDID_START_3                                  0x04
  // (ReadWrite, Bits 3) 
  // Start to get EDID block 4. Self-resetting to 0. 
  #define BIT_MSK__EDID_START_EXT1__REG_GET_EDID_START_4                                  0x08
  // (ReadWrite, Bits 4) 
  // Start to get EDID block 5. Self-resetting to 0. 
  #define BIT_MSK__EDID_START_EXT1__REG_GET_EDID_START_5                                  0x10
  // (ReadWrite, Bits 5) 
  // Start to get EDID block 6. Self-resetting to 0. 
  #define BIT_MSK__EDID_START_EXT1__REG_GET_EDID_START_6                                  0x20
  // (ReadWrite, Bits 6) 
  // Start to get EDID block 7. Self-resetting to 0. 
  #define BIT_MSK__EDID_START_EXT1__REG_GET_EDID_START_7                                  0x40
  // (ReadWrite, Bits 7) 
  // Start to get EDID block 8. Self-resetting to 0. 
  #define BIT_MSK__EDID_START_EXT1__REG_GET_EDID_START_8                                  0x80

// EDID State Machine Status Register
#define REG_ADDR__EDID_STATE_MACHINE                                     (TX_DSEDID_HDMI2MHL1 | 0x000A)
  // (ReadOnly, Bits 0) 
  // tx_ddc_edid_fetch State Machine  is in IDLE state
  #define BIT_MSK__EDID_STATE_MACHINE__EDID_IDLE_STATE                                       0x01
  // (ReadOnly, Bits 1) 
  // tx_ddc_edid_fetch State Machine  is in IDLE state
  #define BIT_MSK__EDID_STATE_MACHINE__EDID_FETCH_REQ_STATE                                  0x02
  // (ReadOnly, Bits 2) 
  // tx_ddc_edid_fetch State Machine  is in IDLE state
  #define BIT_MSK__EDID_STATE_MACHINE__EDID_WAIT_ACK_STATE                                   0x04

// EDID Restart Register
#define REG_ADDR__EDID_RST                                               (TX_DSEDID_HDMI2MHL1 | 0x000B)
  // (ReadWrite, Bits 0) 
  // restart edid block. Self-ressetting to 0.
  #define BIT_MSK__EDID_RST__REG_EDID_RESTART                                      0x01
  // (ReadWrite, Bits 1) 
  // EDID SW reset, active high
  #define BIT_MSK__EDID_RST__REG_EDID_RST                                          0x02

// HDMI2MHL1 Status Register
#define REG_ADDR__HDMI2MHL1_STAT                                         (TX_DSEDID_HDMI2MHL1 | 0x0018)
  // (ReadOnly, Bits 0) 
  // HDMI to MHL1 FIFO overflow
  #define BIT_MSK__HDMI2MHL1_STAT__HDMI2MHL1_FIFO_OVERFLOW                               0x01
  // (ReadOnly, Bits 1) 
  // HDMI to MHL1 FIFO underflow
  #define BIT_MSK__HDMI2MHL1_STAT__HDMI2MHL1_FIFO_UNDERFLOW                              0x02

// HDMI2MHL1 Control 1st Register
#define REG_ADDR__HDMI2MHL1_CTL0                                         (TX_DSEDID_HDMI2MHL1 | 0x0019)
  // (ReadWrite, Bits 7:0) 
  //  I2C register storing MHL commn mode clock shape for EMI reduction  i.      goes to clock shaping digital block ii.      default is 10b0000011111  normal MHL clock iii.      can change common mode clock duty by moving 0-1 transition location. For example; 1.       10b0011111111 -] 80/20 duty 2.       10b0000000001 -] 10/90 duty
  #define BIT_MSK__HDMI2MHL1_CTL0__REG_TX_CLK_SHAPE_B7_B0                                0xFF

// HDMI2MHL1 Control 2nd Register
#define REG_ADDR__HDMI2MHL1_CTL1                                         (TX_DSEDID_HDMI2MHL1 | 0x001A)
  // (ReadWrite, Bits 1:0) 
  //  I2C register storing MHL commn mode clock shape for EMI reduction  i.      goes to clock shaping digital block ii.      default is 10b0000011111  normal MHL clock iii.      can change common mode clock duty by moving 0-1 transition location. For example; 1.       10b0011111111 -] 80/20 duty 2.       10b0000000001 -] 10/90 duty
  #define BIT_MSK__HDMI2MHL1_CTL1__REG_TX_CLK_SHAPE_B9_B8                                0x03
  // (ReadWrite, Bits 7:5) 
  // I2C register selecting EMI mode  i.      goes to both clock shaping digital block and Tx core ii.      3b00x,010 -] normal MHL clock with 50/50 duty, Tx core ignores clock shape from digital block and internally generates 50/50 3x clock pattern which is MHL default clock shape iii.     3'b011 -] clock shaping for 1/2x clock iv.      3b100 -] clock shaping for 3x clock 1.       digital block passes clk_shape[9:0] data from I2C to Tx core w/o change v.      3b101 -] clock shaping for 1x clock 1.       digital block expand clk_shape[9:0] into clk_shape_1x[29:0]. a.       Clk_shape_1x[29:27] = clk_shape[9] b.      Clk_shape_1x[26:24] = clk_shape[8] c.        d.      Clk_shape_1x[5:3] = clk_shape[1] e.       Clk_shape_1x[2:0] = clk_shape[0] 2.       in 3 cycles of mhl_clk (300MHz), send 30bit as 3 chunks of 10-bit data a.       cycle n: clk_shape_1x[9:0] b.      cycle n+1: clk_shape_1x[19:10] c.       cycle n+2: clk_shape_1x[29:20] d.      repeat 3.       no need to align cycle  can start from arbitrary clock cycle vi.      3b110 -] falling edge modulation 40/60 at 3x clock rate (300MHz) 1.       cycle n : send 10b0000_111111 to Tx core 2.       cycle n+1 : send 10b000000_1111 to Tx core 3.       repeat vii.      3b111 -] falling edge modulation 30/70 at 3x clock rate (300MHz) 1.       cycle n: send 10b000_1111111 to Tx core 2.       cycle n+1: send 10b0000000_111 to Tx core 3.       repeat
  #define BIT_MSK__HDMI2MHL1_CTL1__REG_EMI_SEL                                           0xE0

// HDMI2MHL1 Control 3rd Register
#define REG_ADDR__HDMI2MHL1_CTL2                                         (TX_DSEDID_HDMI2MHL1 | 0x001B)
  // (ReadWrite, Bits 7:0) 
  // Lower 8 bits of the fixed 10 bit pattern that HDMI2MHL1 sends out
  #define BIT_MSK__HDMI2MHL1_CTL2__REG_10BIT_PAT_B7_B0                                   0xFF

// HDMI2MHL1 Control 4th Register
#define REG_ADDR__HDMI2MHL1_CTL3                                         (TX_DSEDID_HDMI2MHL1 | 0x001C)
  // (ReadWrite, Bits 1:0) 
  // Upper 2 bits of the fixed 10 bit pattern that HDMI2MHL1 sends out
  #define BIT_MSK__HDMI2MHL1_CTL3__REG_10BIT_PAT_B9_B8                                   0x03
  // (ReadWrite, Bits 2) 
  // Enable HDMI2MHL1 send out fixed 10 bit pattern
  #define BIT_MSK__HDMI2MHL1_CTL3__REG_10BIT_PAT_EN                                      0x04
  // (ReadWrite, Bits 3) 
  // 1:  Bit swap Q data out from encoder (default) 0:  No swap
  #define BIT_MSK__HDMI2MHL1_CTL3__REG_REVERSE_BIT_ORDER                                 0x08
  // (ReadWrite, Bits 6) 
  // MHL FIFO reset 1 - Reset MHL FIFO 0 - Normal operation (default).
  #define BIT_MSK__HDMI2MHL1_CTL3__REG_MHLFIFO_RST                                       0x40
  // (ReadWrite, Bits 7) 
  // Enable MHL2 PP mode
  #define BIT_MSK__HDMI2MHL1_CTL3__REG_MHL2_PP_EN                                        0x80

// HDMI2MHL1 Control 5th Register
#define REG_ADDR__HDMI2MHL1_CTL4                                         (TX_DSEDID_HDMI2MHL1 | 0x001D)
  // (ReadWrite, Bits 0) 
  // Scrambler on/off setting.
  #define BIT_MSK__HDMI2MHL1_CTL4__REG_SCR_ON                                            0x01
  // (ReadWrite, Bits 1) 
  // Scrambler mode. 0: normal; 1: CTS
  #define BIT_MSK__HDMI2MHL1_CTL4__REG_SCR_MD                                            0x02
  // (ReadWrite, Bits 2) 
  // Scrambler on/off for MHL1/2
  #define BIT_MSK__HDMI2MHL1_CTL4__REG_MHL12_SCON                                        0x04
  // (ReadWrite, Bits 3) 
  // HDMI mode overwriting on/off
  #define BIT_MSK__HDMI2MHL1_CTL4__REG_HDMIMD_OVR                                        0x08
  // (ReadWrite, Bits 4) 
  // HDMI mode overwriting value
  #define BIT_MSK__HDMI2MHL1_CTL4__REG_HDMIMD_VAL                                        0x10

// HDMI2MHL1 Control 6th Register
#define REG_ADDR__HDMI2MHL1_CTL5                                         (TX_DSEDID_HDMI2MHL1 | 0x001E)
  // (ReadWrite, Bits 7:0) 
  // SYNC interval counter limit (default 8'h0F)
  #define BIT_MSK__HDMI2MHL1_CTL5__REG_SYNC_INT_LMT                                      0xFF

//***************************************************************************
// TX_EMSC_MHLTOP_TDM. Address: 60
// EMSC General Control Register
#define REG_ADDR__GENCTL                                                 (TX_EMSC_MHLTOP_TDM | 0x0000)
  // (ReadWrite, Bits 0) 
  // Enable eMSC
  #define BIT_MSK__GENCTL__REG_EMSC_EN                                           0x01
  // (ReadWrite, Bits 1) 
  // Software bit to initialize training sequence if needed, eg Tx fails n retries.
  #define BIT_MSK__GENCTL__REG_START_TRAIN_SEQ                                   0x02
  // (ReadWrite, Bits 2) 
  // clear EMSC XFIFO by setting read and write pointer to 0
  #define BIT_MSK__GENCTL__REG_CLR_XFIFO                                         0x04
  // (ReadWrite, Bits 3) 
  // clear EMSC RFIFO by setting read and write pointer to 0
  #define BIT_MSK__GENCTL__REG_CLR_RFIFO                                         0x08
  // (ReadWrite, Bits 4) 
  // Disable counting data bytes with the internal logic. When set to 1'b1, the first byte written to XFIFO will be the byte count. The specified number of data bytes will follow. Note that the following three cases are supported case 1: A transfer including byte count and data bytes is written in one burst write case 2: A transfer including byte count and data bytes can be broken into multiple writes either single byte write or burst write case 3: Multiple transfers can be written into XFIFO through single burst write with the following limitation      a. 1. byte count has to be written either by a single byte write or as the first byte of a burst write       b. 2. The last data byte has to be written either by a single byte write or as the last byte of a burst write
  #define BIT_MSK__GENCTL__REG_XMIT_DIS_COUNT_DATA                               0x10
  // (ReadWrite, Bits 5) 
  // EMSC software reset. Set to 1'b1 to reset.
  #define BIT_MSK__GENCTL__REG_EMSC_RST                                          0x20
  // (ReadWrite, Bits 6) 
  // 0 (default): eMSC transmitter will go to error state when grant or ACK timeout, wait FW to clear grant timeout or ack timeout.   1: disable xmit_state to go error state.  eMSC will keep retry message after grant or ACK timeout
  #define BIT_MSK__GENCTL__REG_DIS_XMIT_ERR_STATE                                0x40

// EMSC Comma Char1 Register
#define REG_ADDR__COMMACH1                                               (TX_EMSC_MHLTOP_TDM | 0x0001)
  // (ReadWrite, Bits 7:0) 
  // register configurable comma character1 value, default = 0x96
  #define BIT_MSK__COMMACH1__REG_COMMA_CHAR1                                       0xFF

// EMSC Comma Char2 Register
#define REG_ADDR__COMMACH2                                               (TX_EMSC_MHLTOP_TDM | 0x0002)
  // (ReadWrite, Bits 7:0) 
  // register configurable comma character2 value, default = 0x69
  #define BIT_MSK__COMMACH2__REG_COMMA_CHAR2                                       0xFF

// EMSC Null Char Register
#define REG_ADDR__NULLCH                                                 (TX_EMSC_MHLTOP_TDM | 0x0003)
  // (ReadWrite, Bits 7:0) 
  // register configurable null character value, default = 0x00
  #define BIT_MSK__NULLCH__REG_NULL_CHAR                                         0xFF

// EMSC Train Char Register
#define REG_ADDR__TRAINCH                                                (TX_EMSC_MHLTOP_TDM | 0x0004)
  // (ReadWrite, Bits 7:0) 
  // register configurable training character value, default = 0xff
  #define BIT_MSK__TRAINCH__REG_TRAIN_CHAR                                        0xFF

// EMSC Comma ErrorCNT Register
#define REG_ADDR__COMMECNT                                               (TX_EMSC_MHLTOP_TDM | 0x0005)
  // (ReadWrite, Bits 3:0) 
  // number of comma char error mismatches to cause spi_comma_char_err interrupt and a new training sequence. Default value = 3 
  #define BIT_MSK__COMMECNT__REG_COMMA_CHAR_ERR_CNT                                0x0F
  // (ReadWrite, Bits 7) 
  // Enable I2C communicate with EMSC instead of SPI
  #define BIT_MSK__COMMECNT__REG_I2C_TO_EMSC_EN                                    0x80

// EMSC Comma Window Register
#define REG_ADDR__COMMAWIN                                               (TX_EMSC_MHLTOP_TDM | 0x0006)
  // (ReadWrite, Bits 7:0) 
  // slot numbers between two comma character, default = d24
  #define BIT_MSK__COMMAWIN__REG_COMMA_CHAR_WIN                                    0xFF

// EMSC TX Train ByteCnt Low Register
#define REG_ADDR__TXTRAINBCNTL                                           (TX_EMSC_MHLTOP_TDM | 0x0007)
  // (ReadWrite, Bits 7:0) 
  // 8 lsbs for number of Tx training character bytes. Defaut = 'd260
  #define BIT_MSK__TXTRAINBCNTL__REG_TX_TRAIN_CHAR_CNT_B7_B0                           0xFF

// EMSC TX Train ByteCnt High Register
#define REG_ADDR__TXTRAINBCNTH                                           (TX_EMSC_MHLTOP_TDM | 0x0008)
  // (ReadWrite, Bits 0) 
  // MSB for number of Tx training character bytes. Default = 'd260
  #define BIT_MSK__TXTRAINBCNTH__REG_TX_TRAIN_CHAR_CNT_B8                              0x01

// EMSC Skip ByteCnt Low Register
#define REG_ADDR__SKIPBCNTL                                              (TX_EMSC_MHLTOP_TDM | 0x0009)
  // (ReadWrite, Bits 7:0) 
  // 8 lsbs for number of skipped character bytes when invalid command occurs outside of data transfer. Defaut = 260
  #define BIT_MSK__SKIPBCNTL__REG_SKIP_BYTE_CNT_B7_B0                               0xFF

// EMSC Skip ByteCnt High Register
#define REG_ADDR__SKIPBCNTH                                              (TX_EMSC_MHLTOP_TDM | 0x000A)
  // (ReadWrite, Bits 0) 
  // MSB for number of skipped bytes when invalid command occurs outside of data transfer. Defaut = 260
  #define BIT_MSK__SKIPBCNTH__REG_SKIP_BYTE_CNT_B8                                  0x01

// EMSC Rcv Tout Register
#define REG_ADDR__EMSCRCVTOUT                                            (TX_EMSC_MHLTOP_TDM | 0x000B)
  // (ReadWrite, Bits 7:0) 
  // 8 bit MSB configurable timeout value for receiver. Default = 0x09. The granularity is 4096 TDM clock period. TDM clock frequency is 37.5MHz for CoC and 300MHz for DoC
  #define BIT_MSK__EMSCRCVTOUT__REG_RECV_TOUT_MSB                                     0xFF

// EMSC Xmit Tout Register
#define REG_ADDR__EMSCXMITTOUT                                           (TX_EMSC_MHLTOP_TDM | 0x000C)
  // (ReadWrite, Bits 7:0) 
  // 8 bit MSB configurable timeout value for data transfer from TDM to SPI. Default = 0x14. The granularity is 4096 TDM clock period. TDM clock frequency is 37.5MHz for CoC and 300MHz for DoC
  #define BIT_MSK__EMSCXMITTOUT__REG_XMIT_TOUT_MSB                                     0xFF

// EMSC Tx Xmit Retry Max Low  Register
#define REG_ADDR__EMSCXMITRETRYMAXL                                      (TX_EMSC_MHLTOP_TDM | 0x000D)
  // (ReadWrite, Bits 7:0) 
  // 8 bit LSB configurable retry interval for retransmit. Default = 0x20
  #define BIT_MSK__EMSCXMITRETRYMAXL__REG_XMIT_RETRY_MAX_MSB_B7_B0                          0xFF

// EMSC Tx Xmit Retry Max High Register
#define REG_ADDR__EMSCXMITRETRYMAXH                                      (TX_EMSC_MHLTOP_TDM | 0x000E)
  // (ReadWrite, Bits 2:0) 
  // 3 bit MSB configurable retry interval for retransmit. Default = 0x00
  #define BIT_MSK__EMSCXMITRETRYMAXH__REG_XMIT_RETRY_MAX_MSB_B10_B8                         0x07

// EMSC Tx Xmit Retry Limit Register
#define REG_ADDR__EMSCXMITRETRYLMT                                       (TX_EMSC_MHLTOP_TDM | 0x000F)
  // (ReadWrite, Bits 7:0) 
  // number of retries for transmit to send a packet. Default = 0xFF 
  #define BIT_MSK__EMSCXMITRETRYLMT__REG_XMIT_RETRY_LIMIT                                  0xFF

// EMSC Space Check Register
#define REG_ADDR__EMSCSPCHK                                              (TX_EMSC_MHLTOP_TDM | 0x0012)
  // (ReadWrite, Bits 7:0) 
  // Combined with 0x313 (reg_wait_check_space_cnt) to allow HW check repeatedly for the availibility of EMSC RFIFO before replying NACK.
  #define BIT_MSK__EMSCSPCHK__REG_SPACE_CHECK_NUM                                   0xFF

// EMSC Wait Check Register
#define REG_ADDR__EMSCWTCHK                                              (TX_EMSC_MHLTOP_TDM | 0x0013)
  // (ReadWrite, Bits 7:0) 
  // Wait {reg_wait_check_space_cnt, 8'hFF} clocks to check the availibility of EMSC RFIFO.
  #define BIT_MSK__EMSCWTCHK__REG_WAIT_CHECK_SPACE_CNT                              0xFF

// EMSC Xmit Debug Status Register
#define REG_ADDR__EMSCXMITSTAT                                           (TX_EMSC_MHLTOP_TDM | 0x0014)
  // (ReadOnly, Bits 7:0) 
  // Transmit status
  #define BIT_MSK__EMSCXMITSTAT__REG_XMIT_STATUS                                       0xFF

// EMSC Recv Debug Status Register
#define REG_ADDR__EMSCRCVSTAT                                            (TX_EMSC_MHLTOP_TDM | 0x0015)
  // (ReadOnly, Bits 7:0) 
  // Receive status
  #define BIT_MSK__EMSCRCVSTAT__REG_RECV_STATUS                                       0xFF

// XFIFO ByteCnt Needed For Next Transfer Status Low Register
#define REG_ADDR__XFIFOBCNTFORNEXTXMITL                                  (TX_EMSC_MHLTOP_TDM | 0x0016)
  // (ReadOnly, Bits 7:0) 
  // The number of bytes needed for next tranfer - lower 8 bit
  #define BIT_MSK__XFIFOBCNTFORNEXTXMITL__REG_CNT_UNWRITTEN_BYTES_B7_B0                         0xFF

// XFIFO ByteCnt Needed For Next Transfer Status High Register
#define REG_ADDR__XFIFOBCNTFORNEXTXMITH                                  (TX_EMSC_MHLTOP_TDM | 0x0017)
  // (ReadOnly, Bits 0) 
  // The number of bytes needed for next tranfer - lower 8 bit
  #define BIT_MSK__XFIFOBCNTFORNEXTXMITH__REG_CNT_UNWRITTEN_BYTES_B8                            0x01

// EMSC XFIFO ByteCnt Status Low Register
#define REG_ADDR__EMSCXFIFOBCNTL                                         (TX_EMSC_MHLTOP_TDM | 0x0018)
  // (ReadOnly, Bits 7:0) 
  // 8 LSBs for number of available bytes in SPI EMSC XFIFO for debugging
  #define BIT_MSK__EMSCXFIFOBCNTL__REG_EMSC_XFIFO_BYTE_CNT_B7_B0                         0xFF

// EMSC XFIFO ByteCnt Status High Register
#define REG_ADDR__EMSCXFIFOBCNTH                                         (TX_EMSC_MHLTOP_TDM | 0x0019)
  // (ReadOnly, Bits 0) 
  // MSB for number of available bytes in SPI EMSC XFIFO for debugging
  #define BIT_MSK__EMSCXFIFOBCNTH__REG_EMSC_XFIFO_BYTE_CNT_B8                            0x01

// EMSC RFIFO ByteCnt Status Low Register
#define REG_ADDR__EMSCRFIFOBCNTL                                         (TX_EMSC_MHLTOP_TDM | 0x001A)
  // (ReadOnly, Bits 7:0) 
  // 8 LSBs for number of available bytes in SPI EMSC RFIFO for debugging
  #define BIT_MSK__EMSCRFIFOBCNTL__REG_EMSC_RFIFO_BYTE_CNT_B7_B0                         0xFF

// EMSC RFIFO ByteCnt Status High Register
#define REG_ADDR__EMSCRFIFOBCNTH                                         (TX_EMSC_MHLTOP_TDM | 0x001B)
  // (ReadOnly, Bits 0) 
  // MSB for number of available bytes in SPI EMSC RFIFO for debugging
  #define BIT_MSK__EMSCRFIFOBCNTH__REG_EMSC_RFIFO_BYTE_CNT_B8                            0x01

// EMSC XFIFO Space Status Low Register
#define REG_ADDR__EMSCXFIFOSPACEL                                        (TX_EMSC_MHLTOP_TDM | 0x001C)
  // (ReadOnly, Bits 7:0) 
  // 8 LSBs for number of available EMSC XFIFO space for SPI to load new packet
  #define BIT_MSK__EMSCXFIFOSPACEL__REG_EMSC_XFIFO_SPACE_B7_B0                            0xFF

// EMSC XFIFO Space Status High Register
#define REG_ADDR__EMSCXFIFOSPACEH                                        (TX_EMSC_MHLTOP_TDM | 0x001D)
  // (ReadOnly, Bits 0) 
  // MSB for number of available EMSC XFIFO space for SPI to load new packet
  #define BIT_MSK__EMSCXFIFOSPACEH__REG_EMSC_XFIFO_SPACE_B8                               0x01

// EMSC Burst Cnt Status Register
#define REG_ADDR__EMSCBURSTCNT                                           (TX_EMSC_MHLTOP_TDM | 0x001E)
  // (ReadOnly, Bits 7:0) 
  // the first packet size for SPI read
  #define BIT_MSK__EMSCBURSTCNT__REG_EMSC_BURST_CNT                                    0xFF

// EMSC XMIT TOState Register
#define REG_ADDR__EMSCTOSTT                                              (TX_EMSC_MHLTOP_TDM | 0x001F)
  // (ReadOnly, Bits 3:0) 
  // Reflects the internal transmit state machine state when it times out. Used only for debugging. 
  #define BIT_MSK__EMSCTOSTT__REG_XMIT_TIMEOUT_STATE                                0x0F

// EMSC Aggregated Interrupt Status Register
#define REG_ADDR__EMSC_AGGREGATED_INT_STAT                               (TX_EMSC_MHLTOP_TDM | 0x0020)
  // (ReadOnly, Bits 0) 
  // Aggregated interrupt at 0x23
  #define BIT_MSK__EMSC_AGGREGATED_INT_STAT__REG_EMSC_INTR_STAT_B0                                 0x01
  // (ReadOnly, Bits 1) 
  // Aggregated interrupt at 0x2C
  #define BIT_MSK__EMSC_AGGREGATED_INT_STAT__REG_EMSC_INTR_STAT_B1                                 0x02

// EMSC PRAM RFIFO Byte Count  Register
#define REG_ADDR__PRAMRFFFBCNT                                           (TX_EMSC_MHLTOP_TDM | 0x0021)

// EMSC Status Register
#define REG_ADDR__EMSCSTAT                                               (TX_EMSC_MHLTOP_TDM | 0x0022)
  // (ReadOnly, Bits 0) 
  // EMSC Normal mode indicator
  #define BIT_MSK__EMSCSTAT__REG_EMSC_NORMAL_MODE                                  0x01

// EMSC 1st Interrupt Register
#define REG_ADDR__EMSCINTR                                               (TX_EMSC_MHLTOP_TDM | 0x0023)
  // (ReadOnly, Bits 0) 
  // Indicates if EMSC receiver has data to be fetched. It is special since it cannot be cleared unless all the data have been feteched
  #define BIT_MSK__EMSCINTR__REG_EMSC_RFIFO_NOT_EMPTY                              0x01
  // (ReadWrite, Bits 1) 
  // eMSC transmitter not getting grant timeout interrupt  
  #define BIT_MSK__EMSCINTR__REG_XMIT_GNT_TOUT                                     0x02
  // (ReadWrite, Bits 2) 
  // EMSC Xmit Done interrupt. SW write 1 clear.
  #define BIT_MSK__EMSCINTR__REG_XMIT_DONE                                         0x04
  // (ReadWrite, Bits 3) 
  // Number of comma character mismatch reaches the limit defined by Comma Character Error Count.
  #define BIT_MSK__EMSCINTR__REG_COMMA_CHAR_ERR                                    0x08
  // (ReadWrite, Bits 4) 
  // SPI writes more than XFIFO space. SW write 1 clear.
  #define BIT_MSK__EMSCINTR__REG_XFIFO_WRITE_ERR                                   0x10
  // (ReadWrite, Bits 5) 
  // It is asserted when the host interface SPI or I2C tries to read more bytes than the available bytes in eMSC RFIFO.
  #define BIT_MSK__EMSCINTR__REG_RFIFO_READ_ERR                                    0x20
  // (ReadWrite, Bits 6) 
  // eMSC transmitter not getting ACK timeout interrupt  
  #define BIT_MSK__EMSCINTR__REG_XMIT_ACK_TOUT                                     0x40
  // (ReadWrite, Bits 7) 
  // eMSC Xmit FIFO empty
  #define BIT_MSK__EMSCINTR__REG_XFIFO_EMPTY                                       0x80

// EMSC Interrupt Mask Register
#define REG_ADDR__EMSCINTRMASK                                           (TX_EMSC_MHLTOP_TDM | 0x0024)
  // (ReadWrite, Bits 0) 
  // EMSC interrupt mask bit for event 0.
  #define BIT_MSK__EMSCINTRMASK__REG_EMSC_INTR0_MASK0                                  0x01
  // (ReadWrite, Bits 1) 
  // EMSC interrupt mask bit for event 1.
  #define BIT_MSK__EMSCINTRMASK__REG_EMSC_INTR0_MASK1                                  0x02
  // (ReadWrite, Bits 2) 
  // EMSC interrupt mask bit for event 2.
  #define BIT_MSK__EMSCINTRMASK__REG_EMSC_INTR0_MASK2                                  0x04
  // (ReadWrite, Bits 3) 
  // EMSC interrupt mask bit for event 3.
  #define BIT_MSK__EMSCINTRMASK__REG_EMSC_INTR0_MASK3                                  0x08
  // (ReadWrite, Bits 4) 
  // EMSC interrupt mask bit for event 4.
  #define BIT_MSK__EMSCINTRMASK__REG_EMSC_INTR0_MASK4                                  0x10
  // (ReadWrite, Bits 5) 
  // EMSC interrupt mask bit for event 5.
  #define BIT_MSK__EMSCINTRMASK__REG_EMSC_INTR0_MASK5                                  0x20
  // (ReadWrite, Bits 6) 
  // EMSC interrupt mask bit for event 6.
  #define BIT_MSK__EMSCINTRMASK__REG_EMSC_INTR0_MASK6                                  0x40
  // (ReadWrite, Bits 7) 
  // EMSC interrupt mask bit for event 7.
  #define BIT_MSK__EMSCINTRMASK__REG_EMSC_INTR0_MASK7                                  0x80

// EMSC RX Train ByteCnt Low Register
#define REG_ADDR__RXTRAINBCNTL                                           (TX_EMSC_MHLTOP_TDM | 0x0025)
  // (ReadWrite, Bits 7:0) 
  // 8 lsbs for number of Rx training character bytes. Defaut = 'd260
  #define BIT_MSK__RXTRAINBCNTL__REG_RX_TRAIN_CHAR_CNT_B7_B0                           0xFF

// EMSC RX Train ByteCnt High Register
#define REG_ADDR__RXTRAINBCNTH                                           (TX_EMSC_MHLTOP_TDM | 0x0026)
  // (ReadWrite, Bits 0) 
  // MSB for number of Rx training character bytes. Default = 'd260
  #define BIT_MSK__RXTRAINBCNTH__REG_RX_TRAIN_CHAR_CNT_B8                              0x01

// EMSC Grant Retry Cnt Status Register
#define REG_ADDR__EMSCGNTRTYCNT                                          (TX_EMSC_MHLTOP_TDM | 0x0027)
  // (ReadOnly, Bits 7:0) 
  // eMSC TX retry counter until GRANT received.
  #define BIT_MSK__EMSCGNTRTYCNT__REG_GNT_RETRY_CNT                                     0xFF

// EMSC ACK Retry Cnt Status Register
#define REG_ADDR__EMSCACKRTYCNT                                          (TX_EMSC_MHLTOP_TDM | 0x0028)
  // (ReadOnly, Bits 7:0) 
  // eMSC TX retry counter until ACK received.
  #define BIT_MSK__EMSCACKRTYCNT__REG_ACK_RETRY_CNT                                     0xFF

// SPI EMSC FIFO Status Register
#define REG_ADDR__SPIEMSCFIFOSTAT                                        (TX_EMSC_MHLTOP_TDM | 0x0029)
  // (ReadOnly, Bits 7:0) 
  // bit 7: XFIFO is full bit 6: RFIFO is full bit 5:4: Reserved bit 3: XFIFO is empty bit 2: RFIFO is empty bit 1:0: Reserved
  #define BIT_MSK__SPIEMSCFIFOSTAT__REG_EMSC_FIFO_STATUS                                  0xFF

// I2C EMSC XMIT FIFO Write Port
#define REG_ADDR__EMSC_XMIT_WRITE_PORT                                   (TX_EMSC_MHLTOP_TDM | 0x002A)
  // (ReadWrite, Bits 7:0) 
  // EMSC transmit write port for I2C. This is a special port for HW write operation. For register read, the value is always 0.
  #define BIT_MSK__EMSC_XMIT_WRITE_PORT__REG_EMSC_XMIT_WRITE_PORT                              0xFF

// I2C EMSC RCV FIFO Write Port
#define REG_ADDR__EMSC_RCV_READ_PORT                                     (TX_EMSC_MHLTOP_TDM | 0x002B)
  // (ReadOnly, Bits 7:0) 
  // EMSC receive read port for I2C
  #define BIT_MSK__EMSC_RCV_READ_PORT__REG_EMSC_RCV_READ_PORT                                0xFF

// EMSC 2nd Interrupt Register
#define REG_ADDR__EMSCINTR1                                              (TX_EMSC_MHLTOP_TDM | 0x002C)
  // (ReadWrite, Bits 0) 
  // Interrupt to indicate that training sequence wasn't concluded with comma character at slot 0
  #define BIT_MSK__EMSCINTR1__REG_TRAINING_COMMA_ERR                                0x01

// EMSC Interrupt Mask Register
#define REG_ADDR__EMSCINTRMASK1                                          (TX_EMSC_MHLTOP_TDM | 0x002D)
  // (ReadWrite, Bits 0) 
  // EMSC interrupt mask bit for event 0.
  #define BIT_MSK__EMSCINTRMASK1__REG_EMSC_INTR1_MASK0                                  0x01

// MHLTX_TOP Interrupt Status Register
#define REG_ADDR__MHLTXTOP_INTR                                          (TX_EMSC_MHLTOP_TDM | 0x0030)
  // (ReadOnly, Bits 4:0) 
  // MHL_TX interrupt status 0: CBUS general interrupt status 1: eMSC general interrupt status 2: USBT general interrupt status 3: TDM general interrupt status 4: MHL_TX local interrupt status
  #define BIT_MSK__MHLTXTOP_INTR__REG_MHL_TX_INTR_STAT                                  0x1F

// Interrupt Source #1 Register
#define REG_ADDR__MHLTXTOP_INTR1                                         (TX_EMSC_MHLTOP_TDM | 0x0031)
  // (ReadWrite, Bits 0) 
  // PRIF_READY is forced high for eMSC access. Asserted if set to 1. Write '1' to clear this bit.
  #define BIT_MSK__MHLTXTOP_INTR1__REG_INTR1_STAT0                                       0x01

// Interrupt #1 Mask Register
#define REG_ADDR__MHLTXTOP_INTR1_MASK                                    (TX_EMSC_MHLTOP_TDM | 0x0032)
  // (ReadWrite, Bits 0) 
  // Enable INT1[0]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHLTXTOP_INTR1_MASK__REG_INTR1_MASK0                                       0x01

// PRIF_READY Recovery Register
#define REG_ADDR__MHLTXTOP_RDY_RCC                                       (TX_EMSC_MHLTOP_TDM | 0x0033)
  // (ReadWrite, Bits 3:0) 
  // This register defines a timer. After timer expiration IP prif_ready will be forced high for registers located in tclk domain. 4'h0: reserved    4'h1: 4 cycles;    4'h2: 8 cycles;    4'h3: 16 cyles;  4'h4: 32 cycles;   4'h5: 64 cycles;  4'h6: 128 cycles; 4'h7: 256 cyles; 4'h8: 512 cycles;   4'h9: 1k cycles;  4'hA: 2k cycles; 4'hB: 4k cyles; 4'hC: 8k cycles (default);   4'hD: 16k cycles;  4'hE: 32k cycles; 4'hF: 64k cyles;
  #define BIT_MSK__MHLTXTOP_RDY_RCC__REG_FORCERDY_SEL                                      0x0F
  // (ReadWrite, Bits 7) 
  // Set this bit will force IP prif_ready becomes 1 after certain timeout, for register byte located in tclk domain while tclk is not provided by the system.
  #define BIT_MSK__MHLTXTOP_RDY_RCC__REG_FORCERDY_EN                                       0x80

// SRST Register
#define REG_ADDR__TDMSRST                                                (TX_EMSC_MHLTOP_TDM | 0x0040)
  // (ReadWrite, Bits 0) 
  // Active high reset signal for TDM Tx. Power on reset and should be controlled by software. (External synchronizer is required)
  #define BIT_MSK__TDMSRST__REG_TTX_SRST                                          0x01
  // (ReadWrite, Bits 1) 
  // Active high reset signal for TDM Rx. Power on reset and should be controlled by software. (External synchronizer is required)
  #define BIT_MSK__TDMSRST__REG_TRX_SRST                                          0x02
  // (ReadOnly, Bits 2) 
  // general interrupt status.
  #define BIT_MSK__TDMSRST__REG_INTR                                              0x04
  // (ReadOnly, Bits 7:4) 
  // Byte aggregated interrupt status.  Bit 0 for TTXINTL;  Bit 1 for TTXINTH;  Bit 2 for TRXINTL;  Bit 3 for TRXINTH.
  #define BIT_MSK__TDMSRST__REG_AGGRINTR_B3_B0                                    0xF0

// TDM TX INT Low Register
#define REG_ADDR__TTXINTL                                                (TX_EMSC_MHLTOP_TDM | 0x0041)
  // (ReadWrite, Bits 0) 
  // event 0 of ro_tdm_tx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. HSIC2TDM AFIFO empty
  #define BIT_MSK__TTXINTL__REG_TTX_INTR0                                         0x01
  // (ReadWrite, Bits 1) 
  // event 1 of ro_tdm_tx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. HSIC2TDM AFIFO empty during normal TDM operation
  #define BIT_MSK__TTXINTL__REG_TTX_INTR1                                         0x02
  // (ReadWrite, Bits 2) 
  // event 2 of ro_tdm_tx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. TDM Tx CBUS state error due to unexpected CBUS1 transaction
  #define BIT_MSK__TTXINTL__REG_TTX_INTR2                                         0x04
  // (ReadWrite, Bits 3) 
  // event 3 of ro_tdm_tx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. TDM Tx slot 0 location is adjusted for slot 0 interleaving
  #define BIT_MSK__TTXINTL__REG_TTX_INTR3                                         0x08
  // (ReadWrite, Bits 4) 
  // event 4 of ro_tdm_tx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TTXINTL__REG_TTX_INTR4                                         0x10
  // (ReadWrite, Bits 5) 
  // event 5 of ro_tdm_tx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TTXINTL__REG_TTX_INTR5                                         0x20
  // (ReadWrite, Bits 6) 
  // event 6 of ro_tdm_tx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TTXINTL__REG_TTX_INTR6                                         0x40
  // (ReadWrite, Bits 7) 
  // event 7 of ro_tdm_tx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TTXINTL__REG_TTX_INTR7                                         0x80

// TDM TX INT High Register
#define REG_ADDR__TTXINTH                                                (TX_EMSC_MHLTOP_TDM | 0x0042)
  // (ReadWrite, Bits 0) 
  // event 8 of ro_tdm_tx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TTXINTH__REG_TTX_INTR8                                         0x01
  // (ReadWrite, Bits 1) 
  // event 9 of ro_tdm_tx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TTXINTH__REG_TTX_INTR9                                         0x02
  // (ReadWrite, Bits 2) 
  // event 10 of ro_tdm_tx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TTXINTH__REG_TTX_INTR10                                        0x04
  // (ReadWrite, Bits 3) 
  // event 11 of ro_tdm_tx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TTXINTH__REG_TTX_INTR11                                        0x08
  // (ReadWrite, Bits 4) 
  // event 12 of ro_tdm_tx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TTXINTH__REG_TTX_INTR12                                        0x10
  // (ReadWrite, Bits 5) 
  // event 13 of ro_tdm_tx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TTXINTH__REG_TTX_INTR13                                        0x20
  // (ReadWrite, Bits 6) 
  // event 14 of ro_tdm_tx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TTXINTH__REG_TTX_INTR14                                        0x40
  // (ReadWrite, Bits 7) 
  // event 15 of ro_tdm_tx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TTXINTH__REG_TTX_INTR15                                        0x80

// TDM RX INT Low Register
#define REG_ADDR__TRXINTL                                                (TX_EMSC_MHLTOP_TDM | 0x0043)
  // (ReadWrite, Bits 0) 
  // event 0 of ro_tdm_rx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. CBUS packet dropped
  #define BIT_MSK__TRXINTL__REG_TRX_INTR0                                         0x01
  // (ReadWrite, Bits 1) 
  // event 1 of ro_tdm_rx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved (SPI packet dropped)
  #define BIT_MSK__TRXINTL__REG_TRX_INTR1                                         0x02
  // (ReadWrite, Bits 2) 
  // event 2 of ro_tdm_rx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Invalid CBUS packet
  #define BIT_MSK__TRXINTL__REG_TRX_INTR2                                         0x04
  // (ReadWrite, Bits 3) 
  // event 3 of ro_tdm_rx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. TDM2HSIC AFIFO overflow
  #define BIT_MSK__TRXINTL__REG_TRX_INTR3                                         0x08
  // (ReadWrite, Bits 4) 
  // event 4 of ro_tdm_rx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TRXINTL__REG_TRX_INTR4                                         0x10
  // (ReadWrite, Bits 5) 
  // event 5 of ro_tdm_rx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TRXINTL__REG_TRX_INTR5                                         0x20
  // (ReadWrite, Bits 6) 
  // event 6 of ro_tdm_rx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TRXINTL__REG_TRX_INTR6                                         0x40
  // (ReadWrite, Bits 7) 
  // event 7 of ro_tdm_rx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TRXINTL__REG_TRX_INTR7                                         0x80

// TDM RX INT High Register
#define REG_ADDR__TRXINTH                                                (TX_EMSC_MHLTOP_TDM | 0x0044)
  // (ReadWrite, Bits 0) 
  // event 8 of ro_tdm_rx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. TDM status change from SYNC_WAIT to SYNC_DATA
  #define BIT_MSK__TRXINTH__REG_TRX_INTR8                                         0x01
  // (ReadWrite, Bits 1) 
  // event 9 of ro_tdm_rx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. TDM status change from SYNC_DATA to SYNC_WAIT
  #define BIT_MSK__TRXINTH__REG_TRX_INTR9                                         0x02
  // (ReadWrite, Bits 2) 
  // event 10 of ro_tdm_rx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. TDM status change from SYNC_DATA to SYNC_UNSYNC
  #define BIT_MSK__TRXINTH__REG_TRX_INTR10                                        0x04
  // (ReadWrite, Bits 3) 
  // event 11 of ro_tdm_rx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. TDM status change from any state to any state
  #define BIT_MSK__TRXINTH__REG_TRX_INTR11                                        0x08
  // (ReadWrite, Bits 4) 
  // event 12 of ro_tdm_rx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TRXINTH__REG_TRX_INTR12                                        0x10
  // (ReadWrite, Bits 5) 
  // event 13 of ro_tdm_rx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TRXINTH__REG_TRX_INTR13                                        0x20
  // (ReadWrite, Bits 6) 
  // event 14 of ro_tdm_rx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TRXINTH__REG_TRX_INTR14                                        0x40
  // (ReadWrite, Bits 7) 
  // event 15 of ro_tdm_rx_intr[15:0]. Interrupt from tdm_tx module. Only valid when mask bit is 1. Reserved
  #define BIT_MSK__TRXINTH__REG_TRX_INTR15                                        0x80

// TDM TX INTMASK Low Register
#define REG_ADDR__TTXINTML                                               (TX_EMSC_MHLTOP_TDM | 0x0045)
  // (ReadWrite, Bits 0) 
  // mask bit of intr event 0.
  #define BIT_MSK__TTXINTML__REG_TTX_INTRMASK0                                     0x01
  // (ReadWrite, Bits 1) 
  // mask bit of intr event 1.
  #define BIT_MSK__TTXINTML__REG_TTX_INTRMASK1                                     0x02
  // (ReadWrite, Bits 2) 
  // mask bit of intr event 2.
  #define BIT_MSK__TTXINTML__REG_TTX_INTRMASK2                                     0x04
  // (ReadWrite, Bits 3) 
  // mask bit of intr event 3.
  #define BIT_MSK__TTXINTML__REG_TTX_INTRMASK3                                     0x08
  // (ReadWrite, Bits 4) 
  // mask bit of intr event 4.
  #define BIT_MSK__TTXINTML__REG_TTX_INTRMASK4                                     0x10
  // (ReadWrite, Bits 5) 
  // mask bit of intr event 5.
  #define BIT_MSK__TTXINTML__REG_TTX_INTRMASK5                                     0x20
  // (ReadWrite, Bits 6) 
  // mask bit of intr event 6.
  #define BIT_MSK__TTXINTML__REG_TTX_INTRMASK6                                     0x40
  // (ReadWrite, Bits 7) 
  // mask bit of intr event 7.
  #define BIT_MSK__TTXINTML__REG_TTX_INTRMASK7                                     0x80

// TDM TX INTMASK High Register
#define REG_ADDR__TTXINTMH                                               (TX_EMSC_MHLTOP_TDM | 0x0046)
  // (ReadWrite, Bits 0) 
  // mask bit of intr event 8.
  #define BIT_MSK__TTXINTMH__REG_TTX_INTRMASK8                                     0x01
  // (ReadWrite, Bits 1) 
  // mask bit of intr event 9.
  #define BIT_MSK__TTXINTMH__REG_TTX_INTRMASK9                                     0x02
  // (ReadWrite, Bits 2) 
  // mask bit of intr event 10.
  #define BIT_MSK__TTXINTMH__REG_TTX_INTRMASK10                                    0x04
  // (ReadWrite, Bits 3) 
  // mask bit of intr event 11.
  #define BIT_MSK__TTXINTMH__REG_TTX_INTRMASK11                                    0x08
  // (ReadWrite, Bits 4) 
  // mask bit of intr event 12.
  #define BIT_MSK__TTXINTMH__REG_TTX_INTRMASK12                                    0x10
  // (ReadWrite, Bits 5) 
  // mask bit of intr event 13.
  #define BIT_MSK__TTXINTMH__REG_TTX_INTRMASK13                                    0x20
  // (ReadWrite, Bits 6) 
  // mask bit of intr event 14.
  #define BIT_MSK__TTXINTMH__REG_TTX_INTRMASK14                                    0x40
  // (ReadWrite, Bits 7) 
  // mask bit of intr event 15.
  #define BIT_MSK__TTXINTMH__REG_TTX_INTRMASK15                                    0x80

// TDM RX INTMASK Low Register
#define REG_ADDR__TRXINTML                                               (TX_EMSC_MHLTOP_TDM | 0x0047)
  // (ReadWrite, Bits 0) 
  // mask bit of intr event 0.
  #define BIT_MSK__TRXINTML__REG_TRX_INTRMASK0                                     0x01
  // (ReadWrite, Bits 1) 
  // mask bit of intr event 1.
  #define BIT_MSK__TRXINTML__REG_TRX_INTRMASK1                                     0x02
  // (ReadWrite, Bits 2) 
  // mask bit of intr event 2.
  #define BIT_MSK__TRXINTML__REG_TRX_INTRMASK2                                     0x04
  // (ReadWrite, Bits 3) 
  // mask bit of intr event 3.
  #define BIT_MSK__TRXINTML__REG_TRX_INTRMASK3                                     0x08
  // (ReadWrite, Bits 4) 
  // mask bit of intr event 4.
  #define BIT_MSK__TRXINTML__REG_TRX_INTRMASK4                                     0x10
  // (ReadWrite, Bits 5) 
  // mask bit of intr event 5.
  #define BIT_MSK__TRXINTML__REG_TRX_INTRMASK5                                     0x20
  // (ReadWrite, Bits 6) 
  // mask bit of intr event 6.
  #define BIT_MSK__TRXINTML__REG_TRX_INTRMASK6                                     0x40
  // (ReadWrite, Bits 7) 
  // mask bit of intr event 7.
  #define BIT_MSK__TRXINTML__REG_TRX_INTRMASK7                                     0x80

// TDM RX INTMASK High Register
#define REG_ADDR__TRXINTMH                                               (TX_EMSC_MHLTOP_TDM | 0x0048)
  // (ReadWrite, Bits 0) 
  // mask bit of intr event 8.
  #define BIT_MSK__TRXINTMH__REG_TRX_INTRMASK8                                     0x01
  // (ReadWrite, Bits 1) 
  // mask bit of intr event 9.
  #define BIT_MSK__TRXINTMH__REG_TRX_INTRMASK9                                     0x02
  // (ReadWrite, Bits 2) 
  // mask bit of intr event 10.
  #define BIT_MSK__TRXINTMH__REG_TRX_INTRMASK10                                    0x04
  // (ReadWrite, Bits 3) 
  // mask bit of intr event 11.
  #define BIT_MSK__TRXINTMH__REG_TRX_INTRMASK11                                    0x08
  // (ReadWrite, Bits 4) 
  // mask bit of intr event 12.
  #define BIT_MSK__TRXINTMH__REG_TRX_INTRMASK12                                    0x10
  // (ReadWrite, Bits 5) 
  // mask bit of intr event 13.
  #define BIT_MSK__TRXINTMH__REG_TRX_INTRMASK13                                    0x20
  // (ReadWrite, Bits 6) 
  // mask bit of intr event 14.
  #define BIT_MSK__TRXINTMH__REG_TRX_INTRMASK14                                    0x40
  // (ReadWrite, Bits 7) 
  // mask bit of intr event 15.
  #define BIT_MSK__TRXINTMH__REG_TRX_INTRMASK15                                    0x80

// TDM TX Buf Register
#define REG_ADDR__TTXBUF                                                 (TX_EMSC_MHLTOP_TDM | 0x0049)
  // (ReadWrite, Bits 7:0) 
  // ri_tdm_tx_buffer[7:0]. Size of buffering before reading out from afifo in order to maintain fifo level in middle range. Default 8'h8.
  #define BIT_MSK__TTXBUF__REG_TTX_BUFFER_B7_B0                                  0xFF

// TDM TX NUMBITS Register
#define REG_ADDR__TTXNUMB                                                (TX_EMSC_MHLTOP_TDM | 0x004A)
  // (ReadWrite, Bits 2:0) 
  // ri_tdm_tx_num_of_bits_per_symbol[2:0].Number of bits in a symbol 4=(DoC or CoC 8b10b bypass) 5=10-bit(CoC 8b10b)
  #define BIT_MSK__TTXNUMB__REG_TTX_NUMBPS_B2_B0                                  0x07
  // (ReadWrite, Bits 3) 
  // ri_tdm_tx_com1_at_sync_wait. This option will be used only for source device.
  #define BIT_MSK__TTXNUMB__REG_TTX_COM1_AT_SYNC_WAIT                             0x08

// TDM TX NUMSPISYM Register
#define REG_ADDR__TTXSPINUMS                                             (TX_EMSC_MHLTOP_TDM | 0x004B)
  // (ReadWrite, Bits 7:0) 
  // ri_tdm_tx_num_of_spi_symbols_per_period[7:0]. Number of SPI symbols in a period.
  #define BIT_MSK__TTXSPINUMS__REG_TTX_NUMSPISYM                                     0xFF

// TDM TX NUMHSICSYM Register
#define REG_ADDR__TTXHSICNUMS                                            (TX_EMSC_MHLTOP_TDM | 0x004C)
  // (ReadWrite, Bits 7:0) 
  // ri_tdm_tx_num_of_hsic_symbols_per_period[7:0]. Number of HSIC symbols in a period.
  #define BIT_MSK__TTXHSICNUMS__REG_TTX_NUMHSICSYM                                    0xFF

// TDM TX NUMTOTSYM Register
#define REG_ADDR__TTXTOTNUMS                                             (TX_EMSC_MHLTOP_TDM | 0x004D)
  // (ReadWrite, Bits 7:0) 
  // ri_tdm_tx_num_of_total_m1_symbols_per_period[7:0]. Number of total symbols minus one in a period. Should be sum of SPI and HSIC symbols.
  #define BIT_MSK__TTXTOTNUMS__REG_TTX_NUMTOTSYM                                     0xFF

// TDM TX SYMCOM1 Low Register
#define REG_ADDR__TTXSCOM1L                                              (TX_EMSC_MHLTOP_TDM | 0x004E)
  // (ReadWrite, Bits 7:0) 
  // ri_tdm_tx_symbol_com1[9:0]. Symbol code for COM1. 10'hA5 for SE, 10'h1BC for DM.
  #define BIT_MSK__TTXSCOM1L__REG_TTX_SYMCOM1_B7_B0                                 0xFF

// TDM TX SYMCOM1 High Register
#define REG_ADDR__TTXSCOM1H                                              (TX_EMSC_MHLTOP_TDM | 0x004F)
  // (ReadWrite, Bits 1:0) 
  // ri_tdm_tx_symbol_com1[9:0]. Symbol code for COM1. 10'hA5 for SE, 10'h1BC for DM.
  #define BIT_MSK__TTXSCOM1H__REG_TTX_SYMCOM1_B9_B8                                 0x03

// TDM TX SYMCOM2 Low Register
#define REG_ADDR__TTXSCOM2L                                              (TX_EMSC_MHLTOP_TDM | 0x0050)
  // (ReadWrite, Bits 7:0) 
  // ri_tdm_tx_symbol_com2[9:0]. Symbol code for COM2. 10'h5A for SE, 10'h13C for DM.
  #define BIT_MSK__TTXSCOM2L__REG_TTX_SYMCOM2_B7_B0                                 0xFF

// TDM TX SYMCOM2 High Register
#define REG_ADDR__TTXSCOM2H                                              (TX_EMSC_MHLTOP_TDM | 0x0051)
  // (ReadWrite, Bits 1:0) 
  // ri_tdm_tx_symbol_com2[9:0]. Symbol code for COM2. 10'h5A for SE, 10'h13C for DM.
  #define BIT_MSK__TTXSCOM2H__REG_TTX_SYMCOM2_B9_B8                                 0x03

// TDM TX SYMIDLE Low Register
#define REG_ADDR__TTXSIDLEL                                              (TX_EMSC_MHLTOP_TDM | 0x0052)
  // (ReadWrite, Bits 7:0) 
  // ri_tdm_tx_symbol_idle[9:0]. Symbol code for IDLE. Default 10'h0.
  #define BIT_MSK__TTXSIDLEL__REG_TTX_SYMIDLE_B7_B0                                 0xFF

// TDM TX SYMIDLE High Register
#define REG_ADDR__TTXSIDLEH                                              (TX_EMSC_MHLTOP_TDM | 0x0053)
  // (ReadWrite, Bits 1:0) 
  // ri_tdm_tx_symbol_idle[9:0]. Symbol code for IDLE. Default 10'h0.
  #define BIT_MSK__TTXSIDLEH__REG_TTX_SYMIDLE_B9_B8                                 0x03

// TDM TX SYMCBUS Low Register
#define REG_ADDR__TTXSCBUSL                                              (TX_EMSC_MHLTOP_TDM | 0x0054)
  // (ReadWrite, Bits 7:0) 
  // ri_tdm_tx_symbol_cbus[9:0]. Symbol code for CBUS. Default 10'h39.
  #define BIT_MSK__TTXSCBUSL__REG_TTX_SYMCBUS_B7_B0                                 0xFF

// TDM TX SYMCBUS High Register
#define REG_ADDR__TTXSCBUSH                                              (TX_EMSC_MHLTOP_TDM | 0x0055)
  // (ReadWrite, Bits 1:0) 
  // ri_tdm_tx_symbol_cbus[9:0]. Symbol code for CBUS. Default 10'h39.
  #define BIT_MSK__TTXSCBUSH__REG_TTX_SYMCBUS_B9_B8                                 0x03

// TDM TX SYMCBUSA Low Register
#define REG_ADDR__TTXSCBUSAL                                             (TX_EMSC_MHLTOP_TDM | 0x0056)
  // (ReadWrite, Bits 7:0) 
  // ri_tdm_tx_symbol_cbusa[9:0]. Symbol code for CBUSA. Default 10'h63.
  #define BIT_MSK__TTXSCBUSAL__REG_TTX_SYMCBUSA_B7_B0                                0xFF

// TDM TX SYMCBUSA High Register
#define REG_ADDR__TTXSCBUSAH                                             (TX_EMSC_MHLTOP_TDM | 0x0057)
  // (ReadWrite, Bits 1:0) 
  // ri_tdm_tx_symbol_cbusa[9:0]. Symbol code for CBUSA. Default 10'h63.
  #define BIT_MSK__TTXSCBUSAH__REG_TTX_SYMCBUSA_B9_B8                                0x03

// TDM TX SYMCBUSN Low Register
#define REG_ADDR__TTXSCBUSNL                                             (TX_EMSC_MHLTOP_TDM | 0x0058)
  // (ReadWrite, Bits 7:0) 
  // ri_tdm_tx_symbol_cbusn[9:0]. Symbol code for CBUSN. Default 10'h6C.
  #define BIT_MSK__TTXSCBUSNL__REG_TTX_SYMCBUSN_B7_B0                                0xFF

// TDM TX SYMCBUSN High Register
#define REG_ADDR__TTXSCBUSNH                                             (TX_EMSC_MHLTOP_TDM | 0x0059)
  // (ReadWrite, Bits 1:0) 
  // ri_tdm_tx_symbol_cbusn[9:0]. Symbol code for CBUSN. Default 10'h6C.
  #define BIT_MSK__TTXSCBUSNH__REG_TTX_SYMCBUSN_B9_B8                                0x03

// TDM TX Status 1st Register
#define REG_ADDR__TTXSTA1                                                (TX_EMSC_MHLTOP_TDM | 0x005A)
  // (ReadOnly, Bits 7:0) 
  // HSIC2TDM AFIFO rtags
  #define BIT_MSK__TTXSTA1__REG_TTX_STATUS_B7_B0                                  0xFF

// TDM TX Status 2nd Register
#define REG_ADDR__TTXSTA2                                                (TX_EMSC_MHLTOP_TDM | 0x005B)
  // (ReadOnly, Bits 7:0) 
  // bit 2-0: HSIC2TDM AFIFO raddr bit 3: HSIC2TDM AFIFO error bit 4: HSIC current state bit 7-5: CBUS current state 
  #define BIT_MSK__TTXSTA2__REG_TTX_STATUS_B15_B8                                 0xFF

// TDM TX Status 3rd Register
#define REG_ADDR__TTXSTA3                                                (TX_EMSC_MHLTOP_TDM | 0x005C)
  // (ReadOnly, Bits 7:0) 
  // Current tdm_tx slot 0 distance from tdm_rx slot 0 location (positive number) (ES1.0)
  #define BIT_MSK__TTXSTA3__REG_TTX_STATUS_B23_B16                                0xFF

// TDM TX Status 4th Register
#define REG_ADDR__TTXSTA4                                                (TX_EMSC_MHLTOP_TDM | 0x005D)
  // (ReadOnly, Bits 7:0) 
  // link_data value sent out to CoC/DoC (ES1.0)
  #define BIT_MSK__TTXSTA4__REG_TTX_STATUS_B31_B24                                0xFF

// TDM TX Override Low Register
#define REG_ADDR__TTXOVRL                                                (TX_EMSC_MHLTOP_TDM | 0x005E)
  // (ReadWrite, Bits 7:0) 
  // LSB of ri_tdm_tx_hsic_override_hsic_in[10:0], [10]=override_enable,[9:0]=data (default 10'h0) (ES1.0)
  #define BIT_MSK__TTXOVRL__REG_TTX_OVERRIDE_HSIC_IN_B7_B0                        0xFF

// TDM TX Override High Register
#define REG_ADDR__TTXOVRH                                                (TX_EMSC_MHLTOP_TDM | 0x005F)
  // (ReadWrite, Bits 2:0) 
  // MSB of ri_tdm_tx_hsic_override_hsic_in[10:0], [10]=override_enable,[9:0]=data (default 10'h0) (ES1.0)
  #define BIT_MSK__TTXOVRH__REG_TTX_OVERRIDE_HSIC_IN_B10_B8                       0x07

// TDM TX Misc Control Register
#define REG_ADDR__TTXMISCCTL                                             (TX_EMSC_MHLTOP_TDM | 0x0060)
  // (ReadWrite, Bits 0) 
  // ri_tdm_tx_ignore_cbus_in, 0=accept CBUS input, 1=ignore CBUS input (defult 1'b0) (ES1.0)
  #define BIT_MSK__TTXMISCCTL__REG_TTX_IGNORE_CBUS_IN                                0x01
  // (ReadWrite, Bits 1) 
  // ri_tdm_tx_ignore_spi_in, 0=accept SPI input, 1=ignore SPI input (defult 1'b0) (ES1.0)
  #define BIT_MSK__TTXMISCCTL__REG_TTX_IGNORE_SPI_IN                                 0x02
  // (ReadWrite, Bits 2) 
  // ri_tdm_tx_alloc_hsic_then_spi, ES1.0: 0=allocate CBUS/SPI(=N)/HSIC(=M), 1=allocate CBUS/HSIC(=N)/SPI(=M) (default 1'b0)
  #define BIT_MSK__TTXMISCCTL__REG_TTX_ALLOC_HSIC_THEN_SPI                           0x04

// TDM RX Output Enable Register
#define REG_ADDR__TRXOUTEN                                               (TX_EMSC_MHLTOP_TDM | 0x0061)
  // (ReadWrite, Bits 5:0) 
  // [5:4]=SPI out enable (default 3'h3F), [3:2]=HSIC out enable, [1:0]=CBUS out enable, 2'b00=disable, 2'b01=enable when both TDM synched, 2'b11=enable when local TDM synched(default)
  #define BIT_MSK__TRXOUTEN__REG_TRX_OUT_EN                                        0x3F
  // (ReadWrite, Bits 6) 
  // ri_tdm_rx_alloc_hsic_then_spi, ES1.0: 0=allocate CBUS/SPI(=N)/HSIC(=M), 1=allocate CBUS/HSIC(=N)/SPI(=M) (default 1'b0)
  #define BIT_MSK__TRXOUTEN__REG_TRX_ALLOC_HSIC_THEN_SPI                           0x40
  // (ReadWrite, Bits 7) 
  // ri_status_en. Enable to latch status (ro_hsic_tx_status, ro_hsic_rx_status, ro_tdm_tx_status, ro_tdm_rx_status). Turn off to hold the status.
  #define BIT_MSK__TRXOUTEN__REG_STATUS_EN                                         0x80

// TDM RX Control Register
#define REG_ADDR__TRXCTRL                                                (TX_EMSC_MHLTOP_TDM | 0x0062)
  // (ReadWrite, Bits 2:0) 
  // ri_tdm_rx_num_of_bits_per_symbol[2:0].Number of bits in a symbol 4=(DoC or CoC 8b10b bypass) 5=10-bit(CoC 8b10b)
  #define BIT_MSK__TRXCTRL__REG_TRX_NUMBPS_B2_B0                                  0x07
  // (ReadWrite, Bits 3) 
  // ri_tdm_rx_from_se_coc. Select which analog core will be used. 0=Differential CoC, 1=Single-Ended CoC
  #define BIT_MSK__TRXCTRL__REG_TRX_FROM_SE_COC                                   0x08
  // (ReadWrite, Bits 4) 
  // ri_tdm_rx_clear_when_valid_low. Clear latch of link_rx_data_di when link_rx_valid is low. 1=enable (default), 0=disable
  #define BIT_MSK__TRXCTRL__REG_TRX_CLR_WVALLOW                                   0x10

// TDM RX NUMSPISYM Register
#define REG_ADDR__TRXSPINUMS                                             (TX_EMSC_MHLTOP_TDM | 0x0063)
  // (ReadWrite, Bits 7:0) 
  // ri_tdm_rx_num_of_spi_symbols_per_period[7:0]. Number of SPI symbols in a period.
  #define BIT_MSK__TRXSPINUMS__REG_TRX_NUMSPISYM                                     0xFF

// TDM RX NUMHSICSYM Register
#define REG_ADDR__TRXHSICNUMS                                            (TX_EMSC_MHLTOP_TDM | 0x0064)
  // (ReadWrite, Bits 7:0) 
  // ri_tdm_rx_num_of_hsic_symbols_per_period[7:0]. Number of HSIC symbols in a period.
  #define BIT_MSK__TRXHSICNUMS__REG_TRX_NUMHSICSYM                                    0xFF

// TDM RX NUMTOTSYM Register
#define REG_ADDR__TRXTOTNUMS                                             (TX_EMSC_MHLTOP_TDM | 0x0065)
  // (ReadWrite, Bits 7:0) 
  // ri_tdm_rx_num_of_total_m1_symbols_per_period[7:0]. Number of total symbols minus one in a period.Should be sum of SPI and HSIC symbols.
  #define BIT_MSK__TRXTOTNUMS__REG_TRX_NUMTOTSYM                                     0xFF

// TDM RX MIN12MCHPRD Register
#define REG_ADDR__TRXMIN12                                               (TX_EMSC_MHLTOP_TDM | 0x0066)
  // (ReadWrite, Bits 7:0) 
  // ri_minimum_com12_matched_periods[7:0]. Minimum number of period of slot synchronization before sending acknowledge COM2. Default 8'h8.
  #define BIT_MSK__TRXMIN12__REG_TRX_MIN12MP                                       0xFF

// TDM RX MIN2MCHPRD Register
#define REG_ADDR__TRXMIN2                                                (TX_EMSC_MHLTOP_TDM | 0x0067)
  // (ReadWrite, Bits 7:0) 
  // ri_minimum_com2_matched_periods[7:0]. Minimum number of period of slot synchronization before sending actual USB/CBUS data packet. Default 8'h8.
  #define BIT_MSK__TRXMIN2__REG_TRX_MIN2MP                                        0xFF

// TDM RX MAX12MCHPRD Register
#define REG_ADDR__TRXMAX12                                               (TX_EMSC_MHLTOP_TDM | 0x0068)
  // (ReadWrite, Bits 7:0) 
  // ri_maximum_com12_matched_periods[7:0]. maximum number of period of slot synchronization before sending acknowledge COM2. Default 8'hA.
  #define BIT_MSK__TRXMAX12__REG_TRX_MAX12MP                                       0xFF

// TDM RX MAX2MCHPRD Register
#define REG_ADDR__TRXMAX2                                                (TX_EMSC_MHLTOP_TDM | 0x0069)
  // (ReadWrite, Bits 7:0) 
  // ri_maximum_com2_matched_periods[7:0]. maximum number of period of slot synchronization before sending actual USB/CBUS data packet. Default 8'hA.
  #define BIT_MSK__TRXMAX2__REG_TRX_MAX2MP                                        0xFF

// TDM RX Status 1st Register
#define REG_ADDR__TRXSTA1                                                (TX_EMSC_MHLTOP_TDM | 0x006A)
  // (ReadOnly, Bits 7:0) 
  // TDM2HSIC AFIFO wtags
  #define BIT_MSK__TRXSTA1__REG_TRX_STATUS_B7_B0                                  0xFF

// TDM RX Status 2nd Register
#define REG_ADDR__TRXSTA2                                                (TX_EMSC_MHLTOP_TDM | 0x006B)
  // (ReadOnly, Bits 7:0) 
  // bit 2-0: TDM2HSIC AFIFO waddr bir 5-3: CBUS current state bit 7-6: TDM current state
  #define BIT_MSK__TRXSTA2__REG_TRX_STATUS_B15_B8                                 0xFF

// TDM RX Status 3rd Register
#define REG_ADDR__TRXSTA3                                                (TX_EMSC_MHLTOP_TDM | 0x006C)
  // (ReadOnly, Bits 7:0) 
  // Matched COM1/COM2 period count (ES1.0)
  #define BIT_MSK__TRXSTA3__REG_TRX_STATUS_B23_B16                                0xFF

// TDM RX Status 4th Register
#define REG_ADDR__TRXSTA4                                                (TX_EMSC_MHLTOP_TDM | 0x006D)
  // (ReadOnly, Bits 7:0) 
  // Matched COM2 period count (ES1.0)
  #define BIT_MSK__TRXSTA4__REG_TRX_STATUS_B31_B24                                0xFF

// TDM RX Status 5th Register
#define REG_ADDR__TRXSTA5                                                (TX_EMSC_MHLTOP_TDM | 0x006E)
  // (ReadOnly, Bits 7:0) 
  // bit 1-0: LL channel selection result (ES1.0) bit 7-2: reserved
  #define BIT_MSK__TRXSTA5__REG_TRX_STATUS_B39_B32                                0xFF

// TDM RX Status 6th Register
#define REG_ADDR__TRXSTA6                                                (TX_EMSC_MHLTOP_TDM | 0x006F)
  // (ReadOnly, Bits 7:0) 
  // rsvd
  #define BIT_MSK__TRXSTA6__REG_TRX_STATUS_B47_B40                                0xFF

// TDM RX Status 7th Register
#define REG_ADDR__TRXSTA7                                                (TX_EMSC_MHLTOP_TDM | 0x0070)
  // (ReadOnly, Bits 7:0) 
  // rsvd
  #define BIT_MSK__TRXSTA7__REG_TRX_STATUS_B55_B48                                0xFF

// TDM RX Status 8th Register
#define REG_ADDR__TRXSTA8                                                (TX_EMSC_MHLTOP_TDM | 0x0071)
  // (ReadOnly, Bits 7:0) 
  // rsvd
  #define BIT_MSK__TRXSTA8__REG_TRX_STATUS_B63_B56                                0xFF

// TDM Low Latency Register
#define REG_ADDR__TDMLLCTL                                               (TX_EMSC_MHLTOP_TDM | 0x0072)
  // (ReadWrite, Bits 0) 
  // ri_tdm_tx_ll_sel_mode, 0=LL disable 1=LL enable (manual select) (default 1'b0) (ES1.0)
  #define BIT_MSK__TDMLLCTL__REG_TTX_LL_SEL_MODE                                   0x01
  // (ReadWrite, Bits 1) 
  // ri_tdm_tx_ll_tie_low, 0=LL forward after training done 1=LL tied to low (default 1'b0) (ES1.0)
  #define BIT_MSK__TDMLLCTL__REG_TTX_LL_TIE_LOW                                    0x02
  // (ReadWrite, Bits 3:2) 
  // ri_tdm_tx_ll_sel_manual[1:0], ll_sel manual value (default 2'h0) (ES1.0)
  #define BIT_MSK__TDMLLCTL__REG_TTX_LL_SEL_MANUAL                                 0x0C
  // (ReadWrite, Bits 5:4) 
  // ri_tdm_rx_ll_sel_mode[1:0], 0=LL disable 1=LL enable(manual select), 2=LL enable(auto select), 3=invalid (default 2'h0) (ES1.0)
  #define BIT_MSK__TDMLLCTL__REG_TRX_LL_SEL_MODE                                   0x30
  // (ReadWrite, Bits 7:6) 
  // ri_tdm_rx_ll_sel_manual[1:0], ll_sel manual value (default 2'h0) (ES1.0)
  #define BIT_MSK__TDMLLCTL__REG_TRX_LL_SEL_MANUAL                                 0xC0

// TDM Byte Control Register
#define REG_ADDR__TDMBYTE                                                (TX_EMSC_MHLTOP_TDM | 0x0073)
  // (ReadWrite, Bits 0) 
  // ri_tdm_tx_8bit_cbus_if, 0=ES0.0(16-bit interface) 1=ES1.0(8-bit interface) (default 1'b1)
  #define BIT_MSK__TDMBYTE__REG_TTX_8BIT_CBUS_IF                                  0x01
  // (ReadWrite, Bits 1) 
  // ri_tdm_rx_8bit_cbus_if, 0=ES0.0(16-bit interface) 1=ES1.0(8-bit interface) (default 1'b1)
  #define BIT_MSK__TDMBYTE__REG_TRX_8BIT_CBUS_IF                                  0x02
  // (ReadWrite, Bits 2) 
  // ri_tdm_tx_slot0_interleaving, 0(disable ES0.0), 1(enable ES1.0)
  #define BIT_MSK__TDMBYTE__REG_TTX_SLOT0_INTERLEAVING                            0x04

// TDM Interleaving Target Register
#define REG_ADDR__S0TGT                                                  (TX_EMSC_MHLTOP_TDM | 0x0074)
  // (ReadWrite, Bits 7:0) 
  // ri_tdm_tx_slot0_target[7:0], tdm_tx slot 0 position offset from tdm_tx slot 0 (CoC=8'd12/d13, DoC=8'd100)
  #define BIT_MSK__S0TGT__REG_TTX_S0_TARGET                                     0xFF

// TDM Interleaving Allowance Register
#define REG_ADDR__S0ALLOW                                                (TX_EMSC_MHLTOP_TDM | 0x0075)
  // (ReadWrite, Bits 7:0) 
  // ri_tdm_tx_slot0_allowance[7:0], tdm_tx slot 0 position offset allowance (CoC=8'd2, DoC=8'd20)
  #define BIT_MSK__S0ALLOW__REG_TTX_S0_ALLOWANCE                                  0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_1                                        (TX_EMSC_MHLTOP_TDM | 0x0091)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_1__REG_BIST_CTRL_1                                       0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_2                                        (TX_EMSC_MHLTOP_TDM | 0x0092)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_2__REG_BIST_CTRL_2                                       0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_3                                        (TX_EMSC_MHLTOP_TDM | 0x0093)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_3__REG_BIST_CTRL_3                                       0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_4                                        (TX_EMSC_MHLTOP_TDM | 0x0094)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_4__REG_BIST_CTRL_4                                       0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_5                                        (TX_EMSC_MHLTOP_TDM | 0x0095)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_5__REG_BIST_CTRL_5                                       0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_6                                        (TX_EMSC_MHLTOP_TDM | 0x0096)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_6__REG_BIST_CTRL_6                                       0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_7                                        (TX_EMSC_MHLTOP_TDM | 0x0097)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_7__REG_BIST_CTRL_7                                       0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_8                                        (TX_EMSC_MHLTOP_TDM | 0x0098)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_8__REG_BIST_CTRL_8                                       0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_9                                        (TX_EMSC_MHLTOP_TDM | 0x0099)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_9__REG_BIST_CTRL_9                                       0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_10                                       (TX_EMSC_MHLTOP_TDM | 0x009A)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_10__REG_BIST_CTRL_10                                      0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_11                                       (TX_EMSC_MHLTOP_TDM | 0x009B)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_11__REG_BIST_CTRL_11                                      0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_12                                       (TX_EMSC_MHLTOP_TDM | 0x009C)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_12__REG_BIST_CTRL_12                                      0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_13                                       (TX_EMSC_MHLTOP_TDM | 0x009D)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_13__REG_BIST_CTRL_13                                      0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_14                                       (TX_EMSC_MHLTOP_TDM | 0x009E)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_14__REG_BIST_CTRL_14                                      0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_15                                       (TX_EMSC_MHLTOP_TDM | 0x009F)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_15__REG_BIST_CTRL_15                                      0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_16                                       (TX_EMSC_MHLTOP_TDM | 0x00A0)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_16__REG_BIST_CTRL_16                                      0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_17                                       (TX_EMSC_MHLTOP_TDM | 0x00A1)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_17__REG_BIST_CTRL_17                                      0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_18                                       (TX_EMSC_MHLTOP_TDM | 0x00A2)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_18__REG_BIST_CTRL_18                                      0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_19                                       (TX_EMSC_MHLTOP_TDM | 0x00A3)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_19__REG_BIST_CTRL_19                                      0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_20                                       (TX_EMSC_MHLTOP_TDM | 0x00A4)
  // (ReadWrite, Bits 7:0) 
  // TMDS BIST config control register
  #define BIT_MSK__TX_TBIST_CTRL_20__REG_BIST_CTRL_20                                      0xFF

// Config Register
#define REG_ADDR__TX_TBIST_CTRL_21                                       (TX_EMSC_MHLTOP_TDM | 0x00A5)
  // (ReadWrite, Bits 7:0) 
  // bit #0 - reg_rxbist_vgb_en bit #1 - reg_tmds0_bist_vgb_mask bit #2 - enbaled tx tbist bit #3 - enable txbist_vgb
  #define BIT_MSK__TX_TBIST_CTRL_21__REG_BIST_CTRL_21                                      0xFF
  #define BIT_MSK__TX_TBIST_CTRL_21__TX_TBIST                                              0x04

// HANA BIST BLUE CONTROL0 Register
#define REG_ADDR__TX_CONFIG_BIST_10BIT_B_1ST_0                              (TX_EMSC_MHLTOP_TDM | 0x00A7)
  // (ReadWrite, Bits 7:0) 
  // Hana Bist blue 
  #define BIT_MSK__TX_CONFIG_BIST_10BIT_B_1ST_0__REG_BIST_10BIT_BLUE_1ST_B7_B0                         0xFF

// HANA BIST BLUE CONTROL1 Register
#define REG_ADDR__TX_CONFIG_BIST_10BIT_B_1ST_1                              (TX_EMSC_MHLTOP_TDM | 0x00A8)
  // (ReadWrite, Bits 1:0) 
  // Hana Bist blue 
  #define BIT_MSK__TX_CONFIG_BIST_10BIT_B_1ST_1__REG_BIST_10BIT_BLUE_1ST_B9_B8                         0x03

// HANA BIST BLUE CONTROL 2 Register
#define REG_ADDR__TX_CONFIG_BIST_10BIT_B_2ND_0                              (TX_EMSC_MHLTOP_TDM | 0x00A9)
  // (ReadWrite, Bits 7:0) 
  // Hana Bist blue 
  #define BIT_MSK__TX_CONFIG_BIST_10BIT_B_2ND_0__REG_BIST_10BIT_BLUE_2ND_B7_B0                         0xFF

// HANA BIST BLUE CONTROL3 Register
#define REG_ADDR__TX_CONFIG_BIST_10BIT_B_2ND_1                              (TX_EMSC_MHLTOP_TDM | 0x00AA)
  // (ReadWrite, Bits 1:0) 
  // Hana Bist blue 
  #define BIT_MSK__TX_CONFIG_BIST_10BIT_B_2ND_1__REG_BIST_10BIT_BLUE_2ND_B9_B8                         0x03

// HANA BIST Green CONTROL0 Register
#define REG_ADDR__TX_CONFIG_BIST_10BIT_G_1ST_0                              (TX_EMSC_MHLTOP_TDM | 0x00AB)
  // (ReadWrite, Bits 7:0) 
  // Hana Bist Green
  #define BIT_MSK__TX_CONFIG_BIST_10BIT_G_1ST_0__REG_BIST_10BIT_GREEN_1ST_B7_B0                        0xFF

// HANA BIST Green CONTROL1 Register
#define REG_ADDR__TX_CONFIG_BIST_10BIT_G_1ST_1                              (TX_EMSC_MHLTOP_TDM | 0x00AC)
  // (ReadWrite, Bits 1:0) 
  // Hana Bist Green
  #define BIT_MSK__TX_CONFIG_BIST_10BIT_G_1ST_1__REG_BIST_10BIT_GREEN_1ST_B9_B8                        0x03

// HANA BIST Green CONTROL2 Register
#define REG_ADDR__TX_CONFIG_BIST_10BIT_G_2ND_0                              (TX_EMSC_MHLTOP_TDM | 0x00AD)
  // (ReadWrite, Bits 7:0) 
  // Hana Bist Green
  #define BIT_MSK__TX_CONFIG_BIST_10BIT_G_2ND_0__REG_BIST_10BIT_GREEN_2ND_B7_B0                        0xFF

// HANA BIST Green CONTROL3 Register
#define REG_ADDR__TX_CONFIG_BIST_10BIT_G_2ND_1                              (TX_EMSC_MHLTOP_TDM | 0x00AE)
  // (ReadWrite, Bits 1:0) 
  // Hana Bist Green
  #define BIT_MSK__TX_CONFIG_BIST_10BIT_G_2ND_1__REG_BIST_10BIT_GREEN_2ND_B9_B8                        0x03

// HANA BIST Red CONTROL0 Register
#define REG_ADDR__TX_CONFIG_BIST_10BIT_R_1ST_0                              (TX_EMSC_MHLTOP_TDM | 0x00AF)
  // (ReadWrite, Bits 7:0) 
  // Hana Bist Red
  #define BIT_MSK__TX_CONFIG_BIST_10BIT_R_1ST_0__REG_BIST_10BIT_RED_1ST_B7_B0                          0xFF

// HANA BIST Red CONTROL1 Register
#define REG_ADDR__TX_CONFIG_BIST_10BIT_R_1ST_1                              (TX_EMSC_MHLTOP_TDM | 0x00B0)
  // (ReadWrite, Bits 1:0) 
  // Hana Bist Red
  #define BIT_MSK__TX_CONFIG_BIST_10BIT_R_1ST_1__REG_BIST_10BIT_RED_1ST_B9_B8                          0x03

// HANA BIST Red CONTROL2 Register
#define REG_ADDR__TX_CONFIG_BIST_10BIT_R_2ND_0                              (TX_EMSC_MHLTOP_TDM | 0x00B1)
  // (ReadWrite, Bits 7:0) 
  // Hana Bist Red
  #define BIT_MSK__TX_CONFIG_BIST_10BIT_R_2ND_0__REG_BIST_10BIT_RED_2ND_B7_B0                          0xFF

// HANA BIST Red CONTROL3 Register
#define REG_ADDR__TX_CONFIG_BIST_10BIT_R_2ND_1                              (TX_EMSC_MHLTOP_TDM | 0x00B2)
  // (ReadWrite, Bits 1:0) 
  // Hana Bist Red
  #define BIT_MSK__TX_CONFIG_BIST_10BIT_R_2ND_1__REG_BIST_10BIT_RED_2ND_B9_B8                          0x03

// TMDS STPG LUM #0 Register
#define REG_ADDR__TX_STPG_LUM0                                              (TX_EMSC_MHLTOP_TDM | 0x00B4)
  // (ReadWrite, Bits 7:0) 
  // Programmable value for channel R  for STPG Simp92 with Zone ID V5_H4 - V5_H13
  #define BIT_MSK__TX_STPG_LUM0__V5_H4TO13_R                                           0xFF

// TMDS STPG LUM #1 Register
#define REG_ADDR__TX_STPG_LUM1                                              (TX_EMSC_MHLTOP_TDM | 0x00B5)
  // (ReadWrite, Bits 7:0) 
  // Programmable value for channel G  for STPG Simp92 with Zone ID V5_H4 - V5_H13
  #define BIT_MSK__TX_STPG_LUM1__V5_H4TO13_G                                           0xFF

// TMDS STPG LUM #2 Register
#define REG_ADDR__TX_STPG_LUM2                                              (TX_EMSC_MHLTOP_TDM | 0x00B6)
  // (ReadWrite, Bits 7:0) 
  // Programmable value for channel B  for STPG Simp92 with Zone ID V5_H4 - V5_H13
  #define BIT_MSK__TX_STPG_LUM2__V5_H4TO13_B                                           0xFF

// TMDS STPG LUM #3 Register
#define REG_ADDR__TX_STPG_LUM0B                                             (TX_EMSC_MHLTOP_TDM | 0x00B7)
  // (ReadWrite, Bits 7:0) 
  // Programmable value for channel R for STPG Simp92 with Zone V7_H4 - V7_H13
  #define BIT_MSK__TX_STPG_LUM0B__V7_H4TO13_R                                           0xFF

// TMDS STPG LUM #4 Register
#define REG_ADDR__TX_STPG_LUM1B                                             (TX_EMSC_MHLTOP_TDM | 0x00B8)
  // (ReadWrite, Bits 7:0) 
  // Programmable value for channel G for STPG Simp92 with Zone V7_H4 - V7_H13
  #define BIT_MSK__TX_STPG_LUM1B__V7_H4TO13_G                                           0xFF

// TMDS STPG LUM #5 Register
#define REG_ADDR__TX_STPG_LUM2B                                             (TX_EMSC_MHLTOP_TDM | 0x00B9)
  // (ReadWrite, Bits 7:0) 
  // Programmable value for channel B for STPG Simp92 with Zone V7_H4 - V7_H13
  #define BIT_MSK__TX_STPG_LUM2B__V7_H4TO13_B                                           0xFF

// TMDS STPG #0 Register
#define REG_ADDR__TX_REG_V5_H4TO13                                          (TX_EMSC_MHLTOP_TDM | 0x00BA)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V5H4TO13
  #define BIT_MSK__TX_REG_V5_H4TO13__V5_H4TO13                                             0xFF

// TMDS STPG #1 Register
#define REG_ADDR__TX_REG_V6_H2                                              (TX_EMSC_MHLTOP_TDM | 0x00BB)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H2
  #define BIT_MSK__TX_REG_V6_H2__V6_H2                                                 0xFF

// TMDS STPG #2 Register
#define REG_ADDR__TX_REG_V6_H3                                              (TX_EMSC_MHLTOP_TDM | 0x00BC)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H3
  #define BIT_MSK__TX_REG_V6_H3__V6_H3                                                 0xFF

// TMDS STPG #3 Register
#define REG_ADDR__TX_REG_V6_H4                                              (TX_EMSC_MHLTOP_TDM | 0x00BD)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H4
  #define BIT_MSK__TX_REG_V6_H4__V6_H4                                                 0xFF

// TMDS STPG #4 Register
#define REG_ADDR__TX_REG_V6_H5                                              (TX_EMSC_MHLTOP_TDM | 0x00BE)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H5
  #define BIT_MSK__TX_REG_V6_H5__V6_H5                                                 0xFF

// TMDS STPG #5 Register
#define REG_ADDR__TX_REG_V6_H6                                              (TX_EMSC_MHLTOP_TDM | 0x00BF)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H6
  #define BIT_MSK__TX_REG_V6_H6__V6_H6                                                 0xFF

// TMDS STPG #6 Register
#define REG_ADDR__TX_REG_V6_H7                                              (TX_EMSC_MHLTOP_TDM | 0x00C0)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H7
  #define BIT_MSK__TX_REG_V6_H7__V6_H7                                                 0xFF

// TMDS STPG #7 Register
#define REG_ADDR__TX_REG_V6_H8                                              (TX_EMSC_MHLTOP_TDM | 0x00C1)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H8
  #define BIT_MSK__TX_REG_V6_H8__V6_H8                                                 0xFF

// TMDS STPG #8 Register
#define REG_ADDR__TX_REG_V6_H9                                              (TX_EMSC_MHLTOP_TDM | 0x00C2)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H9
  #define BIT_MSK__TX_REG_V6_H9__V6_H9                                                 0xFF

// TMDS STPG #9 Register
#define REG_ADDR__TX_REG_V6_H10                                             (TX_EMSC_MHLTOP_TDM | 0x00C3)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H10
  #define BIT_MSK__TX_REG_V6_H10__V6_H10                                                0xFF

// TMDS STPG #10 Register
#define REG_ADDR__TX_REG_V6_H11                                             (TX_EMSC_MHLTOP_TDM | 0x00C4)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H11
  #define BIT_MSK__TX_REG_V6_H11__V6_H11                                                0xFF

// TMDS STPG #11 Register
#define REG_ADDR__TX_REG_V6_H12                                             (TX_EMSC_MHLTOP_TDM | 0x00C5)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H12
  #define BIT_MSK__TX_REG_V6_H12__V6_H12                                                0xFF

// TMDS STPG #12 Register
#define REG_ADDR__TX_REG_V6_H13                                             (TX_EMSC_MHLTOP_TDM | 0x00C6)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H13
  #define BIT_MSK__TX_REG_V6_H13__V6_H13                                                0xFF

// TMDS STPG #13 Register
#define REG_ADDR__TX_REG_V6_H14                                             (TX_EMSC_MHLTOP_TDM | 0x00C7)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H14
  #define BIT_MSK__TX_REG_V6_H14__V6_H14                                                0xFF

// TMDS STPG #14 Register
#define REG_ADDR__TX_REG_V6_H15                                             (TX_EMSC_MHLTOP_TDM | 0x00C8)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H15
  #define BIT_MSK__TX_REG_V6_H15__V6_H15                                                0xFF

// TMDS STPG #15 Register
#define REG_ADDR__TX_REG_V6_H16                                             (TX_EMSC_MHLTOP_TDM | 0x00C9)
  // (ReadWrite, Bits 7:0) 
  // NVRAM data for V6H16
  #define BIT_MSK__TX_REG_V6_H16__V6_H16                                                0xFF

// TMDS STPG #16 Register
#define REG_ADDR__TX_REG_V7_CONST61                                         (TX_EMSC_MHLTOP_TDM | 0x00CA)
  // (ReadWrite, Bits 7:0) 
  // data for V7
  #define BIT_MSK__TX_REG_V7_CONST61__V7_CONST61                                            0xFF

// TMDS STPG #17 Register
#define REG_ADDR__TX_REG_V7_CONST50                                         (TX_EMSC_MHLTOP_TDM | 0x00CB)
  // (ReadWrite, Bits 7:0) 
  // data for V7
  #define BIT_MSK__TX_REG_V7_CONST50__V7_CONST50                                            0xFF

// TMDS STPG #18 Register
#define REG_ADDR__TX_REG_V7_CONST102                                        (TX_EMSC_MHLTOP_TDM | 0x00CC)
  // (ReadWrite, Bits 7:0) 
  // data for V7
  #define BIT_MSK__TX_REG_V7_CONST102__V7_CONST102                                           0xFF

// TMDS STPG #19 Register
#define REG_ADDR__TX_REG_V9_CONST204                                        (TX_EMSC_MHLTOP_TDM | 0x00CD)
  // (ReadWrite, Bits 7:0) 
  // data for V9
  #define BIT_MSK__TX_REG_V9_CONST204__V9_CONST204                                           0xFF

// TMDS STPG #20 Register
#define REG_ADDR__TX_REG_V9_CONST205                                        (TX_EMSC_MHLTOP_TDM | 0x00CE)
  // (ReadWrite, Bits 7:0) 
  // data for V9
  #define BIT_MSK__TX_REG_V9_CONST205__V9_CONST205                                           0xFF

// TMDS STPG #21 Register
#define REG_ADDR__TX_REG_V9_CONST209                                        (TX_EMSC_MHLTOP_TDM | 0x00CF)
  // (ReadWrite, Bits 7:0) 
  // data for V9
  #define BIT_MSK__TX_REG_V9_CONST209__V9_CONST209                                           0xFF

// TMDS STPG #22 Register
#define REG_ADDR__TX_REG_V9_CONST229                                        (TX_EMSC_MHLTOP_TDM | 0x00D0)
  // (ReadWrite, Bits 7:0) 
  // data for V9
  #define BIT_MSK__TX_REG_V9_CONST229__V9_CONST229                                           0xFF

// TMDS STPG #23 Register
#define REG_ADDR__TX_REG_V9_CONST231                                        (TX_EMSC_MHLTOP_TDM | 0x00D1)
  // (ReadWrite, Bits 7:0) 
  // data for V9
  #define BIT_MSK__TX_REG_V9_CONST231__V9_CONST231                                           0xFF

// TMDS STPG #24 Register
#define REG_ADDR__TX_REG_V10_H3TO4                                          (TX_EMSC_MHLTOP_TDM | 0x00D2)
  // (ReadWrite, Bits 7:0) 
  // V10_H3TO4
  #define BIT_MSK__TX_REG_V10_H3TO4__V10_H3TO4                                             0xFF

// TMDS STPG #25 Register
#define REG_ADDR__TX_REG_V10_H5TO6                                          (TX_EMSC_MHLTOP_TDM | 0x00D3)
  // (ReadWrite, Bits 7:0) 
  // V10_H5TO6
  #define BIT_MSK__TX_REG_V10_H5TO6__V10_H5TO6                                             0xFF

// TMDS STPG #26 Register
#define REG_ADDR__TX_REG_V10_H7TO8                                          (TX_EMSC_MHLTOP_TDM | 0x00D4)
  // (ReadWrite, Bits 7:0) 
  // V10_H7TO8
  #define BIT_MSK__TX_REG_V10_H7TO8__V10_H7TO8                                             0xFF

// TMDS STPG #27 Register
#define REG_ADDR__TX_REG_V10_H9TO10                                         (TX_EMSC_MHLTOP_TDM | 0x00D5)
  // (ReadWrite, Bits 7:0) 
  // V10_H9TO10
  #define BIT_MSK__TX_REG_V10_H9TO10__V10_H9TO10                                            0xFF

// TMDS STPG #28 Register
#define REG_ADDR__TX_REG_V10_H11TO12                                        (TX_EMSC_MHLTOP_TDM | 0x00D6)
  // (ReadWrite, Bits 7:0) 
  // V10_H11TO12
  #define BIT_MSK__TX_REG_V10_H11TO12__V10_H11TO12                                           0xFF

// TMDS STPG #29 Register
#define REG_ADDR__TX_REG_V10_H13TO14                                        (TX_EMSC_MHLTOP_TDM | 0x00D7)
  // (ReadWrite, Bits 7:0) 
  // V10_H13TO14
  #define BIT_MSK__TX_REG_V10_H13TO14__V10_H13TO14                                           0xFF

// TMDS 1 BIST CNTL Register
#define REG_ADDR__TX_BIST_CTRL                                              (TX_EMSC_MHLTOP_TDM | 0x00D8)
  // (ReadWrite, Bits 0) 
  // 0  bist is disabled       1 -  bist is enabled        Whenever bist is enabled normal operation of the chip ceases and the chip goes into bist mode. 
  #define BIT_MSK__TX_BIST_CTRL__REG_BIST_ENABLE                                       0x01
  // (ReadWrite, Bits 1) 
  // 0  the bist module is out of  reset state      1  the bist module is  forced to be in the reset state.         The Bist reset bit is provided as a backup. Normal operation of Bist does not require any toggling of this bit. This is used only for lab debug.
  #define BIT_MSK__TX_BIST_CTRL__REG_BIST_RESET                                        0x02
  // (ReadWrite, Bits 2) 
  // The enable bit for Samsung Test Pattern Generator. When set, it have higher priority than other BIST settings and reg_stpg_sel[3:0] will decide which pattern to generate. When clear, STPG is disabled. 1'b 0 -- clear (default) 1'b 1 -- set
  #define BIT_MSK__TX_BIST_CTRL__REG_STPG_EN                                           0x04
  // (ReadWrite, Bits 3) 
  // 1b 0  The bist module runs the pattern check  for programmed number of frames. 1b 1  The bist module runs continuously till the bist is disabled.
  #define BIT_MSK__TX_BIST_CTRL__REG_BIST_CONT_PROG_DURAT                              0x08
  // (ReadWrite, Bits 4) 
  // Bist start register is a write only  register. To start a Bist sequence 1 to this register. This will generate a pulse. The falling edge of the pulse triggers the bist. Read to this register will provide unknown value.All bist control logic gets reset at the start of a bist including the read only status registers.  Other configuration registers do not get reset.
  #define BIT_MSK__TX_BIST_CTRL__REG_BIST_START                                        0x10

// TMDS 1 BIST DURATION0 Register
#define REG_ADDR__TX_BIST_DURATION0                                         (TX_EMSC_MHLTOP_TDM | 0x00D9)
  // (ReadWrite, Bits 7:0) 
  // BIST Duration register is used to specify the duration of a test in frames. Counting of frames starts with the first vsync falling edge detected after the bist has been enabled. Also a programmed value of n results in n+1 frames. (If zero is programmed; the bist/tx is active for 1 frame)
  #define BIT_MSK__TX_BIST_DURATION0__REG_BIST_DURATION_B7_B0                               0xFF
  #define BIT_MSK__TX_BIST_DURATION0__CONTINOUS_EN                                          0x01

// TMDS 1 BIST DURATION1 Register
#define REG_ADDR__TX_BIST_DURATION1                                         (TX_EMSC_MHLTOP_TDM | 0x00DA)
  // (ReadWrite, Bits 7:0) 
  // Bist duration[15:8]; total is 23 bits.
  #define BIT_MSK__TX_BIST_DURATION1__REG_BIST_DURATION_B15_B8                              0xFF

// TMDS 1 BIST DURATION2 Register
#define REG_ADDR__TX_BIST_DURATION2                                         (TX_EMSC_MHLTOP_TDM | 0x00DB)
  // (ReadWrite, Bits 7:0) 
  // Bist duration[23:16]; total is 24 bits.
  #define BIT_MSK__TX_BIST_DURATION2__REG_BIST_DURATION_B23_B16                             0xFF

// TMDS 1 BIST TEST_SEL Register
#define REG_ADDR__TX_BIST_TEST_SEL                                          (TX_EMSC_MHLTOP_TDM | 0x00DC)
  // (ReadWrite, Bits 4:0) 
  // 5b 0000X  Walking one pattern 5b 0001X   Ramping pattern       5b 0010X  LFSR pattern1         5b 0011X  LFSR pattern 2          5b 0100X  Static pattern 1           5b 0101X  Static pattern 2             5b 0110X  Max switching pattern            5b 0111X  Two column max- switching pattern            5b 1000X  SDVO/TMDS half clock pattern       5b 1001X  SDVO/TMDS 8 bit  static  pattern         5b 1010X  TMDS 10 bit static  pattern.  5'b 1011X - Enable all 4 TMDS patterns at one time      The pattern corresponding to 4h 10  is applicable only to TMDS transmit and are not applicable for SDVO receive test.
  #define BIT_MSK__TX_BIST_TEST_SEL__REG_BIST_PATTERN_SELECT                               0x1F
  #define TEST_WALKING_ONE 0x01
  #define TEST_RAMPING 0x03
  #define TEST_LFSR1 0x05
  #define TEST_LFSR2 0x07
  #define TEST_STATIC1 0x09
  #define TEST_STATIC2 0x0B
  #define TEST_MAX_SWITCH 0x0D
  #define TEST_2COL_SWITCH 0x0F
  #define TEST_SVDO_TMDS_HALF_CLK 0x11
  #define TEST_SVDO_TMDS_8BIT_STATIC 0x13
  #define TEST_SVDO_TMDS_10BIT_STATIC 0x15
  #define TEST_ALL_4TMDS 0x16
  // (ReadWrite, Bits 6:5) 
  // 00-CTL lines[3:0] are static (00);  01-CTL lines[3:0] follow a ramp pattern where each count is valid for 2 clocks;  10-CTL line[3:0] follow a random pattern where each pattern is valid for 2 clocks;  11-reserved (do not use)
  #define BIT_MSK__TX_BIST_TEST_SEL__REG_BIST_TEST_SELECT                                  0x60

// TMDS 1 BIST VIDEO_MODE Register
#define REG_ADDR__TX_BIST_VIDEO_MODE                                        (TX_EMSC_MHLTOP_TDM | 0x00DD)
  // (ReadWrite, Bits 3) 
  // Setting this bit 1 forces the DE going to the TMDS core to be forced to be 1.
  #define BIT_MSK__TX_BIST_VIDEO_MODE__REG_BIST_VIDEO_MODE                                   0x08
  // (ReadWrite, Bits 7:4) 
  // Samsung Test Pattern select. This only takes effect when the enable bit (reg_stpg_en) is set. 4b 0000  Full screen red (default)   4b 0001  Full screen green    4b 0010  Full screen blue                   4b 0011  Full screen black    4b 0100  Full screen white   4b 0101  Ramp, from (0, 0, 0) to (255, 255, 255), each color repeats 5 pixels 4b 0110  Chess. The screen is divided into 8x6 blocks, with the size of 160x120. Black and white blocks alternate horizontally and vertically. 4b 0111  Color bar. 8 color strips with the width of 160 pixels. 4b 1000  Simp92. Simplified version of Master Pattern Generator #92 others      reserved
  #define BIT_MSK__TX_BIST_VIDEO_MODE__REG_STPG_SEL                                          0xF0

// TMDS 1 BIST 8BIT_PATTERN Register
#define REG_ADDR__TX_BIST_8BIT_PATTERN                                      (TX_EMSC_MHLTOP_TDM | 0x00DE)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__TX_BIST_8BIT_PATTERN__REG_BIST_8BIT_PATTERN                                 0xFF

// TMDS 1 BIST 10BIT_PATTERN_L Register
#define REG_ADDR__TX_BIST_10BIT_PATTERN_L                                   (TX_EMSC_MHLTOP_TDM | 0x00DF)
  // (ReadWrite, Bits 7:0) 
  // Lower 8 bits of the static 10-bit pattern to be provided to the TMDS transmitter
  #define BIT_MSK__TX_BIST_10BIT_PATTERN_L__REG_BIST_10BIT_PATTERN_B7_B0                          0xFF

// TMDS 1 BIST 10BIT_PATTERN_U Register
#define REG_ADDR__TX_BIST_10BIT_PATTERN_U                                   (TX_EMSC_MHLTOP_TDM | 0x00E0)
  // (ReadWrite, Bits 1:0) 
  // Upper 2 bits of the static 10-bit pattern to be provided to the TMDS transmitter
  #define BIT_MSK__TX_BIST_10BIT_PATTERN_U__REG_BIST_10BIT_PATTERN_B9_B8                          0x03

// TMDS 1 BIST status Register
#define REG_ADDR__TX_BIST_STATUS                                            (TX_EMSC_MHLTOP_TDM | 0x00E1)
  // (ReadOnly, Bits 1:0) 
  // [1:0]  Bist idle/busy/complete bits 00 b  Bist is idle 01 b  Bist is busy (test in           progress) 10 b  Bist is complete and result is ready in the BIST_RESULT  register
  #define BIT_MSK__TX_BIST_STATUS__BIST_CONFIG_STATUS                                    0x03

// TMDS 1 BIST RESULT Register
#define REG_ADDR__TX_BIST_RESULT                                            (TX_EMSC_MHLTOP_TDM | 0x00E2)
  // (ReadOnly, Bits 0) 
  // Bist pass/fail bit        0  bist test passed        1  bist test failed
  #define BIT_MSK__TX_BIST_RESULT__BIST_CONFIG_FAIL                                      0x01
  // (ReadOnly, Bits 1) 
  // SDVO receive. hsync error
  #define BIT_MSK__TX_BIST_RESULT__BIST_CONFIG_HSYNC_ERROR                               0x02
  // (ReadOnly, Bits 2) 
  // SDVO receive. vsync error
  #define BIT_MSK__TX_BIST_RESULT__BIST_CONFIG_VSYNC_ERROR                               0x04
  // (ReadOnly, Bits 3) 
  // SDVO receive. de error  
  #define BIT_MSK__TX_BIST_RESULT__BIST_CONFIG_DE_ERROR                                  0x08
  // (ReadOnly, Bits 4) 
  // SDVO receive. error count overflow . This bit gets set if  any of the error counters         overflows the max 16 bit count. If this bit is set it may  not be possible to pinpoint  which counter overflowed.All the error bits are valid only if the bit 0 indicates that bist test failed.
  #define BIT_MSK__TX_BIST_RESULT__BIST_CONFIG_OVERFLOW                                  0x10
  // (ReadOnly, Bits 5) 
  // SDVO receive ctl error.
  #define BIT_MSK__TX_BIST_RESULT__BIST_CONFIG_CTL_ERROR                                 0x20

// TMDS 1 BIST P_ERROR_COUNT_0 Register
#define REG_ADDR__TX_BIST_P_ERR_CNT_0                                       (TX_EMSC_MHLTOP_TDM | 0x00E3)
  // (ReadOnly, Bits 7:0) 
  // Lower 8 bits of the pixel error count. This register is a read only register. Its contents are valid only if the bist test failed.A received pixel is in error if any of the 3 channels (Red. Green. Blue) have a value mismatch between generated value and received value.
  #define BIT_MSK__TX_BIST_P_ERR_CNT_0__BIST_P_ERROR_COUNT_0                                  0xFF

// TMDS 1 BIST P_ERROR_COUNT_1 Register
#define REG_ADDR__TX_BIST_P_ERR_CNT_1                                       (TX_EMSC_MHLTOP_TDM | 0x00E4)
  // (ReadOnly, Bits 7:0) 
  // Upper 8 bits of the pixel error count. This register is a read only register. Its contents are valid only if the bist test failed.A received pixel is in error if any of the 3 channels (Red. Green. Blue) have a value mismatch between generated value and received value.If the any of the error count registers exceeds the max 16 bit count then the overflow bit is set in BIST_status register.
  #define BIT_MSK__TX_BIST_P_ERR_CNT_1__BIST_P_ERROR_COUNT_1                                  0xFF

// TMDS 1 BIST R_ERROR_COUNT_0 Register
#define REG_ADDR__TX_BIST_R_ERR_CNT_0                                       (TX_EMSC_MHLTOP_TDM | 0x00E5)
  // (ReadOnly, Bits 7:0) 
  // Lower 8 bits of the red channel error count. This register is a read only register. Its contents are valid only if the bist test failed.A channel is in error if   there is a mismatch between   generated 8 bit value and received 8 bit value
  #define BIT_MSK__TX_BIST_R_ERR_CNT_0__BIST_R_ERROR_COUNT_0                                  0xFF

// TMDS 1 BIST R_ERROR_COUNT_1 Register
#define REG_ADDR__TX_BIST_R_ERR_CNT_1                                       (TX_EMSC_MHLTOP_TDM | 0x00E6)
  // (ReadOnly, Bits 7:0) 
  // Upper 8 bits of the red channel error count. This register is a read only register. Its contents are valid only if the bist test failed. A channel is in error if there is a mismatch between generated 8-bit values and received 8-bit value.If the any of the error count registers exceeds the max 16 bit count then the overflow bit is set in BIST_status register.
  #define BIT_MSK__TX_BIST_R_ERR_CNT_1__BIST_R_ERROR_COUNT_1                                  0xFF

// TMDS 1 BIST G_ERROR_COUNT_0 Register
#define REG_ADDR__TX_BIST_G_ERR_CNT_0                                       (TX_EMSC_MHLTOP_TDM | 0x00E7)
  // (ReadOnly, Bits 7:0) 
  // Lower 8 bits of the green channel error count. This register is a read only register. Its contents are valid only if the bist test failed.A channel is in error if   there is a mismatch between   generated 8-bit values and received 8-bit value.
  #define BIT_MSK__TX_BIST_G_ERR_CNT_0__BIST_G_ERROR_COUNT_0                                  0xFF

// TMDS 1 BIST G_ERROR_COUNT_1 Register
#define REG_ADDR__TX_BIST_G_ERR_CNT_1                                       (TX_EMSC_MHLTOP_TDM | 0x00E8)
  // (ReadOnly, Bits 7:0) 
  // Upper 8 bits of the green channel error count. This register is a read only register. Its contents are valid only if the bist test failed.A channel is in error if there is a mismatch between generated 8-bit values and received 8-bit value.If the any of the error count registers exceeds the max 16 bit count then the overflow bit is set in BIST_status register.
  #define BIT_MSK__TX_BIST_G_ERR_CNT_1__BIST_G_ERROR_COUNT_1                                  0xFF

// TMDS 1 BIST B_ERROR_COUNT_0 Register
#define REG_ADDR__TX_BIST_B_ERR_CNT_0                                       (TX_EMSC_MHLTOP_TDM | 0x00E9)
  // (ReadOnly, Bits 7:0) 
  // Lower 8 bits of the blue channel error count. This register is a read only register. Its contents are valid only if the bist test failed.A channel is in error if   there is a mismatch between   generated 8 bit value and receive
  #define BIT_MSK__TX_BIST_B_ERR_CNT_0__BIST_B_ERROR_COUNT_0                                  0xFF

// TMDS 1 BIST B_ERROR_COUNT_1 Register
#define REG_ADDR__TX_BIST_B_ERR_CNT_1                                       (TX_EMSC_MHLTOP_TDM | 0x00EA)
  // (ReadOnly, Bits 7:0) 
  // Upper 8 bits of the blue channel error count. This register is a read only register. Its contents are valid only if the bist test failed.A channel is in error if there is a mismatch between generated 8-bit values and received 8-bit value.If the any of the error count registers exceeds the max 16 bit count then the overflow bit is set in BIST_status register.
  #define BIT_MSK__TX_BIST_B_ERR_CNT_1__BIST_B_ERROR_COUNT_1                                  0xFF

// TMDS 1 BIST CNTL_ERROR_COUNT Register
#define REG_ADDR__TX_BIST_CNTL_ERR_CNT                                      (TX_EMSC_MHLTOP_TDM | 0x00EB)
  // (ReadOnly, Bits 7:0) 
  // 8 bit counter for counting the number of control erros.  This register is a read only register. Its contents are valid only if the bist test failed.A channel is in error if there is a mismatch between generated control[3:0] values and received control[3:0] values.
  #define BIT_MSK__TX_BIST_CNTL_ERR_CNT__BIST_CNTL_ERROR_COUNT                                 0xFF

// BIST STPG Size1 Register
#define REG_ADDR__TX_STPG_SIZE1                                             (TX_EMSC_MHLTOP_TDM | 0x00EC)
  // (ReadWrite, Bits 7:0) 
  // This register byte defines the height of V1, V6 and V10 for Simp92. Default is 8'h3C. STPG_SIZE1x3 + STPG_SIZE2x5 + STPG_SIZE3x2 must be equal to 720.
  #define BIT_MSK__TX_STPG_SIZE1__REG_V1610_HEIGHT                                      0xFF

// BIST STPG Size2 Register
#define REG_ADDR__TX_STPG_SIZE2                                             (TX_EMSC_MHLTOP_TDM | 0x00ED)
  // (ReadWrite, Bits 7:0) 
  // This register byte defines the height of V2, V3, V4, V8 and V9 for Simp92. Default is 8'h1E. STPG_SIZE1x3 + STPG_SIZE2x5 + STPG_SIZE3x2 must be equal to 720.
  #define BIT_MSK__TX_STPG_SIZE2__REG_V23489_HEIGHT                                     0xFF

// BIST STPG Size3 Register
#define REG_ADDR__TX_STPG_SIZE3                                             (TX_EMSC_MHLTOP_TDM | 0x00EE)
  // (ReadWrite, Bits 7:0) 
  // This register byte defines the height of V5 and V7 for Simp92. Default is 8'hC3. STPG_SIZE1x3 + STPG_SIZE2x5 + STPG_SIZE3x2 must be equal to 720.
  #define BIT_MSK__TX_STPG_SIZE3__REG_V57_HEIGHT                                        0xFF

// Fake Vid Ctrl Register
#define REG_ADDR__TX_BIST_CTRL2                                             (TX_EMSC_MHLTOP_TDM | 0x00F5)
  // (ReadWrite, Bits 0) 
  // if 1 invert hsync
  #define BIT_MSK__TX_BIST_CTRL2__REG_INV_HSYNC_EN                                      0x01
  // (ReadWrite, Bits 1) 
  // if 1 invert vsync
  #define BIT_MSK__TX_BIST_CTRL2__REG_INV_VSYNC_EN                                      0x02
  // (ReadWrite, Bits 2) 
  // if 0 enable STPG out, else Tx BIST
  #define BIT_MSK__TX_BIST_CTRL2__REG_OUT_SEL                                           0x04

// Fake Vid Ctrl Register
#define REG_ADDR__TX_BIST_TIMING_CTRL                                       (TX_EMSC_MHLTOP_TDM | 0x00F6)
  // (ReadWrite, Bits 1:0) 
  // select # of bits: 00 - 8bpp 01 - 10bpp 10 - 12bpp
  #define BIT_MSK__TX_BIST_TIMING_CTRL__REG_DEPTH                                             0x03
  #define CLR_DEPTH_8 0x00
  #define CLR_DEPTH_10 0x01
  #define CLR_DEPTH_12 0x02
  // (ReadWrite, Bits 3:2) 
  // select refresh rate:     for 4k2k:         00 - 30         01 - 25         10 - 24         11 - 24SMPTE    for 1080p:          00 - 50           01 - 60
  #define BIT_MSK__TX_BIST_TIMING_CTRL__REG_REFRESH                                           0x0C
  #define REFRESH_RATE__1080P_50 0x00
  #define REFRESH_RATE__1080P_60 0x04
  #define REFRESH_RATE__4k2K_30 0x00
  #define REFRESH_RATE__4k2K_25 0x04
  #define REFRESH_RATE__4k2K_24 0x80
  #define REFRESH_RATE__4k2K_SMPTE 0xC0
  // (ReadWrite, Bits 7:4) 
  // This register controls BIST timing including video timing.           8'b0000:                    //720p60 case           8'b0001:                     //576p case           8'b0010:                     //480p case           8'b0011:                     //1080p@50 8bpp case           8'b0100:                     //4k2k@30           8'b0101:                     //fully programmable           8'b1000:                     //vga            8'b1001:                     //svga           8'b1010:                     //xga           8'b1011:                      //sxga           8'b1100:                     //uxga           8'b1101:                      //4k2k@30 case
  #define BIT_MSK__TX_BIST_TIMING_CTRL__REG_TIME_MODE                                         0xF0
  #define TIME_MODE__720P60 0x00
  #define TIME_MODE__576P50 0x10
  #define TIME_MODE__480P60 0x20
  #define TIME_MODE__1080P50 0x30
  #define TIME_MODE__4K2KP30 0x40
  #define TIME_MODE__FP 0x50
  #define TIME_MODE__VGA 0x80
  #define TIME_MODE__SVGA 0x90
  #define TIME_MODE__XGA 0xA0
  #define TIME_MODE__SXGA 0xB0
  #define TIME_MODE__UXGA 0xC0

//***************************************************************************
// TX_MHLSPEC. Address: 60
// MHL Capability 1st Byte Register
#define REG_ADDR__MHL_DEVCAP_0                                           (TX_MHLSPEC | 0x0000)
  // (ReadWrite, Bits 7:0) 
  // MHL capability registers 1st byte. Identify current connected and powered state. Default value Tx: 0x00: Rx: 0x00: Dongle: 0x00
  #define BIT_MSK__MHL_DEVCAP_0__REG_MHL_DEVCAP_0                                      0xFF

// MHL Capability 2nd Byte Register
#define REG_ADDR__MHL_DEVCAP_1                                           (TX_MHLSPEC | 0x0001)
  // (ReadWrite, Bits 7:0) 
  // MHL capability registers 2nd byte. Identify level of MHL Spec supported. Default value Tx: 0x10: Rx:0x10: Dongle: 0x20
  #define BIT_MSK__MHL_DEVCAP_1__REG_MHL_DEVCAP_1                                      0xFF

// MHL Capability 3rd Byte Register
#define REG_ADDR__MHL_DEVCAP_2                                           (TX_MHLSPEC | 0x0002)
  // (ReadWrite, Bits 7:0) 
  // MHL capability registers 3rd byte. Identify the type of MHL system. Default value Tx: 0x02: Rx: 0x11: Dongle: 0x13
  #define BIT_MSK__MHL_DEVCAP_2__REG_MHL_DEVCAP_2                                      0xFF

// MHL Capability 4th Byte Register
#define REG_ADDR__MHL_DEVCAP_3                                           (TX_MHLSPEC | 0x0003)
  // (ReadWrite, Bits 7:0) 
  // MHL capability registers 4th byte. High-order byte of Adopter identifier: assigned by MHL LLC. Default value: Tx: 0x00: Rx:0x00: Dongle: 0x01
  #define BIT_MSK__MHL_DEVCAP_3__REG_MHL_DEVCAP_3                                      0xFF

// MHL Capability 5th Byte Register
#define REG_ADDR__MHL_DEVCAP_4                                           (TX_MHLSPEC | 0x0004)
  // (ReadWrite, Bits 7:0) 
  // MHL capability registers 5th byte. Low-order byte of Adopter identifier: assigned by MHL LLC. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x42
  #define BIT_MSK__MHL_DEVCAP_4__REG_MHL_DEVCAP_4                                      0xFF

// MHL Capability 6th Byte Register
#define REG_ADDR__MHL_DEVCAP_5                                           (TX_MHLSPEC | 0x0005)
  // (ReadWrite, Bits 7:0) 
  // MHL capability registers 6th byte. List of link modes supported for video. Default value: Tx: 0x37: Rx: 0x37: Dongle: 0x3F
  #define BIT_MSK__MHL_DEVCAP_5__REG_MHL_DEVCAP_5                                      0xFF

// MHL Capability 7th Byte Register
#define REG_ADDR__MHL_DEVCAP_6                                           (TX_MHLSPEC | 0x0006)
  // (ReadWrite, Bits 7:0) 
  // MHL capability registers 7th byte. List of link modes supported for audio. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x03
  #define BIT_MSK__MHL_DEVCAP_6__REG_MHL_DEVCAP_6                                      0xFF

// MHL Capability 8th Byte Register
#define REG_ADDR__MHL_DEVCAP_7                                           (TX_MHLSPEC | 0x0007)
  // (ReadWrite, Bits 7:0) 
  // MHL capability registers 8th byte. List of video types supported. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x8F
  #define BIT_MSK__MHL_DEVCAP_7__REG_MHL_DEVCAP_7                                      0xFF

// MHL Capability 9th Byte Register
#define REG_ADDR__MHL_DEVCAP_8                                           (TX_MHLSPEC | 0x0008)
  // (ReadWrite, Bits 7:0) 
  // MHL capability registers 9th byte. Map of logical device types. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x41
  #define BIT_MSK__MHL_DEVCAP_8__REG_MHL_DEVCAP_8                                      0xFF

// MHL Capability 10th Byte Register
#define REG_ADDR__MHL_DEVCAP_9                                           (TX_MHLSPEC | 0x0009)
  // (ReadWrite, Bits 7:0) 
  // MHL capability registers 10th byte. Upper bound of MHL link bandwidth. Default value: Tx: 0x0F: Rx: 0x0F: Dongle: 0x0F
  #define BIT_MSK__MHL_DEVCAP_9__REG_MHL_DEVCAP_9                                      0xFF

// MHL Capability 11th Byte Register
#define REG_ADDR__MHL_DEVCAP_A                                           (TX_MHLSPEC | 0x000A)
  // (ReadWrite, Bits 7:0) 
  // MHL capability registers 11th byte. Set flag for each MHL optional feature. Default value: Tx: 0x07: Rx: 0x07: Dongle: 0x07 
  #define BIT_MSK__MHL_DEVCAP_A__REG_MHL_DEVCAP_A                                      0xFF

// MHL Capability 12th Byte Register
#define REG_ADDR__MHL_DEVCAP_B                                           (TX_MHLSPEC | 0x000B)
  // (ReadWrite, Bits 7:0) 
  // MHL capability registers 12th byte. High-order byte of system identifier: assigned by Adopter. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x92
  #define BIT_MSK__MHL_DEVCAP_B__REG_MHL_DEVCAP_B                                      0xFF

// MHL Capability 13th Byte Register
#define REG_ADDR__MHL_DEVCAP_C                                           (TX_MHLSPEC | 0x000C)
  // (ReadWrite, Bits 7:0) 
  // MHL capability registers 13th byte. Low-order byte of system identifier: assigned by Adopter. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x96
  #define BIT_MSK__MHL_DEVCAP_C__REG_MHL_DEVCAP_C                                      0xFF

// MHL Capability 14th Byte Register
#define REG_ADDR__MHL_DEVCAP_D                                           (TX_MHLSPEC | 0x000D)
  // (ReadWrite, Bits 7:0) 
  // MHL capability registers 14th byte. Total count of Scratchpad registers. Default value: Tx: 0x10: Rx: 0x10: Dongle: 0x10
  #define BIT_MSK__MHL_DEVCAP_D__REG_MHL_DEVCAP_D                                      0xFF

// MHL Capability 15th Byte Register
#define REG_ADDR__MHL_DEVCAP_E                                           (TX_MHLSPEC | 0x000E)
  // (ReadWrite, Bits 7:0) 
  // MHL capability registers 15th byte. Total count of interrupt and status registers. Default value: Tx: 0x33: Rx: 0x33: Dongle: 0x33
  #define BIT_MSK__MHL_DEVCAP_E__REG_MHL_DEVCAP_E                                      0xFF

// MHL Capability 16th Byte Register
#define REG_ADDR__MHL_DEVCAP_F                                           (TX_MHLSPEC | 0x000F)
  // (ReadWrite, Bits 7:0) 
  // MHL capability registers 16th byte: RSVD. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x00
  #define BIT_MSK__MHL_DEVCAP_F__REG_MHL_DEVCAP_F                                      0xFF

// MHL Interrupt 1st Byte Register
#define REG_ADDR__MHL_INT_0                                              (TX_MHLSPEC | 0x0020)
  // (ReadWrite, Bits 0) 
  // MHL interrupt registers 1st byte; status 0. DCAP_CHG: Device Capability Register value changed
  #define BIT_MSK__MHL_INT_0__REG_MHL_INT_0_STAT0                                   0x01
  // (ReadWrite, Bits 1) 
  // MHL interrupt registers 1st byte; status 1. DSCR_CHG: Device Scratchpad Register value changed
  #define BIT_MSK__MHL_INT_0__REG_MHL_INT_0_STAT1                                   0x02
  // (ReadWrite, Bits 2) 
  // MHL interrupt registers 1st byte; status 2. REQ_WRT: Request-to-Write scratchpad
  #define BIT_MSK__MHL_INT_0__REG_MHL_INT_0_STAT2                                   0x04
  // (ReadWrite, Bits 3) 
  // MHL interrupt registers 1st byte; status 3. GRT-WRT: Grant-to-Write scratchpad
  #define BIT_MSK__MHL_INT_0__REG_MHL_INT_0_STAT3                                   0x08
  // (ReadWrite, Bits 4) 
  // MHL interrupt registers 1st byte; status 4. Request for 3D Information
  #define BIT_MSK__MHL_INT_0__REG_MHL_INT_0_STAT4                                   0x10
  // (ReadWrite, Bits 5) 
  // MHL interrupt registers 1st byte; status 5. Request Feature information
  #define BIT_MSK__MHL_INT_0__REG_MHL_INT_0_STAT5                                   0x20
  // (ReadWrite, Bits 6) 
  // MHL interrupt registers 1st byte; status 6. Indicate completion of sending Feature information.
  #define BIT_MSK__MHL_INT_0__REG_MHL_INT_0_STAT6                                   0x40
  // (ReadWrite, Bits 7) 
  // MHL interrupt registers 1st byte; status 7. RSVD
  #define BIT_MSK__MHL_INT_0__REG_MHL_INT_0_STAT7                                   0x80

// MHL Interrupt 2nd Byte Register
#define REG_ADDR__MHL_INT_1                                              (TX_MHLSPEC | 0x0021)
  // (ReadWrite, Bits 0) 
  // MHL interrupt registers 2nd byte; status 0. RSVD
  #define BIT_MSK__MHL_INT_1__REG_MHL_INT_1_STAT0                                   0x01
  // (ReadWrite, Bits 1) 
  // MHL interrupt registers 2nd byte; status 1. EDID_CHG: EDID content change on virtual DDC
  #define BIT_MSK__MHL_INT_1__REG_MHL_INT_1_STAT1                                   0x02
  // (ReadWrite, Bits 2) 
  // MHL interrupt registers 2nd byte; status 2. RSVD
  #define BIT_MSK__MHL_INT_1__REG_MHL_INT_1_STAT2                                   0x04
  // (ReadWrite, Bits 3) 
  // MHL interrupt registers 2nd byte; status 3: RSVD
  #define BIT_MSK__MHL_INT_1__REG_MHL_INT_1_STAT3                                   0x08
  // (ReadWrite, Bits 4) 
  // MHL interrupt registers 2nd byte; status 4: RSVD
  #define BIT_MSK__MHL_INT_1__REG_MHL_INT_1_STAT4                                   0x10
  // (ReadWrite, Bits 5) 
  // MHL interrupt registers 2nd byte; status 5. RSVD
  #define BIT_MSK__MHL_INT_1__REG_MHL_INT_1_STAT5                                   0x20
  // (ReadWrite, Bits 6) 
  // MHL interrupt registers 2nd byte; status 6. RSVD
  #define BIT_MSK__MHL_INT_1__REG_MHL_INT_1_STAT6                                   0x40
  // (ReadWrite, Bits 7) 
  // MHL interrupt registers 2nd byte; status 7. RSVD
  #define BIT_MSK__MHL_INT_1__REG_MHL_INT_1_STAT7                                   0x80

// MHL Interrupt 3rd Byte Register
#define REG_ADDR__MHL_INT_2                                              (TX_MHLSPEC | 0x0022)
  // (ReadWrite, Bits 0) 
  // MHL interrupt registers 3rd byte; status 0. RSVD
  #define BIT_MSK__MHL_INT_2__REG_MHL_INT_2_STAT0                                   0x01
  // (ReadWrite, Bits 1) 
  // MHL interrupt registers 3rd byte; status 1. RSVD
  #define BIT_MSK__MHL_INT_2__REG_MHL_INT_2_STAT1                                   0x02
  // (ReadWrite, Bits 2) 
  // MHL interrupt registers 3rd byte; status 2. RSVD
  #define BIT_MSK__MHL_INT_2__REG_MHL_INT_2_STAT2                                   0x04
  // (ReadWrite, Bits 3) 
  // MHL interrupt registers 3rd byte; status 3. RSVD
  #define BIT_MSK__MHL_INT_2__REG_MHL_INT_2_STAT3                                   0x08
  // (ReadWrite, Bits 4) 
  // MHL interrupt registers 3rd byte; status 4. RSVD
  #define BIT_MSK__MHL_INT_2__REG_MHL_INT_2_STAT4                                   0x10
  // (ReadWrite, Bits 5) 
  // MHL interrupt registers 3rd byte; status 5. RSVD
  #define BIT_MSK__MHL_INT_2__REG_MHL_INT_2_STAT5                                   0x20
  // (ReadWrite, Bits 6) 
  // MHL interrupt registers 3rd byte; status 6. RSVD
  #define BIT_MSK__MHL_INT_2__REG_MHL_INT_2_STAT6                                   0x40
  // (ReadWrite, Bits 7) 
  // MHL interrupt registers 3rd byte; status 7. RSVD
  #define BIT_MSK__MHL_INT_2__REG_MHL_INT_2_STAT7                                   0x80

// MHL Interrupt 4th Byte Register
#define REG_ADDR__MHL_INT_3                                              (TX_MHLSPEC | 0x0023)
  // (ReadWrite, Bits 0) 
  // MHL interrupt registers 4th byte; status 0. RSVD
  #define BIT_MSK__MHL_INT_3__REG_MHL_INT_3_STAT0                                   0x01
  // (ReadWrite, Bits 1) 
  // MHL interrupt registers 4th byte; status 1. RSVD
  #define BIT_MSK__MHL_INT_3__REG_MHL_INT_3_STAT1                                   0x02
  // (ReadWrite, Bits 2) 
  // MHL interrupt registers 4th byte; status 2. RSVD
  #define BIT_MSK__MHL_INT_3__REG_MHL_INT_3_STAT2                                   0x04
  // (ReadWrite, Bits 3) 
  // MHL interrupt registers 4th byte; status 3. RSVD
  #define BIT_MSK__MHL_INT_3__REG_MHL_INT_3_STAT3                                   0x08
  // (ReadWrite, Bits 4) 
  // MHL interrupt registers 4th byte; status 4. RSVD
  #define BIT_MSK__MHL_INT_3__REG_MHL_INT_3_STAT4                                   0x10
  // (ReadWrite, Bits 5) 
  // MHL interrupt registers 4th byte; status 5. RSVD
  #define BIT_MSK__MHL_INT_3__REG_MHL_INT_3_STAT5                                   0x20
  // (ReadWrite, Bits 6) 
  // MHL interrupt registers 4th byte; status 6. RSVD
  #define BIT_MSK__MHL_INT_3__REG_MHL_INT_3_STAT6                                   0x40
  // (ReadWrite, Bits 7) 
  // MHL interrupt registers 4th byte; status 7. RSVD
  #define BIT_MSK__MHL_INT_3__REG_MHL_INT_3_STAT7                                   0x80

// Device Status 1st byte Register
#define REG_ADDR__MHL_STAT_0                                             (TX_MHLSPEC | 0x0030)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 1st byte 0: DCAP_RDY. Capability Register values are stable. 1: XDEVCAP_SUPP. Indicates that Extended Device Capability registers are supported. 2: POW_SAT: When set device can output power across VBUS to the device connected through the cable. When clear device cannot output power across VBUS to the device connected through the cable. 5-3 PLIM_STAT: The device maintains a copy of the value of the field PLIM[2:0] 7-6: Reserved
  #define BIT_MSK__MHL_STAT_0__REG_MHL_STAT_0                                        0xFF

// Device Status 2nd byte Register
#define REG_ADDR__MHL_STAT_1                                             (TX_MHLSPEC | 0x0031)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 2nd byte 0-2: CLK_MODE. The clock mode on the link 3: PATH_EN. Device's TMDS path is not in use 4: MUTED. Device's content stream is muted. 5-7: RSVD
  #define BIT_MSK__MHL_STAT_1__REG_MHL_STAT_1                                        0xFF

// Device Status 3rd byte Register
#define REG_ADDR__MHL_STAT_2                                             (TX_MHLSPEC | 0x0032)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 3rd byte. 3-0: MHL_VER_MINOR 7-4: MHL_VER_MAJOR
  #define BIT_MSK__MHL_STAT_2__REG_MHL_STAT_2                                        0xFF

// Device Status 4th byte Register
#define REG_ADDR__MHL_STAT_3                                             (TX_MHLSPEC | 0x0033)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 4th byte. RSVD
  #define BIT_MSK__MHL_STAT_3__REG_MHL_STAT_3                                        0xFF

// CBUS Scratch Pad 1st Byte Register
#define REG_ADDR__MHL_SCRPAD_0                                           (TX_MHLSPEC | 0x0040)
  // (ReadOnly, Bits 7:0) 
  // CBUS scratch pad 1st byte
  #define BIT_MSK__MHL_SCRPAD_0__REG_MHL_SCRPAD_0                                      0xFF

// CBUS Scratch Pad 2nd Byte Register
#define REG_ADDR__MHL_SCRPAD_1                                           (TX_MHLSPEC | 0x0041)
  // (ReadOnly, Bits 7:0) 
  // CBUS scratch pad 2nd byte
  #define BIT_MSK__MHL_SCRPAD_1__REG_MHL_SCRPAD_1                                      0xFF

// CBUS Scratch Pad 3rd Byte Register
#define REG_ADDR__MHL_SCRPAD_2                                           (TX_MHLSPEC | 0x0042)
  // (ReadOnly, Bits 7:0) 
  // CBUS scratch pad 3rd byte
  #define BIT_MSK__MHL_SCRPAD_2__REG_MHL_SCRPAD_2                                      0xFF

// CBUS Scratch Pad 4th Byte Register
#define REG_ADDR__MHL_SCRPAD_3                                           (TX_MHLSPEC | 0x0043)
  // (ReadOnly, Bits 7:0) 
  // CBUS scratch pad 4th byte
  #define BIT_MSK__MHL_SCRPAD_3__REG_MHL_SCRPAD_3                                      0xFF

// CBUS Scratch Pad 5th Byte Register
#define REG_ADDR__MHL_SCRPAD_4                                           (TX_MHLSPEC | 0x0044)
  // (ReadOnly, Bits 7:0) 
  // CBUS scratch pad 5th byte
  #define BIT_MSK__MHL_SCRPAD_4__REG_MHL_SCRPAD_4                                      0xFF

// CBUS Scratch Pad 6th Byte Register
#define REG_ADDR__MHL_SCRPAD_5                                           (TX_MHLSPEC | 0x0045)
  // (ReadOnly, Bits 7:0) 
  // CBUS scratch pad 6th byte
  #define BIT_MSK__MHL_SCRPAD_5__REG_MHL_SCRPAD_5                                      0xFF

// CBUS Scratch Pad 7th Byte Register
#define REG_ADDR__MHL_SCRPAD_6                                           (TX_MHLSPEC | 0x0046)
  // (ReadOnly, Bits 7:0) 
  // CBUS scratch pad 7th byte
  #define BIT_MSK__MHL_SCRPAD_6__REG_MHL_SCRPAD_6                                      0xFF

// CBUS Scratch Pad 8th Byte Register
#define REG_ADDR__MHL_SCRPAD_7                                           (TX_MHLSPEC | 0x0047)
  // (ReadOnly, Bits 7:0) 
  // CBUS scratch pad 8th byte
  #define BIT_MSK__MHL_SCRPAD_7__REG_MHL_SCRPAD_7                                      0xFF

// CBUS Scratch Pad 9th Byte Register
#define REG_ADDR__MHL_SCRPAD_8                                           (TX_MHLSPEC | 0x0048)
  // (ReadOnly, Bits 7:0) 
  // CBUS scratch pad 9th byte
  #define BIT_MSK__MHL_SCRPAD_8__REG_MHL_SCRPAD_8                                      0xFF

// CBUS Scratch Pad 10th Byte Register
#define REG_ADDR__MHL_SCRPAD_9                                           (TX_MHLSPEC | 0x0049)
  // (ReadOnly, Bits 7:0) 
  // CBUS scratch pad 10th byte
  #define BIT_MSK__MHL_SCRPAD_9__REG_MHL_SCRPAD_9                                      0xFF

// CBUS Scratch Pad 11th Byte Register
#define REG_ADDR__MHL_SCRPAD_A                                           (TX_MHLSPEC | 0x004A)
  // (ReadOnly, Bits 7:0) 
  // CBUS scratch pad 11th byte
  #define BIT_MSK__MHL_SCRPAD_A__REG_MHL_SCRPAD_A                                      0xFF

// CBUS Scratch Pad 12th Byte Register
#define REG_ADDR__MHL_SCRPAD_B                                           (TX_MHLSPEC | 0x004B)
  // (ReadOnly, Bits 7:0) 
  // CBUS scratch pad 12th byte
  #define BIT_MSK__MHL_SCRPAD_B__REG_MHL_SCRPAD_B                                      0xFF

// CBUS Scratch Pad 13th Byte Register
#define REG_ADDR__MHL_SCRPAD_C                                           (TX_MHLSPEC | 0x004C)
  // (ReadOnly, Bits 7:0) 
  // CBUS scratch pad 13th byte
  #define BIT_MSK__MHL_SCRPAD_C__REG_MHL_SCRPAD_C                                      0xFF

// CBUS Scratch Pad 14th Byte Register
#define REG_ADDR__MHL_SCRPAD_D                                           (TX_MHLSPEC | 0x004D)
  // (ReadOnly, Bits 7:0) 
  // CBUS scratch pad 14th byte
  #define BIT_MSK__MHL_SCRPAD_D__REG_MHL_SCRPAD_D                                      0xFF

// CBUS Scratch Pad 15th Byte Register
#define REG_ADDR__MHL_SCRPAD_E                                           (TX_MHLSPEC | 0x004E)
  // (ReadOnly, Bits 7:0) 
  // CBUS scratch pad 15th byte
  #define BIT_MSK__MHL_SCRPAD_E__REG_MHL_SCRPAD_E                                      0xFF

// CBUS Scratch Pad 16th Byte Register
#define REG_ADDR__MHL_SCRPAD_F                                           (TX_MHLSPEC | 0x004F)
  // (ReadOnly, Bits 7:0) 
  // CBUS scratch pad 16th byte
  #define BIT_MSK__MHL_SCRPAD_F__REG_MHL_SCRPAD_F                                      0xFF

// MHL Extended Capability 1st Byte Register
#define REG_ADDR__MHL_EXTDEVCAP_0                                        (TX_MHLSPEC | 0x0080)
  // (ReadWrite, Bits 7:0) 
  // eCBUS Frequencies 0: ECBUS_S_075 1: ECBUS_S_8BIT 2: ECBUS_S_12BIT 3: reserved 4: ECBUS_D_150 5: ECBUS_D_8BIT 7-6: reserved
  #define BIT_MSK__MHL_EXTDEVCAP_0__REG_MHL_EXTDEVCAP_0                                   0xFF

// MHL Extended Capability 2nd Byte Register
#define REG_ADDR__MHL_EXTDEVCAP_1                                        (TX_MHLSPEC | 0x0081)
  // (ReadWrite, Bits 7:0) 
  // TMDS Frequencies 0: TMDS_150 1: TMDS_300 2: TMDS_600 7-3: reserved
  #define BIT_MSK__MHL_EXTDEVCAP_1__REG_MHL_EXTDEVCAP_1                                   0xFF

// MHL Extended Capability 3rd Byte Register
#define REG_ADDR__MHL_EXTDEVCAP_2                                        (TX_MHLSPEC | 0x0082)
  // (ReadWrite, Bits 7:0) 
  // 0: DEV_HOST 1: DEV_DEVICE 2: DEV_CHARGER 3: HID_HOST 4: HID_DEVICE 7:5 reserved
  #define BIT_MSK__MHL_EXTDEVCAP_2__REG_MHL_EXTDEVCAP_2                                   0xFF

// MHL Extended Capability 4th Byte Register
#define REG_ADDR__MHL_EXTDEVCAP_3                                        (TX_MHLSPEC | 0x0083)
  // (ReadWrite, Bits 7:0) 
  // 0: LD_PHONE 7:1 reserved
  #define BIT_MSK__MHL_EXTDEVCAP_3__REG_MHL_EXTDEVCAP_3                                   0xFF

// MHL Extended Capability 5th Byte Register
#define REG_ADDR__MHL_EXTDEVCAP_4                                        (TX_MHLSPEC | 0x0084)
  // (ReadWrite, Bits 7:0) 
  // Extended Logical Device Map 0: LD_PHONE 7-1: reserved
  #define BIT_MSK__MHL_EXTDEVCAP_4__REG_MHL_EXTDEVCAP_4                                   0xFF

// MHL Extended Capability 6th Byte Register
#define REG_ADDR__MHL_EXTDEVCAP_5                                        (TX_MHLSPEC | 0x0085)
  // (ReadWrite, Bits 7:0) 
  // MHL extended capability registers 6th byte: RSVD. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x00
  #define BIT_MSK__MHL_EXTDEVCAP_5__REG_MHL_EXTDEVCAP_5                                   0xFF

// MHL Extended Capability 7th Byte Register
#define REG_ADDR__MHL_EXTDEVCAP_6                                        (TX_MHLSPEC | 0x0086)
  // (ReadWrite, Bits 7:0) 
  // MHL extended capability registers 7th byte: RSVD. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x00
  #define BIT_MSK__MHL_EXTDEVCAP_6__REG_MHL_EXTDEVCAP_6                                   0xFF

// MHL Extended Capability 8th Byte Register
#define REG_ADDR__MHL_EXTDEVCAP_7                                        (TX_MHLSPEC | 0x0087)
  // (ReadWrite, Bits 7:0) 
  // MHL extended capability registers 8th byte: RSVD. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x00
  #define BIT_MSK__MHL_EXTDEVCAP_7__REG_MHL_EXTDEVCAP_7                                   0xFF

// MHL Extended Capability 9th Byte Register
#define REG_ADDR__MHL_EXTDEVCAP_8                                        (TX_MHLSPEC | 0x0088)
  // (ReadWrite, Bits 7:0) 
  // MHL extended capability registers 9th byte: RSVD. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x00
  #define BIT_MSK__MHL_EXTDEVCAP_8__REG_MHL_EXTDEVCAP_8                                   0xFF

// MHL Extended Capability 10th Byte Register
#define REG_ADDR__MHL_EXTDEVCAP_9                                        (TX_MHLSPEC | 0x0089)
  // (ReadWrite, Bits 7:0) 
  // MHL extended capability registers 10th byte: RSVD. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x00
  #define BIT_MSK__MHL_EXTDEVCAP_9__REG_MHL_EXTDEVCAP_9                                   0xFF

// MHL Extended Capability 11th Byte Register
#define REG_ADDR__MHL_EXTDEVCAP_A                                        (TX_MHLSPEC | 0x008A)
  // (ReadWrite, Bits 7:0) 
  // MHL extended capability registers 11th byte: RSVD. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x00
  #define BIT_MSK__MHL_EXTDEVCAP_A__REG_MHL_EXTDEVCAP_A                                   0xFF

// MHL Extended Capability 12th Byte Register
#define REG_ADDR__MHL_EXTDEVCAP_B                                        (TX_MHLSPEC | 0x008B)
  // (ReadWrite, Bits 7:0) 
  // MHL extended capability registers 12th byte: RSVD. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x00
  #define BIT_MSK__MHL_EXTDEVCAP_B__REG_MHL_EXTDEVCAP_B                                   0xFF

// MHL Extended Capability 13th Byte Register
#define REG_ADDR__MHL_EXTDEVCAP_C                                        (TX_MHLSPEC | 0x008C)
  // (ReadWrite, Bits 7:0) 
  // MHL extended capability registers 13th byte: RSVD. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x00
  #define BIT_MSK__MHL_EXTDEVCAP_C__REG_MHL_EXTDEVCAP_C                                   0xFF

// MHL Extended Capability 14th Byte Register
#define REG_ADDR__MHL_EXTDEVCAP_D                                        (TX_MHLSPEC | 0x008D)
  // (ReadWrite, Bits 7:0) 
  // MHL extended capability registers 14th byte: RSVD. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x00
  #define BIT_MSK__MHL_EXTDEVCAP_D__REG_MHL_EXTDEVCAP_D                                   0xFF

// MHL Extended Capability 15th Byte Register
#define REG_ADDR__MHL_EXTDEVCAP_E                                        (TX_MHLSPEC | 0x008E)
  // (ReadWrite, Bits 7:0) 
  // MHL extended capability registers 15th byte: RSVD. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x00
  #define BIT_MSK__MHL_EXTDEVCAP_E__REG_MHL_EXTDEVCAP_E                                   0xFF

// MHL Extended Capability 16th Byte Register
#define REG_ADDR__MHL_EXTDEVCAP_F                                        (TX_MHLSPEC | 0x008F)
  // (ReadWrite, Bits 7:0) 
  // MHL extended capability registers 16th byte: RSVD. Default value: Tx: 0x00: Rx: 0x00: Dongle: 0x00
  #define BIT_MSK__MHL_EXTDEVCAP_F__REG_MHL_EXTDEVCAP_F                                   0xFF

// Device Extended Status 1st byte Register
#define REG_ADDR__MHL_EXTSTAT_0                                          (TX_MHLSPEC | 0x0090)
  // (ReadOnly, Bits 7:0) 
  // Current eCBUS-S or eCBUS-D TDM slot mode. 1-0: SLOT_MODE 3-2: ECBUS_MODE 7-4: reserved
  #define BIT_MSK__MHL_EXTSTAT_0__REG_MHL_EXTSTAT_0                                     0xFF

// Device Extended Status 2nd byte Register
#define REG_ADDR__MHL_EXTSTAT_1                                          (TX_MHLSPEC | 0x0091)
  // (ReadOnly, Bits 7:0) 
  // Sink indicates TMDS link status to Source. 1-0: LINK_STATUS
  #define BIT_MSK__MHL_EXTSTAT_1__REG_MHL_EXTSTAT_1                                     0xFF

// Device Extended Status 3rd byte Register
#define REG_ADDR__MHL_EXTSTAT_2                                          (TX_MHLSPEC | 0x0092)
  // (ReadOnly, Bits 7:0) 
  // Source indicates TMDS bandwidth to Sink. 2-0: LINK_RATE 7-3: reserved
  #define BIT_MSK__MHL_EXTSTAT_2__REG_MHL_EXTSTAT_2                                     0xFF

// Device Extended Status 4th byte Register
#define REG_ADDR__MHL_EXTSTAT_3                                          (TX_MHLSPEC | 0x0093)
  // (ReadOnly, Bits 7:0) 
  // Sink readiness for multiple-sink connection. 1-0: SINK_STATUS_0 3-2: SINK_STATUS_1 5-4: SINK_STATUS_2 7-6: SINK_STATUS_3
  #define BIT_MSK__MHL_EXTSTAT_3__REG_MHL_EXTSTAT_3                                     0xFF

// Device Extended Status 5th byte Register
#define REG_ADDR__MHL_EXTSTAT_4                                          (TX_MHLSPEC | 0x0094)
  // (ReadOnly, Bits 7:0) 
  // rsvd
  #define BIT_MSK__MHL_EXTSTAT_4__REG_MHL_EXTSTAT_4                                     0xFF

// Device Extended Status 6th byte Register
#define REG_ADDR__MHL_EXTSTAT_5                                          (TX_MHLSPEC | 0x0095)
  // (ReadOnly, Bits 7:0) 
  // rsvd
  #define BIT_MSK__MHL_EXTSTAT_5__REG_MHL_EXTSTAT_5                                     0xFF

// Device Extended Status 7th byte Register
#define REG_ADDR__MHL_EXTSTAT_6                                          (TX_MHLSPEC | 0x0096)
  // (ReadOnly, Bits 7:0) 
  // rsvd
  #define BIT_MSK__MHL_EXTSTAT_6__REG_MHL_EXTSTAT_6                                     0xFF

// Device Extended Status 8th byte Register
#define REG_ADDR__MHL_EXTSTAT_7                                          (TX_MHLSPEC | 0x0097)
  // (ReadOnly, Bits 7:0) 
  // rsvd
  #define BIT_MSK__MHL_EXTSTAT_7__REG_MHL_EXTSTAT_7                                     0xFF

// Device Extended Status 9th byte Register
#define REG_ADDR__MHL_EXTSTAT_8                                          (TX_MHLSPEC | 0x0098)
  // (ReadOnly, Bits 7:0) 
  // rsvd
  #define BIT_MSK__MHL_EXTSTAT_8__REG_MHL_EXTSTAT_8                                     0xFF

// Device Extended Status 10th byte Register
#define REG_ADDR__MHL_EXTSTAT_9                                          (TX_MHLSPEC | 0x0099)
  // (ReadOnly, Bits 7:0) 
  // rsvd
  #define BIT_MSK__MHL_EXTSTAT_9__REG_MHL_EXTSTAT_9                                     0xFF

// Device Extended Status 11th byte Register
#define REG_ADDR__MHL_EXTSTAT_A                                          (TX_MHLSPEC | 0x009A)
  // (ReadOnly, Bits 7:0) 
  // rsvd
  #define BIT_MSK__MHL_EXTSTAT_A__REG_MHL_EXTSTAT_A                                     0xFF

// Device Extended Status 12th byte Register
#define REG_ADDR__MHL_EXTSTAT_B                                          (TX_MHLSPEC | 0x009B)
  // (ReadOnly, Bits 7:0) 
  // rsvd
  #define BIT_MSK__MHL_EXTSTAT_B__REG_MHL_EXTSTAT_B                                     0xFF

// Device Extended Status 13th byte Register
#define REG_ADDR__MHL_EXTSTAT_C                                          (TX_MHLSPEC | 0x009C)
  // (ReadOnly, Bits 7:0) 
  // rsvd
  #define BIT_MSK__MHL_EXTSTAT_C__REG_MHL_EXTSTAT_C                                     0xFF

// Device Extended Status 14th byte Register
#define REG_ADDR__MHL_EXTSTAT_D                                          (TX_MHLSPEC | 0x009D)
  // (ReadOnly, Bits 7:0) 
  // rsvd
  #define BIT_MSK__MHL_EXTSTAT_D__REG_MHL_EXTSTAT_D                                     0xFF

// Device Extended Status 15th byte Register
#define REG_ADDR__MHL_EXTSTAT_E                                          (TX_MHLSPEC | 0x009E)
  // (ReadOnly, Bits 7:0) 
  // rsvd
  #define BIT_MSK__MHL_EXTSTAT_E__REG_MHL_EXTSTAT_E                                     0xFF

// Device Extended Status 16th byte Register
#define REG_ADDR__MHL_EXTSTAT_F                                          (TX_MHLSPEC | 0x009F)
  // (ReadOnly, Bits 7:0) 
  // rsvd
  #define BIT_MSK__MHL_EXTSTAT_F__REG_MHL_EXTSTAT_F                                     0xFF

// Device Extended Status 17th byte Register
#define REG_ADDR__MHL_EXTSTAT_10                                         (TX_MHLSPEC | 0x00A0)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 17th byte. RSVD
  #define BIT_MSK__MHL_EXTSTAT_10__REG_MHL_EXTSTAT_10                                    0xFF

// Device Extended Status 18th byte Register
#define REG_ADDR__MHL_EXTSTAT_11                                         (TX_MHLSPEC | 0x00A1)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 18th byte. RSVD
  #define BIT_MSK__MHL_EXTSTAT_11__REG_MHL_EXTSTAT_11                                    0xFF

// Device Extended Status 19th byte Register
#define REG_ADDR__MHL_EXTSTAT_12                                         (TX_MHLSPEC | 0x00A2)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 19th byte. RSVD
  #define BIT_MSK__MHL_EXTSTAT_12__REG_MHL_EXTSTAT_12                                    0xFF

// Device Extended Status 20th byte Register
#define REG_ADDR__MHL_EXTSTAT_13                                         (TX_MHLSPEC | 0x00A3)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 20th byte. RSVD
  #define BIT_MSK__MHL_EXTSTAT_13__REG_MHL_EXTSTAT_13                                    0xFF

// Device Extended Status 21th byte Register
#define REG_ADDR__MHL_EXTSTAT_14                                         (TX_MHLSPEC | 0x00A4)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 21st byte. RSVD
  #define BIT_MSK__MHL_EXTSTAT_14__REG_MHL_EXTSTAT_14                                    0xFF

// Device Extended Status 22th byte Register
#define REG_ADDR__MHL_EXTSTAT_15                                         (TX_MHLSPEC | 0x00A5)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 22nd byte. RSVD
  #define BIT_MSK__MHL_EXTSTAT_15__REG_MHL_EXTSTAT_15                                    0xFF

// Device Extended Status 23th byte Register
#define REG_ADDR__MHL_EXTSTAT_16                                         (TX_MHLSPEC | 0x00A6)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 23rd byte. RSVD
  #define BIT_MSK__MHL_EXTSTAT_16__REG_MHL_EXTSTAT_16                                    0xFF

// Device Extended Status 24th byte Register
#define REG_ADDR__MHL_EXTSTAT_17                                         (TX_MHLSPEC | 0x00A7)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 24th byte. RSVD
  #define BIT_MSK__MHL_EXTSTAT_17__REG_MHL_EXTSTAT_17                                    0xFF

// Device Extended Status 25th byte Register
#define REG_ADDR__MHL_EXTSTAT_18                                         (TX_MHLSPEC | 0x00A8)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 25rd byte. RSVD
  #define BIT_MSK__MHL_EXTSTAT_18__REG_MHL_EXTSTAT_18                                    0xFF

// Device Extended Status 26th byte Register
#define REG_ADDR__MHL_EXTSTAT_19                                         (TX_MHLSPEC | 0x00A9)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 26rd byte. RSVD
  #define BIT_MSK__MHL_EXTSTAT_19__REG_MHL_EXTSTAT_19                                    0xFF

// Device Extended Status 27th byte Register
#define REG_ADDR__MHL_EXTSTAT_1A                                         (TX_MHLSPEC | 0x00AA)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 27rd byte. RSVD
  #define BIT_MSK__MHL_EXTSTAT_1A__REG_MHL_EXTSTAT_1A                                    0xFF

// Device Extended Status 28th byte Register
#define REG_ADDR__MHL_EXTSTAT_1B                                         (TX_MHLSPEC | 0x00AB)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 28rd byte. RSVD
  #define BIT_MSK__MHL_EXTSTAT_1B__REG_MHL_EXTSTAT_1B                                    0xFF

// Device Extended Status 29th byte Register
#define REG_ADDR__MHL_EXTSTAT_1C                                         (TX_MHLSPEC | 0x00AC)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 29rd byte. RSVD
  #define BIT_MSK__MHL_EXTSTAT_1C__REG_MHL_EXTSTAT_1C                                    0xFF

// Device Extended Status 30th byte Register
#define REG_ADDR__MHL_EXTSTAT_1D                                         (TX_MHLSPEC | 0x00AD)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 30rd byte. RSVD
  #define BIT_MSK__MHL_EXTSTAT_1D__REG_MHL_EXTSTAT_1D                                    0xFF

// Device Extended Status 31th byte Register
#define REG_ADDR__MHL_EXTSTAT_1E                                         (TX_MHLSPEC | 0x00AE)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 31rd byte. RSVD
  #define BIT_MSK__MHL_EXTSTAT_1E__REG_MHL_EXTSTAT_1E                                    0xFF

// Device Extended Status 32th byte Register
#define REG_ADDR__MHL_EXTSTAT_1F                                         (TX_MHLSPEC | 0x00AF)
  // (ReadOnly, Bits 7:0) 
  // MHL status registers 32rd byte. RSVD
  #define BIT_MSK__MHL_EXTSTAT_1F__REG_MHL_EXTSTAT_1F                                    0xFF

//***************************************************************************
// TX_CBUS_MSCAGENT_DISC. Address: 60
// CBUS_MSC_AGENT Interrupt Status Register
#define REG_ADDR__CBUS_MSC_AGENT_INTR                                    (TX_CBUS_MSCAGENT_DISC | 0x0000)
  // (ReadWrite, Bits 0) 
  // DeviceCap registers are available in DEVCAP FIFO
  #define BIT_MSK__CBUS_MSC_AGENT_INTR__REG_CBUS_MSC_AGENT_INTR_STAT0                         0x01

// CBUS_MSC_AGENT Interrupt Mask Register
#define REG_ADDR__CBUS_MSC_AGENT_INTR_MASK                               (TX_CBUS_MSCAGENT_DISC | 0x0001)
  // (ReadWrite, Bits 0) 
  // Enable INT[0]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_MSC_AGENT_INTR_MASK__REG_CBUS_MSC_AGENT_INTR_MASK0                         0x01

// CBUS_MSC_AGENT Aggregated Interrupt Status Register
#define REG_ADDR__CBUS_MSC_AGENT_INTR_STAT                               (TX_CBUS_MSCAGENT_DISC | 0x0002)
  // (ReadOnly, Bits 0) 
  // CBUS_MSC_AGENT aggregated interrupt at 0x00
  #define BIT_MSK__CBUS_MSC_AGENT_INTR_STAT__REG_CBUS_MSC_AGENT_INTR_STAT                          0x01

// CBUS_MSC_AGENT Start Register
#define REG_ADDR__CBUS_MSC_START                                         (TX_CBUS_MSCAGENT_DISC | 0x0003)
  // (ReadWrite, Bits 0) 
  // Start to get DEVCAP. Self-resetting to 0. If CBUS not connected, to write 1 to this bit does not take effect.
  #define BIT_MSK__CBUS_MSC_START__REG_GET_DEVCAP_START                                  0x01

// CBUS_MSC_AGENT Control Register
#define REG_ADDR__CBUS_MSC_AGENT_CTRL                                    (TX_CBUS_MSCAGENT_DISC | 0x0004)
  // (ReadWrite, Bits 0) 
  // 0: read DevCap through CBUS from Rx (could be MHL1/2/3 device) 1: read extended DevCap through CBUS from Rx (most likely an MHL3 device) 
  #define BIT_MSK__CBUS_MSC_AGENT_CTRL__REG_XDEVCAP_EN                                        0x01
  // (ReadWrite, Bits 1) 
  // Self-clear. Write 1'b1 to move DEVCAP FIFO read pointer back to 4'h0
  #define BIT_MSK__CBUS_MSC_AGENT_CTRL__REG_DEVCAP_RADDR_CLR                                  0x02

// CBUS_MSC_AGENT Status Register
#define REG_ADDR__CBUS_MSC_AGENT_STAT                                    (TX_CBUS_MSCAGENT_DISC | 0x0005)
  // (ReadOnly, Bits 0) 
  // Device Capability in FIFO is valid
  #define BIT_MSK__CBUS_MSC_AGENT_STAT__MSC_DEVCAP_VALID                                      0x01
  // (ReadOnly, Bits 1) 
  // Indicates that CBUS is busy after TPI_CBUS_START.* is requested.
  #define BIT_MSK__CBUS_MSC_AGENT_STAT__MSC_STATUS_BUSY                                       0x02

// DEVCAP Read Port
#define REG_ADDR__CBUS_DEVCAP_FIFO                                       (TX_CBUS_MSCAGENT_DISC | 0x0006)
  // (ReadWrite, Bits 7:0) 
  // Read this port to get peer device capability register after 0x00[0] is asserted
  #define BIT_MSK__CBUS_DEVCAP_FIFO__REG_DEVCAP_RDATA                                      0xFF

// CBUS WRITE_BURST Transmit 1st Byte Register
#define REG_ADDR__WB_XMIT_DATA_0                                         (TX_CBUS_MSCAGENT_DISC | 0x0060)
  // (ReadWrite, Bits 7:0) 
  // WRITE_BURST transmit 1st byte
  #define BIT_MSK__WB_XMIT_DATA_0__REG_WB_XMIT_DATA_0                                    0xFF

// CBUS WRITE_BURST Transmit 2nd Byte Register
#define REG_ADDR__WB_XMIT_DATA_1                                         (TX_CBUS_MSCAGENT_DISC | 0x0061)
  // (ReadWrite, Bits 7:0) 
  // WRITE_BURST transmit 2nd byte
  #define BIT_MSK__WB_XMIT_DATA_1__REG_WB_XMIT_DATA_1                                    0xFF

// CBUS WRITE_BURST Transmit 3rd Byte Register
#define REG_ADDR__WB_XMIT_DATA_2                                         (TX_CBUS_MSCAGENT_DISC | 0x0062)
  // (ReadWrite, Bits 7:0) 
  // WRITE_BURST transmit 3rd byte
  #define BIT_MSK__WB_XMIT_DATA_2__REG_WB_XMIT_DATA_2                                    0xFF

// CBUS WRITE_BURST Transmit 4th Byte Register
#define REG_ADDR__WB_XMIT_DATA_3                                         (TX_CBUS_MSCAGENT_DISC | 0x0063)
  // (ReadWrite, Bits 7:0) 
  // WRITE_BURST transmit 4th byte
  #define BIT_MSK__WB_XMIT_DATA_3__REG_WB_XMIT_DATA_3                                    0xFF

// CBUS WRITE_BURST Transmit 5th Byte Register
#define REG_ADDR__WB_XMIT_DATA_4                                         (TX_CBUS_MSCAGENT_DISC | 0x0064)
  // (ReadWrite, Bits 7:0) 
  // WRITE_BURST transmit 5th byte
  #define BIT_MSK__WB_XMIT_DATA_4__REG_WB_XMIT_DATA_4                                    0xFF

// CBUS WRITE_BURST Transmit 6th Byte Register
#define REG_ADDR__WB_XMIT_DATA_5                                         (TX_CBUS_MSCAGENT_DISC | 0x0065)
  // (ReadWrite, Bits 7:0) 
  // WRITE_BURST transmit 6th byte
  #define BIT_MSK__WB_XMIT_DATA_5__REG_WB_XMIT_DATA_5                                    0xFF

// CBUS WRITE_BURST Transmit 7th Byte Register
#define REG_ADDR__WB_XMIT_DATA_6                                         (TX_CBUS_MSCAGENT_DISC | 0x0066)
  // (ReadWrite, Bits 7:0) 
  // WRITE_BURST transmit 7th byte
  #define BIT_MSK__WB_XMIT_DATA_6__REG_WB_XMIT_DATA_6                                    0xFF

// CBUS WRITE_BURST Transmit 8th Byte Register
#define REG_ADDR__WB_XMIT_DATA_7                                         (TX_CBUS_MSCAGENT_DISC | 0x0067)
  // (ReadWrite, Bits 7:0) 
  // WRITE_BURST transmit 8th byte
  #define BIT_MSK__WB_XMIT_DATA_7__REG_WB_XMIT_DATA_7                                    0xFF

// CBUS WRITE_BURST Transmit 9th Byte Register
#define REG_ADDR__WB_XMIT_DATA_8                                         (TX_CBUS_MSCAGENT_DISC | 0x0068)
  // (ReadWrite, Bits 7:0) 
  // WRITE_BURST transmit 9th byte
  #define BIT_MSK__WB_XMIT_DATA_8__REG_WB_XMIT_DATA_8                                    0xFF

// CBUS WRITE_BURST Transmit 10th Byte Register
#define REG_ADDR__WB_XMIT_DATA_9                                         (TX_CBUS_MSCAGENT_DISC | 0x0069)
  // (ReadWrite, Bits 7:0) 
  // WRITE_BURST transmit 10th byte
  #define BIT_MSK__WB_XMIT_DATA_9__REG_WB_XMIT_DATA_9                                    0xFF

// CBUS WRITE_BURST Transmit 11th Byte Register
#define REG_ADDR__WB_XMIT_DATA_A                                         (TX_CBUS_MSCAGENT_DISC | 0x006A)
  // (ReadWrite, Bits 7:0) 
  // WRITE_BURST transmit 11th byte
  #define BIT_MSK__WB_XMIT_DATA_A__REG_WB_XMIT_DATA_A                                    0xFF

// CBUS WRITE_BURST Transmit 12th Byte Register
#define REG_ADDR__WB_XMIT_DATA_B                                         (TX_CBUS_MSCAGENT_DISC | 0x006B)
  // (ReadWrite, Bits 7:0) 
  // WRITE_BURST transmit 12th byte
  #define BIT_MSK__WB_XMIT_DATA_B__REG_WB_XMIT_DATA_B                                    0xFF

// CBUS WRITE_BURST Transmit 13th Byte Register
#define REG_ADDR__WB_XMIT_DATA_C                                         (TX_CBUS_MSCAGENT_DISC | 0x006C)
  // (ReadWrite, Bits 7:0) 
  // WRITE_BURST transmit 13th byte
  #define BIT_MSK__WB_XMIT_DATA_C__REG_WB_XMIT_DATA_C                                    0xFF

// CBUS WRITE_BURST Transmit 14th Byte Register
#define REG_ADDR__WB_XMIT_DATA_D                                         (TX_CBUS_MSCAGENT_DISC | 0x006D)
  // (ReadWrite, Bits 7:0) 
  // WRITE_BURST transmit 14th byte
  #define BIT_MSK__WB_XMIT_DATA_D__REG_WB_XMIT_DATA_D                                    0xFF

// CBUS WRITE_BURST Transmit 15th Byte Register
#define REG_ADDR__WB_XMIT_DATA_E                                         (TX_CBUS_MSCAGENT_DISC | 0x006E)
  // (ReadWrite, Bits 7:0) 
  // WRITE_BURST transmit 15th byte
  #define BIT_MSK__WB_XMIT_DATA_E__REG_WB_XMIT_DATA_E                                    0xFF

// CBUS WRITE_BURST Transmit 16th Byte Register
#define REG_ADDR__WB_XMIT_DATA_F                                         (TX_CBUS_MSCAGENT_DISC | 0x006F)
  // (ReadWrite, Bits 7:0) 
  // WRITE_BURST transmit 16th byte
  #define BIT_MSK__WB_XMIT_DATA_F__REG_WB_XMIT_DATA_F                                    0xFF

// Debug Control Low Register
#define REG_ADDR__DBG_CTL_L                                              (TX_CBUS_MSCAGENT_DISC | 0x0070)
  // (ReadWrite, Bits 7:0) 
  // Debug control register; 1st byte
  #define BIT_MSK__DBG_CTL_L__REG_DBG_CTL_B7_B0                                     0xFF

// Debug Control High Register
#define REG_ADDR__DBG_CTL_H                                              (TX_CBUS_MSCAGENT_DISC | 0x0071)
  // (ReadWrite, Bits 7:0) 
  // Debug control register; 2nd byte
  #define BIT_MSK__DBG_CTL_H__REG_DBG_CTL_B15_B8                                    0xFF

// Debug External Status Register
#define REG_ADDR__DBG_EXT_STAT                                           (TX_CBUS_MSCAGENT_DISC | 0x0072)
  // (ReadOnly, Bits 7:0) 
  // External status for debugging purpose
  #define BIT_MSK__DBG_EXT_STAT__REG_DBG_EXT_STAT                                      0xFF

// Debug Internal Status Select Register
#define REG_ADDR__DBG_INT_STAT_SEL                                       (TX_CBUS_MSCAGENT_DISC | 0x0073)
  // (ReadWrite, Bits 1:0) 
  // Debug internal status select
  #define BIT_MSK__DBG_INT_STAT_SEL__REG_DBG_INT_STAT_SEL                                  0x03

// Debug Internal Status Low Register
#define REG_ADDR__DBG_INT_STAT_L                                         (TX_CBUS_MSCAGENT_DISC | 0x0074)
  // (ReadOnly, Bits 7:0) 
  // Internal status for debugging purpose; low byte
  #define BIT_MSK__DBG_INT_STAT_L__REG_DBG_INT_STAT_B7_B0                                0xFF

// Debug Internal Status High Register
#define REG_ADDR__DBG_INT_STAT_H                                         (TX_CBUS_MSCAGENT_DISC | 0x0075)
  // (ReadOnly, Bits 7:0) 
  // Internal status for debugging purpose; high byte
  #define BIT_MSK__DBG_INT_STAT_H__REG_DBG_INT_STAT_B15_B8                               0xFF

// CBUS System Control Register
#define REG_ADDR__CBUS_SYS_CTL                                           (TX_CBUS_MSCAGENT_DISC | 0x0078)
  // (ReadWrite, Bits 0) 
  // Set to 1'b1 to reset CBUS
  #define BIT_MSK__CBUS_SYS_CTL__REG_CBUS_RST                                          0x01

// CBUS System Aggregated Interrupt Status #1 Register
#define REG_ADDR__CBUS_AGGREGATED_INT_STAT_0                             (TX_CBUS_MSCAGENT_DISC | 0x0079)
  // (ReadOnly, Bits 0) 
  // Aggregate interrupt status for 0x92
  #define BIT_MSK__CBUS_AGGREGATED_INT_STAT_0__REG_CBUS_INTR_STAT_B0                                 0x01
  // (ReadOnly, Bits 1) 
  // Aggregate interrupt status for 0x94
  #define BIT_MSK__CBUS_AGGREGATED_INT_STAT_0__REG_CBUS_INTR_STAT_B1                                 0x02
  // (ReadOnly, Bits 2) 
  // Aggregate interrupt status for 0x8A
  #define BIT_MSK__CBUS_AGGREGATED_INT_STAT_0__REG_CBUS_INTR_STAT_B2                                 0x04
  // (ReadOnly, Bits 3) 
  // Aggregate interrupt status for 0x8E
  #define BIT_MSK__CBUS_AGGREGATED_INT_STAT_0__REG_CBUS_INTR_STAT_B3                                 0x08
  // (ReadOnly, Bits 4) 
  // Aggregate interrupt status for MHLSPEC page 0x20
  #define BIT_MSK__CBUS_AGGREGATED_INT_STAT_0__REG_CBUS_INTR_STAT_B4                                 0x10
  // (ReadOnly, Bits 5) 
  // Aggregate interrupt status for MHLSPEC page 0x21
  #define BIT_MSK__CBUS_AGGREGATED_INT_STAT_0__REG_CBUS_INTR_STAT_B5                                 0x20
  // (ReadOnly, Bits 6) 
  // Aggregate interrupt status for MHLSPEC page 0x22
  #define BIT_MSK__CBUS_AGGREGATED_INT_STAT_0__REG_CBUS_INTR_STAT_B6                                 0x40
  // (ReadOnly, Bits 7) 
  // Aggregate interrupt status for MHLSPEC page 0x23
  #define BIT_MSK__CBUS_AGGREGATED_INT_STAT_0__REG_CBUS_INTR_STAT_B7                                 0x80

// CBUS System Aggregated Interrupt Status #2 Register
#define REG_ADDR__CBUS_AGGREGATED_INT_STAT_1                             (TX_CBUS_MSCAGENT_DISC | 0x007A)
  // (ReadOnly, Bits 0) 
  // Aggregate interrupt status for 0x9A
  #define BIT_MSK__CBUS_AGGREGATED_INT_STAT_1__REG_CBUS_INTR_STAT_B8                                 0x01
  // (ReadOnly, Bits 1) 
  // Aggregate interrupt status for 0x9C
  #define BIT_MSK__CBUS_AGGREGATED_INT_STAT_1__REG_CBUS_INTR_STAT_B9                                 0x02
  // (ReadOnly, Bits 2) 
  // Aggregate interrupt status for 0x98
  #define BIT_MSK__CBUS_AGGREGATED_INT_STAT_1__REG_CBUS_INTR_STAT_B10                                0x04
  // (ReadOnly, Bits 3) 
  // Aggregate interrupt status for 0xDD
  #define BIT_MSK__CBUS_AGGREGATED_INT_STAT_1__REG_CBUS_INTR_STAT_B11                                0x08
  // (ReadOnly, Bits 4) 
  // Aggregate interrupt status for CBUS discovery page (0x10[0])
  #define BIT_MSK__CBUS_AGGREGATED_INT_STAT_1__REG_CBUS_INTR_STAT_B12                                0x10
  // (ReadOnly, Bits 5) 
  // Aggregate interrupt status for  CBUS MSC AGENT page (0x02[0])
  #define BIT_MSK__CBUS_AGGREGATED_INT_STAT_1__REG_CBUS_INTR_STAT_B13                                0x20

// CBUS Discovery Clock Ratio Register
#define REG_ADDR__CBUS_DISC_CLK_RATIO_L                                  (TX_CBUS_MSCAGENT_DISC | 0x007E)
  // (ReadWrite, Bits 7:0) 
  // Tx Only: The ratio between cbus discovery clock frequency to 60KHz clock (bits [7:0]) 
  #define BIT_MSK__CBUS_DISC_CLK_RATIO_L__REG_RATIO_60KHZ_2_DISC_B7_B0                          0xFF

// CBUS System Control Register
#define REG_ADDR__CBUS_DISC_CLK_RATIO_H                                  (TX_CBUS_MSCAGENT_DISC | 0x007F)
  // (ReadWrite, Bits 1:0) 
  // Tx Only: The ratio between cbus discovery clock frequency to 60KHz clock (bist [9:8]) 
  #define BIT_MSK__CBUS_DISC_CLK_RATIO_H__REG_RATIO_60KHZ_2_DISC_B9_B8                          0x03
  // (ReadWrite, Bits 7) 
  // 1'b1: CBUS discovery clock is 60KHz 1'b0: The ratio between CBUS discovery clock and 60KHz clock 
  #define BIT_MSK__CBUS_DISC_CLK_RATIO_H__REG_SEL_60KHZ_4_DISC                                  0x80

// Interrupt Mask 1st Register
#define REG_ADDR__MHL_INT_0_MASK                                         (TX_CBUS_MSCAGENT_DISC | 0x0080)
  // (ReadWrite, Bits 0) 
  // Enable DCAP_CHG interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_0_MASK__REG_MHL_INT_0_MASK0                                   0x01
  // (ReadWrite, Bits 1) 
  // Eanble DSCR_CHG interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_0_MASK__REG_MHL_INT_0_MASK1                                   0x02
  // (ReadWrite, Bits 2) 
  // Enable REQ_WRT interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_0_MASK__REG_MHL_INT_0_MASK2                                   0x04
  // (ReadWrite, Bits 3) 
  // Enable GRT_WRT interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_0_MASK__REG_MHL_INT_0_MASK3                                   0x08
  // (ReadWrite, Bits 4) 
  // Enable MHL_INT_0[4]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_0_MASK__REG_MHL_INT_0_MASK4                                   0x10
  // (ReadWrite, Bits 5) 
  // Enable MHL_INT_0[5]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_0_MASK__REG_MHL_INT_0_MASK5                                   0x20
  // (ReadWrite, Bits 6) 
  // Enable MHL_INT_0[6]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_0_MASK__REG_MHL_INT_0_MASK6                                   0x40
  // (ReadWrite, Bits 7) 
  // Enable MHL_INT_0[7]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_0_MASK__REG_MHL_INT_0_MASK7                                   0x80

// Interrupt Mask 2nd Register
#define REG_ADDR__MHL_INT_1_MASK                                         (TX_CBUS_MSCAGENT_DISC | 0x0081)
  // (ReadWrite, Bits 0) 
  // Enable MHL_INT_1[0]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_1_MASK__REG_MHL_INT_1_MASK0                                   0x01
  // (ReadWrite, Bits 1) 
  // Enable EDID_CHG interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_1_MASK__REG_MHL_INT_1_MASK1                                   0x02
  // (ReadWrite, Bits 2) 
  // Enable MHL_INT_1[2]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_1_MASK__REG_MHL_INT_1_MASK2                                   0x04
  // (ReadWrite, Bits 3) 
  // Enable MHL_INT_1[3]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_1_MASK__REG_MHL_INT_1_MASK3                                   0x08
  // (ReadWrite, Bits 4) 
  // Enable MHL_INT_1[4]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_1_MASK__REG_MHL_INT_1_MASK4                                   0x10
  // (ReadWrite, Bits 5) 
  // Enable MHL_INT_1[5]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_1_MASK__REG_MHL_INT_1_MASK5                                   0x20
  // (ReadWrite, Bits 6) 
  // Enable MHL_INT_1[6]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_1_MASK__REG_MHL_INT_1_MASK6                                   0x40
  // (ReadWrite, Bits 7) 
  // Enable MHL_INT_1[7]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_1_MASK__REG_MHL_INT_1_MASK7                                   0x80

// Interrupt Mask 3rd Register
#define REG_ADDR__MHL_INT_2_MASK                                         (TX_CBUS_MSCAGENT_DISC | 0x0082)
  // (ReadWrite, Bits 0) 
  // Enable MHL_INT_2[0]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_2_MASK__REG_MHL_INT_2_MASK0                                   0x01
  // (ReadWrite, Bits 1) 
  // Enable MHL_INT_2[1]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_2_MASK__REG_MHL_INT_2_MASK1                                   0x02
  // (ReadWrite, Bits 2) 
  // Enable MHL_INT_2[2]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_2_MASK__REG_MHL_INT_2_MASK2                                   0x04
  // (ReadWrite, Bits 3) 
  // Enable MHL_INT_2[3]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_2_MASK__REG_MHL_INT_2_MASK3                                   0x08
  // (ReadWrite, Bits 4) 
  // Enable MHL_INT_2[4]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_2_MASK__REG_MHL_INT_2_MASK4                                   0x10
  // (ReadWrite, Bits 5) 
  // Enable MHL_INT_2[5]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_2_MASK__REG_MHL_INT_2_MASK5                                   0x20
  // (ReadWrite, Bits 6) 
  // Enable MHL_INT_2[6]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_2_MASK__REG_MHL_INT_2_MASK6                                   0x40
  // (ReadWrite, Bits 7) 
  // Enable MHL_INT_2[7]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_2_MASK__REG_MHL_INT_2_MASK7                                   0x80

// Interrupt Mask 4th Register
#define REG_ADDR__MHL_INT_3_MASK                                         (TX_CBUS_MSCAGENT_DISC | 0x0083)
  // (ReadWrite, Bits 0) 
  // Enable MHL_INT_3[0]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_3_MASK__REG_MHL_INT_3_MASK0                                   0x01
  // (ReadWrite, Bits 1) 
  // Enable MHL_INT_3[1]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_3_MASK__REG_MHL_INT_3_MASK1                                   0x02
  // (ReadWrite, Bits 2) 
  // Enable MHL_INT_3[2]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_3_MASK__REG_MHL_INT_3_MASK2                                   0x04
  // (ReadWrite, Bits 3) 
  // Enable MHL_INT_3[3]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_3_MASK__REG_MHL_INT_3_MASK3                                   0x08
  // (ReadWrite, Bits 4) 
  // Enable MHL_INT_3[4]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_3_MASK__REG_MHL_INT_3_MASK4                                   0x10
  // (ReadWrite, Bits 5) 
  // Enable MHL_INT_3[5]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_3_MASK__REG_MHL_INT_3_MASK5                                   0x20
  // (ReadWrite, Bits 6) 
  // Enable MHL_INT_3[6]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_3_MASK__REG_MHL_INT_3_MASK6                                   0x40
  // (ReadWrite, Bits 7) 
  // Enable MHL_INT_3[7]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MHL_INT_3_MASK__REG_MHL_INT_3_MASK7                                   0x80

// MDT Reveive Time Out Register
#define REG_ADDR__MDT_RCV_TIMEOUT                                        (TX_CBUS_MSCAGENT_DISC | 0x0084)
  // (ReadWrite, Bits 7:0) 
  // MDT receive time out threshold MSB (increment of 1048576 clocks)
  #define BIT_MSK__MDT_RCV_TIMEOUT__REG_MDT_RCV_TIMEOUT_MAX_MSB                           0xFF

// MDT Transmit Time Out Register
#define REG_ADDR__MDT_XMIT_TIMEOUT                                       (TX_CBUS_MSCAGENT_DISC | 0x0085)
  // (ReadWrite, Bits 7:0) 
  // MDT transmit time out threshold MSB (increment of 1048576 clocks)
  #define BIT_MSK__MDT_XMIT_TIMEOUT__REG_MDT_XMIT_TIMEOUT_MAX_MSB                          0xFF

// MDT Receive Control Register
#define REG_ADDR__MDT_RCV_CONTROL                                        (TX_CBUS_MSCAGENT_DISC | 0x0086)
  // (ReadWrite, Bits 0) 
  // Increments receive fifo read-pointer to next level.  0 = No 1 = yes (self-resetting bit)
  #define BIT_MSK__MDT_RCV_CONTROL__REG_MDT_RFIFO_CLR_CUR                                 0x01
  // (ReadWrite, Bits 1) 
  // Resets receive fifo read-pointer to zero. 0 = No 1 = yes (self-resetting bit)
  #define BIT_MSK__MDT_RCV_CONTROL__REG_MDT_RFIFO_CLR_ALL                                 0x02
  // (ReadWrite, Bits 2) 
  // Disable MDT transmission and receiving - reset both transmission and receiving state machine to idle
  #define BIT_MSK__MDT_RCV_CONTROL__REG_MDT_DISABLE                                       0x04
  // (ReadWrite, Bits 3) 
  // Enable MDT transmission FIFO over write when it is full
  #define BIT_MSK__MDT_RCV_CONTROL__REG_MDT_XFIFO_OVER_WR_EN                              0x08
  // (ReadWrite, Bits 4) 
  // Enable MDT receiving FIFO over write when it is full
  #define BIT_MSK__MDT_RCV_CONTROL__REG_MDT_RFIFO_OVER_WR_EN                              0x10
  // (ReadWrite, Bits 6) 
  // When this bit is set and reg_mdt_rcv_en is set; internal MDT receive enable will be delayed to set until a following MSC transaction has been triggered and finished. This will gurantee that atomic behavior of enabling MDT receiving.
  #define BIT_MSK__MDT_RCV_CONTROL__REG_MDT_DELAY_RCV_EN                                  0x40
  // (ReadWrite, Bits 7) 
  // Enable MDT receive: 1 - Enable 0 - Disable
  #define BIT_MSK__MDT_RCV_CONTROL__REG_MDT_RCV_EN                                        0x80

// MDT Receive Read Port
#define REG_ADDR__MDT_RCV_READ_PORT                                      (TX_CBUS_MSCAGENT_DISC | 0x0087)
  // (ReadOnly, Bits 7:0) 
  // MDT receive read data port. Use I2C burst read to read out received WRITE_BURST data.
  #define BIT_MSK__MDT_RCV_READ_PORT__MDT_RFIFO_DATA                                        0xFF

// MDT Transmit Control Register
#define REG_ADDR__MDT_XMIT_CONTROL                                       (TX_CBUS_MSCAGENT_DISC | 0x0088)
  // (ReadWrite, Bits 0) 
  // Increments transmit fifo read-pointer to next level. 0 = No 1 = Yes (self-resetting bit)
  #define BIT_MSK__MDT_XMIT_CONTROL__REG_MDT_XFIFO_CLR_CUR                                 0x01
  // (ReadWrite, Bits 1) 
  // Resets transmit fifo read-pointer to zero. 0 = No 1 = Yes (self-resetting bit)
  #define BIT_MSK__MDT_XMIT_CONTROL__REG_MDT_XFIFO_CLR_ALL                                 0x02
  // (ReadWrite, Bits 2) 
  // Clear wait state due to received ABORT packet. This applies both to MDT receive and transmit 0 = No 1 = Yes (self-resetting bit)
  #define BIT_MSK__MDT_XMIT_CONTROL__REG_MDT_CLR_ABORT_WAIT                                0x04
  // (ReadWrite, Bits 3) 
  // Onec enabled: MDT transmit will only do a single WRITE_BURST. For the second single run: it needs to be cleared and set by FW again. 0 = No 1 = Yes (Not self-resetting)
  #define BIT_MSK__MDT_XMIT_CONTROL__REG_MDT_XMIT_SINGLE_RUN_EN                            0x08
  // (ReadWrite, Bits 4) 
  // MDT transmit use the fixed Adopter ID
  #define BIT_MSK__MDT_XMIT_CONTROL__REG_MDT_XMIT_FIXED_AID                                0x10
  // (ReadWrite, Bits 5) 
  // MDT transmit use the fixed burst length
  #define BIT_MSK__MDT_XMIT_CONTROL__REG_MDT_XMIT_FIXED_BURST_LEN                          0x20
  // (ReadWrite, Bits 6) 
  // MDT transmit enable merging DSCR_CHG and REQ_WRT in one SET_INT command if possible
  #define BIT_MSK__MDT_XMIT_CONTROL__REG_MDT_XMIT_CMD_MERGE_EN                             0x40
  // (ReadWrite, Bits 7) 
  // Enable MDT transmit: 1 - Enable 0 - Disable
  #define BIT_MSK__MDT_XMIT_CONTROL__REG_MDT_XMIT_EN                                       0x80

// MDT Receive WRITE Port
#define REG_ADDR__MDT_XMIT_WRITE_PORT                                    (TX_CBUS_MSCAGENT_DISC | 0x0089)
  // (ReadWrite, Bits 7:0) 
  // MDT transmit write data port. Use I2C burst write to write WRITE_BURST data to be transmitted.
  #define BIT_MSK__MDT_XMIT_WRITE_PORT__MDT_XFIFO_WDATA                                       0xFF

// MDT RFIFO Status Register
#define REG_ADDR__MDT_RFIFO_STAT                                         (TX_CBUS_MSCAGENT_DISC | 0x008A)
  // (ReadOnly, Bits 4:0) 
  // MDT RFIFO received data byte count for the current level
  #define BIT_MSK__MDT_RFIFO_STAT__REG_MDT_RFIFO_CUR_BYTE_CNT                            0x1F
  // (ReadOnly, Bits 7:5) 
  // MDT RFIFO available data level
  #define BIT_MSK__MDT_RFIFO_STAT__REG_MDT_RFIFO_CNT                                     0xE0

// MDT XFIFO Status Register
#define REG_ADDR__MDT_XFIFO_STAT                                         (TX_CBUS_MSCAGENT_DISC | 0x008B)
  // (ReadOnly, Bits 3:0) 
  // MDT XFIFO data byte count for next WRITE_BURST if no fixed WRITE_BURST length is selected.
  #define BIT_MSK__MDT_XFIFO_STAT__REG_MDT_WRITE_BURST_LEN                               0x0F
  // (ReadWrite, Bits 4) 
  // MDT Transmit preemptive handshaking enable 1: Enable 0: Disable
  #define BIT_MSK__MDT_XFIFO_STAT__REG_MDT_XMIT_PRE_HS_EN                                0x10
  // (ReadOnly, Bits 7:5) 
  // MDT XFIFO empty/available data level 
  #define BIT_MSK__MDT_XFIFO_STAT__REG_MDT_XFIFO_LEVEL_AVAIL                             0xE0

// MDT Interrupt 0 Register
#define REG_ADDR__MDT_INT_0                                              (TX_CBUS_MSCAGENT_DISC | 0x008C)
  // (ReadWrite, Bits 0) 
  // MDT RFIFO data ready status
  #define BIT_MSK__MDT_INT_0__REG_MDT_INT_0_0                                       0x01
  // (ReadWrite, Bits 1) 
  // MDT XFIFO full status
  #define BIT_MSK__MDT_INT_0__REG_MDT_INT_0_1                                       0x02
  // (ReadWrite, Bits 2) 
  // MDT state machine comes to IDLE after reg_mdt_xmit_en  AND / OR  reg_mdt_rcv_en are disabled. This informs FW to take over.
  #define BIT_MSK__MDT_INT_0__REG_MDT_INT_0_2                                       0x04
  // (ReadWrite, Bits 3) 
  // MDT XFIFO empty stauts
  #define BIT_MSK__MDT_INT_0__REG_MDT_INT_0_3                                       0x08

// MDT Interrupt 0 Mask Register
#define REG_ADDR__MDT_INT_0_MASK                                         (TX_CBUS_MSCAGENT_DISC | 0x008D)
  // (ReadWrite, Bits 0) 
  // Enable MDT RFIFO data ready interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MDT_INT_0_MASK__REG_MDT_INT_0_MASK0                                   0x01
  // (ReadWrite, Bits 1) 
  // Enable MDT XFIFO full interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MDT_INT_0_MASK__REG_MDT_INT_0_MASK1                                   0x02
  // (ReadWrite, Bits 2) 
  // Enable MDT state machine IDLE interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MDT_INT_0_MASK__REG_MDT_INT_0_MASK2                                   0x04
  // (ReadWrite, Bits 3) 
  // Enable MDT XFIFO empty interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MDT_INT_0_MASK__REG_MDT_INT_0_MASK3                                   0x08

// MDT Interrupt 1 Register
#define REG_ADDR__MDT_INT_1                                              (TX_CBUS_MSCAGENT_DISC | 0x008E)
  // (ReadWrite, Bits 0) 
  // MDT Receive time out status
  #define BIT_MSK__MDT_INT_1__REG_MDT_INT_1_0                                       0x01
  // (ReadWrite, Bits 1) 
  // MDT Receive state machine received abort packet status
  #define BIT_MSK__MDT_INT_1__REG_MDT_INT_1_1                                       0x02
  // (ReadWrite, Bits 2) 
  // MDT Receive state machine error status
  #define BIT_MSK__MDT_INT_1__REG_MDT_INT_1_2                                       0x04
  // (ReadWrite, Bits 5) 
  // MDT Transmit time out status
  #define BIT_MSK__MDT_INT_1__REG_MDT_INT_1_5                                       0x20
  // (ReadWrite, Bits 6) 
  // MDT Transmit state machine received abort packet status
  #define BIT_MSK__MDT_INT_1__REG_MDT_INT_1_6                                       0x40
  // (ReadWrite, Bits 7) 
  // MDT Transmit state machine error status
  #define BIT_MSK__MDT_INT_1__REG_MDT_INT_1_7                                       0x80

// MDT Interrupt 1 Mask Register
#define REG_ADDR__MDT_INT_1_MASK                                         (TX_CBUS_MSCAGENT_DISC | 0x008F)
  // (ReadWrite, Bits 0) 
  // Enable MDT Receive time out interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MDT_INT_1_MASK__REG_MDT_INT_1_MASK0                                   0x01
  // (ReadWrite, Bits 1) 
  // Enable MDT Receive state machine received abort packet status interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MDT_INT_1_MASK__REG_MDT_INT_1_MASK1                                   0x02
  // (ReadWrite, Bits 2) 
  // Enable MDT Receive state machine error interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MDT_INT_1_MASK__REG_MDT_INT_1_MASK2                                   0x04
  // (ReadWrite, Bits 5) 
  // Enable MDT Transmit time out interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MDT_INT_1_MASK__REG_MDT_INT_1_MASK5                                   0x20
  // (ReadWrite, Bits 6) 
  // Enable MDT Transmit state machine received abort packet status interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MDT_INT_1_MASK__REG_MDT_INT_1_MASK6                                   0x40
  // (ReadWrite, Bits 7) 
  // Enable MDT Transmit state machine error interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MDT_INT_1_MASK__REG_MDT_INT_1_MASK7                                   0x80

// CBUS Vendor ID Register
#define REG_ADDR__CBUS_VENDOR_ID                                         (TX_CBUS_MSCAGENT_DISC | 0x0090)
  // (ReadOnly, Bits 7:0) 
  // CBUS Vendor ID. This is the value returned if a GET_VENDOR_ID is received. Note that this is different from adopter ID.
  #define BIT_MSK__CBUS_VENDOR_ID__REG_CBUS_VENDOR_ID                                    0xFF

// CBUS Connection Status Register
#define REG_ADDR__CBUS_STATUS                                            (TX_CBUS_MSCAGENT_DISC | 0x0091)
  // (ReadOnly, Bits 0) 
  // Rx Only: CBUS connected. N/A for Tx
  #define BIT_MSK__CBUS_STATUS__REG_CBUS_CONNECTED                                    0x01
  // (ReadOnly, Bits 1) 
  // CBUS is ready for commands.
  #define BIT_MSK__CBUS_STATUS__REG_MHL_MODE                                          0x02
  // (ReadOnly, Bits 2) 
  // SET_HPD is received by Tx. N/A for Rx
  #define BIT_MSK__CBUS_STATUS__REG_CBUS_HPD                                          0x04
  // (ReadOnly, Bits 3) 
  // MSC heartbeat success indicator
  #define BIT_MSK__CBUS_STATUS__REG_MSC_HB_SUCCESS                                    0x08
  // (ReadOnly, Bits 4) 
  // MHL cable detect sense
  #define BIT_MSK__CBUS_STATUS__REG_MHL_CABLE_PRESENT                                 0x10

// CBUS Interrupt 1st Register
#define REG_ADDR__CBUS_INT_0                                             (TX_CBUS_MSCAGENT_DISC | 0x0092)
  // (ReadWrite, Bits 0) 
  // CBUS connection change interrupt status
  #define BIT_MSK__CBUS_INT_0__REG_CBUS_INT_0_STAT0                                  0x01
  // (ReadWrite, Bits 1) 
  // MSC command done interrupt status
  #define BIT_MSK__CBUS_INT_0__REG_CBUS_INT_0_STAT1                                  0x02
  // (ReadWrite, Bits 2) 
  // CBUS HPD change status (TX Only)
  #define BIT_MSK__CBUS_INT_0__REG_CBUS_INT_0_STAT2                                  0x04
  // (ReadWrite, Bits 3) 
  // MSC WRITE_STAT command received interrupt status
  #define BIT_MSK__CBUS_INT_0__REG_CBUS_INT_0_STAT3                                  0x08
  // (ReadWrite, Bits 4) 
  // MSC_MSG command received interrupt status
  #define BIT_MSK__CBUS_INT_0__REG_CBUS_INT_0_STAT4                                  0x10
  // (ReadWrite, Bits 5) 
  // MSC WRITE_BURST command received interrupt status
  #define BIT_MSK__CBUS_INT_0__REG_CBUS_INT_0_STAT5                                  0x20
  // (ReadWrite, Bits 6) 
  // MSC SET_INT command received interrupt status. Note that this is not masked by MHL_INT_*_MASK but is masked by CBUS_INT_0_MASK.B769
  #define BIT_MSK__CBUS_INT_0__REG_CBUS_INT_0_STAT6                                  0x40
  // (ReadWrite, Bits 7) 
  // MSC_MSG  command done with NACK interrupt status.
  #define BIT_MSK__CBUS_INT_0__REG_CBUS_INT_0_STAT7                                  0x80

// CBUS Interrupt Mask 1st Register
#define REG_ADDR__CBUS_INT_0_MASK                                        (TX_CBUS_MSCAGENT_DISC | 0x0093)
  // (ReadWrite, Bits 0) 
  // Enable CBUS connection change interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_INT_0_MASK__REG_CBUS_INT_0_MASK0                                  0x01
  // (ReadWrite, Bits 1) 
  // Enable MSC command done interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_INT_0_MASK__REG_CBUS_INT_0_MASK1                                  0x02
  // (ReadWrite, Bits 2) 
  // Enable CBUS HPD change interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_INT_0_MASK__REG_CBUS_INT_0_MASK2                                  0x04
  // (ReadWrite, Bits 3) 
  // Enable MSC WRITE_STAT  received interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_INT_0_MASK__REG_CBUS_INT_0_MASK3                                  0x08
  // (ReadWrite, Bits 4) 
  // Enable MSC_MSG received interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_INT_0_MASK__REG_CBUS_INT_0_MASK4                                  0x10
  // (ReadWrite, Bits 5) 
  // Enable MSC WRITE_BURST received interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_INT_0_MASK__REG_CBUS_INT_0_MASK5                                  0x20
  // (ReadWrite, Bits 6) 
  // Enable MSC SET_INT command received interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_INT_0_MASK__REG_CBUS_INT_0_MASK6                                  0x40
  // (ReadWrite, Bits 7) 
  // Enable MSC_MSG command done with NACK interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_INT_0_MASK__REG_CBUS_INT_0_MASK7                                  0x80

// CBUS Interrupt 2nd Register
#define REG_ADDR__CBUS_INT_1                                             (TX_CBUS_MSCAGENT_DISC | 0x0094)
  // (ReadWrite, Bits 0) 
  // MSC heartbeat max fail interrupt staus
  #define BIT_MSK__CBUS_INT_1__REG_CBUS_INT_1_STAT0                                  0x01
  // (ReadWrite, Bits 2) 
  // DDC abort interrupt status
  #define BIT_MSK__CBUS_INT_1__REG_CBUS_INT_1_STAT2                                  0x04
  // (ReadWrite, Bits 3) 
  // MSC received command error interrupt status (As Responder). For exact error; check 0x9C
  #define BIT_MSK__CBUS_INT_1__REG_CBUS_INT_1_STAT3                                  0x08
  // (ReadWrite, Bits 5) 
  // CBUS packet received interrupt status
  #define BIT_MSK__CBUS_INT_1__REG_CBUS_INT_1_STAT5                                  0x20
  // (ReadWrite, Bits 6) 
  // MSC command error interrupt status (As Requester). For exact error; check 0x9A
  #define BIT_MSK__CBUS_INT_1__REG_CBUS_INT_1_STAT6                                  0x40
  // (ReadWrite, Bits 7) 
  // MHL Cable connect interrupt status
  #define BIT_MSK__CBUS_INT_1__REG_CBUS_INT_1_STAT7                                  0x80

// CBUS Interrupt Mask 2nd Register
#define REG_ADDR__CBUS_INT_1_MASK                                        (TX_CBUS_MSCAGENT_DISC | 0x0095)
  // (ReadWrite, Bits 0) 
  // Enable MSC heartbeat max fail interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_INT_1_MASK__REG_CBUS_INT_1_MASK0                                  0x01
  // (ReadWrite, Bits 2) 
  // Enable DDC abort interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_INT_1_MASK__REG_CBUS_INT_1_MASK2                                  0x04
  // (ReadWrite, Bits 3) 
  // Enable MSC abort received interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_INT_1_MASK__REG_CBUS_INT_1_MASK3                                  0x08
  // (ReadWrite, Bits 5) 
  // Enable CBUS packet received intrrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_INT_1_MASK__REG_CBUS_INT_1_MASK5                                  0x20
  // (ReadWrite, Bits 6) 
  // Enable MSC command abort interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_INT_1_MASK__REG_CBUS_INT_1_MASK6                                  0x40
  // (ReadWrite, Bits 7) 
  // Enable MHL cable connect interrupt status 1 - enable 0 - disable (default)
  #define BIT_MSK__CBUS_INT_1_MASK__REG_CBUS_INT_1_MASK7                                  0x80

// CBUS DDC Abort Interrupt Register
#define REG_ADDR__DDC_ABORT_INT                                          (TX_CBUS_MSCAGENT_DISC | 0x0098)
  // (ReadWrite, Bits 0) 
  // DDC max fail interrupt status
  #define BIT_MSK__DDC_ABORT_INT__REG_DDC_ABORT_INT_STAT0                               0x01
  // (ReadWrite, Bits 1) 
  // DDC protocol error interrupt status
  #define BIT_MSK__DDC_ABORT_INT__REG_DDC_ABORT_INT_STAT1                               0x02
  // (ReadWrite, Bits 2) 
  // DDC time out interrupt status
  #define BIT_MSK__DDC_ABORT_INT__REG_DDC_ABORT_INT_STAT2                               0x04
  // (ReadWrite, Bits 7) 
  // DDC aborted by peer interrupt status
  #define BIT_MSK__DDC_ABORT_INT__REG_DDC_ABORT_INT_STAT7                               0x80

// CBUS DDC Abort Interrupt Mask Register
#define REG_ADDR__DDC_ABORT_INT_MASK                                     (TX_CBUS_MSCAGENT_DISC | 0x0099)
  // (ReadWrite, Bits 0) 
  // Enable DDC max fail interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__DDC_ABORT_INT_MASK__REG_DDC_ABORT_INT_MASK0                               0x01
  // (ReadWrite, Bits 1) 
  // Enable DDC protocol error interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__DDC_ABORT_INT_MASK__REG_DDC_ABORT_INT_MASK1                               0x02
  // (ReadWrite, Bits 2) 
  // Enable DDC time out interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__DDC_ABORT_INT_MASK__REG_DDC_ABORT_INT_MASK2                               0x04
  // (ReadWrite, Bits 7) 
  // Enable DDC aborted by peer interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__DDC_ABORT_INT_MASK__REG_DDC_ABORT_INT_MASK7                               0x80

// CBUS MSC Requester Abort Interrupt Register
#define REG_ADDR__MSC_MT_ABORT_INT                                       (TX_CBUS_MSCAGENT_DISC | 0x009A)
  // (ReadWrite, Bits 0) 
  // MSC max fail interrupt status (as requester)
  #define BIT_MSK__MSC_MT_ABORT_INT__REG_MSC_MT_ABORT_INT_STAT0                            0x01
  // (ReadWrite, Bits 1) 
  // MSC protocol error interrupt status (as requester)
  #define BIT_MSK__MSC_MT_ABORT_INT__REG_MSC_MT_ABORT_INT_STAT1                            0x02
  // (ReadWrite, Bits 2) 
  // MSC time out interrupt status (as requester)
  #define BIT_MSK__MSC_MT_ABORT_INT__REG_MSC_MT_ABORT_INT_STAT2                            0x04
  // (ReadWrite, Bits 3) 
  // MSC undefined command initiated interrupt status (as requester)
  #define BIT_MSK__MSC_MT_ABORT_INT__REG_MSC_MT_ABORT_INT_STAT3                            0x08
  // (ReadWrite, Bits 5) 
  // MSC queued command aborted by heartbeat fail interrupt status
  #define BIT_MSK__MSC_MT_ABORT_INT__REG_MSC_MT_ABORT_INT_STAT5                            0x20
  // (ReadWrite, Bits 7) 
  // MSC aborted by peer interrupt status (as requester)
  #define BIT_MSK__MSC_MT_ABORT_INT__REG_MSC_MT_ABORT_INT_STAT7                            0x80

// CBUS MSC Reqeuster Abort Interrupt Mask Register
#define REG_ADDR__MSC_MT_ABORT_INT_MASK                                  (TX_CBUS_MSCAGENT_DISC | 0x009B)
  // (ReadWrite, Bits 0) 
  // Enable MSC max fail interrupt (as requester): 1 - enable; 0 - disable (default)
  #define BIT_MSK__MSC_MT_ABORT_INT_MASK__REG_MSC_MT_ABORT_INT_MASK0                            0x01
  // (ReadWrite, Bits 1) 
  // Enable MSC protocol error interrupt (as requester): 1 - enable; 0 - disable (default)
  #define BIT_MSK__MSC_MT_ABORT_INT_MASK__REG_MSC_MT_ABORT_INT_MASK1                            0x02
  // (ReadWrite, Bits 2) 
  // Enable MSC time out interrupt (as requester): 1 - enable; 0 - disable (default)
  #define BIT_MSK__MSC_MT_ABORT_INT_MASK__REG_MSC_MT_ABORT_INT_MASK2                            0x04
  // (ReadWrite, Bits 3) 
  // Enable MSC undefined command initiated interrupt (as requester): 1 - enable; 0 - disable (default)
  #define BIT_MSK__MSC_MT_ABORT_INT_MASK__REG_MSC_MT_ABORT_INT_MASK3                            0x08
  // (ReadWrite, Bits 5) 
  // Enable MSC queued command aborted by heartbeat fail interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MSC_MT_ABORT_INT_MASK__REG_MSC_MT_ABORT_INT_MASK5                            0x20
  // (ReadWrite, Bits 7) 
  // Enable MSC aborted by peer interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MSC_MT_ABORT_INT_MASK__REG_MSC_MT_ABORT_INT_MASK7                            0x80

// CBUS MSC Responder Abort Interrupt Register
#define REG_ADDR__MSC_MR_ABORT_INT                                       (TX_CBUS_MSCAGENT_DISC | 0x009C)
  // (ReadWrite, Bits 0) 
  // MSC max fail interrupt status (as responder)
  #define BIT_MSK__MSC_MR_ABORT_INT__REG_MSC_MR_ABORT_INT_STAT0                            0x01
  // (ReadWrite, Bits 1) 
  // MSC protocol error interrupt status (as responder)
  #define BIT_MSK__MSC_MR_ABORT_INT__REG_MSC_MR_ABORT_INT_STAT1                            0x02
  // (ReadWrite, Bits 2) 
  // MSC time out interrupt status (as responder)
  #define BIT_MSK__MSC_MR_ABORT_INT__REG_MSC_MR_ABORT_INT_STAT2                            0x04
  // (ReadWrite, Bits 3) 
  // MSC undefined command received interrupt status (as responder)
  #define BIT_MSK__MSC_MR_ABORT_INT__REG_MSC_MR_ABORT_INT_STAT3                            0x08
  // (ReadWrite, Bits 4) 
  // MSC received bad offset interrupt status (as responder)
  #define BIT_MSK__MSC_MR_ABORT_INT__REG_MSC_MR_ABORT_INT_STAT4                            0x10
  // (ReadWrite, Bits 5) 
  // MSC_MSG overflow  interrupt status (as responder)
  #define BIT_MSK__MSC_MR_ABORT_INT__REG_MSC_MR_ABORT_INT_STAT5                            0x20
  // (ReadWrite, Bits 7) 
  // MSC aborted by peer interrupt status (as responder)
  #define BIT_MSK__MSC_MR_ABORT_INT__REG_MSC_MR_ABORT_INT_STAT7                            0x80

// CBUS MSC Responder Abort Interrupt Mask Register
#define REG_ADDR__MSC_MR_ABORT_INT_MASK                                  (TX_CBUS_MSCAGENT_DISC | 0x009D)
  // (ReadWrite, Bits 0) 
  // Enable MSC max fail interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MSC_MR_ABORT_INT_MASK__REG_MSC_MR_ABORT_INT_MASK0                            0x01
  // (ReadWrite, Bits 1) 
  // Enable MSC protocol error interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MSC_MR_ABORT_INT_MASK__REG_MSC_MR_ABORT_INT_MASK1                            0x02
  // (ReadWrite, Bits 2) 
  // Enable MSC time out interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MSC_MR_ABORT_INT_MASK__REG_MSC_MR_ABORT_INT_MASK2                            0x04
  // (ReadWrite, Bits 3) 
  // Enable MSC undefined command received interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MSC_MR_ABORT_INT_MASK__REG_MSC_MR_ABORT_INT_MASK3                            0x08
  // (ReadWrite, Bits 4) 
  // Enable MSC received bad offset interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MSC_MR_ABORT_INT_MASK__REG_MSC_MR_ABORT_INT_MASK4                            0x10
  // (ReadWrite, Bits 5) 
  // Enable MSC_MSG overflow interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MSC_MR_ABORT_INT_MASK__REG_MSC_MR_ABORT_INT_MASK5                            0x20
  // (ReadWrite, Bits 7) 
  // Enable MSC aborted by peer interrupt: 1 - enable; 0 - disable (default)
  #define BIT_MSK__MSC_MR_ABORT_INT_MASK__REG_MSC_MR_ABORT_INT_MASK7                            0x80

// CBUS_Link_Layer Control #1 Register
#define REG_ADDR__CBUS_LINK_CONTROL_1                                    (TX_CBUS_MSCAGENT_DISC | 0x00A0)
  // (ReadWrite, Bits 5:0) 
  // number of packet for each cbus arbitration
  #define BIT_MSK__CBUS_LINK_CONTROL_1__REG_LNK_PACKET_LIMIT                                  0x3F

// CBUS_Link_Layer Control #2 Register
#define REG_ADDR__CBUS_LINK_CONTROL_2                                    (TX_CBUS_MSCAGENT_DISC | 0x00A1)
  // (ReadWrite, Bits 3:0) 
  // CBUS Link Layer initiator time-out. Unit in clock cycle. 
  #define BIT_MSK__CBUS_LINK_CONTROL_2__REG_LNK_INI_TIMEOUT_MAX                               0x0F
  // (ReadWrite, Bits 7:4) 
  // CBUS packet receiver glitch filter number of taps. Value 0 means no filter applied.
  #define BIT_MSK__CBUS_LINK_CONTROL_2__REG_LNK_GLITCH_FILTER_SEL                             0xF0

// CBUS_Link_Layer Control #3 Register
#define REG_ADDR__CBUS_LINK_CONTROL_3                                    (TX_CBUS_MSCAGENT_DISC | 0x00A2)
  // (ReadWrite, Bits 2:0) 
  // CBUS packet receiver algorithm control 000 = Easy CBS with by2 001 = Easy CBC with by2 + by8 (default) 010 = Easy CBC with by2 + by4 011 = Easy CBC with by2 + by4 + by8 1xx = Compare bit count algorithm
  #define BIT_MSK__CBUS_LINK_CONTROL_3__REG_LNK_RCV_BIT_CHECK_OPT                             0x07
  // (ReadWrite, Bits 5:3) 
  // CBUS link follower ACK timing control in clocks.
  #define BIT_MSK__CBUS_LINK_CONTROL_3__REG_LNK_FWR_ACK_OFFSET                                0x38
  // (ReadWrite, Bits 7) 
  // Enable sync filtering
  #define BIT_MSK__CBUS_LINK_CONTROL_3__REG_LNK_SYNC_FILTER_EN                                0x80

// CBUS_Link_Layer Control #4 Register
#define REG_ADDR__CBUS_LINK_CONTROL_4                                    (TX_CBUS_MSCAGENT_DISC | 0x00A3)
  // (ReadWrite, Bits 2:0) 
  // CBUS link transmission opportunity timeout in bit time unit. This is for after winning the arbitration.
  #define BIT_MSK__CBUS_LINK_CONTROL_4__REG_LNK_XMIT_OPP_TIMEOUT_MAX                          0x07
  // (ReadWrite, Bits 7:3) 
  // CBUS link receiving opportunity timeout in bit time units. This is for after losing the arbitration.
  #define BIT_MSK__CBUS_LINK_CONTROL_4__REG_LNK_RCV_OPP_TIMEOUT_MAX                           0xF8

// CBUS_Link_Layer Control #5 Register
#define REG_ADDR__CBUS_LINK_CONTROL_5                                    (TX_CBUS_MSCAGENT_DISC | 0x00A4)
  // (ReadWrite, Bits 3:0) 
  // CBUS long HIGH time out (the increment is 36 clocks)
  #define BIT_MSK__CBUS_LINK_CONTROL_5__REG_LNK_HIGH_TIMEOUT_MAX_MSB                          0x0F
  // (ReadWrite, Bits 7:4) 
  // CBUS long LOW time out (the increment is 36 clocks)
  #define BIT_MSK__CBUS_LINK_CONTROL_5__REG_LNK_LOW_TIMEOUT_MAX_MSB                           0xF0

// CBUS_Link_Layer Control #6 Register
#define REG_ADDR__CBUS_LINK_CONTROL_6                                    (TX_CBUS_MSCAGENT_DISC | 0x00A5)
  // (ReadWrite, Bits 2:0) 
  // CBUS port driver high time in 2 clock unit. (default: 4 clocks)
  #define BIT_MSK__CBUS_LINK_CONTROL_6__REG_LNK_DRV_HIGH_LIMIT                                0x07
  // (ReadWrite, Bits 5:3) 
  // CBUS port driver high disable time in clock unit (default: 2 clocks)
  #define BIT_MSK__CBUS_LINK_CONTROL_6__REG_LNK_CHECK_HIGH_LIMIT                              0x38

// CBUS_Link_Layer Control #7 Register
#define REG_ADDR__CBUS_LINK_CONTROL_7                                    (TX_CBUS_MSCAGENT_DISC | 0x00A6)
  // (ReadWrite, Bits 4:0) 
  // CBUS link layer bus_controller transmission idle timeout in bit time unit.
  #define BIT_MSK__CBUS_LINK_CONTROL_7__REG_LNK_XMIT_IDLE_TIMEOUT                             0x1F
  // (ReadWrite, Bits 5) 
  // Select the bit time for transmitting (only apply to MHL Tx) 1: register-programmed value 0: calibrated bit time
  #define BIT_MSK__CBUS_LINK_CONTROL_7__REG_LNK_XMIT_BIT_TIME_SEL0                            0x20

// CBUS_Link_Layer Control #8 Register
#define REG_ADDR__CBUS_LINK_CONTROL_8                                    (TX_CBUS_MSCAGENT_DISC | 0x00A7)
  // (ReadWrite, Bits 7:0) 
  // CBUS link 1 bit time in clocks.  For Source: the default is 8'h1f. For Sink and Dongle: the default is 8'h13.
  #define BIT_MSK__CBUS_LINK_CONTROL_8__REG_LNK_XMIT_BIT_TIME                                 0xFF

// CBUS_Link_Layer Control #9 Register
#define REG_ADDR__CBUS_LINK_CONTROL_9                                    (TX_CBUS_MSCAGENT_DISC | 0x00A8)
  // (ReadWrite, Bits 2:0) 
  // Number of calibration bytes before the first ACK. Default is 7. 0 is invalid setting.
  #define BIT_MSK__CBUS_LINK_CONTROL_9__REG_LNK_CAL_BYTE_CNT_MIN                              0x07
  // (ReadWrite, Bits 5:3) 
  // Average bit time FIFO depth 
  #define BIT_MSK__CBUS_LINK_CONTROL_9__REG_LNK_CAL_FIFO_DEPTH                                0x38
  // (ReadWrite, Bits 6) 
  // 1: invert CBUS polarity 
  #define BIT_MSK__CBUS_LINK_CONTROL_9__REG_LNK_INV_POLARITY                                  0x40
  // (ReadWrite, Bits 7) 
  // Only applies to MHL Tx (reg_lnk_arb_id = 0) and reg_lnk_xmit_bit_time_sel0 == 1'b1. 0: Tx use the calibrated bit time when calibration is done for initiator 1: Tx use the constantly-calibrated bit time for initiator
  #define BIT_MSK__CBUS_LINK_CONTROL_9__REG_LNK_XMIT_BIT_TIME_SEL1                            0x80

// CBUS_Link_Layer Control #10 Register
#define REG_ADDR__CBUS_LINK_CONTROL_10                                   (TX_CBUS_MSCAGENT_DISC | 0x00A9)
  // (ReadWrite, Bits 2:0) 
  // In normal operation mode; the max offset value that allows for the different between current sync pulse width and averaged sync pulse width.  Default value is 4. 
  #define BIT_MSK__CBUS_LINK_CONTROL_10__REG_LNK_CAL_SYNC_OFFSET                               0x07
  // (ReadWrite, Bits 5:3) 
  // In normal operation mode; the max offset value that allows for the different between current bit time and averaged bit time value.  Default value is 4. 
  #define BIT_MSK__CBUS_LINK_CONTROL_10__REG_LNK_CAL_BIT_OFFSET                                0x38
  // (ReadWrite, Bits 6) 
  // Select the bit time for undestanding the incoming packets 1: Use the register-programmed transmit bit time 0: Use the calibrated bit time
  #define BIT_MSK__CBUS_LINK_CONTROL_10__REG_LNK_RCV_BIT_TIME_SEL                              0x40
  // (ReadWrite, Bits 7) 
  // 1: Check parity and bi-phase error at the last byte of calication mode before leave calibration mode.   0: Do not check parity and bi-phase error before leave calibration mode. Default value 1
  #define BIT_MSK__CBUS_LINK_CONTROL_10__REG_LNK_CAL_ERROR_CHECK                               0x80

// CBUS_Link_Layer Control #11 Register
#define REG_ADDR__CBUS_LINK_CONTROL_11                                   (TX_CBUS_MSCAGENT_DISC | 0x00AA)
  // (ReadWrite, Bits 0) 
  // 1: Use CBUS edge transition to synchronize bit boundary in calibration mode 0: Use average bit time for bit boundary in calibration operation mode Default value is 1
  #define BIT_MSK__CBUS_LINK_CONTROL_11__REG_LNK_CAL_BDY_CTL                                   0x01
  // (ReadWrite, Bits 1) 
  // 1: Use CBUS edge transition to synchronize bit boundary in normal operation mode 0: Use average bit time for bit boundary in normal operation mode Default value is 0
  #define BIT_MSK__CBUS_LINK_CONTROL_11__REG_LNK_NORM_BDY_CTL                                  0x02
  // (ReadWrite, Bits 7:2) 
  // CBUS_Link_Layer retry limit. Default value is 0x20
  #define BIT_MSK__CBUS_LINK_CONTROL_11__REG_LNK_XMIT_RETRY_LIMIT                              0xFC

// CBUS Ack Control Register
#define REG_ADDR__CBUS_ACK_CONTROL                                       (TX_CBUS_MSCAGENT_DISC | 0x00AB)
  // (ReadWrite, Bits 2:0) 
  // CBUS_Link_Layer acknowlodge window size
  #define BIT_MSK__CBUS_ACK_CONTROL__REG_LNK_ACK_WIN_WIDTH                                 0x07

// CBUS Calibration Control Register
#define REG_ADDR__CBUS_CAL_CONTROL                                       (TX_CBUS_MSCAGENT_DISC | 0x00AC)
  // (ReadWrite, Bits 5:0) 
  // Number of the NACKs on the same packet to enter re-calibaration mode due to bit error. default value is 16 
  #define BIT_MSK__CBUS_CAL_CONTROL__REG_LNK_NACK_CNT_MAX                                  0x3F
  // (ReadWrite, Bits 6) 
  // 1: enable force re-calibration mode when NACK stucks at one packet for number of reg_lnk_nack_limit times due to bit error 0: disable force re-calibration mode 
  #define BIT_MSK__CBUS_CAL_CONTROL__REG_LNK_EN_CAL_BY_NACK                                0x40

// CBUS Link Layer Status #1 Register
#define REG_ADDR__CBUS_LINK_STATUS_0                                     (TX_CBUS_MSCAGENT_DISC | 0x00AD)
  // (ReadOnly, Bits 7:0) 
  // 1 bit time in number of clock used in receiving
  #define BIT_MSK__CBUS_LINK_STATUS_0__REG_LNK_RCV_BIT_TIME                                  0xFF

// CBUS Xmit ERR CNT Register
#define REG_ADDR__CBUS_XMIT_ERR_CNT                                      (TX_CBUS_MSCAGENT_DISC | 0x00AE)
  // (ReadWrite, Bits 6:0) 
  // Number of link transmission errors.
  #define BIT_MSK__CBUS_XMIT_ERR_CNT__REG_LNK_XMIT_ERR_COUNT                                0x7F

// CBUS Bi-Phase ERR CNT Register
#define REG_ADDR__CBUS_BIPHZ_ERR_CNT                                     (TX_CBUS_MSCAGENT_DISC | 0x00AF)
  // (ReadWrite, Bits 3:0) 
  // Bi phase error count in calibration mode; write 0s to clear
  #define BIT_MSK__CBUS_BIPHZ_ERR_CNT__REG_LNK_CAL_BIPHZ_ERR_CNT                             0x0F
  // (ReadWrite, Bits 7:4) 
  // Bi phase error count in normal operation mode; write 0s to clear
  #define BIT_MSK__CBUS_BIPHZ_ERR_CNT__REG_LNK_NORM_BIPHZ_ERR_CNT                            0xF0

// CBUS Parity ERR CNT Register
#define REG_ADDR__CBUS_PARITY_ERR_CNT                                    (TX_CBUS_MSCAGENT_DISC | 0x00B0)
  // (ReadWrite, Bits 3:0) 
  // Parity error count in calibration mode; write 0s to clear the register
  #define BIT_MSK__CBUS_PARITY_ERR_CNT__REG_LNK_CAL_PARITY_ERR_CNT                            0x0F
  // (ReadWrite, Bits 7:4) 
  // Parity error count in normal operation mode; write 0s to clear the register
  #define BIT_MSK__CBUS_PARITY_ERR_CNT__REG_LNK_RCV_ERR_COUNT                                 0xF0

// CBUS_Link_Layer Sync Filter Control #1 Register
#define REG_ADDR__CBUS_LINK_SYNC_CONTROL_1                               (TX_CBUS_MSCAGENT_DISC | 0x00B1)
  // (ReadWrite, Bits 3:0) 
  // Adjustments for lower bound to filter sync low time 
  #define BIT_MSK__CBUS_LINK_SYNC_CONTROL_1__REG_LNK_SYNC_LOW_MIN_OFFSET                           0x0F
  // (ReadWrite, Bits 7:4) 
  // Adjustments for upper bound to filter sync low time 
  #define BIT_MSK__CBUS_LINK_SYNC_CONTROL_1__REG_LNK_SYNC_LOW_MAX_OFFSET                           0xF0

// CBUS_Link_Layer Sync Filter Control #2 Register
#define REG_ADDR__CBUS_LINK_SYNC_CONTROL_2                               (TX_CBUS_MSCAGENT_DISC | 0x00B2)
  // (ReadWrite, Bits 3:0) 
  // Adjustments for lower bound to filter sync bit time 
  #define BIT_MSK__CBUS_LINK_SYNC_CONTROL_2__REG_LNK_SYNC_BIT_MIN_OFFSET                           0x0F
  // (ReadWrite, Bits 7:4) 
  // Adjustments for upper bound to filter sync bit time 
  #define BIT_MSK__CBUS_LINK_SYNC_CONTROL_2__REG_LNK_SYNC_BIT_MAX_OFFSET                           0xF0

// MDT State Machine Status Register
#define REG_ADDR__MDT_SM_STAT                                            (TX_CBUS_MSCAGENT_DISC | 0x00B5)
  // (ReadOnly, Bits 3:0) 
  // MDT transmit state machine state
  #define BIT_MSK__MDT_SM_STAT__REG_MDT_XMIT_STATE                                    0x0F
  // (ReadOnly, Bits 7:4) 
  // MDT receive state machine state
  #define BIT_MSK__MDT_SM_STAT__REG_MDT_RCV_STATE                                     0xF0

// MDT Peer Adopter ID Low Byte Register
#define REG_ADDR__MDT_PEER_ADOPER_ID_LOW                                 (TX_CBUS_MSCAGENT_DISC | 0x00B6)
  // (ReadWrite, Bits 7:0) 
  // MDT Peer Adopter ID low byte
  #define BIT_MSK__MDT_PEER_ADOPER_ID_LOW__REG_PEER_ADOPTER_ID_B7_B0                             0xFF

// MDT Peer Adopter ID High Byte Register
#define REG_ADDR__MDT_PEER_ADOPER_ID_HIGH                                (TX_CBUS_MSCAGENT_DISC | 0x00B7)
  // (ReadWrite, Bits 7:0) 
  // MDT Peer Adopter ID high byte
  #define BIT_MSK__MDT_PEER_ADOPER_ID_HIGH__REG_PEER_ADOPTER_ID_B15_B8                            0xFF

// CBUS MSC 2nd Transmit Data Register
#define REG_ADDR__MSC_2ND_TRANSMIT_DATA                                  (TX_CBUS_MSCAGENT_DISC | 0x00B8)
  // (ReadWrite, Bits 7:0) 
  // 2nd transmit data sent by MSC requester Only used for MSC_MSG 2nd data (DATA)
  #define BIT_MSK__MSC_2ND_TRANSMIT_DATA__REG_MSC_MT_DATA1                                      0xFF

// CBUS MSC 1st Transmit Data Register
#define REG_ADDR__MSC_1ST_TRANSMIT_DATA                                  (TX_CBUS_MSCAGENT_DISC | 0x00B9)
  // (ReadWrite, Bits 7:0) 
  // 1st transmit data sent by MSC requester 1. Used for WRITE_STAT/SET_INT transmit data  2. MSC_MSG 1st transmit data (CMD) 3. Used for DEBUG data
  #define BIT_MSK__MSC_1ST_TRANSMIT_DATA__REG_MSC_MT_DATA0                                      0xFF

// CBUS MSC Command/Offset Register
#define REG_ADDR__MSC_CMD_OR_OFFSET                                      (TX_CBUS_MSCAGENT_DISC | 0x00BA)
  // (ReadWrite, Bits 7:0) 
  // MSC command/offset. This register is used either as command opcode or offset for MSC commands 1. Used as command opcode when MSC_COMMAND_START register bit 0 is set 2. Used as offset when MSC_COMMAND_START register bit 2; 3; or 4 is set 3. Used as {header (2 bits); control (1 bit)} when MSC_COMMAND_START register bit 5 is set 
  #define BIT_MSK__MSC_CMD_OR_OFFSET__REG_MSC_MT_CMD_OR_OFFSET                              0xFF

// CBUS MSC command trigger Register
#define REG_ADDR__MSC_COMMAND_START                                      (TX_CBUS_MSCAGENT_DISC | 0x00BB)
  // (ReadWrite, Bits 0) 
  // Write 1 to trigger peer command including GET_STATE: GET_VENDOR_ID: SET_HPD: CLR_HPD: SET_CAP_ID: GET_CAP_ID: GET_VS_ABORT: GET_DDC_ABORT: GET_MSC_ABORT. Self-resetting to 0.
  #define BIT_MSK__MSC_COMMAND_START__REG_MSC_PEER_CMD                                      0x01
  // (ReadWrite, Bits 1) 
  // Write 1 to trigger MSC_MSG command
  #define BIT_MSK__MSC_COMMAND_START__REG_MSC_MSC_MSG_CMD                                   0x02
  // (ReadWrite, Bits 2) 
  // Write 1 to trigger READ_DEVCAP command. Self-resetting to 0.
  #define BIT_MSK__MSC_COMMAND_START__REG_MSC_READ_DEVCAP_CMD                               0x04
  // (ReadWrite, Bits 3) 
  // Write 1 to trigger WRITE_STAT/SET_INT command. Self-resetting to 0.
  #define BIT_MSK__MSC_COMMAND_START__REG_MSC_WRITE_STAT_CMD                                0x08
  // (ReadWrite, Bits 4) 
  // Write 1 to trigger WRITE_BURST command. Self-resetting to 0.
  #define BIT_MSK__MSC_COMMAND_START__REG_MSC_WRITE_BURST_CMD                               0x10
  // (ReadWrite, Bits 5) 
  // Write 1 to send a debug packet. {Header (2 bits): Control (1 bit)} = reg_msc_mt_cmd_or_offset[2:0]: Data = reg_msc_mt_data_cmd[7:0]. Self-resetting to 0.
  #define BIT_MSK__MSC_COMMAND_START__REG_MSC_DEBUG_CMD                                     0x20

// CBUS MSC Requester Received 1st Data Register
#define REG_ADDR__MSC_MT_RCVD_DATA0                                      (TX_CBUS_MSCAGENT_DISC | 0x00BC)
  // (ReadOnly, Bits 7:0) 
  // 1st data received by MSC requester
  #define BIT_MSK__MSC_MT_RCVD_DATA0__REG_MSC_MT_RCVD_DATA0                                 0xFF

// CBUS MSC Requester Received 2nd Data Register
#define REG_ADDR__MSC_MT_RCVD_DATA1                                      (TX_CBUS_MSCAGENT_DISC | 0x00BD)
  // (ReadOnly, Bits 7:0) 
  // 2nd data received by MSC requester
  #define BIT_MSK__MSC_MT_RCVD_DATA1__REG_MSC_MT_RCVD_DATA1                                 0xFF

// CBUS MSC Requester Received State Register
#define REG_ADDR__MSC_MT_RCVD_STATE                                      (TX_CBUS_MSCAGENT_DISC | 0x00BE)
  // (ReadOnly, Bits 7:0) 
  // Peer state received by MSC requester (GET_STATE)
  #define BIT_MSK__MSC_MT_RCVD_STATE__REG_MSC_MT_RCVD_STATE                                 0xFF

// CBUS MSC Responder MSC_MSG Received 1st Data Register
#define REG_ADDR__MSC_MR_MSC_MSG_RCVD_1ST_DATA                           (TX_CBUS_MSCAGENT_DISC | 0x00BF)
  // (ReadOnly, Bits 7:0) 
  // 1st received data from MSC_MSG
  #define BIT_MSK__MSC_MR_MSC_MSG_RCVD_1ST_DATA__REG_MSC_MR_MSC_MSG_RCVD_DATA0                         0xFF

// CBUS MSC Responder MSC_MSG Received Data Register
#define REG_ADDR__MSC_MR_MSC_MSG_RCVD_2ND_DATA                           (TX_CBUS_MSCAGENT_DISC | 0x00C0)
  // (ReadOnly, Bits 7:0) 
  // 2nd received data from MSC_MSG
  #define BIT_MSK__MSC_MR_MSC_MSG_RCVD_2ND_DATA__REG_MSC_MR_MSC_MSG_RCVD_DATA1                         0xFF

// CBUS MSC Responder Received Offset Register
#define REG_ADDR__MSC_MR_RCVD_OFFSET                                     (TX_CBUS_MSCAGENT_DISC | 0x00C1)
  // (ReadOnly, Bits 7:0) 
  // received offset for certain MSC commands. Apply to WRITE_STAT SET_INT WRITE_BURST and READ_DEVCAP.
  #define BIT_MSK__MSC_MR_RCVD_OFFSET__REG_MSC_MR_RCVD_OFFSET                                0xFF

// CBUS MSC Responder Rcvd Data Register
#define REG_ADDR__MSC_MR_RCVD_DATA                                       (TX_CBUS_MSCAGENT_DISC | 0x00C2)
  // (ReadOnly, Bits 7:0) 
  // received data for certain MSC commands. Apply to WRITE_STAT SET_INT WRITE_BURST (only the last data)
  #define BIT_MSK__MSC_MR_RCVD_DATA__REG_MSC_MR_RCVD_DATA                                  0xFF

// CBUS MSC Rcvd Data Cnt Register
#define REG_ADDR__MSC_RCVD_DATA_CNT                                      (TX_CBUS_MSCAGENT_DISC | 0x00C3)
  // (ReadOnly, Bits 4:0) 
  // received data count for MSC WRITE_BURST
  #define BIT_MSK__MSC_RCVD_DATA_CNT__REG_MSC_MR_RCVD_DATA_CNT                              0x1F

// CBUS MSC Heartbeat Control Register
#define REG_ADDR__MSC_HEARTBEAT_CONTROL                                  (TX_CBUS_MSCAGENT_DISC | 0x00C4)
  // (ReadWrite, Bits 3:0) 
  // Select the heart beat period. 4'h0: 3.125ms 4'h1: 6.25ms 4'h2: 10ms 4'h3: 12.5ms 4'h4: 20ms 4'h5: 25ms 4'h6: 37.5ms 4'h7: 50ms 4'h8: 75ms 4'h9: 100ms 4'hA: 125ms 4'hB: 150ms 4'hC: 200ms 4'hD: 250ms 4'hE: 300ms 4'hF: 400ms
  #define BIT_MSK__MSC_HEARTBEAT_CONTROL__REG_MSC_HB_PERIOD_MSB                                 0x0F
  // (ReadWrite, Bits 6:4) 
  // MSC heartbeat maximum number of consecutive fails  3'b000: 5'h01; 3'b001: 5'h02; 3'b010: 5'h04; 3'b011: 5'h06;  3'b100: 5'h08; 3'b101: 5'h0A; 3'b110: 5'h0C; 3'b111: 5'h0E;
  #define BIT_MSK__MSC_HEARTBEAT_CONTROL__REG_MSC_HB_FAIL_LIMIT                                 0x70
  // (ReadWrite, Bits 7) 
  // MSC heartbeat enable
  #define BIT_MSK__MSC_HEARTBEAT_CONTROL__REG_MSC_HB_EN                                         0x80

// CBUS MSC Heartbeat Fail Count Register
#define REG_ADDR__MSC_HEARTBEAT_FAIL_CNT                                 (TX_CBUS_MSCAGENT_DISC | 0x00C5)
  // (ReadWrite, Bits 4:0) 
  // MSC consecutive heartbeat fail count
  #define BIT_MSK__MSC_HEARTBEAT_FAIL_CNT__REG_MSC_HB_FAIL_CNT                                   0x1F
  // (ReadWrite, Bits 7) 
  // Enable heartbeat automatically after MHL discovered if reg_msc_hb_en (0xC4[7]) is set
  #define BIT_MSK__MSC_HEARTBEAT_FAIL_CNT__REG_HW_HB_EN                                          0x80

// CBUS MSC Write_Burst length Register
#define REG_ADDR__MSC_WRITE_BURST_DATA_LEN                               (TX_CBUS_MSCAGENT_DISC | 0x00C6)
  // (ReadWrite, Bits 3:0) 
  // The number of data bytes to be transmitted for MSC WRITE_BURST. 0 means 1 byte to transmit and 4'b1111 means 16 bytes to transmit.
  #define BIT_MSK__MSC_WRITE_BURST_DATA_LEN__REG_MSC_WRITE_BURST_LEN                               0x0F

// CBUS MSC Compatibility Control Register
#define REG_ADDR__CBUS_MSC_COMPATIBILITY_CONTROL                         (TX_CBUS_MSCAGENT_DISC | 0x00C7)
  // (ReadWrite, Bits 2) 
  // Disable GET_VS1_ERRORCODE
  #define BIT_MSK__CBUS_MSC_COMPATIBILITY_CONTROL__REG_DISABLE_GET_VS1_ERRORCODE                         0x04
  // (ReadWrite, Bits 3) 
  // Disable GET_DDC_ERRORCODE
  #define BIT_MSK__CBUS_MSC_COMPATIBILITY_CONTROL__REG_DISABLE_GET_DDC_ERRORCODE                         0x08
  // (ReadWrite, Bits 5) 
  // Disable DDC on CBUS
  #define BIT_MSK__CBUS_MSC_COMPATIBILITY_CONTROL__REG_DISABLE_DDC_ON_CBUS                               0x20
  // (ReadWrite, Bits 6) 
  // Disable MSC on CBUS
  #define BIT_MSK__CBUS_MSC_COMPATIBILITY_CONTROL__REG_DISABLE_MSC_ON_CBUS                               0x40
  // (ReadWrite, Bits 7) 
  // Enable READ_XDEVCAP and WRITE_STAT/SET_INT for extended offset no matter MHL3 or MHL1/2
  #define BIT_MSK__CBUS_MSC_COMPATIBILITY_CONTROL__REG_XDEVCAP_EN                                        0x80

// CBUS DDC Abort Reason Register
#define REG_ADDR__DDC_ERRORCODE                                          (TX_CBUS_MSCAGENT_DISC | 0x00CB)
  // (ReadWrite, Bits 7:0) 
  // DDC error code that can be fetched over CBUS by GET_DDC_ERRORCODE
  #define BIT_MSK__DDC_ERRORCODE__REG_DDC_ERRORCODE                                     0xFF

// CBUS MSC Abort Reason Register
#define REG_ADDR__MSC_ERRORCODE                                          (TX_CBUS_MSCAGENT_DISC | 0x00CC)
  // (ReadWrite, Bits 7:0) 
  // MSC error code that can be fetched over CBUS by GET_MSC_ERRORCODE
  #define BIT_MSK__MSC_ERRORCODE__REG_MSC_ERRORCODE                                     0xFF

// CBUS DDC Fail Limit Register
#define REG_ADDR__CBUS_DDC_FAIL_LIMIT                                    (TX_CBUS_MSCAGENT_DISC | 0x00CE)
  // (ReadWrite, Bits 3:0) 
  // The total number of translation layer retry allowed for DDC before declaring a max fail.
  #define BIT_MSK__CBUS_DDC_FAIL_LIMIT__REG_DDC_RETRY_FAIL_LIMIT                              0x0F

// CBUS MSC Fail Limit Register
#define REG_ADDR__CBUS_MSC_FAIL_LIMIT                                    (TX_CBUS_MSCAGENT_DISC | 0x00CF)
  // (ReadWrite, Bits 3:0) 
  // The total number of translation layer retry allowed for MSC before declaring a max fail.
  #define BIT_MSK__CBUS_MSC_FAIL_LIMIT__REG_MSC_RETRY_FAIL_LIMIT                              0x0F

// CBUS DDC Time Out Register
#define REG_ADDR__DDC_TIMEOUT                                            (TX_CBUS_MSCAGENT_DISC | 0x00D1)
  // (ReadWrite, Bits 7:0) 
  // DDC time out thereshold MSB (increment of 1048576 clocks)
  #define BIT_MSK__DDC_TIMEOUT__REG_DDC_TIMEOUT_MAX_MSB                               0xFF

// CBUS MSC Time Out Register
#define REG_ADDR__MSC_TIMEOUT                                            (TX_CBUS_MSCAGENT_DISC | 0x00D2)
  // (ReadWrite, Bits 7:0) 
  // MSC time out threshold MSB (increment of 1048576 clocks)
  #define BIT_MSK__MSC_TIMEOUT__REG_MSC_TIMEOUT_MAX_MSB                               0xFF

// CBUS DDC Retry Interval Register
#define REG_ADDR__DDC_RETRY_INTERVAL                                     (TX_CBUS_MSCAGENT_DISC | 0x00D4)
  // (ReadWrite, Bits 7:0) 
  // The idle time MSB for DDC translation layer retry (increment of 512 clocks)
  #define BIT_MSK__DDC_RETRY_INTERVAL__REG_DDC_RETRY_MAX_MSB                                 0xFF

// CBUS MSC Retry Interval Register
#define REG_ADDR__MSC_RETRY_INTERVAL                                     (TX_CBUS_MSCAGENT_DISC | 0x00D5)
  // (ReadWrite, Bits 7:0) 
  // The idle time MSB for MSC translation layer retry (increment of 512 clocks)
  #define BIT_MSK__MSC_RETRY_INTERVAL__REG_MSC_RETRY_MAX_MSB                                 0xFF

// CBUS DDC Master Speed Control Register
#define REG_ADDR__CBUS_DDC_SPEED_CONTROL                                 (TX_CBUS_MSCAGENT_DISC | 0x00D6)
  // (ReadWrite, Bits 7:0) 
  // CBUS DDC master speed control. tLOW = 2 * (reg_ddc_speed_ctrl + 1) * clock period. tHIGH = (2 * (reg_ddc_speed_ctrl  + 1)  + 4) * clock period
  #define BIT_MSK__CBUS_DDC_SPEED_CONTROL__REG_DDC_SPEED_CTRL                                    0xFF

// CBUS DDC START STOP Timing Control Register
#define REG_ADDR__CBUS_DDC_ST_SP_TIMING_CONTROL                          (TX_CBUS_MSCAGENT_DISC | 0x00D7)
  // (ReadWrite, Bits 3:0) 
  // CBUS DDC master tSU;STA control. tSU;STA = (reg_ddc_sp_timing_ctrl * 16 + 1) * 2 * clock_period
  #define BIT_MSK__CBUS_DDC_ST_SP_TIMING_CONTROL__REG_DDC_ST_TIMING_CTRL                                0x0F
  // (ReadWrite, Bits 7:4) 
  // CBUS DDC master tSU;STO control. tSU;STO = (reg_ddc_sp_timing_ctrl * 16 + 5) * clock_period
  #define BIT_MSK__CBUS_DDC_ST_SP_TIMING_CONTROL__REG_DDC_SP_TIMING_CTRL                                0xF0

// CBUS MISC Control Register
#define REG_ADDR__CBUS_MISC_CONTROL                                      (TX_CBUS_MSCAGENT_DISC | 0x00D8)
  // (ReadWrite, Bits 0) 
  // Enable Ri prefetch when upstream DDC master is trying to read Ri.
  #define BIT_MSK__CBUS_MISC_CONTROL__REG_RI_PREFETCH_EN                                    0x01
  // (ReadWrite, Bits 2) 
  // When is not set: block cbus device capability register DEV_CAT to be changed by FW
  #define BIT_MSK__CBUS_MISC_CONTROL__REG_DEV_CAT_OVR                                       0x04
  // (ReadWrite, Bits 3) 
  // When enabled: enhance the performance when CBUS slew rate is not good.
  #define BIT_MSK__CBUS_MISC_CONTROL__REG_SLOW_SL_ENH                                       0x08

// CBUS MISC Control Register
#define REG_ADDR__CBUS_RCVD_PAYLOAD                                      (TX_CBUS_MSCAGENT_DISC | 0x00D9)
  // (ReadOnly, Bits 7:0) 
  // payload for last received CBUS packet
  #define BIT_MSK__CBUS_RCVD_PAYLOAD__REG_CBUS_RCVD_PAYLOAD                                 0xFF

// CBUS MISC Control Register
#define REG_ADDR__CBUS_RCVD_HC                                           (TX_CBUS_MSCAGENT_DISC | 0x00DA)
  // (ReadOnly, Bits 2:0) 
  // header and control for last received CBUS packet
  #define BIT_MSK__CBUS_RCVD_HC__REG_CBUS_RCVD_HC                                      0x07

// CBUS DDC EDID Slave Address Register
#define REG_ADDR__CBUS_DDC_EDID                                          (TX_CBUS_MSCAGENT_DISC | 0x00DB)
  // (ReadWrite, Bits 7:0) 
  // cbus edid access slave address configuration
  #define BIT_MSK__CBUS_DDC_EDID__REG_CBUS_DDC_EDID_ADDR                                0xFF

// CBUS1 Converter Control Register
#define REG_ADDR__CBUS1_CNVT                                             (TX_CBUS_MSCAGENT_DISC | 0x00DC)
  // (ReadWrite, Bits 0) 
  // Enable bit for cbus1 Converter.
  #define BIT_MSK__CBUS1_CNVT__REG_CBUS1CNVT_EN                                      0x01
  // (ReadWrite, Bits 1) 
  // Enable bit to tear down CBUS if not needed.
  #define BIT_MSK__CBUS1_CNVT__REG_TEARCBUS_EN                                       0x02
  // (ReadWrite, Bits 3:2) 
  // Peer TDM No ACK/NAK timeout select. 00: 2k TDM cycles; 01: 4k; 10: 8k; 11: 16k 
  #define BIT_MSK__CBUS1_CNVT__REG_CBUS1_PEERTOUT_SEL                                0x0C
  // (ReadWrite, Bits 7:4) 
  // Retry limit for cbus1 transmit. Default is 11 for Source and 9 for Sink. Granularity is 4. Source will retry for (reg_cbus1_retrylmt*4+3) times. Sink will retry for (reg_cbus1_retrylmt*4+1) times.
  #define BIT_MSK__CBUS1_CNVT__REG_CBUS1_RETRYLMT                                    0xF0

// CBUS1 Converter INTR Register
#define REG_ADDR__CBUS1_INTR                                             (TX_CBUS_MSCAGENT_DISC | 0x00DD)
  // (ReadWrite, Bits 0) 
  // cbus1 Interrupt Event 0; local TDM timeout
  #define BIT_MSK__CBUS1_INTR__REG_CBUS1_INTR_0                                      0x01
  // (ReadWrite, Bits 1) 
  // cbus1 Interrupt Event 1; peer TDM timeout
  #define BIT_MSK__CBUS1_INTR__REG_CBUS1_INTR_1                                      0x02
  // (ReadWrite, Bits 2) 
  // cbus1 Interrupt Event 2; Header collision detected
  #define BIT_MSK__CBUS1_INTR__REG_CBUS1_INTR_2                                      0x04

// CBUS1 Converter INTRMASK Register
#define REG_ADDR__CBUS1_INTRMASK                                         (TX_CBUS_MSCAGENT_DISC | 0x00DE)
  // (ReadWrite, Bits 0) 
  // cbus1 Interrupt Mask bit for Event 0
  #define BIT_MSK__CBUS1_INTRMASK__REG_CBUS1_INTRMASK_0                                  0x01
  // (ReadWrite, Bits 1) 
  // cbus1 Interrupt Mask bit for Event 1
  #define BIT_MSK__CBUS1_INTRMASK__REG_CBUS1_INTRMASK_1                                  0x02
  // (ReadWrite, Bits 2) 
  // cbus1 Interrupt Mask bit for Event 2
  #define BIT_MSK__CBUS1_INTRMASK__REG_CBUS1_INTRMASK_2                                  0x04

// CBUS1 Converter Status Register
#define REG_ADDR__CBUS1_STATUS                                           (TX_CBUS_MSCAGENT_DISC | 0x00DF)
  // (ReadWrite, Bits 4:0) 
  // cbus1 Arbiter state.
  #define BIT_MSK__CBUS1_STATUS__REG_CBUS1_STATE                                       0x1F
  // (ReadWrite, Bits 7) 
  // TDM 8bit Interface enable bit.
  #define BIT_MSK__CBUS1_STATUS__REG_TDM8BIF_EN                                        0x80

// Discovery Control1 Register
#define REG_ADDR__DISC_CTRL1                                             (TX_CBUS_MSCAGENT_DISC | 0x00E0)
  // (ReadWrite, Bits 0) 
  // CBUS device discovery enable bit. 0 - discovery is disabled (default). 1 - discovery is enabled.
  #define BIT_MSK__DISC_CTRL1__REG_DISC_EN                                           0x01
  // (ReadWrite, Bits 3:2) 
  // CBUS discovery cycle time for each drive and float 00: 50us 01: 100us (default) 10: 150us 11: 200us
  #define BIT_MSK__DISC_CTRL1__REG_DISC_CYC                                          0x0C
  // (ReadWrite, Bits 5:4) 
  // Number of sending discovery pulses from TX 00: 10 01: 20 10: 30 11: 40
  #define BIT_MSK__DISC_CTRL1__REG_DISC_ATT                                          0x30
  // (ReadWrite, Bits 6) 
  // Set to make MHL RxSense equal to heartbeat. If both this bit and 0xE1[5] are not set; MHL RxSense is equal to TMDS RxSense
  #define BIT_MSK__DISC_CTRL1__REG_HB_ONLY                                           0x40
  // (ReadWrite, Bits 7) 
  // Cbus interrupt enable bit. When set 1; latched cbus falling edge will generate interrupt. This interrupt can only be cleared by HW reset. Default is 0.
  #define BIT_MSK__DISC_CTRL1__REG_CBUS_INTR_EN                                      0x80

// Discovery Control2 Register
#define REG_ADDR__DISC_CTRL2                                             (TX_CBUS_MSCAGENT_DISC | 0x00E1)
  // (ReadWrite, Bits 0) 
  // Enable CBUS communication channel running at 125KHz 1- Enable 0- Disable (default)
  #define BIT_MSK__DISC_CTRL2__REG_CBUS125K_EN                                       0x01
  // (ReadWrite, Bits 1) 
  // Indicate whether 125KHz clock for CBUS communication channel be enabled through SW or HW 1- Enable 125KHz through SW (reg_cbus12k_en) (default) 0-Enable 125KHz through HW
  #define BIT_MSK__DISC_CTRL2__REG_CBUS125K_SWOVRIDE                                 0x02
  // (ReadWrite, Bits 3) 
  // Enable internal 100K pull-up.  Default: 1  0  Disable  1  Enable(default)  This bit is reused as USB switch select normal drive high/low control; active low (reg_usb_d_oen). 0: usb_d_sw is output to CI2CA with polarity control from reg_ci2ca_pol; 1: disabled (default)
  #define BIT_MSK__DISC_CTRL2__REG_CBUS100K_EN                                       0x08
  // (ReadWrite, Bits 5) 
  // If 0xE0[6] is not set; set to make MHL RxSense equal to Heartbeat (oCBUS) OR link activity check. If both this bit and 0xE0[6] are not set; MHL RxSense is equal to TMDS RxSense. 
  #define BIT_MSK__DISC_CTRL2__REG_HB_LCC_BOTH                                       0x20
  // (ReadWrite, Bits 6) 
  // To skip RGND detection on TX side if this bit is enabled. =0 (default): detection is conducted; =1: detection is skipped;
  #define BIT_MSK__DISC_CTRL2__REG_SKIP_RGND                                         0x40
  // (ReadWrite, Bits 7) 
  // CBUS delay trigger enable bit. When this bit is enable; a watch dog is triggered upon CBUS_PON; and CBUS reset is activated till the expiration of the timer. 0: Disable 1: Enable (default)
  #define BIT_MSK__DISC_CTRL2__REG_DLYTRG_EN                                         0x80

// Discovery Control3 Register
#define REG_ADDR__DISC_CTRL3                                             (TX_CBUS_MSCAGENT_DISC | 0x00E2)
  // (ReadWrite, Bits 3:0) 
  // Wait time after RGND interrupt cleared before SM transitions to the next state in the unit of ms for VBUS_CBUS_STABLE. 4'h0: 0;  4'h1: 1;    4'h2: 2;    4'h3: 4;  4'h4: 8;  4'h5: 64; 4'h6: 105  -- default value  4'h7: 112 4'h8: 128  4'h9: 144 4'hA: 160 4'hB: 176 4'hC: 192 4'hD: 208 4'hE: 224 4'hF: 378 
  #define BIT_MSK__DISC_CTRL3__REG_VBUS_WAITTIME                                     0x0F
  // (ReadWrite, Bits 5) 
  // Simulation mode for CBUS discovery. When enabled; time constant used by CBUS Disc is shortened. 0: disable (default) 1: enable
  #define BIT_MSK__DISC_CTRL3__REG_DISC_SIMODE                                       0x20
  // (ReadWrite, Bits 6) 
  // Forced MHL mode. This bit controls both usb_id_on and usb_d_on signals of the USB switch at the same time. 1 - MHL mode is forced true 0 - Not to force MHL mode. The mode is established based on CBUS discovery (default).
  #define BIT_MSK__DISC_CTRL3__REG_FORCE_MHL                                         0x40
  // (ReadWrite, Bits 7) 
  // This bit controls immediate communication of CBUS after MHL discovered or hold until micro allows to do so. =1 (default); immediate communication; =0: on hold till micro allows it;
  #define BIT_MSK__DISC_CTRL3__REG_COMM_IMME                                         0x80

// Discovery Control4 Register
#define REG_ADDR__DISC_CTRL4                                             (TX_CBUS_MSCAGENT_DISC | 0x00E3)
  // (ReadWrite, Bits 3:0) 
  // Wait time for wake up before SM transitions to the next state in the unit of ms for WAKE_TO_DISCOVER. 4'h0: 0;  4'h1: 1;    4'h2: 2;    4'h3: 4;  4'h4: 8;  4'h5: 64; 4'h6: 105  -- default value  4'h7: 112 4'h8: 128  4'h9: 144 4'hA: 160 4'hB: 176 4'hC: 192 4'hD: 208 4'hE: 224 4'hF: 378
  #define BIT_MSK__DISC_CTRL4__REG_WAKEUP_WAITTIME                                   0x0F
  // (ReadWrite, Bits 5:4) 
  // CBUS Pull Up select for IDLE states 00 (default): Off 01: 20k 10: 10k 11: 5k
  #define BIT_MSK__DISC_CTRL4__REG_CBUSIDLE_PUP_SEL                                  0x30
  // (ReadWrite, Bits 7:6) 
  // CBUS Pull Up select for discovery states 00 : Off 01: 20k 10(default): 10k 11: 5k
  #define BIT_MSK__DISC_CTRL4__REG_CBUSDISC_PUP_SEL                                  0xC0

// Discovery Control5 Register
#define REG_ADDR__DISC_CTRL5                                             (TX_CBUS_MSCAGENT_DISC | 0x00E4)
  // (ReadWrite, Bits 1:0) 
  // CBUS Pull Up select for MHL states 00: Off 01: 20k 10: 10k 11: 5k (default)
  #define BIT_MSK__DISC_CTRL5__REG_CBUSMHL_PUP_SEL                                   0x03
  // (ReadWrite, Bits 3) 
  // Discovery State Machine override. Default is 0. When enable;Discovery SM is forced by FM at reg_disc_sm[4:0].
  #define BIT_MSK__DISC_CTRL5__REG_DSM_OVRIDE                                        0x08

// Discovery Control6 Register
#define REG_ADDR__DISC_CTRL6                                             (TX_CBUS_MSCAGENT_DISC | 0x00E5)
  // (ReadWrite, Bits 0) 
  // Single discovery attempt. When this bit is enable; MHL will establish if CBUS stays high after first drive and float.  When disable; multiple attempts are needed. Default is 1.
  #define BIT_MSK__DISC_CTRL6__REG_SINGLE_ATT                                        0x01
  // (ReadWrite, Bits 1) 
  // This is enable bit to allow CI2CA serve as a wake up signal at D3; if MCU needs to wake up  quietly. 0 - disable (default) 1 - enable
  #define BIT_MSK__DISC_CTRL6__REG_CI2CA_WKUP                                        0x02
  // (ReadWrite, Bits 2) 
  // This bit indicates the polarity of CI2CA wake up pulse. 0 - wake up pulse active high (default) 1 - wake up pulse active low  This bit has second definition to control the polarity for the option to output USB switch select on CI2CA. When this feature is on through reg_usb_d_oen or reg_use_d_odn; this is the definition: 0: CI2CA output LOW means USB and output HIGH means MHL(default); 1: CI2CA output LOW means MHL and output HIGH means USB; 
  #define BIT_MSK__DISC_CTRL6__REG_CI2CA_POL                                         0x04
  // (ReadWrite, Bits 4) 
  // This bit indicates whether to block RGND INT in Discovery SM. When set block; after interrupt clear; reg_drvflt_sel will decide whether to go to DRV_FLT or to USB_ESTABLISHED state. 0 - no block  1 - block (default)
  #define BIT_MSK__DISC_CTRL6__REG_BLOCK_RGNDINT                                     0x10

// Discovery Control7 Register
#define REG_ADDR__DISC_CTRL7                                             (TX_CBUS_MSCAGENT_DISC | 0x00E6)
  // (ReadWrite, Bits 1:0) 
  // This register defines the way to interprete RGND. 00 - only 1k is considered MHL impedance value (default) 01 - only 2k is considered MHL impedance value  10 - both 1k and 2k are considered MHL impedance value 11 - invalid
  #define BIT_MSK__DISC_CTRL7__REG_RGND_INTP                                         0x03
  // (ReadWrite, Bits 3) 
  // This bit defines CTRL BUS debug mode. When enable; CTRL BUS related signals will map to GPIO pins (GPIO4 is for cbus_out and GPIO5 is for cbus_oe). 0: disable (default) 1: enable
  #define BIT_MSK__DISC_CTRL7__REG_CBUS_DBGMODE                                      0x08
  // (ReadWrite, Bits 6) 
  // This bit controls CtrlBUS level from SW or HW. 0: from HW (default) 1: from register bit reg_cbuslvl_val
  #define BIT_MSK__DISC_CTRL7__REG_CBUSLVL_SW                                        0x40
  // (ReadWrite, Bits 7) 
  // This bit controls CtrlBUS level at SW mode. 0: level 0 (default) 1: level 1
  #define BIT_MSK__DISC_CTRL7__REG_CBUSLVL_VAL                                       0x80

// Discovery Control8 Register
#define REG_ADDR__DISC_CTRL8                                             (TX_CBUS_MSCAGENT_DISC | 0x00E7)
  // (ReadWrite, Bits 0) 
  // Delay CBUS discovery related interrupt until internally generated reset go high when enabled
  #define BIT_MSK__DISC_CTRL8__REG_DELAY_CBUS_INTR_EN                                0x01
  // (ReadWrite, Bits 7) 
  // Allow state go from NOMHL_EST to IDLE  without waiting for nomhlint_clr
  #define BIT_MSK__DISC_CTRL8__REG_NOMHLINT_CLR_BYPASS                               0x80

// Discovery Control9 Register
#define REG_ADDR__DISC_CTRL9                                             (TX_CBUS_MSCAGENT_DISC | 0x00E8)
  // (ReadWrite, Bits 0) 
  // VBUS Output Capability Source 0: No OTG. No need to monitor VBUS level 1: OTG. Need to monitor if VBUS is high for 100ms to 1000ms
  #define BIT_MSK__DISC_CTRL9__REG_VBUS_OUTPUT_CAPABILITY_SRC                        0x01
  // (ReadWrite, Bits 1) 
  // Wake pulse bypass 0: wake pulse sequence will be generated (default) 1: wake pulse sequence will be bypassed and not generated
  #define BIT_MSK__DISC_CTRL9__REG_WAKE_PULSE_BYPASS                                 0x02
  // (ReadWrite, Bits 2) 
  // Discovery pulse proceed 0: discovery pulse will not be generated after wake pulse sequence 1: discovery pulse will be generated after wake pulse sequence (default)
  #define BIT_MSK__DISC_CTRL9__REG_DISC_PULSE_PROCEED                                0x04
  // (ReadWrite, Bits 3) 
  // NO MHL establish 0: NOMHL not establish (default) 1: NOMHL establish
  #define BIT_MSK__DISC_CTRL9__REG_NOMHL_EST                                         0x08
  // (ReadWrite, Bits 4) 
  // 0: float low for wake pulse  1: drive low for wake pulse (default)
  #define BIT_MSK__DISC_CTRL9__REG_WAKE_DRVFLT                                       0x10

// Discovery Control10 Register
#define REG_ADDR__DISC_CTRL10                                            (TX_CBUS_MSCAGENT_DISC | 0x00E9)
  // (ReadWrite, Bits 7:0) 
  // TSRC:WAKE_PULSE_WIDTH_1
  #define BIT_MSK__DISC_CTRL10__REG_TSRC_WAKE_PULSE_WIDTH_1                           0xFF

// Discovery Control11 Register
#define REG_ADDR__DISC_CTRL11                                            (TX_CBUS_MSCAGENT_DISC | 0x00EA)
  // (ReadWrite, Bits 7:0) 
  // TSRC:WAKE_PULSE_WIDTH_2
  #define BIT_MSK__DISC_CTRL11__REG_TSRC_WAKE_PULSE_WIDTH_2                           0xFF

// Discovery Status1 Register
#define REG_ADDR__DISC_STAT1                                             (TX_CBUS_MSCAGENT_DISC | 0x00EB)
  // (ReadWrite, Bits 3:0) 
  // Discovery State Machine read back
  #define BIT_MSK__DISC_STAT1__REG_DISC_SM                                           0x0F
  // (ReadWrite, Bits 5) 
  // Power State Machine override. Default is 0. When enable; Power SM is forced by FM by reg_pwr_sm[1:0].
  #define BIT_MSK__DISC_STAT1__REG_PSM_OVRIDE                                        0x20

// Discovery Status2 Register
#define REG_ADDR__DISC_STAT2                                             (TX_CBUS_MSCAGENT_DISC | 0x00EC)
  // (ReadOnly, Bits 1:0) 
  // RGND status 00: open 01: 2k 10: 1k 11: short
  #define BIT_MSK__DISC_STAT2__REG_RGND                                              0x03
  // (ReadOnly, Bits 4) 
  // receiver sense
  #define BIT_MSK__DISC_STAT2__REG_RSEN                                              0x10
  // (ReadOnly, Bits 5) 
  // CBUS level status
  #define BIT_MSK__DISC_STAT2__REG_CBUS_SATUS                                        0x20
  // (ReadWrite, Bits 6) 
  // CBUS_OE polarity
  #define BIT_MSK__DISC_STAT2__REG_CBUS_OE_POL                                       0x40

// Interrupt CBUS_reg1 INTR0 Register
#define REG_ADDR__CBUS_DISC_INTR0                                        (TX_CBUS_MSCAGENT_DISC | 0x00ED)
  // (ReadWrite, Bits 0) 
  // cbus level toggle interrupt for all MHL modes. It is desired to know when cbus level changes and keep the value for some certain clock periods.
  #define BIT_MSK__CBUS_DISC_INTR0__REG_CBUS_DISC_INTR0_STAT0                             0x01
  // (ReadWrite, Bits 2) 
  // MHL mode established. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__CBUS_DISC_INTR0__REG_CBUS_DISC_INTR0_STAT2                             0x04
  // (ReadWrite, Bits 3) 
  // Not MHL mode established. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__CBUS_DISC_INTR0__REG_CBUS_DISC_INTR0_STAT3                             0x08
  // (ReadWrite, Bits 5) 
  // CBUS (MHL) disconnect. Write 1 to clear.
  #define BIT_MSK__CBUS_DISC_INTR0__REG_CBUS_DISC_INTR0_STAT5                             0x20
  // (ReadWrite, Bits 6) 
  // RGND Detection is done and RGND is available for read.
  #define BIT_MSK__CBUS_DISC_INTR0__REG_CBUS_DISC_INTR0_STAT6                             0x40

// Interrupt CBUS_reg1 INTR0 Mask Register
#define REG_ADDR__CBUS_DISC_INTR0_MASK                                   (TX_CBUS_MSCAGENT_DISC | 0x00EE)
  // (ReadWrite, Bits 0) 
  // Enable INT[1]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_DISC_INTR0_MASK__REG_CBUS_DISC_INTR0_MASK0                             0x01
  // (ReadWrite, Bits 2) 
  // Enable INT[2]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_DISC_INTR0_MASK__REG_CBUS_DISC_INTR0_MASK2                             0x04
  // (ReadWrite, Bits 3) 
  // Enable INT[3]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_DISC_INTR0_MASK__REG_CBUS_DISC_INTR0_MASK3                             0x08
  // (ReadWrite, Bits 5) 
  // Enable INT[5]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_DISC_INTR0_MASK__REG_CBUS_DISC_INTR0_MASK5                             0x20
  // (ReadWrite, Bits 6) 
  // Enable INT[6]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__CBUS_DISC_INTR0_MASK__REG_CBUS_DISC_INTR0_MASK6                             0x40

// MHL TX Test Control Register
#define REG_ADDR__MHLTX_TESTCTRL                                         (TX_CBUS_MSCAGENT_DISC | 0x00EF)
  // (ReadWrite, Bits 0) 
  // Set to 1'b1 to reset CBUS Discovery
  #define BIT_MSK__MHLTX_TESTCTRL__REG_CBUS_DISC_RST                                     0x01
  // (ReadWrite, Bits 5) 
  // Evaluation Mode
  #define BIT_MSK__MHLTX_TESTCTRL__REG_EVAL_MODE                                         0x20

// Tx Discovery Aggregated Interrupt Status Register
#define REG_ADDR__DISC_TX_AGGREGATED_INTR_STAT                           (TX_CBUS_MSCAGENT_DISC | 0x00F0)
  // (ReadOnly, Bits 0) 
  // Tx discovery aggregated interrupt status
  #define BIT_MSK__DISC_TX_AGGREGATED_INTR_STAT__REG_CBUS_DISC_TX_INTR_STAT                            0x01

//***************************************************************************
// TX_TPI. Address: 60
// TPI DTD Byte7 Register
#define REG_ADDR__TPI_MISC                                               (TX_TPI | 0x0007)
  // (ReadWrite, Bits 0) 
  // Select the event to trigger the interrupt at 0x3D[2] 1: Interrupt will be asserted only after both BKSV and BCAPS are read successfully 0: Interrupt will be asserted after BKSV is read successfully
  #define BIT_MSK__TPI_MISC__REG_ONLY_BKSV_DONE_SEL                                0x01

// TPI Pixel Repetition Data Register
#define REG_ADDR__TPI_PRD                                                (TX_TPI | 0x0008)
  // (ReadWrite, Bits 1:0) 
  // Clock mode register bits 00 = Pixel data is not replicated (default).   01 = Pixels are replicated once.   11 = Pixels are replicated four times.   10 = rsvd.   (Note: Whatever is programmed into these 2 bits is also the value to program into the pixel replication field of the AVI v2 data byte 5 if the EnDeMux bit is clear (register 0x4A bit 1). Use the next higher entry if EnDeMux is set. )
  #define BIT_MSK__TPI_PRD__REG_ICLK                                              0x03
  // (ReadWrite, Bits 4) 
  // Edge Select (same function as EDGE pin)                                                  0  Input data is falling edge latched (falling edge latched first in dual edge mode)                                                                                                       1  Input data is rising edge latched (rising edge latched first in dual edge mode)
  #define BIT_MSK__TPI_PRD__REG_EDGE                                              0x10

// Input Format Register
#define REG_ADDR__TPI_INPUT                                              (TX_TPI | 0x0009)
  // (ReadWrite, Bits 1:0) 
  // 00 = RGB 01 = YCbCr 4:4:4 10 = YCbCr 4:2:2 11 = Internal RGB solid color (from blank register bytes)
  #define BIT_MSK__TPI_INPUT__REG_INPUT_FORMAT                                      0x03
  // (ReadWrite, Bits 3:2) 
  // 00 = Auto-selected by [1:0] 01 = Full range (0-255) 10 = Limited range (16-235) 11 = Rsvd
  #define BIT_MSK__TPI_INPUT__REG_INPUT_QUAN_RANGE                                  0x0C

// Output Format Register
#define REG_ADDR__TPI_OUTPUT                                             (TX_TPI | 0x000A)
  // (ReadWrite, Bits 1:0) 
  // 00 = HDMI to RGB 01 = HDMI to YCbCr 4:4:4 10 = HDMI to YCbCr 4:2:2 11 = DVI to RGB
  #define BIT_MSK__TPI_OUTPUT__REG_OUTPUT_FORMAT                                     0x03
  // (ReadWrite, Bits 3:2) 
  // 00 = Auto-selected by [1:0] 01 = Full range (0-255) 10 = Limited range (16-235) 11 = Rsvd
  #define BIT_MSK__TPI_OUTPUT__REG_OUTPUT_QUAN_RANGE                                 0x0C

// TPI AVI Check Sum Register
#define REG_ADDR__TPI_AVI_CHSUM                                          (TX_TPI | 0x000C)
  // (ReadWrite, Bits 7:0) 
  // AVI InfoFrame Checksum (also pre loads AVI Header to 0x0282; and AVI Length to 13)
  #define BIT_MSK__TPI_AVI_CHSUM__TPI_AVI_CHSUM                                         0xFF

// TPI AVI Data Byte 1 Register
#define REG_ADDR__TPI_AVI_BYTE1                                          (TX_TPI | 0x000D)
  // (ReadWrite, Bits 7:0) 
  // Bit[1:0] = S1:0 scan information Bit[3:2] = B1:0 bar info data valid Bit[4] = A0 active info Bit[6:5] = Y1:0 RGB/YCbCr Indicator Bit[7] = reserved
  #define BIT_MSK__TPI_AVI_BYTE1__TPI_AVI_BYTE1                                         0xFF

// TPI AVI Data Byte 2 Register
#define REG_ADDR__TPI_AVI_BYTE2                                          (TX_TPI | 0x000E)
  // (ReadWrite, Bits 7:0) 
  // Bit[3:0] = R 3:0 active format aspect ratio Bit[5:4] = M 1:0 picture aspect ratio Bit[7:6] = C 1:0 colorimetry info
  #define BIT_MSK__TPI_AVI_BYTE2__TPI_AVI_BYTE2                                         0xFF

// TPI AVI Data Byte 3 Register
#define REG_ADDR__TPI_AVI_BYTE3                                          (TX_TPI | 0x000F)
  // (ReadWrite, Bits 7:0) 
  // Bit[1:0] = SC 1:0 non-uniform scaling Bit[3:2] = Q 1:0 RGB Quantization Range Bit[6:4] = ES 2:0 Extended Colorimetry Bit[7] = ITC IT Content
  #define BIT_MSK__TPI_AVI_BYTE3__TPI_AVI_BYTE3                                         0xFF

// TPI AVI Data Byte 4 Register
#define REG_ADDR__TPI_AVI_BYTE4                                          (TX_TPI | 0x0010)
  // (ReadWrite, Bits 7:0) 
  // Bit[6:0] = VIC 6:0 video format identification code Bit[7] = reserved
  #define BIT_MSK__TPI_AVI_BYTE4__TPI_AVI_BYTE4                                         0xFF

// TPI AVI Data Byte 5 Register
#define REG_ADDR__TPI_AVI_BYTE5                                          (TX_TPI | 0x0011)
  // (ReadWrite, Bits 7:0) 
  // Bit[3:0] = PR 3:0 Pixel Repetition Factor Bit[5:4] = CN1:0 Content Type Bit[7:6] = YQ 1:0 YCC Quantiztion Range
  #define BIT_MSK__TPI_AVI_BYTE5__TPI_AVI_BYTE5                                         0xFF

// TPI AVI Data Byte 6 Register
#define REG_ADDR__TPI_AVI_BYTE6                                          (TX_TPI | 0x0012)
  // (ReadWrite, Bits 7:0) 
  // EndTopBar Line Number of the End of Top Bar - LSB
  #define BIT_MSK__TPI_AVI_BYTE6__TPI_AVI_BYTE6                                         0xFF

// TPI AVI Data Byte 7 Register
#define REG_ADDR__TPI_AVI_BYTE7                                          (TX_TPI | 0x0013)
  // (ReadWrite, Bits 7:0) 
  // EndTopBar Line Number of the End of Top Bar - MSB
  #define BIT_MSK__TPI_AVI_BYTE7__TPI_AVI_BYTE7                                         0xFF

// TPI AVI Data Byte 8 Register
#define REG_ADDR__TPI_AVI_BYTE8                                          (TX_TPI | 0x0014)
  // (ReadWrite, Bits 7:0) 
  // StartBottomBar Line Number of start of Bottom Bar - LSB
  #define BIT_MSK__TPI_AVI_BYTE8__TPI_AVI_BYTE8                                         0xFF

// TPI AVI Data Byte 9 Register
#define REG_ADDR__TPI_AVI_BYTE9                                          (TX_TPI | 0x0015)
  // (ReadWrite, Bits 7:0) 
  // StartBottomBar Line Number of start of Bottom Bar - MSB
  #define BIT_MSK__TPI_AVI_BYTE9__TPI_AVI_BYTE9                                         0xFF

// TPI AVI Data Byte 10 Register
#define REG_ADDR__TPI_AVI_BYTE10                                         (TX_TPI | 0x0016)
  // (ReadWrite, Bits 7:0) 
  // EndLeftBar Pixel Number of End of Left Bar - LSB
  #define BIT_MSK__TPI_AVI_BYTE10__TPI_AVI_BYTE10                                        0xFF

// TPI AVI Data Byte 11 Register
#define REG_ADDR__TPI_AVI_BYTE11                                         (TX_TPI | 0x0017)
  // (ReadWrite, Bits 7:0) 
  // EndLeftBar Pixel Number of End of Left Bar - MSB
  #define BIT_MSK__TPI_AVI_BYTE11__TPI_AVI_BYTE11                                        0xFF

// TPI AVI Data Byte 12 Register
#define REG_ADDR__TPI_AVI_BYTE12                                         (TX_TPI | 0x0018)
  // (ReadWrite, Bits 7:0) 
  // EndRightBar Pixel Number of End of Right Bar - LSB
  #define BIT_MSK__TPI_AVI_BYTE12__TPI_AVI_BYTE12                                        0xFF

// TPI AVI Data Byte 13 Register
#define REG_ADDR__TPI_AVI_BYTE13                                         (TX_TPI | 0x0019)
  // (ReadWrite, Bits 7:0) 
  // EndRightBar Pixel Number of End of Right Bar - MSB Write Triggers Info Frame to be sent (AVI_RPT and AVI_EN; CP_RPT and CP_EN)
  #define BIT_MSK__TPI_AVI_BYTE13__TPI_AVI_BYTE13                                        0xFF

// TPI System Control Register
#define REG_ADDR__TPI_SC                                                 (TX_TPI | 0x001A)
  // (ReadWrite, Bits 0) 
  // Output mode Read: 1'b0: DVI 1'b1: HDMI Write (in Hot Plug Service Loop): 1'b0: set DVI 1'b1 set HDMI
  #define BIT_MSK__TPI_SC__REG_TPI_OUTPUT_MODE_B0                                0x01
  // (ReadWrite, Bits 1) 
  // DDC TPI SW. This is a special bit. FW can write as normal. When read back; it actually reflects the status of (GPU request and TPI grant).
  #define BIT_MSK__TPI_SC__REG_DDC_TPI_SW                                        0x02
  // (ReadWrite, Bits 2) 
  // 0 = Not using DDC 1 = Request to use DDC
  #define BIT_MSK__TPI_SC__REG_DDC_GPU_REQUEST                                   0x04
  // (ReadWrite, Bits 3) 
  // 0 = Normal audio/video 1 = Mute audio/video at receiver
  #define BIT_MSK__TPI_SC__REG_TPI_AV_MUTE                                       0x08
  // (ReadWrite, Bits 5) 
  // See description in reg_tpi_output_mode[0] 0x1A bit 0
  #define BIT_MSK__TPI_SC__REG_TPI_OUTPUT_MODE_B1                                0x20
  // (ReadWrite, Bits 6) 
  // Cipher Initialize bit (0x1A[6]) and Link encryption suspended (0x29[5:4]=11) status need to be considered together. Lets say that link is secured and protection level (0x2A[0]) changes from 1 (max security) to 0 (min security) then based on Cipher Initialize bit HW TPI will behave in two different ways. 0 (default) =] Cipher engine is NOT initialized; 0x29[5:4] =11 (Link encryption suspended); 0x29[6] = 0 (Local link not secured); COPP status change interrupt bit (0x3D[5])) is set 1 =] Initialize Cipher engine; 0x29[5:4] = 00 (normal); 0x29[6] = 0 (Local link not secured); COPP status change interrupt bit (0x3D[5])) is set
  #define BIT_MSK__TPI_SC__REG_TPI_REAUTH_CTL                                    0x40
  // (ReadWrite, Bits 7) 
  // 0 = Normal operation (only r/w in 1932; no use) 1 = Jump to Flash Update
  #define BIT_MSK__TPI_SC__REG_TPI_UPDATE_FLG                                    0x80

// TPI Device ID Register
#define REG_ADDR__TPI_DEV_ID                                             (TX_TPI | 0x001B)
  // (ReadOnly, Bits 7:0) 
  // TPI Device ID(0xB2)
  #define BIT_MSK__TPI_DEV_ID__REG_TPI_DEV_ID                                        0xFF

// TPI COPP Query Data Register
#define REG_ADDR__TPI_COPP_DATA1                                         (TX_TPI | 0x0029)
  // (ReadOnly, Bits 0) 
  // 00  DVI 01  HDMI 10  Unrecognized 11  UDI (Reserved)
  #define BIT_MSK__TPI_COPP_DATA1__REG_COPP_CONNTYPE_B1                                  0x01
  // (ReadOnly, Bits 1) 
  // 0  None 1  HDCP
  #define BIT_MSK__TPI_COPP_DATA1__REG_COPP_PROTYPE                                      0x02
  // (ReadOnly, Bits 2) 
  // See description in reg_copp_conntype[1]
  #define BIT_MSK__TPI_COPP_DATA1__REG_COPP_CONNTYPE_B0                                  0x04
  // (ReadOnly, Bits 3) 
  // 0  No 1  Yes
  #define BIT_MSK__TPI_COPP_DATA1__REG_COPP_HDCP_REP                                     0x08
  // (ReadOnly, Bits 5:4) 
  // 00  Normal 01  Link Lost 10  Renegotiation required 11 - Rsvd If 0x29[5:4] = 11 and 0x2A[0] goes from 0 (min protection) to 1 (max protection) 0x29[5:4] =] 00 (normal); 0x29[6] = 1 (Local link secured); status change interrupt bit (0x3D[5])) is set.
  #define BIT_MSK__TPI_COPP_DATA1__REG_COPP_LINK_STATUS                                  0x30
  // (ReadOnly, Bits 6) 
  // 0  No link protection 1  Link secure
  #define BIT_MSK__TPI_COPP_DATA1__REG_COPP_LPROT                                        0x40
  // (ReadOnly, Bits 7) 
  // 0  No link protection 1  Link secure
  #define BIT_MSK__TPI_COPP_DATA1__REG_COPP_GPROT                                        0x80

// TPI COPP Control Data Register
#define REG_ADDR__TPI_COPP_DATA2                                         (TX_TPI | 0x002A)
  // (ReadWrite, Bits 0) 
  // 0  Min (no protection needed) 1  Max (HDCP required) Link encryption suspended means that link was secured before protection level (0x2A[0]) changed from 1 to 0 Renegotiation required status happens when authentication fails.
  #define BIT_MSK__TPI_COPP_DATA2__REG_COPP_PROTLEVEL                                    0x01
  // (ReadWrite, Bits 1) 
  // DDC Short Ri read enable bit 0: disable (default) 1: enable
  #define BIT_MSK__TPI_COPP_DATA2__REG_DDC_SHORT_RI_RD                                   0x02
  // (ReadWrite, Bits 2) 
  // Double Ri check enable bit 0: disable (default) 1: enable
  #define BIT_MSK__TPI_COPP_DATA2__REG_DOUBLE_RI_CHECK                                   0x04
  // (ReadWrite, Bits 3) 
  // Intermediate Ri check enable bit 0: disable (default) 1: enable
  #define BIT_MSK__TPI_COPP_DATA2__REG_INTERM_RI_CHECK_EN                                0x08
  // (ReadWrite, Bits 4) 
  // KSV forward enable bit 0: disable (default) 1: enable
  #define BIT_MSK__TPI_COPP_DATA2__REG_KSV_FORWARD                                       0x10
  // (ReadWrite, Bits 5) 
  // Interrupt encryption enable bit 0: disable (default) 1: enable
  #define BIT_MSK__TPI_COPP_DATA2__REG_INTR_ENCRYPTION                                   0x20
  // (ReadWrite, Bits 6) 
  // Cancel Protect Request Enable when 0x2A bit 0 goes from 1 to 0 the HW TPI state machine will get reset CONFIG state 0  disabled 1  enabled
  #define BIT_MSK__TPI_COPP_DATA2__REG_CANCEL_PROT_EN                                    0x40
  // (ReadWrite, Bits 7) 
  // TPI HDCP Prep Enable set to enable the TPI HDCP State machine to advance to the Prep state to start discovering if HDCP is available through reading the BCAPs and BKSV.
  #define BIT_MSK__TPI_COPP_DATA2__REG_TPI_HDCP_PREP_EN                                  0x80

// TPI Write BKSV1 Register
#define REG_ADDR__TPI_WR_BKSV_1                                          (TX_TPI | 0x002B)
  // (ReadWrite, Bits 7:0) 
  // Reciever's Key Select Vector. It is read from the reciever and then writen to here. When software writes byte #1 of Key Selector Vector in this register the 1 clock write strobe is generated and data is loaded into the bksv1 register located inside HDCP block.  During read get Data of BKSV #1 register. 
  #define BIT_MSK__TPI_WR_BKSV_1__TPI_BKSV0                                             0xFF

// TPI Write BKSV2 Register
#define REG_ADDR__TPI_WR_BKSV_2                                          (TX_TPI | 0x002C)
  // (ReadWrite, Bits 7:0) 
  // Reciever's Key Select Vector. It is read from the reciever and then writen to here. When software writes byte #2 of Key Selector Vector in this register the 1 clock write strobe is generated and data is loaded into the bksv2 register located inside HDCP block.  During read get Data of BKSV #2 register. 
  #define BIT_MSK__TPI_WR_BKSV_2__TPI_BKSV1                                             0xFF

// TPI_Write BKSV3 Register
#define REG_ADDR__TPI_WR_BKSV_3                                          (TX_TPI | 0x002D)
  // (ReadWrite, Bits 7:0) 
  // Reciever's Key Select Vector. It is read from the reciever and then writen to here. When software writes byte #3 of Key Selector Vector in this register the 1 clock write strobe is generated and data is loaded into the bksv3 register located inside HDCP block.  During read get Data of BKSV #3 register. 
  #define BIT_MSK__TPI_WR_BKSV_3__TPI_BKSV2                                             0xFF

// TPI Write BKSV4 Register
#define REG_ADDR__TPI_WR_BKSV_4                                          (TX_TPI | 0x002E)
  // (ReadWrite, Bits 7:0) 
  // Reciever's Key Select Vector. It is read from the reciever and then writen to here. When software writes byte #4 of Key Selector Vector in this register the 1 clock write strobe is generated and data is loaded into the bksv4 register located inside HDCP block.  During read get Data of BKSV #4 register. 
  #define BIT_MSK__TPI_WR_BKSV_4__TPI_BKSV3                                             0xFF

// TPI Write BKSV5 Register
#define REG_ADDR__TPI_WR_BKSV_5                                          (TX_TPI | 0x002F)
  // (ReadWrite, Bits 7:0) 
  // Reciever's Key Select Vector. It is read from the reciever and then writen to here. When software writes byte #5 of Key Selector Vector in this register the 1 clock write strobe is generated and data is loaded into the bksv5 register located inside HDCP block. In addition if HDCP is enabled then by writing into this register the authentication is triggered.  During read get Data of BKSV #5 register. 
  #define BIT_MSK__TPI_WR_BKSV_5__TPI_BKSV4                                             0xFF

// TPI HDCP Revision Register
#define REG_ADDR__TPI_HDCP_REV                                           (TX_TPI | 0x0030)
  // (ReadOnly, Bits 7:0) 
  // Without HDCP; 8'h00. else with HDCP is 8'h12
  #define BIT_MSK__TPI_HDCP_REV__REG_TPI_HDCP_REV                                      0xFF

// TPI KSV and V' Value Data Register
#define REG_ADDR__TPI_KSV_V                                              (TX_TPI | 0x0031)
  // (ReadWrite, Bits 2:0) 
  // V Value Select 000=H0 001=H1 010=H2 011=H3 100=H4 101=Rsvd 11x=Rsvd
  #define BIT_MSK__TPI_KSV_V__REG_TPI_V_SEL                                         0x07
  // (ReadWrite, Bits 3) 
  // 0=No 1=Yes
  #define BIT_MSK__TPI_KSV_V__REG_COPP_VSEL_RDY                                     0x08
  // (ReadOnly, Bits 7:6) 
  // 00=Auth. required 01=Re-auth. required 10=Authenticated 11=Repeater auth. Required
  #define BIT_MSK__TPI_KSV_V__TPI_AUTH_STATE                                        0xC0

// TPI V' Value Byte 0 Register
#define REG_ADDR__TPI_VVALUE_B0                                          (TX_TPI | 0x0032)
  // (ReadOnly, Bits 7:0) 
  // Based on reg_tpi_v_sel (0x31 bit[2:0]) 3'b000 = tpi_vp_h0_b0 3'b001 = tpi_vp_h1_b0 3'b010 = tpi_vp_h2_b0 3'b011 = tpi_vp_h3_b0 3'b100 = tpi_vp_h4_b0
  #define BIT_MSK__TPI_VVALUE_B0__TPI_VP_HX_B0                                          0xFF

// TPI V' Value Byte 1 Register
#define REG_ADDR__TPI_VVALUE_B1                                          (TX_TPI | 0x0033)
  // (ReadOnly, Bits 7:0) 
  // Based on reg_tpi_v_sel (0x31 bit[2:0]) 3'b000 = tpi_vp_h0_b1 3'b001 = tpi_vp_h1_b1 3'b010 = tpi_vp_h2_b1 3'b011 = tpi_vp_h3_b1 3'b100 = tpi_vp_h4_b1
  #define BIT_MSK__TPI_VVALUE_B1__TPI_VP_HX_B1                                          0xFF

// TPI V' Value Byte 2 Register
#define REG_ADDR__TPI_VVALUE_B2                                          (TX_TPI | 0x0034)
  // (ReadOnly, Bits 7:0) 
  // Based on reg_tpi_v_sel (0x31 bit[2:0]) 3'b000 = tpi_vp_h0_b2 3'b001 = tpi_vp_h1_b2 3'b010 = tpi_vp_h2_b2 3'b011 = tpi_vp_h3_b2 3'b100 = tpi_vp_h4_b2
  #define BIT_MSK__TPI_VVALUE_B2__TPI_VP_HX_B2                                          0xFF

// TPI V' Value Byte 3 Register
#define REG_ADDR__TPI_VVALUE_B3                                          (TX_TPI | 0x0035)
  // (ReadOnly, Bits 7:0) 
  // Based on reg_tpi_v_sel (0x31 bit[2:0]) 3'b000 = tpi_vp_h0_b3 3'b001 = tpi_vp_h1_b3 3'b010 = tpi_vp_h2_b3 3'b011 = tpi_vp_h3_b3 3'b100 = tpi_vp_h4_b3
  #define BIT_MSK__TPI_VVALUE_B3__TPI_VP_HX_B3                                          0xFF

// TPI AKSV_1 Register
#define REG_ADDR__TPI_AKSV_1                                             (TX_TPI | 0x0036)
  // (ReadOnly, Bits 7:0) 
  // Byte #1 of transmitters key select vector.  Five bytes: 1 is the LSB; 5 is the MSB.  All five bytes should be read from here and then written to the receiver.  Byte 5 should be written last into the receiver; and will trigger the authentication process in the receiver.
  #define BIT_MSK__TPI_AKSV_1__REG_TPI_AKSV0                                         0xFF

// TPI AKSV_2 Register
#define REG_ADDR__TPI_AKSV_2                                             (TX_TPI | 0x0037)
  // (ReadOnly, Bits 7:0) 
  // Byte #2 of transmitters key select vector.  Five bytes: 1 is the LSB; 5 is the MSB.  All five bytes should be read from here and then written to the receiver.  Byte 5 should be written last into the receiver; and will trigger the authentication process in the receiver.
  #define BIT_MSK__TPI_AKSV_2__REG_TPI_AKSV1                                         0xFF

// TPI AKSV_3 Register
#define REG_ADDR__TPI_AKSV_3                                             (TX_TPI | 0x0038)
  // (ReadOnly, Bits 7:0) 
  // Byte #3 of transmitters key select vector.  Five bytes: 1 is the LSB; 5 is the MSB.  All five bytes should be read from here and then written to the receiver.  Byte 5 should be written last into the receiver; and will trigger the authentication process in the receiver.
  #define BIT_MSK__TPI_AKSV_3__REG_TPI_AKSV2                                         0xFF

// TPI AKSV_4 Register
#define REG_ADDR__TPI_AKSV_4                                             (TX_TPI | 0x0039)
  // (ReadOnly, Bits 7:0) 
  // Byte #4 of transmitters key select vector.  Five bytes: 1 is the LSB; 5 is the MSB.  All five bytes should be read from here and then written to the receiver.  Byte 5 should be written last into the receiver; and will trigger the authentication process in the receiver.
  #define BIT_MSK__TPI_AKSV_4__REG_TPI_AKSV3                                         0xFF

// TPI AKSV_5 Register
#define REG_ADDR__TPI_AKSV_5                                             (TX_TPI | 0x003A)
  // (ReadOnly, Bits 7:0) 
  // Byte #5 of transmitters key select vector.  Five bytes: 1 is the LSB; 5 is the MSB.  All five bytes should be read from here and then written to the receiver.  Byte 5 should be written last into the receiver; and will trigger the authentication process in the receiver.
  #define BIT_MSK__TPI_AKSV_5__REG_TPI_AKSV4                                         0xFF

// HPD and RSEN status Register
#define REG_ADDR__TPI_HPD_RSEN                                           (TX_TPI | 0x003B)
  // (ReadOnly, Bits 0) 
  // HPD
  #define BIT_MSK__TPI_HPD_RSEN__HPD                                                   0x01
  // (ReadOnly, Bits 2:1) 
  // HPD State 0 - Disconnected 1 - Measuring a Connection 2 - Connection
  #define BIT_MSK__TPI_HPD_RSEN__HPD_STATE                                             0x06
  // (ReadOnly, Bits 4) 
  // RSEN
  #define BIT_MSK__TPI_HPD_RSEN__RSEN                                                  0x10
  // (ReadOnly, Bits 6:5) 
  // RSEN State 0 - Disconnected 1 - Measuring a Connection 2 - Connection
  #define BIT_MSK__TPI_HPD_RSEN__RSEN_STATE                                            0x60

// TPI Interrupt Enable Register
#define REG_ADDR__TPI_INTR_EN                                            (TX_TPI | 0x003C)
  // (ReadWrite, Bits 0) 
  // Read Rx repeater bit enable 0=Disable 1=Enable
  #define BIT_MSK__TPI_INTR_EN__REG_TPI_INTR_MASK_B0                                  0x01
  // (ReadWrite, Bits 1) 
  // Read BKSV error enable 0=Disable 1=Enable
  #define BIT_MSK__TPI_INTR_EN__REG_TPI_INTR_MASK_B1                                  0x02
  // (ReadWrite, Bits 2) 
  // Read BKSV done enable 0=Disable 1=Enable
  #define BIT_MSK__TPI_INTR_EN__REG_TPI_INTR_MASK_B2                                  0x04
  // (ReadWrite, Bits 3) 
  // KSV FIFO First enable 0=Disable 1=Enable
  #define BIT_MSK__TPI_INTR_EN__REG_TPI_INTR_MASK_B3                                  0x08
  // (ReadWrite, Bits 4) 
  // rsvd
  #define BIT_MSK__TPI_INTR_EN__REG_TPI_INTR_MASK_B4                                  0x10
  // (ReadWrite, Bits 5) 
  // COPP link status change 0=Disable 1=Enable
  #define BIT_MSK__TPI_INTR_EN__REG_TPI_INTR_MASK_B5                                  0x20
  // (ReadWrite, Bits 6) 
  // HDCP V value ready 0=Disable 1=Enable
  #define BIT_MSK__TPI_INTR_EN__REG_TPI_INTR_MASK_B6                                  0x40
  // (ReadWrite, Bits 7) 
  // HDCP authentication status change 0=Disable 1=Enable
  #define BIT_MSK__TPI_INTR_EN__REG_TPI_INTR_MASK_B7                                  0x80

// TPI Interrupt Status Low Byte Register
#define REG_ADDR__TPI_INTR_ST0                                           (TX_TPI | 0x003D)
  // (ReadWrite, Bits 0) 
  // BKSV read error indicator
  #define BIT_MSK__TPI_INTR_ST0__TPI_INTR_ST0                                          0x01
  // (ReadWrite, Bits 1) 
  // Either BKSV or BCAPS read error indicator
  #define BIT_MSK__TPI_INTR_ST0__TPI_INTR_ST1                                          0x02
  // (ReadWrite, Bits 2) 
  // Both BKSV and BCAPS read done indicator or only BKSV read done indicator. The behavior can controlled by 0x07[0]
  #define BIT_MSK__TPI_INTR_ST0__TPI_INTR_ST2                                          0x04
  // (ReadWrite, Bits 3) 
  // KSV FIFO first byte indicator
  #define BIT_MSK__TPI_INTR_ST0__TPI_INTR_ST3                                          0x08
  // (ReadWrite, Bits 5) 
  // indicates a status change event in the LinkStatus value so that the host driver can take appropriate action to re-establish the link.
  #define BIT_MSK__TPI_INTR_ST0__TPI_INTR_ST5                                          0x20
  // (ReadWrite, Bits 6) 
  // indicates whether the V value computation has completed.
  #define BIT_MSK__TPI_INTR_ST0__TPI_INTR_ST6                                          0x40
  // (ReadWrite, Bits 7) 
  // indicates either that the previous authentication request (from a write to the COPP ProtLevel bit) has completed; or that an Ri mismatch has caused authentication to fail.
  #define BIT_MSK__TPI_INTR_ST0__TPI_INTR_ST7                                          0x80

// TPI KSV FIFO Fill Level Status Register
#define REG_ADDR__TPI_KSV_FIFO_STAT                                      (TX_TPI | 0x0041)
  // (ReadOnly, Bits 4:0) 
  // The number of KSV FIFO bytes to forward when KSV Forward feature is enabled
  #define BIT_MSK__TPI_KSV_FIFO_STAT__KSV_FIFO_BYTES                                        0x1F
  // (ReadOnly, Bits 7) 
  // This bit indicates KSV FIFO last byte arriving
  #define BIT_MSK__TPI_KSV_FIFO_STAT__KSV_FIFO_LAST                                         0x80

// TPI KSV FIFO Forward Port Register
#define REG_ADDR__TPI_KSV_FIFO_FORW                                      (TX_TPI | 0x0042)
  // (ReadOnly, Bits 7:0) 
  // Internal port for KSV FIFO Forwarding
  #define BIT_MSK__TPI_KSV_FIFO_FORW__REG_KSV_FIFO_OUT                                      0xFF

// TPI DS BCAPS Status Register
#define REG_ADDR__TPI_DS_BCAPS                                           (TX_TPI | 0x0044)
  // (ReadOnly, Bits 7:0) 
  // dowstream BCAPS status
  #define BIT_MSK__TPI_DS_BCAPS__REG_DS_BCAPS                                          0xFF

// TPI BStatus1 Register
#define REG_ADDR__TPI_BSTATUS1                                           (TX_TPI | 0x0045)
  // (ReadOnly, Bits 6:0) 
  // Device Count
  #define BIT_MSK__TPI_BSTATUS1__REG_DS_DEV_CNT                                        0x7F
  // (ReadOnly, Bits 7) 
  // Device Count Exceeds
  #define BIT_MSK__TPI_BSTATUS1__REG_DS_DEV_EXCEED                                     0x80

// TPI BStatus2 Register
#define REG_ADDR__TPI_BSTATUS2                                           (TX_TPI | 0x0046)
  // (ReadOnly, Bits 2:0) 
  // Device Depth
  #define BIT_MSK__TPI_BSTATUS2__REG_DS_DEPTH                                          0x07
  // (ReadOnly, Bits 3) 
  // Down Stream Cascade Exceeds
  #define BIT_MSK__TPI_BSTATUS2__REG_DS_CASC_EXCEED                                    0x08
  // (ReadOnly, Bits 4) 
  // downstream HDMI mode 0 = DVI mode 1 = HDMI mode
  #define BIT_MSK__TPI_BSTATUS2__REG_DS_HDMI_MODE                                      0x10
  // (ReadOnly, Bits 7:5) 
  // Downstream BSTATUS
  #define BIT_MSK__TPI_BSTATUS2__REG_DS_BSTATUS                                        0xE0

// TPI Video Mute Low Byte Register
#define REG_ADDR__TPI_VID_MUTE0                                          (TX_TPI | 0x004B)
  // (ReadWrite, Bits 7:0) 
  // Video mute data for channel 0. When video mute is enabled; regular video is replaced by mute data.
  #define BIT_MSK__TPI_VID_MUTE0__TPI_VID_MUTE0                                         0xFF

// TPI Video Mute Mid Byte Register
#define REG_ADDR__TPI_VID_MUTE1                                          (TX_TPI | 0x004D)
  // (ReadWrite, Bits 7:0) 
  // Video mute data for channel 1. When video mute is enabled; regular video is replaced by mute data.
  #define BIT_MSK__TPI_VID_MUTE1__TPI_VID_MUTE1                                         0xFF

// TPI Video Mute High Byte Register
#define REG_ADDR__TPI_VID_MUTE2                                          (TX_TPI | 0x004F)
  // (ReadWrite, Bits 7:0) 
  // Video mute data for channel 2. When video mute is enabled; regular video is replaced by mute data.
  #define BIT_MSK__TPI_VID_MUTE2__TPI_VID_MUTE2                                         0xFF

// TPI HW Debug #1 Register
#define REG_ADDR__TPI_HW_DBG1                                            (TX_TPI | 0x0079)
  // (ReadOnly, Bits 0) 
  // Read BKSV successful
  #define BIT_MSK__TPI_HW_DBG1__READ_BKSV_DONE                                        0x01
  // (ReadOnly, Bits 1) 
  // Read RX repeater successful
  #define BIT_MSK__TPI_HW_DBG1__READ_RX_REPEATER_DONE                                 0x02
  // (ReadOnly, Bits 2) 
  // Write AN successful
  #define BIT_MSK__TPI_HW_DBG1__WRITE_AN_DONE                                         0x04
  // (ReadOnly, Bits 3) 
  // Write AKSV successful
  #define BIT_MSK__TPI_HW_DBG1__WRITE_AKSV_DONE                                       0x08
  // (ReadOnly, Bits 4) 
  // Read R0 Prime successful
  #define BIT_MSK__TPI_HW_DBG1__READ_R0_PRIME_DONE                                    0x10
  // (ReadOnly, Bits 5) 
  // Read KSV FIFO ready successful
  #define BIT_MSK__TPI_HW_DBG1__READ_KSV_FIFO_RDY_DONE                                0x20
  // (ReadOnly, Bits 6) 
  // Read Bstatus successful
  #define BIT_MSK__TPI_HW_DBG1__READ_BSTATUS_DONE                                     0x40
  // (ReadOnly, Bits 7) 
  // Read KSV list successful
  #define BIT_MSK__TPI_HW_DBG1__READ_KSV_LIST_DONE                                    0x80

// TPI HW Debug #2 Register
#define REG_ADDR__TPI_HW_DBG2                                            (TX_TPI | 0x007A)
  // (ReadOnly, Bits 0) 
  // Read V prime successful
  #define BIT_MSK__TPI_HW_DBG2__READ_V_PRIME_DONE                                     0x01
  // (ReadOnly, Bits 1) 
  // Read RI prime successful
  #define BIT_MSK__TPI_HW_DBG2__READ_RI_PRIME_DONE                                    0x02
  // (ReadOnly, Bits 2) 
  // Read 2nd RI prime successful
  #define BIT_MSK__TPI_HW_DBG2__READ_RI_2ND_DONE                                      0x04

// TPI HW Debug #3 Register
#define REG_ADDR__TPI_HW_DBG3                                            (TX_TPI | 0x007B)
  // (ReadOnly, Bits 0) 
  // Read BKSV error
  #define BIT_MSK__TPI_HW_DBG3__READ_BKSV_ERR                                         0x01
  // (ReadOnly, Bits 1) 
  // Read RX repeater error
  #define BIT_MSK__TPI_HW_DBG3__READ_RX_REPEATER_ERR                                  0x02
  // (ReadOnly, Bits 2) 
  // Write AN error
  #define BIT_MSK__TPI_HW_DBG3__WRITE_AN_ERR                                          0x04
  // (ReadOnly, Bits 3) 
  // Write AKSV error
  #define BIT_MSK__TPI_HW_DBG3__WRITE_AKSV_ERR                                        0x08
  // (ReadOnly, Bits 4) 
  // Read R0 Prime error
  #define BIT_MSK__TPI_HW_DBG3__READ_R0_PRIME_ERR                                     0x10
  // (ReadOnly, Bits 5) 
  // Read KSV FIFO ready error
  #define BIT_MSK__TPI_HW_DBG3__READ_KSV_FIFO_RDY_ERR                                 0x20
  // (ReadOnly, Bits 6) 
  // Read Bstatus error
  #define BIT_MSK__TPI_HW_DBG3__READ_BSTATUS_ERR                                      0x40
  // (ReadOnly, Bits 7) 
  // Read KSV list error
  #define BIT_MSK__TPI_HW_DBG3__READ_KSV_LIST_ERR                                     0x80

// TPI HW Debug #4 Register
#define REG_ADDR__TPI_HW_DBG4                                            (TX_TPI | 0x007C)
  // (ReadOnly, Bits 0) 
  // Read V prime error
  #define BIT_MSK__TPI_HW_DBG4__READ_V_PRIME_ERR                                      0x01
  // (ReadOnly, Bits 1) 
  // Read RI prime error
  #define BIT_MSK__TPI_HW_DBG4__READ_RI_PRIME_ERR                                     0x02
  // (ReadOnly, Bits 2) 
  // Read 2nd RI prime error
  #define BIT_MSK__TPI_HW_DBG4__READ_RI_2ND_ERR                                       0x04

// TPI HW Debug #5 Register
#define REG_ADDR__TPI_HW_DBG5                                            (TX_TPI | 0x007D)
  // (ReadOnly, Bits 3:0) 
  // TPI HW current state
  #define BIT_MSK__TPI_HW_DBG5__TPI_HW_CS                                             0x0F
  // (ReadOnly, Bits 7:4) 
  // TPI HW Repeater Authentication SM
  #define BIT_MSK__TPI_HW_DBG5__TPI_DS_AUTH_CS                                        0xF0

// TPI HW Debug #6 Register
#define REG_ADDR__TPI_HW_DBG6                                            (TX_TPI | 0x007E)
  // (ReadOnly, Bits 4:0) 
  // TPI HW RX Authentication SM
  #define BIT_MSK__TPI_HW_DBG6__TPI_RX_AUTH_CS_B4_B0                                  0x1F
  // (ReadOnly, Bits 7:5) 
  // TPI HW Link Integrity SM
  #define BIT_MSK__TPI_HW_DBG6__TPI_LINK_ENC_CS_B2_B0                                 0xE0

// TPI HW Debug #7 Register
#define REG_ADDR__TPI_HW_DBG7                                            (TX_TPI | 0x007F)
  // (ReadOnly, Bits 3:0) 
  // TPI HW DDC Master Controller SM
  #define BIT_MSK__TPI_HW_DBG7__TPI_DDCM_CTL_CS_B3_B0                                 0x0F

// TPI HW Debug #8 Register
#define REG_ADDR__TPI_HW_DBG8                                            (TX_TPI | 0x0080)
  // (ReadOnly, Bits 7:0) 
  // # of DDC master access byte (LSb) including read and write
  #define BIT_MSK__TPI_HW_DBG8__REG_DDC_HDCP_ACC_NMB_B7_B0                            0xFF

// TPI HW Debug #9 Register
#define REG_ADDR__TPI_HW_DBG9                                            (TX_TPI | 0x0081)
  // (ReadOnly, Bits 1:0) 
  // # of DDC master access byte (MSb) including read and write
  #define BIT_MSK__TPI_HW_DBG9__REG_DDC_HDCP_ACC_NMB_B9_B8                            0x03

// TPI HW Optimization Control #0 Register
#define REG_ADDR__TPI_HW_OPT0                                            (TX_TPI | 0x00B8)
  // (ReadWrite, Bits 0) 
  // TPI R0 Wait Absolute time Enable 1: use 2MHz clock to generate a ] 100ms pulse; 2MHz + 5% = 2.1MHz; 18'h34968 (18'd215400) = ~102.57ms  0: use # (0x6B9[3:0]) of vsyncs
  #define BIT_MSK__TPI_HW_OPT0__REG_R0_ABSOLUTE                                       0x01
  // (ReadWrite, Bits 1) 
  // HW TPI State Machine Reset (includes DDC Master) 1: Enabled 0: disabled
  #define BIT_MSK__TPI_HW_OPT0__REG_HW_TPI_SM_RST                                     0x02

// TPI HW Optimization Control #1 Register
#define REG_ADDR__TPI_HW_OPT1                                            (TX_TPI | 0x00B9)
  // (ReadWrite, Bits 3:0) 
  // TPI R0 Calculation Time
  #define BIT_MSK__TPI_HW_OPT1__REG_TPI_R0_CALC_TIME_B3_B0                            0x0F
  // (ReadWrite, Bits 6:4) 
  // TPI Autnentication Retry Counter
  #define BIT_MSK__TPI_HW_OPT1__REG_TPI_AUTH_RETRY_CNT_B2_B0                          0x70
  // (ReadWrite, Bits 7) 
  // DDC delay counter 9 bits of MSB bit
  #define BIT_MSK__TPI_HW_OPT1__REG_DDC_DELAY_CNT_B1                                  0x80

// TPI HW Optimization Control #2 Register
#define REG_ADDR__TPI_HW_OPT2                                            (TX_TPI | 0x00BA)
  // (ReadWrite, Bits 7:0) 
  // DDC delay counter 9 bits of lower 8-bit
  #define BIT_MSK__TPI_HW_OPT2__REG_DDC_DELAY_CNT_B0                                  0xFF

// TPI HW Optimization Control #3 Register
#define REG_ADDR__TPI_HW_OPT3                                            (TX_TPI | 0x00BB)
  // (ReadWrite, Bits 1:0) 
  // TPI DDC Request Level
  #define BIT_MSK__TPI_HW_OPT3__REG_TPI_DDC_REQ_LEVEL                                 0x03
  // (ReadWrite, Bits 2) 
  // TPI DDC Burst Mode
  #define BIT_MSK__TPI_HW_OPT3__REG_TPI_DDC_BURST_MODE                                0x04
  // (ReadWrite, Bits 3) 
  // RI Check Skip
  #define BIT_MSK__TPI_HW_OPT3__REG_RI_CHECK_SKIP                                     0x08
  // (ReadWrite, Bits 6:4) 
  // Legacy ri check
  #define BIT_MSK__TPI_HW_OPT3__REG_LEGACY_TPI_RI_CHECK                               0x70
  // (ReadWrite, Bits 7) 
  // DDC delay counter 9 bits of MSB bit
  #define BIT_MSK__TPI_HW_OPT3__REG_DDC_DEBUG                                         0x80

// TPI Info Frame Select Register
#define REG_ADDR__TPI_INFO_FSEL                                          (TX_TPI | 0x00BF)
  // (ReadWrite, Bits 4:0) 
  // InfoFrame Packet Buffer Selection. 0  Buffer 0 (19 bytes) i.e. AVI 1  Buffer 1 (31 bytes) i.e. GAMUT 2  Buffer 2 (14 bytes) i.e. Audio 3  Buffer 3 (31 bytes) i.e. SPD 4  Buffer 4 (31 bytes) i.e. MPEG 5  Buffer 5 (31 bytes) i.e. VSIF 6  Buffer 6 (31 bytes) i.e. GEN1 7  Buffer 7 (31 bytes) i.e. GEN2 8  Buffer 8 (31 bytes) i.e. GEN3 9  Buffer 9 (31 bytes) i.e. GEN4 10  Buffer 10 (31 bytes) i.e. GEN5 11  Buffer 11 (31 bytes) i.e. VSIF1 for compression/decompression 12  Buffer 12 (31 bytes) i.e. VSIF2 for compression/decompression 13  Buffer 13 (31 bytes) i.e. VSIF3 for compression/decompression 14  Buffer 14 (31 bytes) i.e. VSIF4 for compression/decompression 15 - Buffer 15 (31 bytes) i.e. VSIF5 for Vx1 CTL16 data Buffers are in priority order of how they will be sent 0; then 1; etc.
  #define BIT_MSK__TPI_INFO_FSEL__REG_TPI_INFO_SEL                                      0x1F

// TPI Info Byte #0 Register
#define REG_ADDR__TPI_INFO_B0                                            (TX_TPI | 0x00C0)
  // (ReadWrite, Bits 7:0) 
  // Bit[6:0] = I-F_Type InfoFrame type per CEA-861-E spec Bit[7] = always write as 1
  #define BIT_MSK__TPI_INFO_B0__TPI_INFO_B0                                           0xFF

// TPI Info Byte #1 Register
#define REG_ADDR__TPI_INFO_B1                                            (TX_TPI | 0x00C1)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = I-F_Ver InfoFrame version per CEA-861-E spec
  #define BIT_MSK__TPI_INFO_B1__TPI_INFO_B1                                           0xFF

// TPI Info Byte #2 Register
#define REG_ADDR__TPI_INFO_B2                                            (TX_TPI | 0x00C2)
  // (ReadWrite, Bits 7:0) 
  // Bit[4:0] = I-F_Length InfoFrame length per CEA-861-E spec Bit[7:5] = rsvd
  #define BIT_MSK__TPI_INFO_B2__TPI_INFO_B2                                           0xFF

// TPI Info Byte #3 Register
#define REG_ADDR__TPI_INFO_B3                                            (TX_TPI | 0x00C3)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame checksum
  #define BIT_MSK__TPI_INFO_B3__TPI_INFO_B3                                           0xFF

// TPI Info Byte #4 Register
#define REG_ADDR__TPI_INFO_B4                                            (TX_TPI | 0x00C4)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte1
  #define BIT_MSK__TPI_INFO_B4__TPI_INFO_B4                                           0xFF

// TPI Info Byte #5 Register
#define REG_ADDR__TPI_INFO_B5                                            (TX_TPI | 0x00C5)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte2
  #define BIT_MSK__TPI_INFO_B5__TPI_INFO_B5                                           0xFF

// TPI Info Byte #6 Register
#define REG_ADDR__TPI_INFO_B6                                            (TX_TPI | 0x00C6)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte3
  #define BIT_MSK__TPI_INFO_B6__TPI_INFO_B6                                           0xFF

// TPI Info Byte #7 Register
#define REG_ADDR__TPI_INFO_B7                                            (TX_TPI | 0x00C7)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte4
  #define BIT_MSK__TPI_INFO_B7__TPI_INFO_B7                                           0xFF

// TPI Info Byte #8 Register
#define REG_ADDR__TPI_INFO_B8                                            (TX_TPI | 0x00C8)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte5
  #define BIT_MSK__TPI_INFO_B8__TPI_INFO_B8                                           0xFF

// TPI Info Byte #9 Register
#define REG_ADDR__TPI_INFO_B9                                            (TX_TPI | 0x00C9)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte6
  #define BIT_MSK__TPI_INFO_B9__TPI_INFO_B9                                           0xFF

// TPI Info Byte #10 Register
#define REG_ADDR__TPI_INFO_B10                                           (TX_TPI | 0x00CA)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte7
  #define BIT_MSK__TPI_INFO_B10__TPI_INFO_B10                                          0xFF

// TPI Info Byte #11 Register
#define REG_ADDR__TPI_INFO_B11                                           (TX_TPI | 0x00CB)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte8
  #define BIT_MSK__TPI_INFO_B11__TPI_INFO_B11                                          0xFF

// TPI Info Byte #12 Register
#define REG_ADDR__TPI_INFO_B12                                           (TX_TPI | 0x00CC)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte9
  #define BIT_MSK__TPI_INFO_B12__TPI_INFO_B12                                          0xFF

// TPI Info Byte #13 Register
#define REG_ADDR__TPI_INFO_B13                                           (TX_TPI | 0x00CD)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte10 (the last location for Audio InfoFrames)
  #define BIT_MSK__TPI_INFO_B13__TPI_INFO_B13                                          0xFF

// TPI Info Byte #14 Register
#define REG_ADDR__TPI_INFO_B14                                           (TX_TPI | 0x00CE)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte11
  #define BIT_MSK__TPI_INFO_B14__TPI_INFO_B14                                          0xFF

// TPI Info Byte #15 Register
#define REG_ADDR__TPI_INFO_B15                                           (TX_TPI | 0x00CF)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte12
  #define BIT_MSK__TPI_INFO_B15__TPI_INFO_B15                                          0xFF

// TPI Info Byte #16 Register
#define REG_ADDR__TPI_INFO_B16                                           (TX_TPI | 0x00D0)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte13
  #define BIT_MSK__TPI_INFO_B16__TPI_INFO_B16                                          0xFF

// TPI Info Byte #17 Register
#define REG_ADDR__TPI_INFO_B17                                           (TX_TPI | 0x00D1)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte14
  #define BIT_MSK__TPI_INFO_B17__TPI_INFO_B17                                          0xFF

// TPI Info Byte #18 Register
#define REG_ADDR__TPI_INFO_B18                                           (TX_TPI | 0x00D2)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte15
  #define BIT_MSK__TPI_INFO_B18__TPI_INFO_B18                                          0xFF

// TPI Info Byte #19 Register
#define REG_ADDR__TPI_INFO_B19                                           (TX_TPI | 0x00D3)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte16
  #define BIT_MSK__TPI_INFO_B19__TPI_INFO_B19                                          0xFF

// TPI Info Byte #20 Register
#define REG_ADDR__TPI_INFO_B20                                           (TX_TPI | 0x00D4)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte17
  #define BIT_MSK__TPI_INFO_B20__TPI_INFO_B20                                          0xFF

// TPI Info Byte #21 Register
#define REG_ADDR__TPI_INFO_B21                                           (TX_TPI | 0x00D5)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte18
  #define BIT_MSK__TPI_INFO_B21__TPI_INFO_B21                                          0xFF

// TPI Info Byte #22 Register
#define REG_ADDR__TPI_INFO_B22                                           (TX_TPI | 0x00D6)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte19
  #define BIT_MSK__TPI_INFO_B22__TPI_INFO_B22                                          0xFF

// TPI Info Byte #23 Register
#define REG_ADDR__TPI_INFO_B23                                           (TX_TPI | 0x00D7)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte20
  #define BIT_MSK__TPI_INFO_B23__TPI_INFO_B23                                          0xFF

// TPI Info Byte #24 Register
#define REG_ADDR__TPI_INFO_B24                                           (TX_TPI | 0x00D8)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte21
  #define BIT_MSK__TPI_INFO_B24__TPI_INFO_B24                                          0xFF

// TPI Info Byte #25 Register
#define REG_ADDR__TPI_INFO_B25                                           (TX_TPI | 0x00D9)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte22
  #define BIT_MSK__TPI_INFO_B25__TPI_INFO_B25                                          0xFF

// TPI Info Byte #26 Register
#define REG_ADDR__TPI_INFO_B26                                           (TX_TPI | 0x00DA)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte23
  #define BIT_MSK__TPI_INFO_B26__TPI_INFO_B26                                          0xFF

// TPI Info Byte #27 Register
#define REG_ADDR__TPI_INFO_B27                                           (TX_TPI | 0x00DB)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte24
  #define BIT_MSK__TPI_INFO_B27__TPI_INFO_B27                                          0xFF

// TPI Info Byte #28 Register
#define REG_ADDR__TPI_INFO_B28                                           (TX_TPI | 0x00DC)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte25
  #define BIT_MSK__TPI_INFO_B28__TPI_INFO_B28                                          0xFF

// TPI Info Byte #29 Register
#define REG_ADDR__TPI_INFO_B29                                           (TX_TPI | 0x00DD)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = InfoFrame data byte26
  #define BIT_MSK__TPI_INFO_B29__TPI_INFO_B29                                          0xFF

// TPI Info Byte #30 Register
#define REG_ADDR__TPI_INFO_B30                                           (TX_TPI | 0x00DE)
  // (ReadWrite, Bits 7:0) 
  // Bit[7:0] = Last InfoFrame data byte (for amm except Audio InfoFrames)
  #define BIT_MSK__TPI_INFO_B30__TPI_INFO_B30                                          0xFF

// TPI Info Enable Register
#define REG_ADDR__TPI_INFO_EN                                            (TX_TPI | 0x00DF)
  // (ReadOnly, Bits 5) 
  // Selected TPI InfoFrame transmission on HDMI Enabled and Sending next vsync.
  #define BIT_MSK__TPI_INFO_EN__CEA_INFO_EN                                           0x20
  // (ReadWrite, Bits 6) 
  // Repeat selected TPI InfoFrame Packet data each frame. Once this bit is set and transmition bit is enabled hardware would try to send InfoFrame Packet once every vblank period. Software has to disable this bit first to force clear of the transmission enable bit
  #define BIT_MSK__TPI_INFO_EN__REG_TPI_INFO_RPT                                      0x40
  // (ReadWrite, Bits 7) 
  // Enable request of selected TPI InfoFrame transmission on HDMI. To enable transmission write 1 into this bit. Have to be enabled only after packet data is written to the registers:
  #define BIT_MSK__TPI_INFO_EN__REG_TPI_INFO_EN                                       0x80

// VSIF Compression Control Register
#define REG_ADDR__VSIF_COMP_CNTL                                         (TX_TPI | 0x00E0)
  // (ReadWrite, Bits 0) 
  // 1: send only one enabled VSIF compression packet per frame 0: send all enabled VSIF compression packets per frame (up to 4 packets)
  #define BIT_MSK__VSIF_COMP_CNTL__REG_VSIF_COMP_ONE_PER_FRAME                           0x01

// TPI DDC Master Enable Register
#define REG_ADDR__TPI_DDC_MASTER_EN                                      (TX_TPI | 0x00F8)
  // (ReadWrite, Bits 7) 
  // Write 1 to enable DDC master access in HW TPI mode
  #define BIT_MSK__TPI_DDC_MASTER_EN__REG_HW_DDC_MASTER                                     0x80

// TPI VSIF VX1CTL HW Enable Register
#define REG_ADDR__TPI_VSIF_VX1CTL_HW_EN                                  (TX_TPI | 0x00F9)
  // (ReadWrite, Bits 6) 
  // Write 1 to enable main VX1 module 0 CTL 16bit data loaded into Byte7 and Byte8 of VSIF VX1CTL packet  in HW TPI mode
  #define BIT_MSK__TPI_VSIF_VX1CTL_HW_EN__REG_VSIF_VX1CTL_M0_HW_EN                              0x40
  // (ReadWrite, Bits 7) 
  // Write 1 to enable main VX1 module 1 CTL 16bit data loaded into Byte8 and Byte9 of VSIF VX1CTL packet  in HW TPI mode
  #define BIT_MSK__TPI_VSIF_VX1CTL_HW_EN__REG_VSIF_VX1CTL_M1_HW_EN                              0x80

// TPI VX1_CTL_M0_MSB Register
#define REG_ADDR__TPI_VX1CTL_M0_MSB                                      (TX_TPI | 0x00FA)
  // (ReadOnly, Bits 7:0) 
  // VX1 CTL data. M0 CTL16 MSB data. 
  #define BIT_MSK__TPI_VX1CTL_M0_MSB__REG_TPI_VX1CTL_M0_CTL16_MSB                           0xFF

// TPI V1X_CTL_M0_LSB Register
#define REG_ADDR__TPI_VX1CTL_M0_LSB                                      (TX_TPI | 0x00FB)
  // (ReadOnly, Bits 7:0) 
  // VX1 CTL data. M0 CTL16 LSB data. 
  #define BIT_MSK__TPI_VX1CTL_M0_LSB__REG_TPI_VX1CTL_M0_CTL16_LSB                           0xFF

// TPI VX1_CTL_M1_MSB Register
#define REG_ADDR__TPI_VX1CTL_M1_MSB                                      (TX_TPI | 0x00FC)
  // (ReadOnly, Bits 7:0) 
  // VX1 CTL data. M1 CTL16 MSB data. 
  #define BIT_MSK__TPI_VX1CTL_M1_MSB__REG_TPI_VX1CTL_M1_CTL16_MSB                           0xFF

// TPI V1X_CTL_M1_LSB Register
#define REG_ADDR__TPI_VX1CTL_M1_LSB                                      (TX_TPI | 0x00FD)
  // (ReadOnly, Bits 7:0) 
  // VX1 CTL data. M1 CTL16 LSB data. 
  #define BIT_MSK__TPI_VX1CTL_M1_LSB__REG_TPI_VX1CTL_M1_CTL16_LSB                           0xFF

//***************************************************************************
// TX_HDCP2. Address: 60
// HDCP General Control 0 Register
#define REG_ADDR__TX_HDCP2X_CTRL_0                                          (TX_HDCP2 | 0x0000)
  // (ReadWrite, Bits 0) 
  // Constant: 1 for TX 0 for RX
  #define BIT_MSK__TX_HDCP2X_CTRL_0__RI_HDCP2_HDCPTX                                       0x01
  // (ReadWrite, Bits 1) 
  // Valid only for Rx. Don't care for Tx. Constant: 1 for Repeater 0 for Receiver
  #define BIT_MSK__TX_HDCP2X_CTRL_0__RI_HDCP2RX_REPEATER                                   0x02
  // (ReadWrite, Bits 2) 
  // Constant: 1 for HDMI 0 for MHL
  #define BIT_MSK__TX_HDCP2X_CTRL_0__RI_HDCP2_HDMIMODE                                     0x04
  
// HDCP General Control 1 Register
#define REG_ADDR__TX_HDCP2X_CTRL_1                                          (TX_HDCP2 | 0x0001)
  // (ReadWrite, Bits 0) 
  // Active high long pulse
  #define BIT_MSK__TX_HDCP2X_CTRL_1__RI_HDCP2_REAUTH_SW                                    0x01
  // (ReadWrite, Bits 1) 
  // Valid only for Tx. Don't care for Rx. 1 to mask auth_done to link (No CTL3) . Default is 0 - unmaked.
  #define BIT_MSK__TX_HDCP2X_CTRL_1__RI_HDCP2TX_CTL3MSK                                    0x02
  // (ReadWrite, Bits 7:4) 
  // {mask_ecc mask_hpd mask_req mask_sw}  1 to mask(off) . 0 to unmask(on)
  #define BIT_MSK__TX_HDCP2X_CTRL_1__RI_HDCP2_REAUTH_MSK                                   0xF0

// HDCP General Control 2 Register
#define REG_ADDR__TX_HDCP2X_CTRL_2                                          (TX_HDCP2 | 0x0002)
  // (ReadWrite, Bits 0) 
  // Active high long pulse Write 1 to this register to start patch code check. Write back to 0 after code check finishes.
  #define BIT_MSK__TX_HDCP2X_CTRL_2__RI_HDCP2_CUPD_DONE                                    0x01
  // (ReadWrite, Bits 1) 
  // Active high long pulse Write 1 to this register to gain write access to PRAM for patch.
  #define BIT_MSK__TX_HDCP2X_CTRL_2__RI_HDCP2_CUPD_START                                   0x02
  // (ReadWrite, Bits 2) 
  // 1(default): Use i_hw_cupd_start/i_hw_cupd_done. 0: Use ri_hdcp2_cupd_start/ri_hdcp2_cupd_done.
  #define BIT_MSK__TX_HDCP2X_CTRL_2__RI_HDCP2_CUPD_HW                                      0x04
  // (ReadWrite, Bits 7:4) 
  // 4'hA for HDCP 2.2 for HDMI or MHL. Do not change this regiseter.
  #define BIT_MSK__TX_HDCP2X_CTRL_2__RI_HDCP2_CPVER_B3_B0                                  0xF0

// HDCP Interrupt0 Status Register
#define REG_ADDR__TX_HDCP2X_INTR0                                           (TX_HDCP2 | 0x0003)
  // (ReadWrite, Bits 0) 
  // ro_hdcp2_auth_stat[0] : auth_done
  #define BIT_MSK__TX_HDCP2X_INTR0__INTR0_STAT0                                           0x01
  // (ReadWrite, Bits 1) 
  // ro_hdcp2_auth_stat[1] : auth_fail
  #define BIT_MSK__TX_HDCP2X_INTR0__INTR0_STAT1                                           0x02
  // (ReadWrite, Bits 2) 
  // ro_hdcp2_auth_stat[2] : rpt_ready
  #define BIT_MSK__TX_HDCP2X_INTR0__INTR0_STAT2                                           0x04
  // (ReadWrite, Bits 3) 
  // ro_hdcp2_auth_stat[3] : hash_fail
  #define BIT_MSK__TX_HDCP2X_INTR0__INTR0_STAT3                                           0x08
  // (ReadWrite, Bits 4) 
  // ro_hdcp2_auth_stat[4] : cchk_done
  #define BIT_MSK__TX_HDCP2X_INTR0__INTR0_STAT4                                           0x10
  // (ReadWrite, Bits 5) 
  // ro_hdcp2_auth_stat[5] : cchk_fail
  #define BIT_MSK__TX_HDCP2X_INTR0__INTR0_STAT5                                           0x20
  // (ReadWrite, Bits 6) 
  // ro_hdcp2_auth_stat[6] : reauth_req
  #define BIT_MSK__TX_HDCP2X_INTR0__INTR0_STAT6                                           0x40
  // (ReadWrite, Bits 7) 
  // ro_hdcp2_auth_stat[7]: polling_interval
  #define BIT_MSK__TX_HDCP2X_INTR0__INTR0_STAT7                                           0x80

// HDCP Interrupt1 Status Register
#define REG_ADDR__TX_HDCP2X_INTR1                                           (TX_HDCP2 | 0x0004)
  // (ReadWrite, Bits 0) 
  // ro_rpt_rcvid_changed
  #define BIT_MSK__TX_HDCP2X_INTR1__INTR1_STAT0                                           0x01
  // (ReadWrite, Bits 1) 
  // ro_rpt_smng_changed
  #define BIT_MSK__TX_HDCP2X_INTR1__INTR1_STAT1                                           0x02
  // (ReadWrite, Bits 2) 
  // ro_ake_sent_rcvd
  #define BIT_MSK__TX_HDCP2X_INTR1__INTR1_STAT2                                           0x04
  // (ReadWrite, Bits 3) 
  // ro_ske_sent_rcvd
  #define BIT_MSK__TX_HDCP2X_INTR1__INTR1_STAT3                                           0x08
  // (ReadWrite, Bits 4) 
  // ro_rpt_rcvid_xfer_done
  #define BIT_MSK__TX_HDCP2X_INTR1__INTR1_STAT4                                           0x10
  // (ReadWrite, Bits 5) 
  // ro_rpt_smng_xfer_done
  #define BIT_MSK__TX_HDCP2X_INTR1__INTR1_STAT5                                           0x20
  // (ReadWrite, Bits 6) 
  // ro_cert_sent_rcvd
  #define BIT_MSK__TX_HDCP2X_INTR1__INTR1_STAT6                                           0x40
  // (ReadWrite, Bits 7) 
  // ro_gp3[7]
  #define BIT_MSK__TX_HDCP2X_INTR1__INTR1_STAT7                                           0x80

// HDCP Interrupt2 Status Register
#define REG_ADDR__TX_HDCP2X_INTR2                                           (TX_HDCP2 | 0x0005)
  // (ReadWrite, Bits 0) 
  // ro_msg_intr[0]:ro_km_sent_rcvd
  #define BIT_MSK__TX_HDCP2X_INTR2__INTR2_STAT0                                           0x01
  // (ReadWrite, Bits 1) 
  // ro_msg_intr[1]:ro_ekhkm_sent_rcvd
  #define BIT_MSK__TX_HDCP2X_INTR2__INTR2_STAT1                                           0x02
  // (ReadWrite, Bits 2) 
  // ro_msg_intr[2]:ro_h_sent_rcvd
  #define BIT_MSK__TX_HDCP2X_INTR2__INTR2_STAT2                                           0x04
  // (ReadWrite, Bits 3) 
  // ro_msg_intr[3]:ro_pair_sent_rcvd
  #define BIT_MSK__TX_HDCP2X_INTR2__INTR2_STAT3                                           0x08
  // (ReadWrite, Bits 4) 
  // ro_msg_intr[4]:ro_lc_sent_rcvd
  #define BIT_MSK__TX_HDCP2X_INTR2__INTR2_STAT4                                           0x10
  // (ReadWrite, Bits 5) 
  // ro_msg_intr[5]:ro_l_sent_rcvd
  #define BIT_MSK__TX_HDCP2X_INTR2__INTR2_STAT5                                           0x20
  // (ReadWrite, Bits 6) 
  // ro_msg_intr[6]:ro_vack_sent_rcvd
  #define BIT_MSK__TX_HDCP2X_INTR2__INTR2_STAT6                                           0x40
  // (ReadWrite, Bits 7) 
  // ro_msg_intr[7]:ro_mack_sent_rcvd
  #define BIT_MSK__TX_HDCP2X_INTR2__INTR2_STAT7                                           0x80

// HDCP AES Debug Register
#define REG_ADDR__TX_HDCP2X_INTR3                                           (TX_HDCP2 | 0x0006)
  // (ReadWrite, Bits 0) 
  // Underrun in AES FIFO
  #define BIT_MSK__TX_HDCP2X_INTR3__INTR3_STAT0                                           0x01
  // (ReadWrite, Bits 1) 
  // Encryption enable status changed(RX only)
  #define BIT_MSK__TX_HDCP2X_INTR3__INTR3_STAT1                                           0x02

// HDCP Interrupt0 Mask Register
#define REG_ADDR__TX_HDCP2X_INTR0_MASK                                      (TX_HDCP2 | 0x0007)
  // (ReadWrite, Bits 0) 
  // Mask for INTR0[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR0_MASK__INTR0_MASK_B0                                         0x01
  // (ReadWrite, Bits 1) 
  // Mask for INTR0[1]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR0_MASK__INTR0_MASK_B1                                         0x02
  // (ReadWrite, Bits 2) 
  // Mask for INTR0[2]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR0_MASK__INTR0_MASK_B2                                         0x04
  // (ReadWrite, Bits 3) 
  // Mask for INTR0[3]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR0_MASK__INTR0_MASK_B3                                         0x08
  // (ReadWrite, Bits 4) 
  // Mask for INTR0[4]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR0_MASK__INTR0_MASK_B4                                         0x10
  // (ReadWrite, Bits 5) 
  // Mask for INTR0[5]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR0_MASK__INTR0_MASK_B5                                         0x20
  // (ReadWrite, Bits 6) 
  // Mask for INTR0[6]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR0_MASK__INTR0_MASK_B6                                         0x40
  // (ReadWrite, Bits 7) 
  // Mask for INTR0[7]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR0_MASK__INTR0_MASK_B7                                         0x80

// HDCP Interrupt1 MaskRegister
#define REG_ADDR__TX_HDCP2X_INTR1_MASK                                      (TX_HDCP2 | 0x0008)
  // (ReadWrite, Bits 0) 
  // Mask for INTR1[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR1_MASK__INTR1_MASK_B0                                         0x01
  // (ReadWrite, Bits 1) 
  // Mask for INTR1[1]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR1_MASK__INTR1_MASK_B1                                         0x02
  // (ReadWrite, Bits 2) 
  // Mask for INTR1[2]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR1_MASK__INTR1_MASK_B2                                         0x04
  // (ReadWrite, Bits 3) 
  // Mask for INTR1[3]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR1_MASK__INTR1_MASK_B3                                         0x08
  // (ReadWrite, Bits 4) 
  // Mask for INTR1[4]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR1_MASK__INTR1_MASK_B4                                         0x10
  // (ReadWrite, Bits 5) 
  // Mask for INTR1[5]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR1_MASK__INTR1_MASK_B5                                         0x20
  // (ReadWrite, Bits 6) 
  // Mask for INTR1[6]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR1_MASK__INTR1_MASK_B6                                         0x40
  // (ReadWrite, Bits 7) 
  // Mask for INTR1[7]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR1_MASK__INTR1_MASK_B7                                         0x80

// HDCP Interrupt2 Mask Register
#define REG_ADDR__TX_HDCP2X_INTR2_MASK                                      (TX_HDCP2 | 0x0009)
  // (ReadWrite, Bits 0) 
  // Mask for INTR2[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR2_MASK__INTR2_MASK_B0                                         0x01
  // (ReadWrite, Bits 1) 
  // Mask for INTR2[1]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR2_MASK__INTR2_MASK_B1                                         0x02
  // (ReadWrite, Bits 2) 
  // Mask for INTR2[2]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR2_MASK__INTR2_MASK_B2                                         0x04
  // (ReadWrite, Bits 3) 
  // Mask for INTR2[3]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR2_MASK__INTR2_MASK_B3                                         0x08
  // (ReadWrite, Bits 4) 
  // Mask for INTR2[4]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR2_MASK__INTR2_MASK_B4                                         0x10
  // (ReadWrite, Bits 5) 
  // Mask for INTR2[5]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR2_MASK__INTR2_MASK_B5                                         0x20
  // (ReadWrite, Bits 6) 
  // Mask for INTR2[6]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR2_MASK__INTR2_MASK_B6                                         0x40
  // (ReadWrite, Bits 7) 
  // Mask for INTR2[7]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR2_MASK__INTR2_MASK_B7                                         0x80

// HDCP Interrupt3 Mask Register
#define REG_ADDR__TX_HDCP2X_INTR3_MASK                                      (TX_HDCP2 | 0x000A)
  // (ReadWrite, Bits 0) 
  // Mask for INTR3[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR3_MASK__INTR3_MASK_B0                                         0x01
  // (ReadWrite, Bits 1) 
  // Mask for INTR3[1]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__TX_HDCP2X_INTR3_MASK__INTR3_MASK_B1                                         0x02

// HDCP Interrupt Status Register
#define REG_ADDR__TX_HDCP2X_INTRSTATUS                                      (TX_HDCP2 | 0x000B)
  // (ReadOnly, Bits 0) 
  // OR of all HDCP interrupts
  #define BIT_MSK__TX_HDCP2X_INTRSTATUS__RO_INTR                                               0x01
  // (ReadOnly, Bits 7:4) 
  // Byte aggregated interrupt stateu Bit 0 for HDCP2X_INTR0 Bit 1 for HDCP2X_INTR1 Bit 2 for HDCP2X_INTR2 Bit 3 for HDCP2X_INTR3
  #define BIT_MSK__TX_HDCP2X_INTRSTATUS__RO_AGGRINTR_B3_B0                                     0xF0

// HDCP Auth Status Register
#define REG_ADDR__TX_HDCP2X_AUTH_STAT                                       (TX_HDCP2 | 0x000C)
  // (ReadOnly, Bits 7:0) 
  // [0]: auth_done [1]: auth_fail [2]: rpt_ready [3]: hash_fail [4]: cchk_done [5]: cchk_fail [6]: reauth_req [7]: polling_inverval
  #define BIT_MSK__TX_HDCP2X_AUTH_STAT__RO_HDCP2_AUTH_STAT_B7_B0                              0xFF
  #define BIT_MSK__TX_HDCP2X_AUTH_STAT__REAUTH_REQ                                            0x40

// HDCP State Status Register
#define REG_ADDR__TX_HDCP2X_STATE                                           (TX_HDCP2 | 0x000D)
  // (ReadOnly, Bits 7:0) 
  // State for debugging
  #define BIT_MSK__TX_HDCP2X_STATE__RO_HDCP2_STATE_B7_B0                                  0xFF

// HDCP General Staus Register
#define REG_ADDR__TX_HDCP2X_GEN_STATUS                                      (TX_HDCP2 | 0x000E)
  // (ReadOnly, Bits 0) 
  // Debugging info: 1 if RAM patch code is running 0 if ROM code is running
  #define BIT_MSK__TX_HDCP2X_GEN_STATUS__RO_HDCP2_PRG_SEL                                      0x01
  // (ReadOnly, Bits 1) 
  // Valid only for Rx. Don't care for Tx. Connected to HDCP2X mode detection signal from i2c. Tuns to 0 if DDC offset address 0 ~ 0x4F are accessed. Turns to 1 if DDC offset address 0x50 and above are accessed. Power on default is 0.
  #define BIT_MSK__TX_HDCP2X_GEN_STATUS__RO_HDCP2RX_MODE_SEL                                   0x02
  // (ReadOnly, Bits 2) 
  // For TX set to 1 when connected downstream device is an HDCP2 repeater. For RX set to 1 if ri_hdcp2x_repeater(HDCP2X_CMD_CTRL_0[1]) is set and HDCP2X core is running.
  #define BIT_MSK__TX_HDCP2X_GEN_STATUS__RO_HDCP2_REPEATER                                     0x04
  // (ReadOnly, Bits 7:4) 
  // encryptino enable status for each stream (up to 4) RX only
  #define BIT_MSK__TX_HDCP2X_GEN_STATUS__ENC_EN                                                0xF0

// HDCP TP0  Register
#define REG_ADDR__TX_HDCP2X_TP0                                             (TX_HDCP2 | 0x0010)
  // (ReadWrite, Bits 7:0) 
  // eclk divider selection (2=divide by 8) 0: divide by 2    1: divide by 4    2: divide by 8   other: divide by 16
  #define BIT_MSK__TX_HDCP2X_TP0__RI_HDCP2_TP0_B7_B0                                    0xFF

// HDCP TP1  Register
#define REG_ADDR__TX_HDCP2X_TP1                                             (TX_HDCP2 | 0x0011)
  // (ReadWrite, Bits 7:0) 
  // Coutner to generate base timer tick Value for 12ms timer = 12ms * eclk / divider / 256  24MHz eclk divide by 8 -] 140 20MHz eckl divide by 8 -] 117 For a given eclk frequency bigger value means slower tick For a given tick time faster eclk requires bigger value.
  #define BIT_MSK__TX_HDCP2X_TP1__RI_HDCP2_TP1_B7_B0                                    0xFF

// HDCP TP2 Register
#define REG_ADDR__TX_HDCP2X_TP2                                             (TX_HDCP2 | 0x0012)
  // (ReadWrite, Bits 7:0) 
  // Restart wait time (Default 1=12ms )
  #define BIT_MSK__TX_HDCP2X_TP2__RI_HDCP2_TP2_B7_B0                                    0xFF

// HDCP TP3  Register
#define REG_ADDR__TX_HDCP2X_TP3                                             (TX_HDCP2 | 0x0013)
  // (ReadWrite, Bits 7:0) 
  // DDC hang timeout  (Default 42=0x2A=504ms)
  #define BIT_MSK__TX_HDCP2X_TP3__RI_HDCP2_TP3_B7_B0                                    0xFF

// HDCP TP4  Register
#define REG_ADDR__TX_HDCP2X_TP4                                             (TX_HDCP2 | 0x0014)
  // (ReadWrite, Bits 7:0) 
  // H check timeout (storedkm case)  (Default 17=0x11=204ms)
  #define BIT_MSK__TX_HDCP2X_TP4__RI_HDCP2_TP4_B7_B0                                    0xFF

// HDCP TP5  Register
#define REG_ADDR__TX_HDCP2X_TP5                                             (TX_HDCP2 | 0x0015)
  // (ReadWrite, Bits 7:0) 
  // H check timeout (no-storedkm case)  (Default 100=1.2s)
  #define BIT_MSK__TX_HDCP2X_TP5__RI_HDCP2_TP5_B7_B0                                    0xFF

// HDCP TP6 Register
#define REG_ADDR__TX_HDCP2X_TP6                                             (TX_HDCP2 | 0x0016)
  // (ReadWrite, Bits 7:0) 
  // Locality check timeout  (Default 2=24ms)
  #define BIT_MSK__TX_HDCP2X_TP6__RI_HDCP2_TP6_B7_B0                                    0xFF

// HDCP TP7  Register
#define REG_ADDR__TX_HDCP2X_TP7                                             (TX_HDCP2 | 0x0017)
  // (ReadWrite, Bits 7:0) 
  // M check timeout  (Default 9=108ms)
  #define BIT_MSK__TX_HDCP2X_TP7__RI_HDCP2_TP7_B7_B0                                    0xFF

// HDCP TP8  Register
#define REG_ADDR__TX_HDCP2X_TP8                                             (TX_HDCP2 | 0x0018)
  // (ReadWrite, Bits 7:0) 
  // Certificate read timeout  (Default 9=108ms)
  #define BIT_MSK__TX_HDCP2X_TP8__RI_HDCP2_TP8_B7_B0                                    0xFF

// HDCP TP9  Register
#define REG_ADDR__TX_HDCP2X_TP9                                             (TX_HDCP2 | 0x0019)
  // (ReadWrite, Bits 7:0) 
  // Paring timeout  (Default 17=0x11=204ms)
  #define BIT_MSK__TX_HDCP2X_TP9__RI_HDCP2_TP9_B7_B0                                    0xFF

// HDCP TP10 Register
#define REG_ADDR__TX_HDCP2X_TP10                                            (TX_HDCP2 | 0x001A)
  // (ReadWrite, Bits 7:0) 
  // Authdonen wait time  (Default 17=0x11=204ms)
  #define BIT_MSK__TX_HDCP2X_TP10__RI_HDCP2_TP10_B7_B0                                   0xFF

// HDCP TP11  Register
#define REG_ADDR__TX_HDCP2X_TP11                                            (TX_HDCP2 | 0x001B)
  // (ReadWrite, Bits 7:0) 
  // V check timeout  (Default 167=0xA7=2s)
  #define BIT_MSK__TX_HDCP2X_TP11__RI_HDCP2_TP11_B7_B0                                   0xFF

// HDCP TP12  Register
#define REG_ADDR__TX_HDCP2X_TP12                                            (TX_HDCP2 | 0x001C)
  // (ReadWrite, Bits 7:0) 
  // Retry wait time  (Default 125 = 0x7D=1.5s)
  #define BIT_MSK__TX_HDCP2X_TP12__RI_HDCP2_TP12_B7_B0                                   0xFF

// HDCP TP13  Register
#define REG_ADDR__TX_HDCP2X_TP13                                            (TX_HDCP2 | 0x001D)
  // (ReadWrite, Bits 7:0) 
  // Stream_Ready to ENC_EN wait time. (Default 13 = 0x0D = 156ms)
  #define BIT_MSK__TX_HDCP2X_TP13__RI_HDCP2_TP13_B7_B0                                   0xFF

// HDCP TP14 Register
#define REG_ADDR__TX_HDCP2X_TP14                                            (TX_HDCP2 | 0x001E)
  // (ReadWrite, Bits 7:0) 
  // Wait time for V (Default 250=0xFA=3s)
  #define BIT_MSK__TX_HDCP2X_TP14__RI_HDCP2_TP14_B7_B0                                   0xFF

// HDCP TP15  Register
#define REG_ADDR__TX_HDCP2X_TP15                                            (TX_HDCP2 | 0x001F)
  // (ReadWrite, Bits 7:0) 
  // L check auto retry limit / 8 (Default 0)
  #define BIT_MSK__TX_HDCP2X_TP15__RI_HDCP2_TP15_B7_B0                                   0xFF

// HDCP GP In 0 Register
#define REG_ADDR__TX_HDCP2X_GP_IN0                                          (TX_HDCP2 | 0x0020)
  // (ReadWrite, Bits 7:0) 
  // General purpose input 0
  #define BIT_MSK__TX_HDCP2X_GP_IN0__RI_HDCP2_GP0_B7_B0                                    0xFF

// HDCP GP In 1 Register
#define REG_ADDR__TX_HDCP2X_GP_IN1                                          (TX_HDCP2 | 0x0021)
  // (ReadWrite, Bits 7:0) 
  // General purpose input 1
  #define BIT_MSK__TX_HDCP2X_GP_IN1__RI_HDCP2_GP1_B7_B0                                    0xFF

// HDCP GP In 2 Register
#define REG_ADDR__TX_HDCP2X_GP_IN2                                          (TX_HDCP2 | 0x0022)
  // (ReadWrite, Bits 7:0) 
  // General purpose input 2
  #define BIT_MSK__TX_HDCP2X_GP_IN2__RI_HDCP2_GP2_B7_B0                                    0xFF

// HDCP GP In 3 Register
#define REG_ADDR__TX_HDCP2X_GP_IN3                                          (TX_HDCP2 | 0x0023)
  // (ReadWrite, Bits 7:0) 
  // General purpose input 3
  #define BIT_MSK__TX_HDCP2X_GP_IN3__RI_HDCP2_GP3_B7_B0                                    0xFF

// HDCP GP Out 0 Register
#define REG_ADDR__TX_HDCP2X_GP_OUT0                                         (TX_HDCP2 | 0x0024)
  // (ReadOnly, Bits 7:0) 
  // Version Indicator. 0X: TX ROM                    5X: RX ROM 2X: TX RAM                     1X: RX RAM 8X: TX RAM                     9X: RX RAM 4X: Sydney TX RAM       3X: Sydney RX RAM 6X: RogueES0 TX RAM  7X: RogueES0 RX RAM
  #define BIT_MSK__TX_HDCP2X_GP_OUT0__RO_HDCP2_GP0_B7_B0                                    0xFF

// HDCP GP Out 1 Register
#define REG_ADDR__TX_HDCP2X_GP_OUT1                                         (TX_HDCP2 | 0x0025)
  // (ReadOnly, Bits 7:0) 
  // General purpose output 1
  #define BIT_MSK__TX_HDCP2X_GP_OUT1__RO_HDCP2_GP1_B7_B0                                    0xFF

// HDCP GP Out 2 Register
#define REG_ADDR__TX_HDCP2X_GP_OUT2                                         (TX_HDCP2 | 0x0026)
  // (ReadOnly, Bits 7:0) 
  // General purpose output 2
  #define BIT_MSK__TX_HDCP2X_GP_OUT2__RO_HDCP2_GP2_B7_B0                                    0xFF

// HDCP GP Out 3 Register
#define REG_ADDR__TX_HDCP2X_GP_OUT3                                         (TX_HDCP2 | 0x0027)
  // (ReadOnly, Bits 7:0) 
  // General purpose output 3
  #define BIT_MSK__TX_HDCP2X_GP_OUT3__RO_HDCP2_GP3_B7_B0                                    0xFF

// HDCP2 Rx ID_0 from Core Register
#define REG_ADDR__TX_HDCP2X_RX_ID_CORE_0                                    (TX_HDCP2 | 0x0028)
  // (ReadOnly, Bits 7:0) 
  // hdcp2 receiver ID from core For RX this 40-bit field is filled as soon as HDCP2x core starts running. For TX this 40-bit field is filled when Certification(including Receiver Device ID) is read from Rx.
  #define BIT_MSK__TX_HDCP2X_RX_ID_CORE_0__RO_HDCP2_RCVR_ID_B7_B0                                0xFF

// HDCP2 Rx ID_1 from Core Register
#define REG_ADDR__TX_HDCP2X_RX_ID_CORE_1                                    (TX_HDCP2 | 0x0029)
  // (ReadOnly, Bits 7:0) 
  // hdcp2 receiver ID from core
  #define BIT_MSK__TX_HDCP2X_RX_ID_CORE_1__RO_HDCP2_RCVR_ID_B15_B8                               0xFF

// HDCP2 Rx ID_2 from Core Register
#define REG_ADDR__TX_HDCP2X_RX_ID_CORE_2                                    (TX_HDCP2 | 0x002A)
  // (ReadOnly, Bits 7:0) 
  // hdcp2 receiver ID from core
  #define BIT_MSK__TX_HDCP2X_RX_ID_CORE_2__RO_HDCP2_RCVR_ID_B23_B16                              0xFF

// HDCP2 Rx ID_3 from Core Register
#define REG_ADDR__TX_HDCP2X_RX_ID_CORE_3                                    (TX_HDCP2 | 0x002B)
  // (ReadOnly, Bits 7:0) 
  // hdcp2 receiver ID from core
  #define BIT_MSK__TX_HDCP2X_RX_ID_CORE_3__RO_HDCP2_RCVR_ID_B31_B24                              0xFF

// HDCP2 Rx ID_4 from Core Register
#define REG_ADDR__TX_HDCP2X_RX_ID_CORE_4                                    (TX_HDCP2 | 0x002C)
  // (ReadOnly, Bits 7:0) 
  // hdcp2x receiver ID from core
  #define BIT_MSK__TX_HDCP2X_RX_ID_CORE_4__RO_HDCP2_RCVR_ID_B39_B32                              0xFF

// HDCP Misc Control 1 Register
#define REG_ADDR__TX_HDCP2X_RPT_DETAIL                                      (TX_HDCP2 | 0x002D)
  // (ReadWrite, Bits 0) 
  // For TX use this bit to read HDCP1DEV_DSTRM field of Receiver ID List message For RX use this bit to program HDCP1DEV_DSTRM field of Receiver ID List message
  #define BIT_MSK__TX_HDCP2X_RPT_DETAIL__RI_HDCP2RX_RPT_HDCP1DEV_DSTRM                         0x01
  // (ReadWrite, Bits 1) 
  // For TX use this bit to read HDCP20RPT_DSTRM field of Receiver ID List message For RX use this bit to program HDCP20RPT_DSTRM field of Receiver ID List message
  #define BIT_MSK__TX_HDCP2X_RPT_DETAIL__RI_HDCP2RX_RPT_HDCP20RPT_DSTRM                        0x02
  // (ReadWrite, Bits 2) 
  // For TX use this bit to read MAX_CASCADE_EXCEEDED  field of Receiver ID List message For RX use this bit to program MAX_CASCADE_EXCEEDED field of Receiver ID List message
  #define BIT_MSK__TX_HDCP2X_RPT_DETAIL__RI_HDCP2RX_RPT_MX_CASC_EXC                            0x04
  // (ReadWrite, Bits 3) 
  // For TX use this bit to read MAX_DEVICE_EXCEEDED  field of Receiver ID List message For RX use this bit to program MAX_DEVICE_EXCEEDED field of Receiver ID List message
  #define BIT_MSK__TX_HDCP2X_RPT_DETAIL__RI_HDCP2RX_RPT_MX_DEVS_EXC                            0x08

// HDCP RPT SMNG K Register
#define REG_ADDR__TX_HDCP2X_RPT_SMNG_K                                      (TX_HDCP2 | 0x002E)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to program K  field of Stream Management message For RX use this bit to read K field of Stream Manage message
  #define BIT_MSK__TX_HDCP2X_RPT_SMNG_K__RI_HDCP2TX_RPT_SMNG_K_B7_B0                           0xFF

// HDCP Depth Control Register
#define REG_ADDR__TX_HDCP2X_RPT_DEPTH                                       (TX_HDCP2 | 0x002F)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to read DEPTH  field of Receiver ID List message For RX use this bit to program DEPTH field of Receiver ID List message
  #define BIT_MSK__TX_HDCP2X_RPT_DEPTH__RI_HDCP2RX_RPT_DEPTH_B7_B0                            0xFF

// HDCP Devcnt Control Register
#define REG_ADDR__TX_HDCP2X_RPT_DEVCNT                                      (TX_HDCP2 | 0x0030)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to read DEVICE_COUNT  field of Receiver ID List message For RX use this bit to program DEVICE_COUNT field of Receiver ID List message
  #define BIT_MSK__TX_HDCP2X_RPT_DEVCNT__RI_HDCP2RX_RPT_DEVCNT_B7_B0                           0xFF

// HDCP RPT SEQ NUM V 0 Register
#define REG_ADDR__TX_HDCP2X_RX_SEQ_NUM_V_0                                  (TX_HDCP2 | 0x0031)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to read seq_num_V  field of Receiver ID List message For RX use this bit to program seq_num_V field of Receiver ID List message
  #define BIT_MSK__TX_HDCP2X_RX_SEQ_NUM_V_0__RI_HDCP2RX_RPT_SEQ_NUM_V_B7_B0                        0xFF

// HDCP RPT SEQ NUM V 1 Register
#define REG_ADDR__TX_HDCP2X_RX_SEQ_NUM_V_1                                  (TX_HDCP2 | 0x0032)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to read seq_num_V  field of Receiver ID List message For RX use this bit to program seq_num_V field of Receiver ID List message
  #define BIT_MSK__TX_HDCP2X_RX_SEQ_NUM_V_1__RI_HDCP2RX_RPT_SEQ_NUM_V_B15_B8                       0xFF

// HDCP RPT SEQ NUM V 2 Register
#define REG_ADDR__TX_HDCP2X_RX_SEQ_NUM_V_2                                  (TX_HDCP2 | 0x0033)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to read seq_num_V  field of Receiver ID List message For RX use this bit to program seq_num_V field of Receiver ID List message
  #define BIT_MSK__TX_HDCP2X_RX_SEQ_NUM_V_2__RI_HDCP2RX_RPT_SEQ_NUM_V_B23_B16                      0xFF

// HDCP RPT SEQ NUM M 0 Register
#define REG_ADDR__TX_HDCP2X_RX_SEQ_NUM_M_0                                  (TX_HDCP2 | 0x0034)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to program seq_num_M  field of Stream Management message For RX use this bit to read seq_num_M  field of Stream Manage message
  #define BIT_MSK__TX_HDCP2X_RX_SEQ_NUM_M_0__RI_HDCP2TX_RPT_SEQ_NUM_M_B7_B0                        0xFF

// HDCP RPT SEQ NUM M 1 Register
#define REG_ADDR__TX_HDCP2X_RX_SEQ_NUM_M_1                                  (TX_HDCP2 | 0x0035)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to program seq_num_M  field of Stream Management message For RX use this bit to read seq_num_M  field of Stream Manage message
  #define BIT_MSK__TX_HDCP2X_RX_SEQ_NUM_M_1__RI_HDCP2TX_RPT_SEQ_NUM_M_B15_B8                       0xFF

// HDCP RPT SEQ NUM M 2 Register
#define REG_ADDR__TX_HDCP2X_RX_SEQ_NUM_M_2                                  (TX_HDCP2 | 0x0036)
  // (ReadWrite, Bits 7:0) 
  // For TX use this bit to program seq_num_M  field of Stream Management message For RX use this bit to read seq_num_M  field of Stream Manage message
  #define BIT_MSK__TX_HDCP2X_RX_SEQ_NUM_M_2__RI_HDCP2TX_RPT_SEQ_NUM_M_B23_B16                      0xFF

// HDCP Input Counter 0 Register
#define REG_ADDR__TX_HDCP2X_IPT_CTR_7TO0                                    (TX_HDCP2 | 0x0037)
  // (ReadOnly, Bits 7:0) 
  // Frame counter (input counter[33:26]) to monitor if input coutner value changes.
  #define BIT_MSK__TX_HDCP2X_IPT_CTR_7TO0__RO_HDCP2_IPT_CTR_B7_B0                                0xFF

// HDCP Input Counter 1 Register
#define REG_ADDR__TX_HDCP2X_IPT_CTR_15TO8                                   (TX_HDCP2 | 0x0038)
  // (ReadOnly, Bits 7:0) 
  // Frame counter (input counter[41:34]) to monitor if input coutner value changes.
  #define BIT_MSK__TX_HDCP2X_IPT_CTR_15TO8__RO_HDCP2_IPT_CTR_B15_B8                               0xFF

// HDCP AES Control Register
#define REG_ADDR__TX_HDCP2X_AESCTL                                          (TX_HDCP2 | 0x0039)
  // (ReadWrite, Bits 0) 
  // Apply manual AES reset
  #define BIT_MSK__TX_HDCP2X_AESCTL__RI_AES_RST_MAN                                        0x01
  // (ReadWrite, Bits 1) 
  // Apply AES reset when authdone=0
  #define BIT_MSK__TX_HDCP2X_AESCTL__RI_AES_RST_AUTHDONE                                   0x02

// HDCP Debug Control Register
#define REG_ADDR__TX_HDCP2X_DBGCTL                                          (TX_HDCP2 | 0x003A)
  // (ReadWrite, Bits 7:0) 
  // Debug control
  #define BIT_MSK__TX_HDCP2X_DBGCTL__RI_HDCP2_DBG_CTL_B7_B0                                0xFF

// HDCP Debug Control 2 Register
#define REG_ADDR__TX_HDCP2X_DBGCTL2                                         (TX_HDCP2 | 0x003B)
  // (ReadWrite, Bits 7:0) 
  // Debug control 2
  #define BIT_MSK__TX_HDCP2X_DBGCTL2__RI_HDCP2_DBG_CTL2_B7_B0                               0xFF

// HDCP Misc Control 0 Register
#define REG_ADDR__TX_HDCP2X_RX_CTRL_0                                       (TX_HDCP2 | 0x0040)
  // (ReadWrite, Bits 0) 
  // Valid only for Rx. Don't care for Tx. Write to Receiver ID List message buffer.
  #define BIT_MSK__TX_HDCP2X_RX_CTRL_0__RI_HDCP2RX_RPT_RCVID_WR                               0x01
  // (ReadWrite, Bits 1) 
  // Valid only for Rx. Don't care for Tx. Write 1 to reset Receiver ID List message buffer pointer to 0.
  #define BIT_MSK__TX_HDCP2X_RX_CTRL_0__RI_HDCP2RX_RPT_RCVID_WR_START                         0x02
  // (ReadWrite, Bits 2) 
  // Valid only for Rx. Don't care for Tx. Write 1 to start transfer of Receiver ID List message.
  #define BIT_MSK__TX_HDCP2X_RX_CTRL_0__RI_HDCP2RX_RPT_RCVID_XFER_START                       0x04
  // (ReadWrite, Bits 3) 
  // Valid only for Rx. Don't care for Tx. Read from Stream Manage message buffer.
  #define BIT_MSK__TX_HDCP2X_RX_CTRL_0__RI_HDCP2RX_RPT_SMNG_RD                                0x08
  // (ReadWrite, Bits 4) 
  // Valid only for Rx. Don't care for Tx. Write 1 to reset Stream Manage message buffer pointer to 0.
  #define BIT_MSK__TX_HDCP2X_RX_CTRL_0__RI_HDCP2RX_RPT_SMNG_RD_START                          0x10
  // (ReadWrite, Bits 5) 
  // Valid only for Rx. Don't care for Tx. 0: Clear reauth_req when RX_STATUS register is read out. 1: Clear reauth_req under internal 8051 control.
  #define BIT_MSK__TX_HDCP2X_RX_CTRL_0__RI_REAUTH_REQ_CLR_OPTION                              0x20
  // (ReadWrite, Bits 6) 
  // Valid only for Rx. Don't care for Tx. 0: Clear rpt_ready when RX_STATUS register is read out. 1: Clear rpt_ready under internal 8051 control.
  #define BIT_MSK__TX_HDCP2X_RX_CTRL_0__RI_RPT_READY_CLR_OPTION                               0x40
  // (ReadWrite, Bits 7) 
  // Valid only for Rx. Don't care for Tx. 0: Clear msg_sz when msg_send_done is asserted. 1: Clear msg_sz under internal 8051 control.
  #define BIT_MSK__TX_HDCP2X_RX_CTRL_0__RI_MSG_SZ_CLR_OPTION                                  0x80

// HDCP Misc Staus Register
#define REG_ADDR__TX_HDCP2X_RX_STATUS                                       (TX_HDCP2 | 0x0041)
  // (ReadOnly, Bits 2) 
  // Valid only for Rx. Don't care for Tx. Indicate that Receiver ID List message transfer is done. (Also connected to INTR1[4])
  #define BIT_MSK__TX_HDCP2X_RX_STATUS__RO_HDCP2RX_RPT_RCVID_XFER_DONE                        0x04

// HDCP RPT SMNG Out Register
#define REG_ADDR__TX_HDCP2X_RX_RPT_SMNG_OUT                                 (TX_HDCP2 | 0x0042)
  // (ReadOnly, Bits 7:0) 
  // Valid only for Rx. Don't care for Tx. Data output port for Stream Manage message buffer.
  #define BIT_MSK__TX_HDCP2X_RX_RPT_SMNG_OUT__RO_HDCP2RX_RPT_SMNG_OUT_B7_B0                         0xFF

// HDCP RPT RCVID In Register
#define REG_ADDR__TX_HDCP2X_RX_RPT_RCVID_IN                                 (TX_HDCP2 | 0x0043)
  // (ReadWrite, Bits 7:0) 
  // Valid only for Rx. Don't care for Tx. Write one byte to Receiver ID List message buffer.
  #define BIT_MSK__TX_HDCP2X_RX_RPT_RCVID_IN__RI_HDCP2RX_RPT_RCVID_IN                               0xFF

// HDCP ECC Control Register
#define REG_ADDR__TX_HDCP2X_RX_ECC_CTRL                                     (TX_HDCP2 | 0x0044)
  // (ReadWrite, Bits 0) 
  // Enable ECC based out-of-sync detection
  #define BIT_MSK__TX_HDCP2X_RX_ECC_CTRL__RI_ECC_CHK_EN                                         0x01
  // (ReadWrite, Bits 2:1) 
  // 00: accumulates ECC errors until it reaches a given threshold. 01: In a given number of consecutive frames in which ECC errors keep reaching the threshold 10: In a given number of consecutive frames we don't get any correct ECC 11: Accumulates ECC errors for a given number of frames
  #define BIT_MSK__TX_HDCP2X_RX_ECC_CTRL__RI_ECC_CHK_MODE                                       0x06
  // (ReadWrite, Bits 3) 
  // Write 1 then 0 to clear counter manually.
  #define BIT_MSK__TX_HDCP2X_RX_ECC_CTRL__RI_ACCM_ERR_MANU_CLR                                  0x08

// HDCP ECC Count for Check 0 Register
#define REG_ADDR__TX_HDCP2X_RX_ECC_CNT2CHK_0                                (TX_HDCP2 | 0x0045)
  // (ReadWrite, Bits 7:0) 
  // VSYNC count to skip before starting ECC check
  #define BIT_MSK__TX_HDCP2X_RX_ECC_CNT2CHK_0__RI_CNT2CHK_ECC_B7_B0                                  0xFF

// HDCP ECC Count for Check 1 Register
#define REG_ADDR__TX_HDCP2X_RX_ECC_CNT2CHK_1                                (TX_HDCP2 | 0x0046)
  // (ReadWrite, Bits 0) 
  // VSYNC count to skip before starting ECC check
  #define BIT_MSK__TX_HDCP2X_RX_ECC_CNT2CHK_1__RI_CNT2CHK_ECC_B8                                     0x01

// HDCP ECC ACCM Error Threshold 0 Register
#define REG_ADDR__TX_HDCP2X_RX_ECC_ACCM_ERR_THR_0                           (TX_HDCP2 | 0x0047)
  // (ReadWrite, Bits 7:0) 
  // Threadshold for accumulated ECC error
  #define BIT_MSK__TX_HDCP2X_RX_ECC_ACCM_ERR_THR_0__RI_ACCM_ERR_THR_B7_B0                                 0xFF

// HDCP ECC ACCM Error Threshold 1 Register
#define REG_ADDR__TX_HDCP2X_RX_ECC_ACCM_ERR_THR_1                           (TX_HDCP2 | 0x0048)
  // (ReadWrite, Bits 7:0) 
  // Threadshold for accumulated ECC error
  #define BIT_MSK__TX_HDCP2X_RX_ECC_ACCM_ERR_THR_1__RI_ACCM_ERR_THR_B15_B8                                0xFF

// HDCP ECC ACCM Error Threshold 2 Register
#define REG_ADDR__TX_HDCP2X_RX_ECC_ACCM_ERR_THR_2                           (TX_HDCP2 | 0x0049)
  // (ReadWrite, Bits 4:0) 
  // Threadshold for accumulated ECC error
  #define BIT_MSK__TX_HDCP2X_RX_ECC_ACCM_ERR_THR_2__RI_ACCM_ERR_THR_B20_B16                               0x1F

// HDCP ECC Frame Error Threshold 0 Register
#define REG_ADDR__TX_HDCP2X_RX_ECC_FRM_ERR_THR_0                            (TX_HDCP2 | 0x004A)
  // (ReadWrite, Bits 7:0) 
  // Threadshold for frame ECC error
  #define BIT_MSK__TX_HDCP2X_RX_ECC_FRM_ERR_THR_0__RI_FRAME_ECC_ERR_THR_B7_B0                            0xFF

// HDCP ECC Frame Error Threshold 1 Register
#define REG_ADDR__TX_HDCP2X_RX_ECC_FRM_ERR_THR_1                            (TX_HDCP2 | 0x004B)
  // (ReadWrite, Bits 7:0) 
  // Threadshold for frame ECC error
  #define BIT_MSK__TX_HDCP2X_RX_ECC_FRM_ERR_THR_1__RI_FRAME_ECC_ERR_THR_B15_B8                           0xFF

// HDCP ECC Consecutive Frames Error Threshold Register
#define REG_ADDR__TX_HDCP2X_RX_CONS_ERR_THR                                 (TX_HDCP2 | 0x004C)
  // (ReadWrite, Bits 7:0) 
  // Number of consecutive frames in which ECC error get threshold
  #define BIT_MSK__TX_HDCP2X_RX_CONS_ERR_THR__RI_CONS_ECC_ERR_THR_B7_B0                             0xFF

// HDCP ECC No Error Threshold Register
#define REG_ADDR__TX_HDCP2X_RX_ECC_NO_ERR_THR                               (TX_HDCP2 | 0x004D)
  // (ReadWrite, Bits 7:0) 
  // Number of consecutive frames that does not get correct ECC
  #define BIT_MSK__TX_HDCP2X_RX_ECC_NO_ERR_THR__RI_NO_ECC_THR_B7_B0                                   0xFF

// HDCP ECC Given Frame Error Register
#define REG_ADDR__TX_HDCP2X_RX_GVN_FRM                                      (TX_HDCP2 | 0x004E)
  // (ReadWrite, Bits 7:0) 
  // Number of consecutive frames in which accumulate ECC error
  #define BIT_MSK__TX_HDCP2X_RX_GVN_FRM__RI_GIVEN_FRAME_B7_B0                                  0xFF

// HDCP ECC Given Frame Error Threshold 0 Register
#define REG_ADDR__TX_HDCP2X_RX_ECC_GVN_FRM_ERR_THR_0                        (TX_HDCP2 | 0x004F)
  // (ReadWrite, Bits 7:0) 
  // Threshold for the number of ECC errors in given frames
  #define BIT_MSK__TX_HDCP2X_RX_ECC_GVN_FRM_ERR_THR_0__RI_GIVEN_FRAME_ERR_THR_B7_B0                          0xFF

// HDCP ECC Given Frame Error Threshold 1 Register
#define REG_ADDR__TX_HDCP2X_RX_ECC_GVN_FRM_ERR_THR_1                        (TX_HDCP2 | 0x0050)
  // (ReadWrite, Bits 7:0) 
  // Threshold for the number of ECC errors in given frames
  #define BIT_MSK__TX_HDCP2X_RX_ECC_GVN_FRM_ERR_THR_1__RI_GIVEN_FRAME_ERR_THR_B15_B8                         0xFF

// HDCP ECC Given Frame Error Threshold 2 Register
#define REG_ADDR__TX_HDCP2X_RX_ECC_GVN_FRM_ERR_THR_2                        (TX_HDCP2 | 0x0051)
  // (ReadWrite, Bits 4:0) 
  // Threshold for the number of ECC errors in given frames
  #define BIT_MSK__TX_HDCP2X_RX_ECC_GVN_FRM_ERR_THR_2__RI_GIVEN_FRAME_ERR_THR_B20_B16                        0x1F

// HDCP Misc Control 0 Register
#define REG_ADDR__TX_HDCP2X_TX_CTRL_0                                       (TX_HDCP2 | 0x0070)
  // (ReadWrite, Bits 0) 
  // Valid only for Tx. Don't care for Rx. Read from Receiver ID List message buffer.
  #define BIT_MSK__TX_HDCP2X_TX_CTRL_0__RI_HDCP2TX_RPT_RCVID_RD                               0x01
  // (ReadWrite, Bits 1) 
  // Valid only for Tx. Don't care for Rx. Write 1 to reset Receiver ID List message buffer pointer to 0.
  #define BIT_MSK__TX_HDCP2X_TX_CTRL_0__RI_HDCP2TX_RPT_RCVID_RD_START                         0x02
  // (ReadWrite, Bits 2) 
  // Valid only for Tx. Don't care for Rx. Write 1 to start transfer of Stream Manage message.
  #define BIT_MSK__TX_HDCP2X_TX_CTRL_0__RI_HDCP2TX_RPT_SMNG_XFER_START                        0x04
  // (ReadWrite, Bits 3) 
  // Valid only for Tx. Don't care for Rx. Write to Stream Manage message buffer.
  #define BIT_MSK__TX_HDCP2X_TX_CTRL_0__RI_HDCP2TX_RPT_SMNG_WR                                0x08
  // (ReadWrite, Bits 4) 
  // Valid only for Tx. Don't care for Rx. Write 1 to reset Stream Manage message buffer pointer to 0.
  #define BIT_MSK__TX_HDCP2X_TX_CTRL_0__RI_HDCP2TX_RPT_SMNG_WR_START                          0x10

// HDCP Misc Staus Register
#define REG_ADDR__TX_HDCP2X_TX_STATUS                                       (TX_HDCP2 | 0x0071)
  // (ReadOnly, Bits 2) 
  // Valid only for Tx. Don't care for Rx. Indicate that Stream Manage message transfer is done. (Also connected to INTR1[5])
  #define BIT_MSK__TX_HDCP2X_TX_STATUS__RO_HDCP2TX_RPT_SMNG_XFER_DONE                         0x04

// HDCP RPT SMNG In Register
#define REG_ADDR__TX_HDCP2X_TX_RPT_SMNG_IN                                  (TX_HDCP2 | 0x0072)
  // (ReadWrite, Bits 7:0) 
  // Valid only for Tx. Don't care for Rx. Write one byte to Stream Manage message buffer.
  #define BIT_MSK__TX_HDCP2X_TX_RPT_SMNG_IN__RI_HDCP2TX_RPT_SMNG_IN                                0xFF

// HDCP RPT RCVID Out Register
#define REG_ADDR__TX_HDCP2X_TX_RPT_RCVID_OUT                                (TX_HDCP2 | 0x0073)
  // (ReadOnly, Bits 7:0) 
  // Valid only for Tx. Don't care for Rx. Data output port for Receiver ID List message buffer.
  #define BIT_MSK__TX_HDCP2X_TX_RPT_RCVID_OUT__RO_HDCP2TX_RPT_RCVID_OUT_B7_B0                        0xFF

// HDCP Stream Count 0a Register
#define REG_ADDR__TX_HDCP2X_STM_CTR_0A                                      (TX_HDCP2 | 0x0080)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__TX_HDCP2X_STM_CTR_0A__RI_HDCP2TX_STM_CTR_B7_B0                              0xFF

// HDCP Stream Count 0b Register
#define REG_ADDR__TX_HDCP2X_STM_CTR_0B                                      (TX_HDCP2 | 0x0081)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__TX_HDCP2X_STM_CTR_0B__RI_HDCP2TX_STM_CTR_B15_B8                             0xFF

// HDCP Stream Count 0c Register
#define REG_ADDR__TX_HDCP2X_STM_CTR_0C                                      (TX_HDCP2 | 0x0082)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__TX_HDCP2X_STM_CTR_0C__RI_HDCP2TX_STM_CTR_B23_B16                            0xFF

// HDCP Stream Count 0d Register
#define REG_ADDR__TX_HDCP2X_STM_CTR_0D                                      (TX_HDCP2 | 0x0083)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__TX_HDCP2X_STM_CTR_0D__RI_HDCP2TX_STM_CTR_B31_B24                            0xFF

// HDCP Stream Count 1a Register
#define REG_ADDR__TX_HDCP2X_STM_CTR_1A                                      (TX_HDCP2 | 0x0084)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__TX_HDCP2X_STM_CTR_1A__RI_HDCP2TX_STM_CTR_B39_B32                            0xFF

// HDCP Stream Count 1b Register
#define REG_ADDR__TX_HDCP2X_STM_CTR_1B                                      (TX_HDCP2 | 0x0085)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__TX_HDCP2X_STM_CTR_1B__RI_HDCP2TX_STM_CTR_B47_B40                            0xFF

// HDCP Stream Count 1c Register
#define REG_ADDR__TX_HDCP2X_STM_CTR_1C                                      (TX_HDCP2 | 0x0086)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__TX_HDCP2X_STM_CTR_1C__RI_HDCP2TX_STM_CTR_B55_B48                            0xFF

// HDCP Stream Count 1d Register
#define REG_ADDR__TX_HDCP2X_STM_CTR_1D                                      (TX_HDCP2 | 0x0087)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__TX_HDCP2X_STM_CTR_1D__RI_HDCP2TX_STM_CTR_B63_B56                            0xFF

// HDCP Stream Count 2a Register
#define REG_ADDR__TX_HDCP2X_STM_CTR_2A                                      (TX_HDCP2 | 0x0088)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__TX_HDCP2X_STM_CTR_2A__RI_HDCP2TX_STM_CTR_B71_B64                            0xFF

// HDCP Stream Count 2b Register
#define REG_ADDR__TX_HDCP2X_STM_CTR_2B                                      (TX_HDCP2 | 0x0089)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__TX_HDCP2X_STM_CTR_2B__RI_HDCP2TX_STM_CTR_B79_B72                            0xFF

// HDCP Stream Count 2c Register
#define REG_ADDR__TX_HDCP2X_STM_CTR_2C                                      (TX_HDCP2 | 0x008A)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__TX_HDCP2X_STM_CTR_2C__RI_HDCP2TX_STM_CTR_B87_B80                            0xFF

// HDCP Stream Count 2d Register
#define REG_ADDR__TX_HDCP2X_STM_CTR_2D                                      (TX_HDCP2 | 0x008B)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__TX_HDCP2X_STM_CTR_2D__RI_HDCP2TX_STM_CTR_B95_B88                            0xFF

// HDCP Stream Count 3a Register
#define REG_ADDR__TX_HDCP2X_STM_CTR_3A                                      (TX_HDCP2 | 0x008C)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__TX_HDCP2X_STM_CTR_3A__RI_HDCP2TX_STM_CTR_B103_B96                           0xFF

// HDCP Stream Count 3b Register
#define REG_ADDR__TX_HDCP2X_STM_CTR_3B                                      (TX_HDCP2 | 0x008D)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__TX_HDCP2X_STM_CTR_3B__RI_HDCP2TX_STM_CTR_B111_B104                          0xFF

// HDCP Stream Count 3c Register
#define REG_ADDR__TX_HDCP2X_STM_CTR_3C                                      (TX_HDCP2 | 0x008E)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__TX_HDCP2X_STM_CTR_3C__RI_HDCP2TX_STM_CTR_B119_B112                          0xFF

// HDCP Stream Count 3d Register
#define REG_ADDR__TX_HDCP2X_STM_CTR_3D                                      (TX_HDCP2 | 0x008F)
  // (ReadWrite, Bits 7:0) 
  // Only for MHL TX
  #define BIT_MSK__TX_HDCP2X_STM_CTR_3D__RI_HDCP2TX_STM_CTR_B127_B120                          0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_CTRL0                                     (TX_HDCP2 | 0x00A0)
  // (ReadWrite, Bits 7:0) 
  // Debug Control 0 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_CTRL0__REG_HDCP2X_DEBUG_CTRL0                                0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_CTRL1                                     (TX_HDCP2 | 0x00A1)
  // (ReadWrite, Bits 7:0) 
  // Debug Control 1 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_CTRL1__REG_HDCP2X_DEBUG_CTRL1                                0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_CTRL2                                     (TX_HDCP2 | 0x00A2)
  // (ReadWrite, Bits 7:0) 
  // Debug Control 2 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_CTRL2__REG_HDCP2X_DEBUG_CTRL2                                0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_CTRL3                                     (TX_HDCP2 | 0x00A3)
  // (ReadWrite, Bits 7:0) 
  // Debug Control 3 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_CTRL3__REG_HDCP2X_DEBUG_CTRL3                                0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_CTRL4                                     (TX_HDCP2 | 0x00A4)
  // (ReadWrite, Bits 7:0) 
  // Debug Control 4 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_CTRL4__REG_HDCP2X_DEBUG_CTRL4                                0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_STAT0                                     (TX_HDCP2 | 0x00A5)
  // (ReadOnly, Bits 7:0) 
  // Debug Status 0 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_STAT0__REG_HDCP2X_DEBUG_STAT0                                0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_STAT1                                     (TX_HDCP2 | 0x00A6)
  // (ReadOnly, Bits 7:0) 
  // Debug Status 1 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_STAT1__REG_HDCP2X_DEBUG_STAT1                                0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_STAT2                                     (TX_HDCP2 | 0x00A7)
  // (ReadOnly, Bits 7:0) 
  // Debug Status 2 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_STAT2__REG_HDCP2X_DEBUG_STAT2                                0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_STAT3                                     (TX_HDCP2 | 0x00A8)
  // (ReadOnly, Bits 7:0) 
  // Debug Status 3 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_STAT3__REG_HDCP2X_DEBUG_STAT3                                0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_STAT4                                     (TX_HDCP2 | 0x00A9)
  // (ReadOnly, Bits 7:0) 
  // Debug Status 4 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_STAT4__REG_HDCP2X_DEBUG_STAT4                                0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_STAT5                                     (TX_HDCP2 | 0x00AA)
  // (ReadOnly, Bits 7:0) 
  // Debug Status 5 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_STAT5__REG_HDCP2X_DEBUG_STAT5                                0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_STAT6                                     (TX_HDCP2 | 0x00AB)
  // (ReadOnly, Bits 7:0) 
  // Debug Status 6 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_STAT6__REG_HDCP2X_DEBUG_STAT6                                0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_STAT7                                     (TX_HDCP2 | 0x00AC)
  // (ReadOnly, Bits 7:0) 
  // Debug Status 7 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_STAT7__REG_HDCP2X_DEBUG_STAT7                                0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_STAT8                                     (TX_HDCP2 | 0x00AD)
  // (ReadOnly, Bits 7:0) 
  // Debug Status 8 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_STAT8__REG_HDCP2X_DEBUG_STAT8                                0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_STAT9                                     (TX_HDCP2 | 0x00AE)
  // (ReadOnly, Bits 7:0) 
  // Debug Status 9 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_STAT9__REG_HDCP2X_DEBUG_STAT9                                0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_STAT10                                    (TX_HDCP2 | 0x00AF)
  // (ReadOnly, Bits 7:0) 
  // Debug Status 10 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_STAT10__REG_HDCP2X_DEBUG_STAT10                               0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_STAT11                                    (TX_HDCP2 | 0x00B0)
  // (ReadOnly, Bits 7:0) 
  // Debug Status 11 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_STAT11__REG_HDCP2X_DEBUG_STAT11                               0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_STAT12                                    (TX_HDCP2 | 0x00B1)
  // (ReadOnly, Bits 7:0) 
  // Debug Status 12 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_STAT12__REG_HDCP2X_DEBUG_STAT12                               0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_STAT13                                    (TX_HDCP2 | 0x00B2)
  // (ReadOnly, Bits 7:0) 
  // Debug Status 13 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_STAT13__REG_HDCP2X_DEBUG_STAT13                               0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_STAT14                                    (TX_HDCP2 | 0x00B3)
  // (ReadOnly, Bits 7:0) 
  // Debug Status 14 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_STAT14__REG_HDCP2X_DEBUG_STAT14                               0xFF

// HDCP Temp Register
#define REG_ADDR__TX_HDCP2X_DEBUG_STAT15                                    (TX_HDCP2 | 0x00B4)
  // (ReadOnly, Bits 7:0) 
  // Debug Status 15 for HDCP 2.x
  #define BIT_MSK__TX_HDCP2X_DEBUG_STAT15__REG_HDCP2X_DEBUG_STAT15                               0xFF

// HDCP Software Reset Register
#define REG_ADDR__TX_HDCP2X_TX_SRST                                         (TX_HDCP2 | 0x00B5)
  // (ReadWrite, Bits 0) 
  // HDCP Soft Reset for crystal clock domain
  #define BIT_MSK__TX_HDCP2X_TX_SRST__REG_HDCP2X_CRST                                       0x01
  // (ReadWrite, Bits 1) 
  // HDCP Soft Reset for pixel clock domain
  #define BIT_MSK__TX_HDCP2X_TX_SRST__REG_HDCP2X_PRST                                       0x02
  // (ReadWrite, Bits 2) 
  // HDCP Soft Reset for eclock domain
  #define BIT_MSK__TX_HDCP2X_TX_SRST__REG_HDCP2X_ERST                                       0x04
  // (ReadWrite, Bits 3) 
  // HDCP Soft Reset for sclock domain
  #define BIT_MSK__TX_HDCP2X_TX_SRST__REG_HDCP2X_SRST                                       0x08
  // (ReadWrite, Bits 5) 
  // Software Reset for hdcp2x logic only 1 - Reset 0 - Normal operation (default).
  #define BIT_MSK__TX_HDCP2X_TX_SRST__REG_HDCP2X_SW_RST                                     0x20

// HDCP Polling Control and Status Register
#define REG_ADDR__TX_HDCP2X_POLL_CS                                         (TX_HDCP2 | 0x00B6)
  // (ReadWrite, Bits 0) 
  // 1: Disable polling 0: Enable polling (default)
  #define BIT_MSK__TX_HDCP2X_POLL_CS__REG_HDCP2X_DIS_POLL_EN                                0x01
  // (ReadOnly, Bits 1) 
  // A status to indicate that HDCP2.2 polling logic has the DDC bus
  #define BIT_MSK__TX_HDCP2X_POLL_CS__REG_HDCP2X_DIS_POLL_GNT                               0x02
  // (ReadWrite, Bits 4) 
  // Reauthentication request clear option. Not used in Cypress.  Can be used as spare register
  #define BIT_MSK__TX_HDCP2X_POLL_CS__REG_HDCP2X_REAUTH_REQ_CLR_OPTION                      0x10
  // (ReadWrite, Bits 5) 
  // Repeater ready status clear option. Not used in Cypress.  Can be used as spare register
  #define BIT_MSK__TX_HDCP2X_POLL_CS__REG_HDCP2X_RPT_READY_CLR_OPTION                       0x20
  // (ReadWrite, Bits 6) 
  // Message size clear option. Not used in Cypress.  Can be used as spare register
  #define BIT_MSK__TX_HDCP2X_POLL_CS__REG_HDCP2X_MSG_SZ_CLR_OPTION                          0x40

// HDCP PRAM Starting Address Lo Register
#define REG_ADDR__TX_HDCP2X_CUPD_START_ADDR_LO                              (TX_HDCP2 | 0x00B7)
  // (ReadWrite, Bits 7:0) 
  // Lower byte starting address for PRAM access This is the starting address for PRAM access. Program this before reg_hdcp2x_cupd_start or reg_hdcp2x_cupd_addr_reset
  #define BIT_MSK__TX_HDCP2X_CUPD_START_ADDR_LO__REG_HDCP2X_CUPD_S_ADDR_B7_B0                          0xFF

// HDCP PRAM Starting Address Hi Register
#define REG_ADDR__TX_HDCP2X_CUPD_START_ADDR_HI                              (TX_HDCP2 | 0x00B8)
  // (ReadWrite, Bits 7:0) 
  // Higher byte starting address for PRAM access This is the starting address for PRAM access. Program this before reg_hdcp2x_cupd_start or reg_hdcp2x_cupd_addr_reset
  #define BIT_MSK__TX_HDCP2X_CUPD_START_ADDR_HI__REG_HDCP2X_CUPD_S_ADDR_B15_B8                         0xFF

// HDCP PRAM Signature Starting Address Lo Register
#define REG_ADDR__TX_HDCP2X_CUPD_SIGN_START_ADDR_LO                         (TX_HDCP2 | 0x00B9)
  // (ReadWrite, Bits 7:0) 
  // Lower byte starting address for signature portion of PRAM access This is the starting address for signature portion for PRAM access. Program this before reg_hdcp2x_cupd_start or reg_hdcp2x_cupd_addr_reset
  #define BIT_MSK__TX_HDCP2X_CUPD_SIGN_START_ADDR_LO__REG_HDCP2X_CUPD_SI_S_ADDR_B7_B0                       0xFF

// HDCP PRAM Signature Starting Address Hi Register
#define REG_ADDR__TX_HDCP2X_CUPD_SIGN_START_ADDR_HI                         (TX_HDCP2 | 0x00BA)
  // (ReadWrite, Bits 7:0) 
  // Higher byte starting address for signature portion of PRAM access This is the starting address for signature portion for PRAM access. Program this before reg_hdcp2x_cupd_start or reg_hdcp2x_cupd_addr_reset
  #define BIT_MSK__TX_HDCP2X_CUPD_SIGN_START_ADDR_HI__REG_HDCP2X_CUPD_SI_S_ADDR_B15_B8                      0xFF

// HDCP PRAM Signature Ending Address Lo Register
#define REG_ADDR__TX_HDCP2X_PRAM_SIGN_END_ADDR_LO                           (TX_HDCP2 | 0x00BB)
  // (ReadWrite, Bits 7:0) 
  // Lower byte ending address for signature portion of PRAM access This is the starting address for signature portion for PRAM access. Program this before reg_hdcp2x_cupd_start or reg_hdcp2x_cupd_addr_reset
  #define BIT_MSK__TX_HDCP2X_PRAM_SIGN_END_ADDR_LO__REG_HDCP2X_CUPD_SI_E_ADDR_B7_B0                       0xFF

// HDCP PRAM Signature Ending Address Hi Register
#define REG_ADDR__TX_HDCP2X_CUPD_SIGN_END_ADDR_HI                           (TX_HDCP2 | 0x00BC)
  // (ReadWrite, Bits 7:0) 
  // Higher byte ending address for signature portion of PRAM access This is the starting address for signature portion for PRAM access. Program this before reg_hdcp2x_cupd_start or reg_hdcp2x_cupd_addr_reset
  #define BIT_MSK__TX_HDCP2X_CUPD_SIGN_END_ADDR_HI__REG_HDCP2X_CUPD_SI_E_ADDR_B15_B8                      0xFF

// HDCP General Control 0 Register
#define REG_ADDR__TX_HDCP2X_CTL_0                                           (TX_HDCP2 | 0x00BD)
  // (ReadWrite, Bits 0) 
  // HDCP 2.x Enable When enabled video encryption mux and ddc mux will select HDCP 2.x. However this signal doesn't go to the hdcp2xcore
  #define BIT_MSK__TX_HDCP2X_CTL_0__REG_HDCP2X_EN                                         0x01
  // (ReadWrite, Bits 5) 
  // DDC polling interval override
  #define BIT_MSK__TX_HDCP2X_CTL_0__REG_HDCP2X_POLINT_OVR                                 0x20
  // (ReadWrite, Bits 6) 
  // DDC polling interval select
  #define BIT_MSK__TX_HDCP2X_CTL_0__REG_HDCP2X_POLINT_SEL                                 0x40
  // (ReadWrite, Bits 7) 
  // HDCP 2.x Encryption Enable This goes to the TX hdmi block to generate CTL3 signal 0: Disable 1: Enable
  #define BIT_MSK__TX_HDCP2X_CTL_0__REG_HDCP2X_ENCRYPT_EN                                 0x80

// HDCP General Control 1 Register
#define REG_ADDR__TX_HDCP2X_CTL_1                                           (TX_HDCP2 | 0x00BE)
  // (ReadWrite, Bits 0) 
  // Reauthentication request This goes to ri_reauth_sw of hdcp2xcore Negative edge triggered
  #define BIT_MSK__TX_HDCP2X_CTL_1__REG_HDCP2X_REAUTH_SW                                  0x01
  // (ReadWrite, Bits 1) 
  // HPD Override
  #define BIT_MSK__TX_HDCP2X_CTL_1__REG_HDCP2X_HPD_OVR                                    0x02
  // (ReadWrite, Bits 2) 
  // HDP Override Value
  #define BIT_MSK__TX_HDCP2X_CTL_1__REG_HDCP2X_HPD_SW                                     0x04

// HDCP General Control 1 Register
#define REG_ADDR__TX_HDCP2X_CTL_2                                           (TX_HDCP2 | 0x00BF)
  // (ReadWrite, Bits 0) 
  // Address reset for PRAM address reset Write 1 to this to give a pulse to reset the internal address pointer to the addresses specified by the other registers such as reg_hdcp2x_cupd_start_addr; reg_hdcp2x_cupd_sign_start_addr etc.
  #define BIT_MSK__TX_HDCP2X_CTL_2__REG_HDCP2X_CUPD_ADDR_RESET                            0x01

// HDCP CUPD Size Lo Register
#define REG_ADDR__TX_HDCP2X_CUPD_SIZE_LO                                    (TX_HDCP2 | 0x00C0)
  // (ReadWrite, Bits 7:0) 
  // Low byte of the size of updated code excluding signature Must be set before reg_hdcp2x_cupd_start or reg_hdcp2x_cupd_addr_reset.
  #define BIT_MSK__TX_HDCP2X_CUPD_SIZE_LO__REG_HDCP2X_CUPD_SIZE_B7_B0                            0xFF

// HDCP CUPD Size Hi Register
#define REG_ADDR__TX_HDCP2X_CUPD_SIZE_HI                                    (TX_HDCP2 | 0x00C1)
  // (ReadWrite, Bits 7:0) 
  // Low byte of the size of updated code excluding signature Must be set before reg_hdcp2x_cupd_start or reg_hdcp2x_cupd_addr_reset.
  #define BIT_MSK__TX_HDCP2X_CUPD_SIZE_HI__REG_HDCP2X_CUPD_SIZE_B15_B8                           0xFF

// HDCP General Staus Register
#define REG_ADDR__TX_HDCP2X_GEN_STA                                         (TX_HDCP2 | 0x00C2)
  // (ReadOnly, Bits 0) 
  // Code update done
  #define BIT_MSK__TX_HDCP2X_GEN_STA__REG_HDCP2X_CUPD_DONE                                  0x01

// HDCP Poll Interval 0 Register
#define REG_ADDR__TX_HDCP2X_POLL_VAL0                                       (TX_HDCP2 | 0x00C3)
  // (ReadWrite, Bits 7:0) 
  // DDC polling interval0
  #define BIT_MSK__TX_HDCP2X_POLL_VAL0__REG_HDCP2X_POL_VAL0_B7_B0                             0xFF

// HDCP Poll Interval 1 Register
#define REG_ADDR__TX_HDCP2X_POLL_VAL1                                       (TX_HDCP2 | 0x00C4)
  // (ReadWrite, Bits 7:0) 
  // DDC polling interval1
  #define BIT_MSK__TX_HDCP2X_POLL_VAL1__REG_HDCP2X_POL_VAL1_B7_B0                             0xFF

// HDCP DDCM Status Register
#define REG_ADDR__TX_HDCP2X_DDCM_STS                                        (TX_HDCP2 | 0x00C5)
  // (ReadOnly, Bits 3:0) 
  // DDCM Control Status
  #define BIT_MSK__TX_HDCP2X_DDCM_STS__REG_HDCP2X_DDCM_CTL_CS_B3_B0                          0x0F
  // (ReadOnly, Bits 7:4) 
  // DDCM Error Status
  #define BIT_MSK__TX_HDCP2X_DDCM_STS__REG_HDCP2X_DDCM_ERR_STS_B3_B0                         0xF0

// HDCP Ring OSC Bist Register
#define REG_ADDR__TX_HDCP2X_ROSC_BIST                                       (TX_HDCP2 | 0x00C6)
  // (ReadWrite, Bits 0) 
  // Start HDCP2 ring oscillator BIST
  #define BIT_MSK__TX_HDCP2X_ROSC_BIST__REG_HDCP2X_RINGOSC_BIST_START                         0x01
  // (ReadOnly, Bits 1) 
  // Indicates that HDCP2 ring oscillator BIST is done
  #define BIT_MSK__TX_HDCP2X_ROSC_BIST__REG_HDCP2X_RINGOSC_BIST_DONE                          0x02
  // (ReadOnly, Bits 2) 
  // Indicates that HDCP2 ring oscillator BIST fails
  #define BIT_MSK__TX_HDCP2X_ROSC_BIST__REG_HDCP2X_RINGOSC_BIST_FAIL                          0x04

// HDCP2 PRAM Data In/Out Register
#define REG_ADDR__TX_HDCP2_PRAM_DATA                                        (TX_HDCP2 | 0x00CF)
  // (ReadWrite, Bits 7:0) 
  // HDCP2 PRAM data register for PRAM data read and write.
  #define BIT_MSK__TX_HDCP2_PRAM_DATA__HDCP2_PRAM_DATA                                       0xFF

//***************************************************************************
// TX_HDMI2_HDMI2MHL3. Address: 60
// HDMI2 Scramble Control Register
#define REG_ADDR__SCRCTL                                                 (TX_HDMI2_HDMI2MHL3 | 0x0000)
  // (ReadWrite, Bits 0) 
  // Scrambler ON/OFF. Should follow HDMI2 spec such as mandatory for 600MHz, optional for lower, etc (from i2c or decision HW if availble; def=0)
  #define BIT_MSK__SCRCTL__REG_SCR_ON                                            0x01
  // (ReadWrite, Bits 1) 
  // Scrambler mode: 0:  normal (default) 1:  CTS
  #define BIT_MSK__SCRCTL__REG_SCR_MD                                            0x02
  // (ReadWrite, Bits 2) 
  // HDMI mode overwriting on/off (from i2c; def=0)
  #define BIT_MSK__SCRCTL__REG_HDMIMD_OVR                                        0x04
  // (ReadWrite, Bits 3) 
  // HDMI mode overwriting value  (from i2c; def=0)
  #define BIT_MSK__SCRCTL__REG_HDMIMD_VAL                                        0x08
  // (ReadWrite, Bits 4) 
  // Special byass ON/OFF         (from i2c; def=0)
  #define BIT_MSK__SCRCTL__REG_HDMI2_BYP                                         0x10
  // (ReadWrite, Bits 5) 
  // 1 - HDMI2 encoder using packet analyzer 0 - Legacy encoder used for HDMI/MHL        - For MHL1/2/3 stream coming from TX datapath,         legacy encoder (0) has to be selected        - For HDMI2 stream, new encoder (1) has to be        selected        - For DVI/HDMI1.4 stream, either one works, but        for the better compatibility, we recommend to        use legacy encoder (0)                In summary, for HDMI2 stream, use 1, and for        all others (HDMI1.x, MHL1/2/3) use 0. This has        to come from TOP HW/FW that knows the stream it        makes
  #define BIT_MSK__SCRCTL__REG_HDMI2_ON                                          0x20

// HDMI Control 0 Register
#define REG_ADDR__HDMI2CTL0                                              (TX_HDMI2_HDMI2MHL3 | 0x0001)
  // (ReadWrite, Bits 0) 
  // 1:  Bit swap Q data out from HDMI2 encoder 0:  No swap (default)
  #define BIT_MSK__HDMI2CTL0__REG_Q_9T0                                             0x01
  // (ReadWrite, Bits 1) 
  // 1:  Has 4 full channels (RGB, CK) (default) 0:  Force CK channel to all zero
  #define BIT_MSK__HDMI2CTL0__REG_USE_CH_MUX                                        0x02
  // (ReadWrite, Bits 2) 
  // 1:  Invert tx bit  for ch0,1,2CK 0:  Normal (default)
  #define BIT_MSK__HDMI2CTL0__REG_TX_BIT_INV                                        0x04

// HDMI Control 1 Register
#define REG_ADDR__HDMI2CTL1                                              (TX_HDMI2_HDMI2MHL3 | 0x0002)
  // (ReadWrite, Bits 1:0) 
  // 00:  select ch0 01:  select ch1 10:  select ch2 11:  select ck
  #define BIT_MSK__HDMI2CTL1__REG_Q0_SEL                                            0x03
  // (ReadWrite, Bits 3:2) 
  // 00:  select ch0 01:  select ch1 10:  select ch2 11:  select ck
  #define BIT_MSK__HDMI2CTL1__REG_Q1_SEL                                            0x0C
  // (ReadWrite, Bits 5:4) 
  // 00:  select ch0 01:  select ch1 10:  select ch2 11:  select ck
  #define BIT_MSK__HDMI2CTL1__REG_Q2_SEL                                            0x30
  // (ReadWrite, Bits 7:6) 
  // 00:  select ch0 01:  select ch1 10:  select ch2 11:  select ck
  #define BIT_MSK__HDMI2CTL1__REG_QC_SEL                                            0xC0

// HDMI TXC Data 0L Register
#define REG_ADDR__TXC_DATA0L                                             (TX_HDMI2_HDMI2MHL3 | 0x0003)
  // (ReadWrite, Bits 7:0) 
  // HDMI TX Clock data byte 0 Low portion
  #define BIT_MSK__TXC_DATA0L__REG_TXC_DATA0_B7_B0                                   0xFF

// HDMI TXC Data 0H Register
#define REG_ADDR__TXC_DATA0H                                             (TX_HDMI2_HDMI2MHL3 | 0x0004)
  // (ReadWrite, Bits 1:0) 
  // HDMI TX Clock data byte 0 high portion
  #define BIT_MSK__TXC_DATA0H__REG_TXC_DATA0_B9_B8                                   0x03

// HDMI TXC DATA 1L Register
#define REG_ADDR__TXC_DATA1L                                             (TX_HDMI2_HDMI2MHL3 | 0x0005)
  // (ReadWrite, Bits 7:0) 
  // HDMI TX Clock data byte 1 low portion
  #define BIT_MSK__TXC_DATA1L__REG_TXC_DATA1_B7_B0                                   0xFF

// HDMI TXC DATA 1H Register
#define REG_ADDR__TXC_DATA1H                                             (TX_HDMI2_HDMI2MHL3 | 0x0006)
  // (ReadWrite, Bits 1:0) 
  // HDMI TX Clock data byte 1 high portion
  #define BIT_MSK__TXC_DATA1H__REG_TXC_DATA1_B9_B8                                   0x03

// HDMI TXC DATA 2L Register
#define REG_ADDR__TXC_DATA2L                                             (TX_HDMI2_HDMI2MHL3 | 0x0007)
  // (ReadWrite, Bits 7:0) 
  // HDMI TX Clock data byte 2 low portion
  #define BIT_MSK__TXC_DATA2L__REG_TXC_DATA2_B7_B0                                   0xFF

// HDMI TXC DATA 2H Register
#define REG_ADDR__TXC_DATA2H                                             (TX_HDMI2_HDMI2MHL3 | 0x0008)
  // (ReadWrite, Bits 1:0) 
  // HDMI TX Clock data byte 2 high portion
  #define BIT_MSK__TXC_DATA2H__REG_TXC_DATA2_B9_B8                                   0x03

// HDMI TXC DIVIDER Register
#define REG_ADDR__TXC_DATA_DIV                                           (TX_HDMI2_HDMI2MHL3 | 0x0009)
  // (ReadWrite, Bits 1:0) 
  // 00:  TXC divide by 1 (default) 01:  TXC divide by 2 10:  TXC divide by 4 11:  TXC divide by 8
  #define BIT_MSK__TXC_DATA_DIV__REG_TXC_DIV                                           0x03

// SCDC Control Register
#define REG_ADDR__SCDC_CTL                                               (TX_HDMI2_HDMI2MHL3 | 0x0020)
  // (ReadWrite, Bits 0) 
  // SCDC access enable strobe, self clear bit 0:  regular DDC master 1.  Enable SCDC DDC bus cycle Write sequence: Firmware needs to check if DDC bus is idle, then write 1 to take over DDC bus.  After writing this bit, check 0x925[2] to make sure there is no bus conflicting.  If so, repeat above procedures.  Prepare DDC_FIFO data, DDC controls and send write command. Read sequence: Firmware needs to check if DDC bus is idle, then write 1 to take over DDC bus.  After writing this bit, check 0x925[2] to make sure there is no bus conflicting.  If so, repeat above procedures.  Prepare DDC controls, send write command.  When 0x925[0] = 1, read DDC_FIFO.
  #define BIT_MSK__SCDC_CTL__REG_SCDC_ACCESS                                       0x01
  // (ReadWrite, Bits 1) 
  // SCDC auto reply read request from slave for SCDC registers up_flag0 and up_flag1 0:  Disable (default), ignore read request 1:  Enable
  #define BIT_MSK__SCDC_CTL__REG_SCDC_AUTO_REPLY                                   0x02
  // (ReadWrite, Bits 2) 
  // SCDC auto polling read from slave for SCDC registers up_flag0 and up_flag1 on every frame 0:  Disable (default), manual polling by firmware 1:  Enable
  #define BIT_MSK__SCDC_CTL__REG_SCDC_AUTO_POLL                                    0x04
  // (ReadWrite, Bits 3) 
  // SCDC auto reply read request with a stop condition instead of reading update flags, 0x920[1] also is needed to set for this function to work. 0:  Disable (default), normal auto reply read request 1:  Enable, SCDC replies with a stop condition
  #define BIT_MSK__SCDC_CTL__REG_SCDC_AUTO_REPLY_STOP                              0x08
  // (ReadWrite, Bits 4) 
  // SCDC auto poll select 0:  (default), use vsync as triggering point 1:  Use internal timer (240ms), program 0x927 and 0x928 for different desired time interval
  #define BIT_MSK__SCDC_CTL__REG_SCDC_AUTO_POLL_SEL                                0x10
  // (ReadWrite, Bits 5) 
  // DDC bus stall request; it will disable reg_scdc_access bit; can't use together Setting this bit to 1 will hold ddc bus for SCDC manual transaction until firmware disable it It will stall hdcp1.4, hdcp2.2 and SCDC auto reply as well After setting bit to 1, HW will detect if ddc bus is busy.  Once the bus is free, it will generate an interrupt, ddc_stall_ack, 0x925[5], to notify firmware bus is ready to use 
  #define BIT_MSK__SCDC_CTL__REG_DDC_STALL_REQ                                     0x20
  // (ReadWrite, Bits 6) 
  // 0: (default)  Firmware will grab the ddc bus any time when it is not used 1:  Once reg_ddc_stall_req is set to 1; it will wait for 128 frames to see if there is any hdcp activity; if so; will wait for current hdcp transaction finish before grabbing the bus; or timer expires.
  #define BIT_MSK__SCDC_CTL__REG_SCDC_HDCP_DET_EN                                  0x40

// SCDC Active Status Register
#define REG_ADDR__SCDC_ACT_STATUS                                        (TX_HDMI2_HDMI2MHL3 | 0x0021)
  // (ReadOnly, Bits 0) 
  // SCDC is using DDC Bus
  #define BIT_MSK__SCDC_ACT_STATUS__REG_SCDC_ACTIVE                                       0x01
  // (ReadOnly, Bits 1) 
  // SCDC auto reply read request  from slave for SCDC registers up_flag0 and up_flag1  or read polling in progress
  #define BIT_MSK__SCDC_ACT_STATUS__REG_SCDC_RREQ_IN_PROG                                 0x02
  // (ReadOnly, Bits 2) 
  // SCDC Read Write in progress
  #define BIT_MSK__SCDC_ACT_STATUS__REG_SCDC_IN_PROG                                      0x04

// SCDC State Machine Status Register
#define REG_ADDR__SCDC_STATE                                             (TX_HDMI2_HDMI2MHL3 | 0x0022)
  // (ReadOnly, Bits 3:0) 
  // Auto Reply to SCDC slave read request state machine status
  #define BIT_MSK__SCDC_STATE__REG_SCDC_RREQ_STATE                                   0x0F
  // (ReadOnly, Bits 7:4) 
  // SCDC read/write state machine status
  #define BIT_MSK__SCDC_STATE__REG_SCDC_STATE                                        0xF0

// SCDC Update Flag 0 Status Register
#define REG_ADDR__SCDC_UP_FLAG0                                          (TX_HDMI2_HDMI2MHL3 | 0x0023)
  // (ReadOnly, Bits 7:0) 
  // SCDC Update Flag0 Status
  #define BIT_MSK__SCDC_UP_FLAG0__REG_SCDC_UP_FLAG0                                     0xFF

// SCDC Update Flag 1 Status Register
#define REG_ADDR__SCDC_UP_FLAG1                                          (TX_HDMI2_HDMI2MHL3 | 0x0024)
  // (ReadOnly, Bits 7:0) 
  // SCDC Update Flag1 Status
  #define BIT_MSK__SCDC_UP_FLAG1__REG_SCDC_UP_FLAG1                                     0xFF

// SCDC interrupt 0 Register
#define REG_ADDR__SCDC_INTR0                                             (TX_HDMI2_HDMI2MHL3 | 0x0025)
  // (ReadWrite, Bits 0) 
  // SCDC DDC read/write access done
  #define BIT_MSK__SCDC_INTR0__REG_SCDC_INTR0_STAT0                                  0x01
  // (ReadWrite, Bits 1) 
  // SCDC DDC read update flag done
  #define BIT_MSK__SCDC_INTR0__REG_SCDC_INTR0_STAT1                                  0x02
  // (ReadWrite, Bits 2) 
  // SCDC DDC conflicting with other client when trying to access DDC Bus
  #define BIT_MSK__SCDC_INTR0__REG_SCDC_INTR0_STAT2                                  0x04
  // (ReadWrite, Bits 3) 
  // SCDC slave read request interrupt; slave is requesting SCDC Master to read update flags
  #define BIT_MSK__SCDC_INTR0__REG_SCDC_INTR0_STAT3                                  0x08
  // (ReadWrite, Bits 4) 
  // SCDC DDC update flag being changed comparing with previous one
  #define BIT_MSK__SCDC_INTR0__REG_SCDC_INTR0_STAT4                                  0x10
  // (ReadWrite, Bits 5) 
  // SCDC DDC stall request acknowledge
  #define BIT_MSK__SCDC_INTR0__REG_SCDC_INTR0_STAT5                                  0x20

// SCDC interrupt 0 Mask Register
#define REG_ADDR__SCDC_INTR0_MASK                                        (TX_HDMI2_HDMI2MHL3 | 0x0026)
  // (ReadWrite, Bits 0) 
  // SCDC DDC read/write access done mask 0:  disable (default) 1: enable interrupt
  #define BIT_MSK__SCDC_INTR0_MASK__REG_SCDC_INTR0_MASK0                                  0x01
  // (ReadWrite, Bits 1) 
  // SCDC DDC read update flag done mask 0:  disable (default) 1: enable interrupt
  #define BIT_MSK__SCDC_INTR0_MASK__REG_SCDC_INTR0_MASK1                                  0x02
  // (ReadWrite, Bits 2) 
  // SCDC DDC bus conflicting mask 0:  disable (default) 1: enable interrupt
  #define BIT_MSK__SCDC_INTR0_MASK__REG_SCDC_INTR0_MASK2                                  0x04
  // (ReadWrite, Bits 3) 
  // SCDC DDC slave read request mask 0:  disable (default) 1: enable interrupt
  #define BIT_MSK__SCDC_INTR0_MASK__REG_SCDC_INTR0_MASK3                                  0x08
  // (ReadWrite, Bits 4) 
  // SCDC DDC update flag change mask 0:  disable (default) 1: enable interrupt
  #define BIT_MSK__SCDC_INTR0_MASK__REG_SCDC_INTR0_MASK4                                  0x10
  // (ReadWrite, Bits 5) 
  // SCDC DDC stall request acknowledge mask 0:  disable (default) 1: enable interrupt
  #define BIT_MSK__SCDC_INTR0_MASK__REG_SCDC_INTR0_MASK5                                  0x20

// SCDC Auto Poll timer 0 Register
#define REG_ADDR__SCDC_POLL_TIMER0                                       (TX_HDMI2_HDMI2MHL3 | 0x0027)
  // (ReadWrite, Bits 7:0) 
  // SCDC auto polling timer
  #define BIT_MSK__SCDC_POLL_TIMER0__REG_SCDC_AUTO_POLL_TIMER_B7_B0                        0xFF

// SCDC Auto Poll timer 1 Register
#define REG_ADDR__SCDC_POLL_TIMER1                                       (TX_HDMI2_HDMI2MHL3 | 0x0028)
  // (ReadWrite, Bits 7:0) 
  // SCDC auto polling timer
  #define BIT_MSK__SCDC_POLL_TIMER1__REG_SCDC_AUTO_POLL_TIMER_B15_B8                       0xFF

// SCDC Auto Poll timer 2 Register
#define REG_ADDR__SCDC_POLL_TIMER2                                       (TX_HDMI2_HDMI2MHL3 | 0x0029)
  // (ReadWrite, Bits 5:0) 
  // SCDC auto polling timer
  #define BIT_MSK__SCDC_POLL_TIMER2__REG_SCDC_AUTO_POLL_TIMER_B21_B16                      0x3F

// SCDC RST Register
#define REG_ADDR__SCDC_SRST                                              (TX_HDMI2_HDMI2MHL3 | 0x002A)
  // (ReadWrite, Bits 0) 
  // SCDC software reset. Set to 1'b1 to reset.
  #define BIT_MSK__SCDC_SRST__REG_SCDC_RST                                          0x01

// SCDC Frame Limit Register
#define REG_ADDR__SCDC_FRM_LIMIT                                         (TX_HDMI2_HDMI2MHL3 | 0x002B)
  // (ReadWrite, Bits 7:0) 
  // SCDC Frame Limit; if internal frame counter (sync to ri_check) is less or equal to this value; then it grants the ddc bus for scdc access
  #define BIT_MSK__SCDC_FRM_LIMIT__REG_SCDC_FRAME_LIMIT                                  0xFF

// SCDC Read Req Frame Limit Register
#define REG_ADDR__RREQ_FRM_LIMIT                                         (TX_HDMI2_HDMI2MHL3 | 0x002C)
  // (ReadWrite, Bits 7:0) 
  // SCDC Read Request Frame Limit; if internal frame counter (sync to ri_check) is less or equal to this value; then it grants the ddc bus for scdc read request
  #define BIT_MSK__RREQ_FRM_LIMIT__REG_RREQ_FRAME_LIMIT                                  0xFF

// HDMI2MHL3 Control Register
#define REG_ADDR__HDMI2MHL3_CTRL                                         (TX_HDMI2_HDMI2MHL3 | 0x0080)
  // (ReadWrite, Bits 0) 
  // master enable. Override port enable
  #define BIT_MSK__HDMI2MHL3_CTRL__REG_MASTER_EN                                         0x01

// HDMI2MHL3 Port0 Control Register
#define REG_ADDR__HDMI2MHL3_P0CTRL                                       (TX_HDMI2_HDMI2MHL3 | 0x0081)
  // (ReadWrite, Bits 0) 
  // port0 enable
  #define BIT_MSK__HDMI2MHL3_P0CTRL__REG_P0_PORT_EN                                        0x01
  // (ReadWrite, Bits 1) 
  // 0: normal mode 1: packed pixel mode
  #define BIT_MSK__HDMI2MHL3_P0CTRL__REG_P0_PIXEL_MODE                                     0x02
  // (ReadWrite, Bits 2) 
  // HDCP 2.1 control packet enable
  #define BIT_MSK__HDMI2MHL3_P0CTRL__REG_P0_HDCP_EN                                        0x04
  // (ReadWrite, Bits 3) 
  // enable unlimit payload mode
  #define BIT_MSK__HDMI2MHL3_P0CTRL__REG_P0_UNLIMIT_EN                                     0x08
  // (ReadWrite, Bits 4) 
  // Not used
  #define BIT_MSK__HDMI2MHL3_P0CTRL__REG_P0_HDCP_ENC_EN                                    0x10
  // (ReadWrite, Bits 5) 
  // Enable ECC mode
  #define BIT_MSK__HDMI2MHL3_P0CTRL__REG_P0_ECC_EN                                         0x20

// HDMI2MHL3 P0 Stream Register
#define REG_ADDR__HDMI2MHL3_P0STM                                        (TX_HDMI2_HDMI2MHL3 | 0x0082)
  // (ReadWrite, Bits 2:0) 
  // port0 stream ID
  #define BIT_MSK__HDMI2MHL3_P0STM__REG_P0_STM_ID                                         0x07

// HDMI2MHL3 Lane Register
#define REG_ADDR__HDMI2MHL3_NLN                                          (TX_HDMI2_HDMI2MHL3 | 0x0083)
  // (ReadWrite, Bits 1:0) 
  // number of lane - 1
  #define BIT_MSK__HDMI2MHL3_NLN__REG_NUM_LANE                                          0x03

// HDMI2MHL3 Payload Low Register
#define REG_ADDR__HDMI2MHL3_PLDL                                         (TX_HDMI2_HDMI2MHL3 | 0x0084)
  // (ReadWrite, Bits 7:0) 
  // Low byte of maximum payload of HDMI packet (default 252)
  #define BIT_MSK__HDMI2MHL3_PLDL__REG_MAX_PAYLOAD_B7_B0                                 0xFF

// HDMI2MHL3 Payload High Register
#define REG_ADDR__HDMI2MHL3_PLDH                                         (TX_HDMI2_HDMI2MHL3 | 0x0085)
  // (ReadWrite, Bits 1:0) 
  // High byte of maximum payload of HDMI packet (default 252)
  #define BIT_MSK__HDMI2MHL3_PLDH__REG_MAX_PAYLOAD_B9_B8                                 0x03

// HDMI2MHL3 Scramble Control Register
#define REG_ADDR__HDMI2MHL3_SCTRL                                        (TX_HDMI2_HDMI2MHL3 | 0x0086)
  // (ReadWrite, Bits 0) 
  // enable scrambler (default 1)
  #define BIT_MSK__HDMI2MHL3_SCTRL__REG_SCRAMBLER_EN                                      0x01
  // (ReadWrite, Bits 7:4) 
  // # of consecutive SR symbol. 0 for no SR. (default 4)
  #define BIT_MSK__HDMI2MHL3_SCTRL__REG_SR_LENGTH                                         0xF0

// HDMI2MHL3 SR Period 1st Register
#define REG_ADDR__HDMI2MHL3_SRP0                                         (TX_HDMI2_HDMI2MHL3 | 0x0087)
  // (ReadWrite, Bits 7:0) 
  // The period of SR symbol [7:0]
  #define BIT_MSK__HDMI2MHL3_SRP0__REG_SR_PERIOD_B7_B0                                   0xFF

// HDMI2MHL3 SR Period 2nd Register
#define REG_ADDR__HDMI2MHL3_SRP1                                         (TX_HDMI2_HDMI2MHL3 | 0x0088)
  // (ReadWrite, Bits 7:0) 
  // The period of SR symbol [15:8]
  #define BIT_MSK__HDMI2MHL3_SRP1__REG_SR_PERIOD_B15_B8                                  0xFF

// HDMI2MHL3 SR Period 3rd Register
#define REG_ADDR__HDMI2MHL3_SRP2                                         (TX_HDMI2_HDMI2MHL3 | 0x0089)
  // (ReadWrite, Bits 7:0) 
  // The period of SR symbol [23:16]
  #define BIT_MSK__HDMI2MHL3_SRP2__REG_SR_PERIOD_B23_B16                                 0xFF

// HDMI2MHL3 SR Period 4th Register
#define REG_ADDR__HDMI2MHL3_SRP3                                         (TX_HDMI2_HDMI2MHL3 | 0x008A)
  // (ReadWrite, Bits 7:0) 
  // The period of SR symbol [31:24]
  #define BIT_MSK__HDMI2MHL3_SRP3__REG_SR_PERIOD_B31_B24                                 0xFF

// HDMI2MHL3 Type #1 Register
#define REG_ADDR__HDMI2MHL3_TYPE1                                        (TX_HDMI2_HDMI2MHL3 | 0x008B)
  // (ReadWrite, Bits 3:0) 
  // type of HDMI packet (default 0x1)
  #define BIT_MSK__HDMI2MHL3_TYPE1__REG_TYPE_HDMI_PKT                                     0x0F
  // (ReadWrite, Bits 7:4) 
  // type of HDCP packet (default 0x2)
  #define BIT_MSK__HDMI2MHL3_TYPE1__REG_TYPE_HDCP_PKT                                     0xF0

// HDMI2MHL3 Type #2 Register
#define REG_ADDR__HDMI2MHL3_TYPE2                                        (TX_HDMI2_HDMI2MHL3 | 0x008C)
  // (ReadWrite, Bits 3:0) 
  // type of HDMI packet (default 0x3)
  #define BIT_MSK__HDMI2MHL3_TYPE2__REG_TYPE_HDMI2_PKT                                    0x0F
  // (ReadWrite, Bits 7:4) 
  // type of HDMI with ECC packet (default 0x4)
  #define BIT_MSK__HDMI2MHL3_TYPE2__REG_TYPE_ECC_PKT                                      0xF0

// HDMI2MHL3 K_SR Register
#define REG_ADDR__HDMI2MHL3_KSR                                          (TX_HDMI2_HDMI2MHL3 | 0x008D)
  // (ReadWrite, Bits 7:0) 
  // Scrambler Reset symbol (default 0x0 for TMDS encode)
  #define BIT_MSK__HDMI2MHL3_KSR__REG_K_SR                                              0xFF

// HDMI2MHL3 K_SOP Register
#define REG_ADDR__HDMI2MHL3_KSOP                                         (TX_HDMI2_HDMI2MHL3 | 0x008E)
  // (ReadWrite, Bits 7:0) 
  // Start of Packet symbol (default 0x01 for TMDS encode)
  #define BIT_MSK__HDMI2MHL3_KSOP__REG_K_SOP                                             0xFF

// HDMI2MHL3 K_EOP Register
#define REG_ADDR__HDMI2MHL3_KEOP                                         (TX_HDMI2_HDMI2MHL3 | 0x008F)
  // (ReadWrite, Bits 7:0) 
  // End of Packet symbol (default 0x02 for TMDS encode)
  #define BIT_MSK__HDMI2MHL3_KEOP__REG_K_EOP                                             0xFF

// HDMI2MHL3 Compression Register
#define REG_ADDR__HDMI2MHL3_COMPRESSION                                  (TX_HDMI2_HDMI2MHL3 | 0x0090)
  // (ReadWrite, Bits 2:0) 
  // Blank compression ratio. 0: disable; n: up to n
  #define BIT_MSK__HDMI2MHL3_COMPRESSION__REG_P0_BLK_CPR_AMT                                    0x07
  // (ReadWrite, Bits 5:4) 
  // Active compression ratio. 0: disable; n: up to n
  #define BIT_MSK__HDMI2MHL3_COMPRESSION__REG_P0_ACT_CPR_AMT                                    0x30

// HDMI2MHL3 ECC Register
#define REG_ADDR__HDMI2MHL3_ECC                                          (TX_HDMI2_HDMI2MHL3 | 0x0091)
  // (ReadWrite, Bits 7:0) 
  // maximum payload of ECC packet (default 246)
  #define BIT_MSK__HDMI2MHL3_ECC__REG_MAX_PAYLOAD2                                      0xFF

// H2M3_TOP Control0 Register
#define REG_ADDR__H2M3_TOP0                                              (TX_HDMI2_HDMI2MHL3 | 0x00C0)
  // (ReadWrite, Bits 4) 
  // Swap the order of 10bit data after encoder 
  #define BIT_MSK__H2M3_TOP0__REG_ENCODE_SWAP                                       0x10
  // (ReadWrite, Bits 5) 
  // Choose TMDS encoding or ANSI8b10b.  1: TMDS (default) 0: 8b10b
  #define BIT_MSK__H2M3_TOP0__REG_ENCODE_TMDS                                       0x20
  // (ReadWrite, Bits 6) 
  // Use EC Coding 1: enable  0: disable (default)
  #define BIT_MSK__H2M3_TOP0__REG_USE_ER_CODE                                       0x40
  // (ReadWrite, Bits 7) 
  // SW Reset
  #define BIT_MSK__H2M3_TOP0__REG_H2M3_RST                                          0x80

//***************************************************************************
// TX_API. Address: 60
// ACR  Control Register
#define REG_ADDR__ACR_CTRL                                               (TX_API | 0x0001)
  // (ReadWrite, Bits 0) 
  // 0 - The CTS value updated by hardware (CTS_HVAL) is sent as HDMI       packet to Rx (default); 1 - The CTS value set by software (CTS_SVAL) is sent as HDMI packet to Rx
  #define BIT_MSK__ACR_CTRL__REG_CTS_HW_SW_SEL                                     0x01
  // (ReadWrite, Bits 1) 
  // 0 - Requests by the ACR module to transmit an CTS/N packet are ignored; so no CTS/N packets are transmitted; multiple CTS/N packet requests that are unserviced do not generate and ACR interrupt (see INTR[2]); 1 - Requests by the ACR module to transmit an CTS/N packet are serviced per microarchitecture spec; multiple CTS/N packet requests that are unserviced generate an ACR interrupt (see INTR[2]);   (default)
  #define BIT_MSK__ACR_CTRL__REG_CTS_REQ_EN                                        0x02
  // (ReadWrite, Bits 2) 
  // select between mclk and tclk time domain mclk counter
  #define BIT_MSK__ACR_CTRL__REG_MCLK_EN                                           0x04
  // (ReadWrite, Bits 3) 
  // 1: CTS Gen without MCLK (auto MCLK generation) 0: CTS Gen with MCLK
  #define BIT_MSK__ACR_CTRL__REG_NO_MCLK_CTSGEN_SEL                                0x08

// ACR  Audio Frequency Register
#define REG_ADDR__FREQ_SVAL                                              (TX_API | 0x0002)
  // (ReadWrite, Bits 2:0) 
  // MCLK input mode: 000 = MCLK is 128*Fs 001 = MCLK is 256*Fs (default) 010 = MCLK is 384*Fs 011 = MCLK is 512*Fs                                                  100 = MCLK is 768*Fs 101 = MCLK is 1024*Fs 110 = MCLK is 1152*Fs 111 = mCLK is 192*Fs
  #define BIT_MSK__FREQ_SVAL__REG_FM_IN_VAL_SW                                      0x07

// ACR N Software Value #1 Register
#define REG_ADDR__N_SVAL1                                                (TX_API | 0x0003)
  // (ReadWrite, Bits 7:0) 
  // N value for audio clock regeneration method. Bits [7:0] of 20-bits value from the N/CTS packet.  Must be entered by software to create the correct divider.  
  #define BIT_MSK__N_SVAL1__REG_N_VAL_SW1                                         0xFF

// ACR N Software Value #2 Register
#define REG_ADDR__N_SVAL2                                                (TX_API | 0x0004)
  // (ReadWrite, Bits 7:0) 
  // N value for audio clock regeneration method. Bits [15:8] of 20-bits value from the N/CTS packet.  Must be entered by software to create the correct divider.  
  #define BIT_MSK__N_SVAL2__REG_N_VAL_SW2                                         0xFF

// ACR N Software Value #3 Register
#define REG_ADDR__N_SVAL3                                                (TX_API | 0x0005)
  // (ReadWrite, Bits 3:0) 
  // N value for audio clock regeneration method. Bits [19:16] of 20-bits value from the N/CTS packet.  Must be entered by software to create the correct divider.  
  #define BIT_MSK__N_SVAL3__REG_N_VAL_SW3                                         0x0F

// ACR CTS Software Value #1 Register
#define REG_ADDR__CTS_TXSVAL1                                            (TX_API | 0x0006)
  // (ReadWrite, Bits 7:0) 
  // Bits [7:0] of 20-bits of the audio clock regeneration CTS value that has been set by software. Whether this software value is sent in the CTS packet to the Rx is controlled by ACR_CTRL[0]
  #define BIT_MSK__CTS_TXSVAL1__REG_CTS_VAL_SW_B7_B0                                  0xFF

// ACR CTS Software Value #2 Register
#define REG_ADDR__CTS_TXSVAL2                                            (TX_API | 0x0007)
  // (ReadWrite, Bits 7:0) 
  // Bits [15:8] of 20-bits of the audio clock regeneration CTS value that has been set by software. Whether this software value is sent in the CTS packet to the Rx is controlled by ACR_CTRL[0]
  #define BIT_MSK__CTS_TXSVAL2__REG_CTS_VAL_SW_B15_B8                                 0xFF

// ACR CTS Software Value #3 Register
#define REG_ADDR__CTS_TXSVAL3                                            (TX_API | 0x0008)
  // (ReadWrite, Bits 3:0) 
  // Bits [19:16] of 20-bits of the audio clock regeneration CTS value that has been set by software. Whether this software value is sent in the CTS packet to the Rx is controlled by ACR_CTRL[0]
  #define BIT_MSK__CTS_TXSVAL3__REG_CTS_VAL_SW_B19_B16                                0x0F

// ACR CTS Hardware Value #1 Register
#define REG_ADDR__CTS_TXHVAL1                                            (TX_API | 0x0009)
  // (ReadOnly, Bits 7:0) 
  // Bits [7:0] of 20-bits of the audio clock regeneration CTS value that is measured and updated by the Tx. Whether this hardware value is sent in the CTS packet to the Rx is controlled by ACR_CTRL[0]
  #define BIT_MSK__CTS_TXHVAL1__CTS_VAL_HW_B7_B0                                      0xFF

// ACR CTS Hardware Value #2 Register
#define REG_ADDR__CTS_TXHVAL2                                            (TX_API | 0x000A)
  // (ReadOnly, Bits 7:0) 
  // Bits [15:8] of 20-bits of the audio clock regeneration CTS value that is measured and updated by the Tx. Whether this hardware value is sent in the CTS packet to the Rx is controlled by ACR_CTRL[0]
  #define BIT_MSK__CTS_TXHVAL2__CTS_VAL_HW_B15_B8                                     0xFF

// ACR CTS Hardware Value #3 Register
#define REG_ADDR__CTS_TXHVAL3                                            (TX_API | 0x000B)
  // (ReadOnly, Bits 3:0) 
  // Bits [19:16] of 20-bits of the audio clock regeneration CTS value that is measured and updated by the Tx. Whether this hardware value is sent in the CTS packet to the Rx is controlled by ACR_CTRL[0]
  #define BIT_MSK__CTS_TXHVAL3__CTS_VAL_HW_B19_B16                                    0x0F

// ACR CTS Filter Ctrl #1 Register
#define REG_ADDR__ACR_CTS_CTRL1                                          (TX_API | 0x000C)
  // (ReadWrite, Bits 0) 
  // enable cts filtering
  #define BIT_MSK__ACR_CTS_CTRL1__REG_CTS_FLT_EN                                        0x01
  // (ReadWrite, Bits 5:1) 
  // # of filter steps: ]15 is 16; ]7 is 8; ]3 is 4; else 2 This # also tells how many new cts value outside of average range need to get in raw to start to calculate new average #
  #define BIT_MSK__ACR_CTS_CTRL1__REG_AVE_MAX                                           0x3E
  // (ReadWrite, Bits 6) 
  // enable to use software cts as average, instead of internal histogram
  #define BIT_MSK__ACR_CTS_CTRL1__REG_USE_SW_CTS                                        0x40

// ACR CTS Filter Ctrl #2 Register
#define REG_ADDR__ACR_CTS_CTRL2                                          (TX_API | 0x000D)
  // (ReadWrite, Bits 7:0) 
  // thresholf value that will be subtracted from or added to cts average number. That will create range against which new cts value will be evaluated. If reg_cts_filt_en is set and new cts value is outside of that range then this new cts value be regejected and old value is used.
  #define BIT_MSK__ACR_CTS_CTRL2__REG_CTS_THRE                                          0xFF

// Input Audio ID Register
#define REG_ADDR__AIP_IN_AUD_ID                                          (TX_API | 0x0012)
  // (ReadOnly, Bits 4:0) 
  // Identification of the incoming stream: bit 0 - ID of the SPDIF bit 1 - ID of the I2S bit 2 - ID of the DSD bit 3 - ID of the HBRA bit 4 - ID of the Audio packetized
  #define BIT_MSK__AIP_IN_AUD_ID__IN_AUD_ID                                             0x1F

// Audio En Register
#define REG_ADDR__AUD_EN                                                 (TX_API | 0x0013)
  // (ReadWrite, Bits 0) 
  // Audio input enable 0 - audio inputs disabled (default) 1 - audio inputs enabled
  #define BIT_MSK__AUD_EN__REG_AUD_IN_EN                                         0x01
  // (ReadWrite, Bits 1) 
  // AIP can select to overwrite incoming selection of the audio by values in AUD_MODE
  #define BIT_MSK__AUD_EN__REG_AUD_SEL_OWRT                                      0x02
  // (ReadWrite, Bits 2) 
  // Enable loading of the audio through DMA (parrel audio input)
  #define BIT_MSK__AUD_EN__REG_AUD_PAR_EN                                        0x04

// Audio In Mode Register
#define REG_ADDR__AUD_MODE                                               (TX_API | 0x0014)
  // (ReadWrite, Bits 0) 
  // Enable to use packetize audio as input
  #define BIT_MSK__AUD_MODE__REG_AUD_PKT_EN                                        0x01
  // (ReadWrite, Bits 1) 
  // SPDIF input enable. 0 - SPDIF input stream is disabled (default) 1 - SPDIF input stream is enabled. NOTE: This bit must also be set in case of parallel audio input if the audio format is SPDIF in order to ensure correct use of audio header type.
  #define BIT_MSK__AUD_MODE__REG_SPDIF_EN                                          0x02
  // (ReadWrite, Bits 2) 
  // High Bitrate Audio flag 0 - Input stream is not High Bitrate stream (default) 1 - Input stream is High Bitrate stream (all of the I2S control bits will apply to the control of the HB Audio)
  #define BIT_MSK__AUD_MODE__REG_HBRA_ON                                           0x04
  // (ReadWrite, Bits 3) 
  // DSD enable. Has lower priorety then spdif enable; but higher then I2S stream. When it is set then most of the I2S configuration register bits became control for the DSD logic; such as SD3/2/1/0 enable; I2S FIFO map and Channel Status registers. NOTE: This bit must also be set in case of parallel audio input if the audio format is DSD in order to ensure correct use of audio header type.
  #define BIT_MSK__AUD_MODE__REG_DSD_EN                                            0x08
  // (ReadWrite, Bits 7:4) 
  // I2S enable for SD3; SD2; SD1; SD0.  Bit 7 = SD3_en  Bit 4 = SD0_en.  All inputs disabled at default. When DSD enabled these bits control the DSD stream. NOTE: This bit(s) must also be set in case of parallel audio input if the audio format is I2S in order to ensure correct use of audio header type.
  #define BIT_MSK__AUD_MODE__REG_I2S_EN                                            0xF0

// Audio In SPDIF Control Register
#define REG_ADDR__SPDIF_CTRL                                             (TX_API | 0x0015)
  // (ReadWrite, Bits 0) 
  // 0 - hardware sample # automatically adjusted for sampling frequency changes (default); 1 - hardware is locked to the reg_max_1ui number
  #define BIT_MSK__SPDIF_CTRL__REG_1UI_LOCK                                          0x01
  // (ReadWrite, Bits 1) 
  // 0 - Use input SPDIF stream Fs; reg SPDIF Fs (default); 1 - Override input stream Fs with Software Fs; define in I2S_CHST4
  #define BIT_MSK__SPDIF_CTRL__REG_FS_OVERRIDE                                       0x02
  // (ReadWrite, Bits 2) 
  // 0 - hardware sample # automatically adjusted for sampling frequency changes (default); 1 -  if and only if lock for 1UI is set then hardware is locked to the reg_max_2ui number
  #define BIT_MSK__SPDIF_CTRL__REG_2UI_LOCK                                          0x04
  // (ReadOnly, Bits 3) 
  // 1 - there is no spdif input: spdif input never changes; 0- detected some change on the input SPDIF
  #define BIT_MSK__SPDIF_CTRL__AUDI_NO_AUDIO                                         0x08
  // (ReadOnly, Bits 7:4) 
  // Channel Status bits 33 to 35; where bit 33 = LSB and 35 = MSB               max 24                               max 20 000      not indicated (default)          not indicated (default) 001      20 bits                                 16 bits 010      22 bits                                 18 bits 100      23 bits                                 19 bits 101      24 bits                                 20 bits 110      21 bits                                 17 bits             
  #define BIT_MSK__SPDIF_CTRL__AUDI_LENGTH                                           0xF0

// Audio In SPDIF Software 1UI Overwrite Register
#define REG_ADDR__SPDIF_SSMPL                                            (TX_API | 0x0016)
  // (ReadWrite, Bits 7:0) 
  // Maximum number of the pixel clocks per one SPDIF bi-phase mark encoded Unit Interval (max 1UI).  Hardware is locked to this number if reg_1ui_lock is set to 1;  otherwise hardware calculates this number automaticly.   Default is 4 (max # if pclk @ 25 MHz and Fs  @ 48 KHz) If reg_1ui1_lock and reg_2ui_lock are both asserted  (set to 1) then max 2UI will be set to the reg_max_2ui value; If reg_1ui_lock is set; but reg_2ui_lock is not then max 2UI is set to the reg_max_1ui times 2;
  #define BIT_MSK__SPDIF_SSMPL__REG_MAX_1UI                                           0xFF

// Audio In SPDIF Hardware 1UI Sample Register
#define REG_ADDR__SPDIF_HSMPL                                            (TX_API | 0x0017)
  // (ReadOnly, Bits 7:0) 
  // Maximum number of the pixel clocks per one SPDIF bi-phase encoded Unit Interval (max 1UI); continuously sampled by the hardware. 
  #define BIT_MSK__SPDIF_HSMPL__AUDI_MAX_1UI                                          0xFF

// Audio In SPDIF Extracted Fs Register
#define REG_ADDR__SPDIF_FS                                               (TX_API | 0x0018)
  // (ReadOnly, Bits 5:0) 
  // contain the Fs extraction from SPDIF input channel status bits 24-27 30-31.   31 30 27 26 25 24 0   0   0   1   0   0 - Fs =   22.05 kHz 0   0   0   0   0   0 - Fs =   44.1 kHz 0   0   1   0   0   0 - Fs =   88.2 kHz 0   0   1   1   0   0 - Fs = 176.4 kHz 0   0   1   1   0   1 - Fs = 352.8 kHz 1   0   1   1   0   1 - Fs = 705.6 kHz 0   1   1   1   0   1 - Fs = 1411.2 kHz 0   0   0   1   1   0 - Fs =   24 kHz 0   0   0   0   1   0 - Fs =   48 kHz 0   0   1   0   1   0 - Fs =   96 kHz 0   0   1   1   1   0 - Fs = 192 kHz 0   0   0   1   0   1 - Fs = 384 kHz 0   0   1   0   0   1 - Fs = 768 kHz 0   1   0   1   0   1 - Fs = 1536 kHz 0   0   0   0   1   1 - Fs =   32 kHz 0   0   1   0   1   1 - Fs =   64 kHz 1   0   1   0   1   1 - Fs =   128 kHz 0   1   1   0   1   1 - Fs =   256 kHz 1   1   1   0   1   1 - Fs =   512 kHz 1   1   0   1   0   1 - Fs =   1024 kHz 0   0   0   0   0   1 Sampling frequency not indicated
  #define BIT_MSK__SPDIF_FS__AUDI_SPDIF_FS                                         0x3F

// Audio In SPDIF Software 2UI Overwrite Register
#define REG_ADDR__SPDIF_SSMPL2                                           (TX_API | 0x0019)
  // (ReadWrite, Bits 7:0) 
  // Maximum number of the pixel clocks per two SPDIF bi-phase encoded Unit Intervals (max 2UI).  Hardware is locked to this number if reg_2ui_lock and reg_1ui_lock both are set to 1; If only reg_1ui_lock is set to one then hardware is locked to the multiple of 2 of the software max for 1UI. Otherwise hardware calculates this number automaticly.  Default is 9 (max # if pclk @ 25 MHz and Fs  @ 48 KHz)  In the I2S mode bits 7:4 are used as swap control for the channels 0-3.  Bit 4 is for channel 0: 1 would force swap between left and right; Bit 5 is for channel 1: 1 would force swap between left and right; Bit 6 is for channel 2: 1 would force swap between left and right; Bit 7 is for channel 3: 1 would force swap between left and right;
  #define BIT_MSK__SPDIF_SSMPL2__REG_MAX_2UI                                           0xFF

// Audio In SPDIF Hardware 2UI Sample Register
#define REG_ADDR__SPDIF_HSMPL2                                           (TX_API | 0x001A)
  // (ReadOnly, Bits 7:0) 
  // Maximum number of the pixel clocks per two SPDIF bi-phase encoded Unit Intervals (max 2UI); continuously sampled by the hardware. 
  #define BIT_MSK__SPDIF_HSMPL2__AUDI_MAX_2UI                                          0xFF

// Audio In Error Threshold Register
#define REG_ADDR__SPDIF_ERTH                                             (TX_API | 0x001B)
  // (ReadWrite, Bits 5:0) 
  // Error threshold level. The frame will be marked as invalid (flat flag will be set) if during decoding of the frame the number of the bi-phase mark encode related errors will exceed this threshold level.
  #define BIT_MSK__SPDIF_ERTH__REG_AUD_ERR_THRESH                                    0x3F
  // (ReadWrite, Bits 6) 
  // enable to use I2S and SPDIF ports for 1st 6 pins of the DSD
  #define BIT_MSK__SPDIF_ERTH__REG_I2S2DSD_EN                                        0x40

// Audio IN I2S Data In Map Register
#define REG_ADDR__I2S_IN_MAP                                             (TX_API | 0x001C)
  // (ReadWrite, Bits 1:0) 
  // Channel map to FIFO #0 (for HDMI layout 0 or 1): 00 - map SD0 to FIFO #0 (default) 01 - map SD1 to FIFO #0 10 - map SD2 to FIFO #0 11 - map SD3 to FIFO #0
  #define BIT_MSK__I2S_IN_MAP__REG_FIFO0_MAP                                         0x03
  // (ReadWrite, Bits 3:2) 
  // Channel map to FIFO #1 (for HDMI layout 1): 00 - map SD0 to FIFO #1 01 - map SD1 to FIFO #1 (default) 10 - map SD2 to FIFO #1 11 - map SD3 to FIFO #1
  #define BIT_MSK__I2S_IN_MAP__REG_FIFO1_MAP                                         0x0C
  // (ReadWrite, Bits 5:4) 
  // Channel map to FIFO #2 (for HDMI layout 1): 00 - map SD0 to FIFO #2 01 - map SD1 to FIFO #2 10 - map SD2 to FIFO #2 (default) 11 - map SD3 to FIFO #2
  #define BIT_MSK__I2S_IN_MAP__REG_FIFO2_MAP                                         0x30
  // (ReadWrite, Bits 7:6) 
  // Channel map to FIFO #3 (for HDMI layout 1): 00 - map SD0 to FIFO #3 01 - map SD1 to FIFO #3 10 - map SD2 to FIFO #3 11 - map SD3 to FIFO #3 (default)
  #define BIT_MSK__I2S_IN_MAP__REG_FIFO3_MAP                                         0xC0

// Audio In I2S Control Register
#define REG_ADDR__I2S_IN_CTRL                                            (TX_API | 0x001D)
  // (ReadWrite, Bits 0) 
  // WS to SD: 1st-bit shift 0 - 1st-bit shift; Philips spec. 1 - no shift (default)
  #define BIT_MSK__I2S_IN_CTRL__REG_1ST_BIT                                           0x01
  // (ReadWrite, Bits 1) 
  // SD: MSb/LSb first: 0 - MSb first (default)
  #define BIT_MSK__I2S_IN_CTRL__REG_DATA_DIR                                          0x02
  // (ReadWrite, Bits 2) 
  // SD: Left-; Right-justified: 1 - data is right justified (default)
  #define BIT_MSK__I2S_IN_CTRL__REG_JUSTIFY                                           0x04
  // (ReadWrite, Bits 3) 
  // WS: Left/Right polarity: 0 - Left polarity when Word Select is low (default) When TDM is not used then WS for I2S (reg_ws(I2S_IN_CTRL[3])) have to match left/right orientation that Source sends. When TDM is used then need to set reg_ws(I2S_IN_CTRL[3]) to opposite of the reg_tdm_ws_negedge(TDM_CTRL[5])
  #define BIT_MSK__I2S_IN_CTRL__REG_WS                                                0x08
  // (ReadWrite, Bits 4) 
  // V bit value: 0 - For PCM data (default)
  #define BIT_MSK__I2S_IN_CTRL__REG_VBIT                                              0x10
  // (ReadWrite, Bits 5) 
  // Order of the Channel Status bits in the High Bitrate stream:  0 - Left and Right sample have consecutive C bits (default) 1 - Left and Right sample have the same C bits
  #define BIT_MSK__I2S_IN_CTRL__REG_CBIT_ORDER                                        0x20
  // (ReadWrite, Bits 6) 
  // SCK: Sample edge rising/falling 0 - Sample edge is falling: SD3-SD0 and WS source should change state on the rising edge of the SCK 1 - Sample edge is rising (default): SD3-SD0 and WS source should change state on the falling edge of SCK
  #define BIT_MSK__I2S_IN_CTRL__REG_SCK_EDGE                                          0x40
  // (ReadWrite, Bits 7) 
  // phase of MCLK. 0: no invert; 1: invert
  #define BIT_MSK__I2S_IN_CTRL__REG_M_CK_PHASE                                        0x80

// Audio In I2S Channel Status #0 Register
#define REG_ADDR__I2S_CHST0                                              (TX_API | 0x001E)
  // (ReadWrite, Bits 7:0) 
  // The information in this register is send in Channel Status field across HDMI link Channel Status byte #0. Please refer to SPDIF spec for detailed description.
  #define BIT_MSK__I2S_CHST0__REG_CBIT0                                             0xFF

// Audio In I2S Channel Status #1 Register
#define REG_ADDR__I2S_CHST1                                              (TX_API | 0x001F)
  // (ReadWrite, Bits 7:0) 
  // The information in this register is send in Channel Status field across HDMI link.  Category code. Please refer to SPDIF spec for detailed description.
  #define BIT_MSK__I2S_CHST1__REG_CBIT1                                             0xFF

// Audio In I2S Channel Status #2 Register
#define REG_ADDR__I2S_CHST2                                              (TX_API | 0x0020)
  // (ReadWrite, Bits 3:0) 
  // The information in this register is send in Channel Status field across HDMI link. Source number. Please refer to SPDIF spec for detailed description.
  #define BIT_MSK__I2S_CHST2__REG_CBIT2A                                            0x0F
  // (ReadWrite, Bits 7:4) 
  // The information in this register is send in Channel Status field across HDMI link Channel Number. Please refer to SPDIF spec for detailed description.
  #define BIT_MSK__I2S_CHST2__REG_CBIT2B                                            0xF0

// Audio in I2S Channel Status #3 Register
#define REG_ADDR__I2S_CHST3                                              (TX_API | 0x0021)
  // (ReadWrite, Bits 3:0) 
  // The information in this register is send in Channel Status field across HDMI link. Please refer to SPDIF spec for detailed description. Sampling frequency set by software (inserted into I2S stream or into SPDIF if fs_overrride is enabled). These bits correspond to the Channel Status bits 24; 25; 26;27; where bit 24 = LSB and 27 = MSB: 27 26 25 24 0   1   0   0 - Fs =   22.05 kHz 0   0   0   0 - Fs =   44.1 kHz 1   0   0   0 - Fs =   88.2 kHz 1   1   0   0 - Fs = 176.4 kHz 0   1   1   0 - Fs =   24 kHz 0   0   1   0 - Fs =   48 kHz 1   0   1   0 - Fs =   96 kHz 1   1   1   0 - Fs = 192 kHz 0   0   1   1 - Fs =   32 kHz 1  0  0  1 -  Fs =  768 kHz*  All other frequencies (default)
  #define BIT_MSK__I2S_CHST3__REG_CBIT3A                                            0x0F
  // (ReadWrite, Bits 7:4) 
  // [5:4] Clock accuracy [7:6] Sampling frequency extension with sampling frequency bits 24 to 27 hbra_on, aud_sample_freq[5:0];  Audio Rate 1b0, 2b00, 4'b0100; 22.05 kHz (n/a) 1b0, 2b00, 4'b0000; 44.1 kHz 1b0, 2b00, 4'b1000; 88.2 kHz 1b0, 2b00, 4'b1100; 176.4 kHz 1b0, 2b00, 4b1101; 352.8 kHz 1b0, 2b10, 4b1101; 705.6 kHz 1b0, 2b01, 4b1101; 1411.2 kHz (n/a) 1b0, 2b00, 4'b0110; 24 kHz (n/a) 1b0, 2b00, 4'b0010; 48 kHz 1b0, 2b00, 4'b1010; 96 kHz 1b0, 2b00, 4'b1110; 192 kHz 1b0, 2b00; 4b0101; 384 kHz 1b0, 2b00, 4b1001; 768 kHz 1b0, 2b01; 4b0101; 1536 kHz (n/a) 1b0, 2b00, 4'b0011; 32 kHz 1b0, 2b00, 4b1011; 64 kHz 1b0, 2b10, 4b1011; 128 kHz 1b0, 2b01, 4b1011; 256 kHz 1b0, 2b11, 4b1011; 512 kHz 1b0, 2b11; 4b0101; 1024 kHz (n/a) 1b1, 2b00, 4'b1100; HBRA 176.4 kHz 1b1, 2b00, 4'b1101; HBRA 352.8 kHz 1b1, 2b10, 4'b1101; HBRA 705.6 kHz 1b1, 2b01, 4b1101; HBRA 1411.2 kHz 1b1, 2b00, 4'b1110; HBRA 192 kHz 1b1, 2b00, 4'b0101; HBRA 384 kHz 1b1, 2b00, 4'b1001; HBRA 768 kHz 1b1, 2b01; 4b0101; HBRA 1536 kHz 1b1, 2b10, 4'b1011; HBRA 128 kHz 1b1, 2b01, 4b1011; HBRA 256 kHz 1b1, 2b11, 4b1011; HBRA 512 kHz 1b1, 2b11, 4b0101; HBRA 1024 kHz 
  #define BIT_MSK__I2S_CHST3__REG_CBIT3B                                            0xF0

// Audio In I2S Channel Status #4 Register
#define REG_ADDR__I2S_CHST4                                              (TX_API | 0x0022)
  // (ReadWrite, Bits 3:0) 
  // Reg_cbit[32] : The information in this register is send in Channel Status field across HDMI link. Channel Status bits32: 0 - Max audio sample word length is 20 bits 1 - Max audio sample word length is 24 bits (default) Reg_cbit[35:32] : The information in this register is send in Channel Status field across HDMI link.Channel Status bits 33 to 35; where bit 33 = LSB and 35 = MSB               max 24                               max 20 000      not indicated         not indicated  001      20 bits                                 16 bits 010      22 bits                                 18 bits 100      23 bits                                 19 bits 101      24 bits                                 20 bits 110      21 bits                                 17 bits              
  #define BIT_MSK__I2S_CHST4__REG_CBIT4A                                            0x0F
  // (ReadWrite, Bits 7:4) 
  // Original Fs
  #define BIT_MSK__I2S_CHST4__REG_CBIT4B                                            0xF0

// Audio In Sample Rate Conversion Register
#define REG_ADDR__ASRC                                                   (TX_API | 0x0023)
  // (ReadWrite, Bits 0) 
  // Enable Audio Sample rate Conversion: 0 disabled (default)
  #define BIT_MSK__ASRC__REG_SRC_EN                                            0x01
  // (ReadWrite, Bits 1) 
  // Selects downsample mode: if 0 then 2:1 mode and will do following sample rate conversion:         44.1   -] 22.05        48      -] 24        88.2   -] 44.1        96      -] 48         176.4 -] 88.2         192    -] 96 if 1 then 4:1 mode and will do following sample rate conversion:         88.2   -] 22.05        96      -] 24         176.4 -] 44.1         192    -] 48
  #define BIT_MSK__ASRC__REG_SRC_CTRL                                          0x02
  // (ReadWrite, Bits 7:4) 
  // Mask for the sample present and flat bit of the High Bit Rate Audio header.  Each bit mask out 1 of the subpacket sample presetn bits. When 0 mask out. Default; only 1 lsb bit is unmasked.
  #define BIT_MSK__ASRC__REG_HBR_SPR_MASK                                      0xF0

// Audio In I2S Input Size Register
#define REG_ADDR__I2S_IN_SIZE                                            (TX_API | 0x0024)
  // (ReadWrite, Bits 3:0) 
  // The information in this register is used for the extraction of the I2S data from the input stream. Number of the valid bits in the input I2S stream; default is 24: 1011 - 24 bits (default); 1001 - 23 bits; 0101 - 22 bits; 1101 - 21 bits; 1010 - 20 bits 1000 - 19 bits 0100 - 18 bits 1100 - 17 bits 0010 - 16 bits
  #define BIT_MSK__I2S_IN_SIZE__REG_I2S_IN_LENGTH                                     0x0F

// Audio Parallel busclk clock disabling Register 1
#define REG_ADDR__AUD_PAR_BUSCLK_1                                       (TX_API | 0x0025)
  // (ReadWrite, Bits 7:0) 
  // Audio Parallel busclk clock disabling Register
  #define BIT_MSK__AUD_PAR_BUSCLK_1__REG_AUD_PAR_B7_B0                                     0xFF

// Audio Parallel busclk clock disabling Register 2
#define REG_ADDR__AUD_PAR_BUSCLK_2                                       (TX_API | 0x0026)
  // (ReadWrite, Bits 7:0) 
  // Audio Parallel busclk clock disabling Register
  #define BIT_MSK__AUD_PAR_BUSCLK_2__REG_AUD_PAR_B15_B8                                    0xFF

// Audio Parallel busclk clock disabling Register 3
#define REG_ADDR__AUD_PAR_BUSCLK_3                                       (TX_API | 0x0027)
  // (ReadWrite, Bits 7:0) 
  // Audio Parallel busclk clock disabling Register
  #define BIT_MSK__AUD_PAR_BUSCLK_3__REG_AUD_PAR_B23_B16                                   0xFF

// Audio In I2S Channel Status #5 Register
#define REG_ADDR__I2S_CHST6                                              (TX_API | 0x0028)
  // (ReadWrite, Bits 7:0) 
  // cbit stream bits 47:40 Please refer to SPDIF spec for detailed description.
  #define BIT_MSK__I2S_CHST6__REG_CBIT_MSB_B7_B0                                    0xFF

// Audio In I2S Channel Status #6 Register
#define REG_ADDR__I2S_CHST7                                              (TX_API | 0x0029)
  // (ReadWrite, Bits 7:0) 
  // cbit stream bits 55:48 Please refer to SPDIF spec for detailed description.
  #define BIT_MSK__I2S_CHST7__REG_CBIT_MSB_B15_B8                                   0xFF

// DSD INTERLEAVE Register
#define REG_ADDR__DSD_INTERLEAVE                                         (TX_API | 0x002A)
  // (ReadWrite, Bits 7:0) 
  // parallel audio settings
  #define BIT_MSK__DSD_INTERLEAVE__REG_DSD_INTERLEAVE_B7_B0                              0xFF

// AUDIO_PAR_MODE_SEL Register
#define REG_ADDR__AUDIO_PAR_MODE_SEL                                     (TX_API | 0x002B)
  // (ReadWrite, Bits 2:0) 
  // parallel audio settings
  #define BIT_MSK__AUDIO_PAR_MODE_SEL__REG_AUDIO_PAR_MODE_B2_B0                              0x07

// AUDIO_RST Register
#define REG_ADDR__AIP_RST                                                (TX_API | 0x002C)
  // (ReadWrite, Bits 0) 
  // software reset for aip - will reset every piece of the AIP logic
  #define BIT_MSK__AIP_RST__REG_RST4AUDIO                                         0x01
  // (ReadWrite, Bits 1) 
  // software reset for aip fifos - will reset only Audio FIFO
  #define BIT_MSK__AIP_RST__REG_RST4AUDIO_FIFO                                    0x02
  // (ReadWrite, Bits 2) 
  // software reset for ACR - will reset only ACR logic
  #define BIT_MSK__AIP_RST__REG_RST4AUDIO_ACR                                     0x04
  // (ReadWrite, Bits 3) 
  // TDM interface software reset
  #define BIT_MSK__AIP_RST__REG_RST4AUDIO_TDM                                     0x08

// AUDIO HDMI2MHL Register
#define REG_ADDR__AIP_HDMI2MHL                                           (TX_API | 0x002D)
  // (ReadWrite, Bits 0) 
  // Indicates output mode: 0 - HDMI, 1 - MHL
  #define BIT_MSK__AIP_HDMI2MHL__REG_MODE_OUT                                          0x01
  // (ReadWrite, Bits 1) 
  // Indicates input mode: 0 - HDMI, 1 - MHL
  #define BIT_MSK__AIP_HDMI2MHL__REG_MODE_IN                                           0x02
  // (ReadWrite, Bits 2) 
  // enable to convert HBRA audio packet from HDMI to MHL or from MHL to HDMI
  #define BIT_MSK__AIP_HDMI2MHL__REG_HBAC_EN                                           0x04
  // (ReadWrite, Bits 7:3) 
  // bit #3 - if 1 then output from AFIFO will be regestered bit #4 - if 1 then logic will identify HBRA packet ID based on the mode, since in HDMI vs MHL HBRA has different header. Otherwise logic will set internal HBRA flag if header is 0x09 (HDMI mode)
  #define BIT_MSK__AIP_HDMI2MHL__REG_AFIFO_TEST                                        0xF8

// Audio In TDM Control Register
#define REG_ADDR__TDM_CTRL                                               (TX_API | 0x002E)
  // (ReadWrite, Bits 0) 
  // TDM enable
  #define BIT_MSK__TDM_CTRL__REG_TDM_EN                                            0x01
  // (ReadWrite, Bits 2:1) 
  // TDM Channel select: 00: 2 channel input (no clock divider) 01: 4 channel input (/2 clock divider) 10: 6 channel input (/3 clock divider) 11: 8 channel input (/4 clock divider)
  #define BIT_MSK__TDM_CTRL__REG_TDM_CH                                            0x06
  // (ReadWrite, Bits 3) 
  // Sampling edge of the TDM data: 1 means that TDM data will be sampled on neg edge
  #define BIT_MSK__TDM_CTRL__REG_TDM_CK_PHASE                                      0x08
  // (ReadWrite, Bits 4) 
  // TDM Incoming Data Block Size 0: 32-bit (default) 1: 16-bit
  #define BIT_MSK__TDM_CTRL__REG_TDM_16_BIT_BLK                                    0x10
  // (ReadWrite, Bits 5) 
  // Select on which edge of the WS to shift in TDM data sample 0: Disabled, i.e. use posedge (default) 1: Enabled, i.e. use negedge
  #define BIT_MSK__TDM_CTRL__REG_TDM_WS_NEGEDGE                                    0x20
  // (ReadWrite, Bits 7:6) 
  // Number of cycles between incoming WS/FS and data. Zero means the data is valid starting from the same cycle WS is active 00: 0 cycle 01: 1 cycle 10: 2 cycles 11: 3 cycles
  #define BIT_MSK__TDM_CTRL__REG_TDM_WS_IN_DELAY                                   0xC0

// Audio PATH Control Register
#define REG_ADDR__AUDP_TXCTRL                                            (TX_API | 0x002F)
  // (ReadWrite, Bits 1) 
  // HDMI Audio Packet layout indicator: 0 - Layout 0 (2-channel) (default) 1 - Layout 1 (Up to 8-channel)
  #define BIT_MSK__AUDP_TXCTRL__REG_LAYOUT                                            0x02
  // (ReadWrite, Bits 7) 
  // Mute Audio in means of no data from interfaces inserted into FIFOs controlled by TPI
  #define BIT_MSK__AUDP_TXCTRL__REG_AUD_MUTE_EN                                       0x80

// Audio PATH Tx FIFO Read Write ptr difference Register
#define REG_ADDR__AUDP_TXFIFO                                            (TX_API | 0x0031)
  // (ReadOnly, Bits 5:0) 
  // Difference between read and write pointers
  #define BIT_MSK__AUDP_TXFIFO__HDMI_FIFO_DIFF                                        0x3F

// Reg Access Time-out Register
#define REG_ADDR__AIP_REG_ACC_TO                                         (TX_API | 0x0032)
  // (ReadWrite, Bits 7:0) 
  // Register access time-out value bits 9:2. LSB tight to 0. If client does not respond within this time frame then flag will be set.
  #define BIT_MSK__AIP_REG_ACC_TO__REG_TO_LIMIT                                          0xFF

// TDM Channel data mapping Register
#define REG_ADDR__AIP_TDM_CH_MAP                                         (TX_API | 0x0033)
  // (ReadWrite, Bits 1:0) 
  // Map which TDM data will go out of SD0:  00 - sample 0 and 1 01 - sample 2 and 3 10 - sample 4 and 5 11 - sample 6 and 7
  #define BIT_MSK__AIP_TDM_CH_MAP__REG_TDM_CH0_MAP                                       0x03
  // (ReadWrite, Bits 3:2) 
  // Map which TDM data will go out of SD1:  00 - sample 0 and 1 01 - sample 2 and 3 10 - sample 4 and 5 11 - sample 6 and 7
  #define BIT_MSK__AIP_TDM_CH_MAP__REG_TDM_CH1_MAP                                       0x0C
  // (ReadWrite, Bits 5:4) 
  // Map which TDM data will go out of SD2:  00 - sample 0 and 1 01 - sample 2 and 3 10 - sample 4 and 5 11 - sample 6 and 7
  #define BIT_MSK__AIP_TDM_CH_MAP__REG_TDM_CH2_MAP                                       0x30
  // (ReadWrite, Bits 7:6) 
  // Map which TDM data will go out of SD3:  00 - sample 0 and 1 01 - sample 2 and 3 10 - sample 4 and 5 11 - sample 6 and 7
  #define BIT_MSK__AIP_TDM_CH_MAP__REG_TDM_CH3_MAP                                       0xC0

// TDM Channel data mapping Register
#define REG_ADDR__AIP_TDM_CTRL_4                                         (TX_API | 0x0034)
  // (ReadWrite, Bits 0) 
  // delay TDM WS out: 1 delay
  #define BIT_MSK__AIP_TDM_CTRL_4__REG_TDM_DEL_WS_OUT                                    0x01

// Interrupt State Register
#define REG_ADDR__AIP_INTR_STATE                                         (TX_API | 0x004E)
  // (ReadOnly, Bits 0) 
  // Interrupt state bit value.  It shows whether the interrupt is active or not.  It is one gate before the polarity is applied to the interrupt.  In other words; whenever the interrupt is asserted; this bit is high.
  #define BIT_MSK__AIP_INTR_STATE__INTR_STATE                                            0x01
  // (ReadOnly, Bits 1) 
  // status of the interrupt from ADAM
  #define BIT_MSK__AIP_INTR_STATE__O_ADMA_INTR                                           0x02

// Interrupt Source #1 Register
#define REG_ADDR__AIP_INTR1                                              (TX_API | 0x004F)
  // (ReadWrite, Bits 0) 
  // Audio FIFO underflow. Asserted if set to 1. Writing 1 into this bit would clear it. '0' - wont change anything
  #define BIT_MSK__AIP_INTR1__REG_INTR1_STAT0                                       0x01
  // (ReadWrite, Bits 1) 
  // Audio FIFO overflow. Asserted if set to 1. Write '1' to clear this bit.
  #define BIT_MSK__AIP_INTR1__REG_INTR1_STAT1                                       0x02
  // (ReadWrite, Bits 3) 
  // Input SPDIF stream had bi-phase error. Asserted if set to 1. Write '1' to clear this bit.
  #define BIT_MSK__AIP_INTR1__REG_INTR1_STAT3                                       0x08
  // (ReadWrite, Bits 4) 
  // New preamble forced to drop sample. Asserted if set to 1. Write '1' to clear this bit.
  #define BIT_MSK__AIP_INTR1__REG_INTR1_STAT4                                       0x10

// Interrupt Source #2 Register
#define REG_ADDR__AIP_INTR2                                              (TX_API | 0x0050)
  // (ReadWrite, Bits 0) 
  // DSD stream got invalid sequence: more then 24 bits of the same value. Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__AIP_INTR2__REG_INTR2_STAT0                                       0x01
  // (ReadWrite, Bits 1) 
  // ACR CTS # is recalculating.  Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__AIP_INTR2__REG_INTR2_STAT1                                       0x02
  // (ReadWrite, Bits 2) 
  // ACR packet overwrite occurred.  Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__AIP_INTR2__REG_INTR2_STAT2                                       0x04
  // (ReadWrite, Bits 3) 
  // ACR CTS Changed.  Asserted if set to 1. Write 1 to clear
  #define BIT_MSK__AIP_INTR2__REG_INTR2_STAT3                                       0x08
  // (ReadWrite, Bits 4) 
  // Did not found expected preamble. Asserted if set to 1. Write '1' to clear this bit.
  #define BIT_MSK__AIP_INTR2__REG_INTR2_STAT4                                       0x10
  // (ReadWrite, Bits 6) 
  // SPDIF parity error. Write 1 to clear
  #define BIT_MSK__AIP_INTR2__REG_INTR2_STAT6                                       0x40

// Interrupt #1 Mask Register
#define REG_ADDR__AIP_INTR1_MASK                                         (TX_API | 0x0051)
  // (ReadWrite, Bits 0) 
  // Enable INT1[0]: 1 - enable; 0 - disable (defualt)
  #define BIT_MSK__AIP_INTR1_MASK__REG_INTR1_MASK0                                       0x01
  // (ReadWrite, Bits 1) 
  // Enable INT1[1]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__AIP_INTR1_MASK__REG_INTR1_MASK1                                       0x02
  // (ReadWrite, Bits 2) 
  // Enable INT1[2]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__AIP_INTR1_MASK__REG_INTR1_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // Enable INT1[3]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__AIP_INTR1_MASK__REG_INTR1_MASK3                                       0x08
  // (ReadWrite, Bits 4) 
  // Enable INT1[4]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__AIP_INTR1_MASK__REG_INTR1_MASK4                                       0x10
  // (ReadWrite, Bits 5) 
  // Enable INT1[5]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__AIP_INTR1_MASK__REG_INTR1_MASK5                                       0x20
  // (ReadWrite, Bits 6) 
  // Enable INT1[6]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__AIP_INTR1_MASK__REG_INTR1_MASK6                                       0x40
  // (ReadWrite, Bits 7) 
  // Enable INT1[7]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__AIP_INTR1_MASK__REG_INTR1_MASK7                                       0x80

// Interrupt #2 Mask Register
#define REG_ADDR__AIP_INTR2_MASK                                         (TX_API | 0x0052)
  // (ReadWrite, Bits 0) 
  // Enable INTR2[0]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__AIP_INTR2_MASK__REG_INTR2_MASK0                                       0x01
  // (ReadWrite, Bits 1) 
  // Enable INTR2[1]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__AIP_INTR2_MASK__REG_INTR2_MASK1                                       0x02
  // (ReadWrite, Bits 2) 
  // Enable INTR2[2]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__AIP_INTR2_MASK__REG_INTR2_MASK2                                       0x04
  // (ReadWrite, Bits 3) 
  // Enable INTR2[3]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__AIP_INTR2_MASK__REG_INTR2_MASK3                                       0x08
  // (ReadWrite, Bits 4) 
  // Enable INTR2[4]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__AIP_INTR2_MASK__REG_INTR2_MASK4                                       0x10
  // (ReadWrite, Bits 5) 
  // Enable INTR2[5]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__AIP_INTR2_MASK__REG_INTR2_MASK5                                       0x20
  // (ReadWrite, Bits 6) 
  // Enable INTR2[6]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__AIP_INTR2_MASK__REG_INTR2_MASK6                                       0x40
  // (ReadWrite, Bits 7) 
  // Enable INTR2[7]: 1 - enable; 0 - disable (default)
  #define BIT_MSK__AIP_INTR2_MASK__REG_INTR2_MASK7                                       0x80

// TPI Audio Down Sample Control Register
#define REG_ADDR__TPI_DOWN_SMPL_CTRL                                     (TX_API | 0x0061)
  // (ReadWrite, Bits 1:0) 
  // S/PDIF Audio Handling. 0b00  Block any audio except audio indicating fs as 32  kHz 44.1 kHz or 48 kHz. 0b01  Same as 0b11 (default for Atmel) 0b10  Down sample incoming audio as needed fs = 32 kHz -] fs = 32 kHz fs = 44.1 kHz -] fs = 44.1 kHz fs = 48 kHz -] fs = 48 kHz fs = 88.2 kHz -] fs = 44.1 kHz fs = 96 kHz -] fs = 48 kHz fs = 176.4 kHz -] fs = 44.1 kHz fs = 192 kHz -] fs = 48 kHz Note: This register will not affect NonPCM streams Note: fS value in the audio status channel is corrected automatically. 0b11  Pass any audio stream without fs modification. (default for SST)  I2S Audio Handling. 0b00 0b01 0b11 - Pass any audio stream without fs modification. 0b10  Down sample incoming audio as needed fs = 32 kHz -] fs = 32 kHz fs = 44.1 kHz -] fs = 44.1 kHz fs = 48 kHz -] fs = 48 kHz fs = 88.2 kHz -] fs = 44.1 kHz fs = 96 kHz -] fs = 48 kHz fs = 176.4 kHz -] fs = 44.1 kHz fs = 192 kHz -] fs = 48 kHz
  #define BIT_MSK__TPI_DOWN_SMPL_CTRL__REG_TPI_AUD_HNDL                                      0x03
  // (ReadWrite, Bits 2) 
  // TPI Audio Lookup Tables Enable 0  Not Enabled 1  Enabled (default)
  #define BIT_MSK__TPI_DOWN_SMPL_CTRL__REG_TPI_AUDIO_LOOKUP_EN                               0x04

// TPI Audio Config Register
#define REG_ADDR__TPI_AUD_CONFIG                                         (TX_API | 0x0062)
  // (ReadWrite, Bits 4) 
  // 0  Normal (clears reg_aud_mute_en) 1  Mute (set reg_aud_mute_en)
  #define BIT_MSK__TPI_AUD_CONFIG__REG_TPI_AUD_MUTE                                      0x10
  // (ReadWrite, Bits 7:6) 
  // 00=Refer to Stream Header 01=16-bit 10=20-bit 11=24-bit
  #define BIT_MSK__TPI_AUD_CONFIG__REG_TPI_SPDIF_SAMPLE_SIZE                             0xC0

// TPI Audio Sample Size/Frequency Register
#define REG_ADDR__TPI_AUD_FS                                             (TX_API | 0x0063)
  // (ReadWrite, Bits 5:0) 
  // Audio Sample Frequency hbra_on, aud_sample_freq[5:0];  Audio Rate 1b0, 2b00, 4'b0100; 22.05 kHz (n/a) 1b0, 2b00, 4'b0000; 44.1 kHz 1b0, 2b00, 4'b1000; 88.2 kHz 1b0, 2b00, 4'b1100; 176.4 kHz 1b0, 2b00, 4b1101; 352.8 kHz 1b0, 2b10, 4b1101; 705.6 kHz 1b0, 2b01, 4b1101; 1411.2 kHz (n/a) 1b0, 2b00, 4'b0110; 24 kHz (n/a) 1b0, 2b00, 4'b0010; 48 kHz 1b0, 2b00, 4'b1010; 96 kHz 1b0, 2b00, 4'b1110; 192 kHz 1b0, 2b00; 4b0101; 384 kHz 1b0, 2b00, 4b1001; 768 kHz 1b0, 2b01; 4b0101; 1536 kHz (n/a) 1b0, 2b00, 4'b0011; 32 kHz 1b0, 2b00, 4b1011; 64 kHz 1b0, 2b10, 4b1011; 128 kHz 1b0, 2b01, 4b1011; 256 kHz 1b0, 2b11, 4b1011; 512 kHz 1b0, 2b11; 4b0101; 1024 kHz (n/a) 1b1, 2b00, 4'b1100; HBRA 176.4 kHz 1b1, 2b00, 4'b1101; HBRA 352.8 kHz 1b1, 2b10, 4'b1101; HBRA 705.6 kHz 1b1, 2b01, 4b1101; HBRA 1411.2 kHz 1b1, 2b00, 4'b1110; HBRA 192 kHz 1b1, 2b00, 4'b0101; HBRA 384 kHz 1b1, 2b00, 4'b1001; HBRA 768 kHz 1b1, 2b01; 4b0101; HBRA 1536 kHz 1b1, 2b10, 4'b1011; HBRA 128 kHz 1b1, 2b01, 4b1011; HBRA 256 kHz 1b1, 2b11, 4b1011; HBRA 512 kHz 1b1, 2b11, 4b0101; HBRA 1024 kHz
  #define BIT_MSK__TPI_AUD_FS__REG_TPI_AUD_SF_B5_B0                                  0x3F
  // (ReadWrite, Bits 7) 
  // Enable for the TPI Sample Frequency override 1 - Use value in reg_tpi_aud_sf 0x63[5:0] 0 - Use incoming stream
  #define BIT_MSK__TPI_AUD_FS__REG_TPI_AUD_SF_OVRD                                   0x80

//***************************************************************************
// ANAPHY_RXDPLL. Address: 60
// TMDS RX Control Registers
#define REG_ADDR__TMDSRX_CTRL                                            (ANAPHY_RXDPLL | 0x0000)
  // (ReadWrite, Bits 3:0) 
  // The proportion path includes two segments: one is the constant current (I16u); the other is the feedback current (Ifb) from VCO. [3:2] : calibate the I16u from 0.5/0.75/1/1.25 [1:0]: calibrate the Ifb from 0.5/0.75/1/1.25 reg_rx_bias_bgr_d_ovr (Bit 7) should be programmed as 1'b1 to consider this value.
  #define BIT_MSK__TMDSRX_CTRL__REG_RX_BIAS_BGR_D                                     0x0F
  // (ReadWrite, Bits 6:4) 
  // 
  #define BIT_MSK__TMDSRX_CTRL__REG_RX_DPCOLOR_CTL                                    0x70
  // (ReadWrite, Bits 7) 
  // Reg overwrite control bit. If 0: bias_bgr_d from zone controller is driven on bias_bgr_d of esally else reg_rx_bias_bgr_d
  #define BIT_MSK__TMDSRX_CTRL__REG_RX_BIAS_BGR_D_OVR                                 0x80

// TMDS PD System Control Register
#define REG_ADDR__TMDSRX_PD_SYS_CTRL                                     (ANAPHY_RXDPLL | 0x0001)
  // (ReadWrite, Bits 0) 
  // 
  #define BIT_MSK__TMDSRX_PD_SYS_CTRL__REG_RX_CH0_EN_OVR                                     0x01
  // (ReadWrite, Bits 1) 
  // RX enable signal. Reg_rx_ch0_en_ovr (1[0]) should be programmed to 1'b1.
  #define BIT_MSK__TMDSRX_PD_SYS_CTRL__REG_RX_CH0_EN                                         0x02
  // (ReadWrite, Bits 2) 
  // 
  #define BIT_MSK__TMDSRX_PD_SYS_CTRL__REG_RX_CH12_EN_OVR                                    0x04
  // (ReadWrite, Bits 3) 
  // chanel1,2 enable. Reg_rx_ch12_en_ovr (1[2]) should be programmed to 1'b1.
  #define BIT_MSK__TMDSRX_PD_SYS_CTRL__REG_RX_CH12_EN                                        0x08
  // (ReadWrite, Bits 4) 
  // 
  #define BIT_MSK__TMDSRX_PD_SYS_CTRL__REG_RX_CHC_EN_OVR                                     0x10
  // (ReadWrite, Bits 5) 
  // 
  #define BIT_MSK__TMDSRX_PD_SYS_CTRL__REG_RX_CHC_EN                                         0x20
  // (ReadWrite, Bits 6) 
  // AV link clock path enable =1: normal mode =0: disable circuit function
  #define BIT_MSK__TMDSRX_PD_SYS_CTRL__REG_RX_PDB_CKDT                                       0x40

// TMDS RX MISC Register
#define REG_ADDR__TMDSRX_MISC                                            (ANAPHY_RXDPLL | 0x0002)
  // (ReadWrite, Bits 1:0) 
  // channel 0 1x clock timing control 00: 1x delay 01: no delay 10: 2x delay 11: inverted clock
  #define BIT_MSK__TMDSRX_MISC__REG_RX_CLK1X_CTL                                      0x03
  // (ReadWrite, Bits 5:4) 
  // channel 1 1x clock timing control 00: 1x delay 01: no delay 10: 2x delay 11: inverted clock
  #define BIT_MSK__TMDSRX_MISC__REG_RX_CLK1X_1_CTL                                    0x30
  // (ReadWrite, Bits 7:6) 
  // channel 2 1x clock timing control 00: 1x delay 01: no delay 10: 2x delay 11: inverted clock
  #define BIT_MSK__TMDSRX_MISC__REG_RX_CLK1X_2_CTL                                    0xC0

// PLL_VCOCAL Register
#define REG_ADDR__PLL_VCOCAL                                             (ANAPHY_RXDPLL | 0x0003)
  // (ReadWrite, Bits 3:0) 
  // PLL vcocal calibration bits
  #define BIT_MSK__PLL_VCOCAL__REG_RX_PLL_VCOCAL                                     0x0F
  // (ReadWrite, Bits 4) 
  // To control refclk ouput =1:  use clkdetect signal to control refclk output =0:  refclk output without clkdetect signal control
  #define BIT_MSK__PLL_VCOCAL__REG_RX_EN_GATE_CLK                                    0x10
  // (ReadWrite, Bits 5) 
  // overwrite of rxzone_vcocal coming from zone cntl and drive reg value to reg_pll_vcocal of esally. If 0: rxzone_vcocal of zone cntl if 1: reg_rx_pll_vcocal
  #define BIT_MSK__PLL_VCOCAL__REG_RX_PLL_VCOCAL_OVR                                 0x20

// TMDS RX CTRL1 Register
#define REG_ADDR__TMDSRX_CTRL1                                           (ANAPHY_RXDPLL | 0x0004)
  // (ReadWrite, Bits 4:0) 
  // PLL configuration
  #define BIT_MSK__TMDSRX_CTRL1__REG_RX_PLL_CONFIG                                     0x1F
  // (ReadWrite, Bits 5) 
  // low BW setting for PLL
  #define BIT_MSK__TMDSRX_CTRL1__REG_RX_LOBW                                           0x20

// HDMI RX Control 1 Registers
#define REG_ADDR__RX_CTRL1                                               (ANAPHY_RXDPLL | 0x0005)
  // (ReadWrite, Bits 0) 
  // EQ bias enable when high 0: equalizers are completely off 1: basic bias circuits of equalizers are on
  #define BIT_MSK__RX_CTRL1__REG_RX_EQ_BIAS_EN                                     0x01
  // (ReadWrite, Bits 1) 
  // PLL bias enable when high (for smaller roving noise; should enclose port switching signal) 0: PLL is completely off 1: basic bias circuits of PLL are on PLL bias and cpath bias enable signal; to enable PLL also need to have reg_pll_en=1
  #define BIT_MSK__RX_CTRL1__REG_RX_PLL_BIAS_EN                                    0x02
  // (ReadWrite, Bits 2) 
  // PLL enable signal; to enable PLL, also need to have reg_pll_bias_en=1 PLL enable when high 0: PLL is off 1: PLL is on
  #define BIT_MSK__RX_CTRL1__REG_RX_PLL_EN                                         0x04
  // (ReadWrite, Bits 6:3) 
  // PLL calrefsel
  #define BIT_MSK__RX_CTRL1__REG_RX_PLL_CALREFSEL                                  0x78

// PLL_SPLLBIAS Register
#define REG_ADDR__PLL_SPLLBIAS                                           (ANAPHY_RXDPLL | 0x0006)
  // (ReadWrite, Bits 3:0) 
  // PLL spill bias [3:2]: compensate the mismatch of the current [1:0]: calibrate the current of the integration path from 0.6uA~1.6uA
  #define BIT_MSK__PLL_SPLLBIAS__REG_RX_PLL_SPLLBIAS                                   0x0F
  // (ReadWrite, Bits 6:4) 
  // PLL vco ibias
  #define BIT_MSK__PLL_SPLLBIAS__REG_RX_PLL_VCO_IBIAS                                  0x70

// TMDS Termination Control Register
#define REG_ADDR__TMDSRX_TERMCTRL                                        (ANAPHY_RXDPLL | 0x0007)
  // (ReadWrite, Bits 2:0) 
  // termination resistors value config 100: 50 111: 47 000: 55
  #define BIT_MSK__TMDSRX_TERMCTRL__REG_RX_TERM_CTL                                       0x07
  // (ReadWrite, Bits 4:3) 
  // TMDS termination select configure input termination: 0X: hdmi mode  50 ohm 1X: termination off
  #define BIT_MSK__TMDSRX_TERMCTRL__REG_RX_TERM_SEL                                       0x18
  // (ReadWrite, Bits 6:5) 
  // reg_test_sel[0]: Not used reg_test_sel[1]: for esd purpose,    =0  shut down EQ inputs    =1 enable EQ inputs reg_rx_auto_esd (A[0]) should be programmed with 1'b0 for this value to take effect.
  #define BIT_MSK__TMDSRX_TERMCTRL__REG_RX_TEST_SEL                                       0x60

// PLL_CTRL Register
#define REG_ADDR__PLL_CTRL                                               (ANAPHY_RXDPLL | 0x0008)
  // (ReadWrite, Bits 1:0) 
  // PLL icpcomp
  #define BIT_MSK__PLL_CTRL__REG_RX_PLL_ICPCOMP                                    0x03
  // (ReadWrite, Bits 2) 
  // scpcal = 1 --] enable token which is not used in RX scpcal=0   --] disable token
  #define BIT_MSK__PLL_CTRL__REG_RX_PLL_SCPCAL                                     0x04

// CLKDET Control OVR Register
#define REG_ADDR__CLKDET_CTL_OVR                                         (ANAPHY_RXDPLL | 0x0009)
  // (ReadWrite, Bits 0) 
  // PLL icpcomp
  #define BIT_MSK__CLKDET_CTL_OVR__REG_CLKDETECT_OVR                                     0x01
  // (ReadWrite, Bits 1) 
  // PLL scpcal
  #define BIT_MSK__CLKDET_CTL_OVR__REG_CLKDETECT_VAL                                     0x02
  // (ReadWrite, Bits 6:2) 
  // clock threshold selection for clkdetect [4]=1: enable auto calibration of offset [3:0]: when [4] is 0; [3:0] set the offset from -30m to 30mV
  #define BIT_MSK__CLKDET_CTL_OVR__REG_RX_CLKDETECT_CTL                                  0x7C

// ESD Protection Select Register
#define REG_ADDR__ESD_PROT_SEL_HWSW                                      (ANAPHY_RXDPLL | 0x000A)
  // (ReadWrite, Bits 0) 
  // select whether ESD protection is controlled by HW or SW 0 = HW controlled (default) 1 = SW controlled
  #define BIT_MSK__ESD_PROT_SEL_HWSW__REG_RX_AUTO_ESD                                       0x01

// TMDSRX Control #2 Register
#define REG_ADDR__TMDSRX_CTRL2                                           (ANAPHY_RXDPLL | 0x000B)
  // (ReadWrite, Bits 0) 
  // 0- normal mode for 6 Gbps 1- power saving mode for low datarate on equalizer
  #define BIT_MSK__TMDSRX_CTRL2__REG_RX_PMODE                                          0x01
  // (ReadWrite, Bits 1) 
  // control AVCC10_esally power switch; 1v power switch on/off control; 0: turn on; 1.8v turnoff; 
  #define BIT_MSK__TMDSRX_CTRL2__REG_PSW_B_H                                           0x02
  // (ReadWrite, Bits 2) 
  // for test equalizer, not used now.  0: normal mode  1: disable Eq common mode bias network
  #define BIT_MSK__TMDSRX_CTRL2__REG_EQ_RESETB                                         0x04
  // (ReadWrite, Bits 4:3) 
  // cpath common mode voltage control
  #define BIT_MSK__TMDSRX_CTRL2__REG_CTL_COM                                           0x18
  // (ReadWrite, Bits 6:5) 
  // cpath threshold control
  #define BIT_MSK__TMDSRX_CTRL2__REG_CTL_THRES                                         0x60

// TMDSRX Control #3 Register
#define REG_ADDR__TMDSRX_CTRL3                                           (ANAPHY_RXDPLL | 0x000C)
  // (ReadWrite, Bits 5:0) 
  // reserved
  #define BIT_MSK__TMDSRX_CTRL3__REG_RX_CFG                                            0x3F

// TMDSRX Control #4 Register
#define REG_ADDR__TMDSRX_CTRL4                                           (ANAPHY_RXDPLL | 0x000D)
  // (ReadWrite, Bits 7:0) 
  // Reserve for future use
  #define BIT_MSK__TMDSRX_CTRL4__REG_RX_PLL_CFG_B7_B0                                  0xFF

// TMDSRX Control #5 Register
#define REG_ADDR__TMDSRX_CTRL5                                           (ANAPHY_RXDPLL | 0x000E)
  // (ReadWrite, Bits 1:0) 
  // Reserve for future use
  #define BIT_MSK__TMDSRX_CTRL5__REG_RX_PLL_CFG_B9_B8                                  0x03

// TMDSRX Pre divider Control Register
#define REG_ADDR__TMDSRX_PRE_DIV_CTL                                     (ANAPHY_RXDPLL | 0x000F)
  // (ReadWrite, Bits 0) 
  // register overwrite control of pre_div_ctl of esally. If 0: rxzone_pre_div from zone controller if 1: from reg_rxzone_div_pre
  #define BIT_MSK__TMDSRX_PRE_DIV_CTL__REG_RXZONE_DIV_PRE_OVR                                0x01
  // (ReadWrite, Bits 5:1) 
  // Bit 0 should be 1'b1. If bit 0 is 0, then value from zonevco will be driven to the phy. 00000: prediv ratio=1 00001: prediv ratio=1 00010: prediv ratio=2 .. 11111: prediv ratio=31
  #define BIT_MSK__TMDSRX_PRE_DIV_CTL__REG_RXZONE_DIV_PRE                                    0x3E

// CoC Overwrite ctl #0 Register
#define REG_ADDR__COC_OVERWRITE_CTRL0                                    (ANAPHY_RXDPLL | 0x0010)
  // (ReadWrite, Bits 0) 
  // register overwrite for coc_vih_ctl enable
  #define BIT_MSK__COC_OVERWRITE_CTRL0__REG_COC_VIH_CTL_OVR                                   0x01
  // (ReadWrite, Bits 7:1) 
  // register overwrite value for coc_vih_ctl for sampler. This is valid if 0 bit is 1'b1, else coc_vih_ctl of samler is driven from coc_dig_src logic.
  #define BIT_MSK__COC_OVERWRITE_CTRL0__REG_COC_VIH_CTL_OVR_VAL                               0xFE

// CoC Overwrite ctl #1 Register
#define REG_ADDR__COC_OVERWRITE_CTRL1                                    (ANAPHY_RXDPLL | 0x0011)
  // (ReadWrite, Bits 0) 
  // register overwrite for coc_vil_ctl enable
  #define BIT_MSK__COC_OVERWRITE_CTRL1__REG_COC_VIL_CTL_OVR                                   0x01
  // (ReadWrite, Bits 7:1) 
  // register overwrite value for coc_vil_ctl for sampler. This is valid if 0 bit is 1'b1, else coc_vil_ctl of samler is driven from coc_dig_src logic.
  #define BIT_MSK__COC_OVERWRITE_CTRL1__REG_COC_VIL_CTL_OVR_VAL                               0xFE

// CoC Overwrite ctl #2 Register
#define REG_ADDR__COC_OVERWRITE_CTRL2                                    (ANAPHY_RXDPLL | 0x0012)
  // (ReadWrite, Bits 0) 
  // register overwrite for coc_cap_ctl enable
  #define BIT_MSK__COC_OVERWRITE_CTRL2__REG_COC_CAP_CTL_OVR                                   0x01
  // (ReadWrite, Bits 4:1) 
  // register overwrite value for coc_cap_ctl. This is valid if 0 bit is 1'b1.
  #define BIT_MSK__COC_OVERWRITE_CTRL2__REG_COC_CAP_CTL_OVR_VAL                               0x1E

// CoC Overwrite ctl #3 Register
#define REG_ADDR__COC_OVERWRITE_CTRL3                                    (ANAPHY_RXDPLL | 0x0013)
  // (ReadWrite, Bits 0) 
  // register overwrite for coc_res_ctl enable
  #define BIT_MSK__COC_OVERWRITE_CTRL3__REG_COC_RES_CTL_OVR                                   0x01
  // (ReadWrite, Bits 4:1) 
  // register overwrite value for coc_res_ctl. This is valid, if 0 bit is 1'b1.
  #define BIT_MSK__COC_OVERWRITE_CTRL3__REG_COC_RES_CTL_OVR_VAL                               0x1E

// CBUS Debug Control Register
#define REG_ADDR__CBUS_DEBUG_CTRL                                        (ANAPHY_RXDPLL | 0x0018)
  // (ReadWrite, Bits 3:0) 
  // SW CBUS FSM state to compare against the CBUS digital state and decide the CBUS HIGH to LOW transition
  #define BIT_MSK__CBUS_DEBUG_CTRL__REG_SW_CBUS_STATE                                     0x0F
  // (ReadWrite, Bits 4) 
  // Enable to use software CBUS state in CBUS_DEBUG_CTRL[3:0]
  #define BIT_MSK__CBUS_DEBUG_CTRL__REG_USE_SW_CBUS_STATE                                 0x10

// MHL Top Ctl Register
#define REG_ADDR__MHL_TOP_CTL                                            (ANAPHY_RXDPLL | 0x0020)
  // (ReadWrite, Bits 1:0) 
  // interface data latching timing through I2C 2'b00 normal clock (default) 2'b01 Early clock increase setup margin 2'b10 Late clock; increase hold margin 2'b11 Interted clock 
  #define BIT_MSK__MHL_TOP_CTL__REG_IF_TIMING_CTL                                     0x03
  // (ReadWrite, Bits 2) 
  // TODO
  #define BIT_MSK__MHL_TOP_CTL__REG_M3AV_EN                                           0x04
  // (ReadWrite, Bits 3) 
  // driver output enable signal for channel 2
  #define BIT_MSK__MHL_TOP_CTL__REG_DP2_OE                                            0x08
  // (ReadWrite, Bits 4) 
  // HDMI mode enable for Harry PHY
  #define BIT_MSK__MHL_TOP_CTL__REG_HDMI_EN                                           0x10
  // (ReadWrite, Bits 5) 
  // MHL 3 in CE mode select
  #define BIT_MSK__MHL_TOP_CTL__REG_MHL3CE_SEL                                        0x20
  // (ReadWrite, Bits 6) 
  // Valid only in MHL2 mode - Normal mode or PackedPixel mode selection 1'b0 Normal mode 1'b1 PackedPixel mode
  #define BIT_MSK__MHL_TOP_CTL__REG_MHL_PP_SEL                                        0x40
  // (ReadWrite, Bits 7) 
  // calibration path enable
  #define BIT_MSK__MHL_TOP_CTL__REG_COC_CAL_EN                                        0x80

// MHL DataPath 1st Ctl Register
#define REG_ADDR__MHL_DP_CTL0                                            (ANAPHY_RXDPLL | 0x0021)
  // (ReadWrite, Bits 5:0) 
  // controls driver in MHL mode only : previous 6'b000000  tx driver output disable mode 6b'111100   legacy MHL mode and PP mode 6b'110011   MHL3CE or PLL test mode 6b'110000  MHL3_mobile mode update logic for banner: 6'b000000  MHL tx driver output disable mode 6b'x00110   legacy MHL mode and PP mode 6b'x11000   flip option for legacy MHL 6b'x00001   MHL3CE or PLL test mode 6b'x00100  MHL3_mobile mode 6b'x10000  flip option MHL3 mobile mode 6b'x10101  hdmi mode
  #define BIT_MSK__MHL_DP_CTL0__REG_TX_OE                                             0x3F
  // (ReadWrite, Bits 6) 
  // Tx output configuration override. 1: Tx output config will be bit [5:0] 0: Tx output config will be 6'b110011 if DoC is enabled and active. Otherwise if HDCP2x is not selected; it will be controlled by HDCP1.x state machine and if HDCP2x is selected; it will b bit [5:0]
  #define BIT_MSK__MHL_DP_CTL0__REG_TX_OE_OVR                                         0x40
  // (ReadWrite, Bits 7) 
  // driver output enable signal
  #define BIT_MSK__MHL_DP_CTL0__REG_DP_OE                                             0x80

// MHL DataPath 2nd Ctl Register
#define REG_ADDR__MHL_DP_CTL1                                            (ANAPHY_RXDPLL | 0x0022)
  // (ReadWrite, Bits 3:0) 
  // data swing control bit
  #define BIT_MSK__MHL_DP_CTL1__REG_DT_SWING_CTL                                      0x0F

// MHL DataPath 3rd Ctl Register
#define REG_ADDR__MHL_DP_CTL2                                            (ANAPHY_RXDPLL | 0x0023)
  // (ReadWrite, Bits 1:0) 
  // driver data channel terminal selection signal 2b'00 open 2b'01 300 ohm 2b'10 150 ohm 2b'11 100 ohm (default)
  #define BIT_MSK__MHL_DP_CTL2__REG_DT_TERM_SEL                                       0x03
  // (ReadWrite, Bits 3:2) 
  // driver clock channel terminal selection signal 2b'00 open 2b'01 300 ohm 2b'10 150 ohm 2b'11 100 ohm (default)
  #define BIT_MSK__MHL_DP_CTL2__REG_CK_TERM_SEL                                       0x0C
  // (ReadWrite, Bits 5:4) 
  // Legacy MHL mode  common mode damping clock termintaion selection 2b'00 open 2b'01 400 ohm 2b'10 200 ohm (default) 2b'11 133 ohm
  #define BIT_MSK__MHL_DP_CTL2__REG_DAMP_TERM_SEL                                     0x30
  // (ReadWrite, Bits 6) 
  // driver output enable signal for clock channel
  #define BIT_MSK__MHL_DP_CTL2__REG_CK_OE                                             0x40
  // (ReadWrite, Bits 7) 
  // Clock bypass enable signal for pixel clock bypass from rx.  After enabled; the pixel clock from eTMDS will be sent out on Tx.
  #define BIT_MSK__MHL_DP_CTL2__REG_CLK_BYPASS_EN                                     0x80

// MHL DataPath 4th Ctl Register
#define REG_ADDR__MHL_DP_CTL3                                            (ANAPHY_RXDPLL | 0x0024)
  // (ReadWrite, Bits 3:0) 
  // bias vdsat control signal for data driver
  #define BIT_MSK__MHL_DP_CTL3__REG_DT_DRV_VNB_CTL                                    0x0F
  // (ReadWrite, Bits 7:4) 
  // bias vdsat control signal for cascade transistor for data driver
  #define BIT_MSK__MHL_DP_CTL3__REG_DT_DRV_VNBC_CTL                                   0xF0

// MHL DataPath 5th Ctl Register
#define REG_ADDR__MHL_DP_CTL4                                            (ANAPHY_RXDPLL | 0x0025)
  // (ReadWrite, Bits 3:0) 
  // bias vdsat control signal for clock driver
  #define BIT_MSK__MHL_DP_CTL4__REG_CK_DRV_VNB_CTL                                    0x0F
  // (ReadWrite, Bits 7:4) 
  // bias vdsat control signal for cascade transistor for clock driver
  #define BIT_MSK__MHL_DP_CTL4__REG_CK_DRV_VNBC_CTL                                   0xF0

// MHL DataPath 6th Ctl Register
#define REG_ADDR__MHL_DP_CTL5                                            (ANAPHY_RXDPLL | 0x0026)
  // (ReadWrite, Bits 1:0) 
  // fine tunning for data term resistor
  #define BIT_MSK__MHL_DP_CTL5__REG_DT_TERM_VGS_CTL                                   0x03
  // (ReadWrite, Bits 3:2) 
  // fine tunning for doc path term resistor
  #define BIT_MSK__MHL_DP_CTL5__REG_CK_TERM_VGS_CTL                                   0x0C
  // (ReadWrite, Bits 5:4) 
  // fine tunning for damping resistor
  #define BIT_MSK__MHL_DP_CTL5__REG_DAMP_TERM_VGS_CTL                                 0x30
  // (ReadWrite, Bits 6) 
  // rx sense enable signal of tx_phy
  #define BIT_MSK__MHL_DP_CTL5__REG_RSEN_EN                                           0x40
  // (ReadWrite, Bits 7) 
  // When it is disable; allows MHL Tx discovery state machine to control RSEN detection automatically; When it is enabled; bit 6 will control RSEN detection
  #define BIT_MSK__MHL_DP_CTL5__REG_RSEN_EN_OVR                                       0x80

// MHL PLL 1st Ctl Register
#define REG_ADDR__MHL_PLL_CTL0                                           (ANAPHY_RXDPLL | 0x0027)
  // (ReadWrite, Bits 0) 
  // control signal to choose oe signal 1'b0 oe signal from I2C 1'b1 oeandlocked signal
  #define BIT_MSK__MHL_PLL_CTL0__REG_ZONE_MASK_OE                                      0x01
  // (ReadWrite, Bits 1) 
  // Select the input clock from crystal for MHL3_CE or MHL3_mobile.  select pll reference clock :                         1'b0 pxl clock                         1'b1 crystal clcok
  #define BIT_MSK__MHL_PLL_CTL0__REG_CRYSTAL_CLK_SEL                                   0x02
  // (ReadWrite, Bits 3:2) 
  // Select frequency ratio betweeen hdmi_clk and pxl_clk 2'b00 0.5x mode; hdmi_clk_freq = 0.5*pxl_clk_freq 2'b01 1x mode; hdmi_clk_freq = 1*pxl_clk_freq (default) 2'b10 2x mode; hdmi_clk_freq = 2*pxl_clk_freq 2'b11 4x mode; hdmi_clk_freq = 4*pxl_clk_freq
  #define BIT_MSK__MHL_PLL_CTL0__REG_HDMI_CLK_RATIO                                    0x0C
  // (ReadWrite, Bits 6:4) 
  // Select frequency ratio between aud_clk and hdmi_clk 3'b000  aud_clk_freq = 5/1 hdmi_clk_freq 3'b001  aud_clk_freq = 5/2 hdmi_clk_freq 3'b010  aud_clk_freq = 5/3 hdmi_clk_freq 3'b011  aud_clk_freq = 5/5 hdmi_clk_freq 3'b100  aud_clk_freq = 5/2 hdmi_clk_freq 3'b101  aud_clk_freq = 5/4 hdmi_clk_freq 3'b110  aud_clk_freq = 5/6 hdmi_clk_freq 3'b111  aud_clk_freq = 5/10 hdmi_clk_freq
  #define BIT_MSK__MHL_PLL_CTL0__REG_AUD_CLK_RATIO                                     0x70
  // (ReadWrite, Bits 7) 
  // enable audio clock generation
  #define BIT_MSK__MHL_PLL_CTL0__REG_AUD_CLK_EN                                        0x80

// MHL PLL 2nd Ctl Register
#define REG_ADDR__MHL_PLL_CTL1                                           (ANAPHY_RXDPLL | 0x0028)
  // (ReadWrite, Bits 3:0) 
  // control PLL BW through I2C
  #define BIT_MSK__MHL_PLL_CTL1__REG_PLL_BW_CTL                                        0x0F
  // (ReadWrite, Bits 7:4) 
  // 4 bit open loop fvco control signal 
  #define BIT_MSK__MHL_PLL_CTL1__REG_FVCO_CTL                                          0xF0

// MHL PLL 3rd Ctl Register
#define REG_ADDR__MHL_PLL_CTL2                                           (ANAPHY_RXDPLL | 0x0029)
  // (ReadWrite, Bits 1:0) 
  // PLL loop filter R/C select signal
  #define BIT_MSK__MHL_PLL_CTL2__REG_PLL_LF_SEL                                        0x03
  // (ReadWrite, Bits 2) 
  // control bit for PLL fast lock enable
  #define BIT_MSK__MHL_PLL_CTL2__REG_PLL_FAST_LOCK                                     0x04
  // (ReadWrite, Bits 3) 
  // measure enable signal for zone control; when enable;  pll is in open loop
  #define BIT_MSK__MHL_PLL_CTL2__REG_MEAS_FVCO                                         0x08
  // (ReadWrite, Bits 7) 
  // clock detect enable signal
  #define BIT_MSK__MHL_PLL_CTL2__REG_CLKDETECT_EN                                      0x80

// MHL BIAS 1st Ctl Register
#define REG_ADDR__MHL_BIAS_CTL0                                          (ANAPHY_RXDPLL | 0x002A)
  // (ReadWrite, Bits 3:0) 
  // bgr output reference voltage control
  #define BIT_MSK__MHL_BIAS_CTL0__REG_BGR_CTL                                           0x0F
  // (ReadWrite, Bits 6:4) 
  // bias swing control signal (in harvey it is fixed setting)
  #define BIT_MSK__MHL_BIAS_CTL0__REG_BIAS_SW_CTL                                       0x70
  // (ReadWrite, Bits 7) 
  // bias select between bgr and resistor divider 1'b0 resistor divider 1'b1 BGR
  #define BIT_MSK__MHL_BIAS_CTL0__REG_BIAS_SEL                                          0x80

// MHL BIAS 2nd Ctl Register
#define REG_ADDR__MHL_BIAS_CTL1                                          (ANAPHY_RXDPLL | 0x002B)
  // (ReadWrite, Bits 3:0) 
  // internal resistor control bit
  #define BIT_MSK__MHL_BIAS_CTL1__REG_RSWING_CTL                                        0x0F
  // (ReadWrite, Bits 5:4) 
  // driver data channel terminal selection signal for channel 1 2b'00 open 2b'01 300 ohm 2b'10 150 ohm 2b'11 100 ohm (default)
  #define BIT_MSK__MHL_BIAS_CTL1__REG_DT1_TERM_SEL                                      0x30
  // (ReadWrite, Bits 7:6) 
  // driver data channel terminal selection signal for channel 2 2b'00 open 2b'01 300 ohm 2b'10 150 ohm 2b'11 100 ohm (default)
  #define BIT_MSK__MHL_BIAS_CTL1__REG_DT2_TERM_SEL                                      0xC0

// MHL BIAS 3rd Ctl Register
#define REG_ADDR__MHL_BIAS_CTL2                                          (ANAPHY_RXDPLL | 0x002C)
  // (ReadWrite, Bits 2:0) 
  // current select between BGR and PTAT (3 10uA bgr; and 3 10uA PTAT; each is 10uA) 3'b000 betaM;3 PTAT 3'b001 2PTAT+1BGR 3'b011 1PTAT+2BGR 3'b111 3 BGR
  #define BIT_MSK__MHL_BIAS_CTL2__REG_IBIAS_SEL                                         0x07
  // (ReadWrite, Bits 4:3) 
  // control driver termination selection (reserved;not use?
  #define BIT_MSK__MHL_BIAS_CTL2__REG_BIAS_TERM_SEL                                     0x18

// MHL CBUS 1st Ctl Register
#define REG_ADDR__MHL_CBUS_CTL0                                          (ANAPHY_RXDPLL | 0x002D)
  // (ReadWrite, Bits 1:0) 
  // cbus driver strength selection 2'b00 weakest value 2'b01 weak value 2'b10 strong value (default) 2'b11 strongest value
  #define BIT_MSK__MHL_CBUS_CTL0__REG_CBUS_DRV_SEL                                      0x03
  // (ReadWrite, Bits 3:2) 
  // rgnd internal resistance control
  #define BIT_MSK__MHL_CBUS_CTL0__REG_CBUS_RES_TEST_SEL                                 0x0C
  // (ReadWrite, Bits 5:4) 
  // control Rgnd measurement thresold through I2C     VIH   VIL   vbias 00: 625   426   734 01: 596   447   747 10: 701   478   740 11: 672   506   754
  #define BIT_MSK__MHL_CBUS_CTL0__REG_CBUS_RGND_VTH_CTL                                 0x30
  // (ReadWrite, Bits 7) 
  // cbus rground measurement testmode
  #define BIT_MSK__MHL_CBUS_CTL0__REG_CBUS_RGND_TEST_MODE                               0x80

// MHL CBUS 2nd Ctl Register
#define REG_ADDR__MHL_CBUS_CTL1                                          (ANAPHY_RXDPLL | 0x002E)
  // (ReadWrite, Bits 2:0) 
  // control Rgnd measurement resistance through I2C Rgnd resistance calibration (rough value for 1K reference), 000: 888 ohm; 100: 1115 ohm (default,tt) 111: 1378 ohm 
  #define BIT_MSK__MHL_CBUS_CTL1__REG_CBUS_RGND_RES_CTL                                 0x07

// MHL CBUS1  Ctl Sts Register
#define REG_ADDR__MHL_CBUS1_CTL_STS                                      (ANAPHY_RXDPLL | 0x002F)
  // (ReadWrite, Bits 0) 
  // control cbus1 in output/input mode for usb3  flip mode. This is software overwrite value. This is valid, when 16'h4068[1] is 1'b1.
  #define BIT_MSK__MHL_CBUS1_CTL_STS__REG_CBUS1_OE                                          0x01
  // (ReadWrite, Bits 1) 
  // Enable CBUS1 to ground resistance measurement ( Typec flip mode) of tx_phy. This is overwrite value. If 0x4068[1] is 1'b1, then it is valid.
  #define BIT_MSK__MHL_CBUS1_CTL_STS__REG_CBUS1_MEAS_RGND_EN                                0x02
  // (ReadOnly, Bits 2) 
  // data from cbus1 pad of tx_phy to digital core for usb3 flip mode status
  #define BIT_MSK__MHL_CBUS1_CTL_STS__REG_TX_CBUS1_C_STS                                    0x04
  // (ReadOnly, Bits 3) 
  // Flip mode: Flag indicating rgnd measurement done 1'b0 Measurement not done yet or disable 1'b1 Measurement done; rgnd[1:0] ready
  #define BIT_MSK__MHL_CBUS1_CTL_STS__REG_TX_CBUS1_RGND_DONE_STS                            0x08
  // (ReadOnly, Bits 5:4) 
  // Flip Mode: measured CBUS to gnd resistance 2'b00 Rgnd ]] 2k or meas_rgnd_en ==1'b0 2'b01 Rgnd ~  2k 2'b10 Rgnd ~  1k 2'b11 Rgnd [[ 1k 
  #define BIT_MSK__MHL_CBUS1_CTL_STS__REG_TX_CBUS1_RGND_STS                                 0x30
  // (ReadOnly, Bits 6) 
  // hpd output (flip mode)
  #define BIT_MSK__MHL_CBUS1_CTL_STS__REG_TX_CBUS1_HPD_DET_STS                              0x40

// MHL CoC 1st Ctl Register
#define REG_ADDR__MHL_COC_CTL0                                           (ANAPHY_RXDPLL | 0x0030)
  // (ReadWrite, Bits 2:0) 
  // coc termination control
  #define BIT_MSK__MHL_COC_CTL0__REG_COC_TERM_CTL                                      0x07
  // (ReadWrite, Bits 3) 
  // coc analog echo cancellation enable 1: enable analog echo cancellation 0: disable analog echo cancellation(use digital echo cancellation(default)
  #define BIT_MSK__MHL_COC_CTL0__REG_COC_AECHO_EN                                      0x08
  // (ReadWrite, Bits 6:4) 
  // coc bias control
  #define BIT_MSK__MHL_COC_CTL0__REG_COC_BIAS_CTL                                      0x70
  // (ReadWrite, Bits 7) 
  // enbale signal for coc bias
  #define BIT_MSK__MHL_COC_CTL0__REG_COC_BIAS_EN                                       0x80

// MHL CoC 2nd Ctl Register
#define REG_ADDR__MHL_COC_CTL1                                           (ANAPHY_RXDPLL | 0x0031)
  // (ReadWrite, Bits 5:0) 
  // coc driver strength control
  #define BIT_MSK__MHL_COC_CTL1__REG_COC_DRV_CTL                                       0x3F
  // (ReadWrite, Bits 6) 
  // Not used
  #define BIT_MSK__MHL_COC_CTL1__REG_COC_OE                                            0x40
  // (ReadWrite, Bits 7) 
  // enbale signal for coc block
  #define BIT_MSK__MHL_COC_CTL1__REG_COC_EN                                            0x80

// MHL CoC 5th Ctl Register
#define REG_ADDR__MHL_COC_CTL4                                           (ANAPHY_RXDPLL | 0x0032)
  // (ReadWrite, Bits 3:0) 
  // coc driver slew rate control signal
  #define BIT_MSK__MHL_COC_CTL4__REG_COC_SLEW_CTL                                      0x0F
  // (ReadWrite, Bits 7:4) 
  // coc interface timing control signal
  #define BIT_MSK__MHL_COC_CTL4__REG_COC_IF_CTL                                        0xF0

// MHL CoC 6th Ctl Register
#define REG_ADDR__MHL_COC_CTL5                                           (ANAPHY_RXDPLL | 0x0033)
  // (ReadWrite, Bits 7:0) 
  // 2 byte researved pI coc_rsvd[4]:  (ctl_clamp) 0(O_100mV = 50mV)1 (O_100mV = 100mV); coc_rsvd[3]: (clamp_sel) 0( bypass)), 1(select); coc_rsvd[2:1]: (leak_ctrl) ; coc_rsvd[0]: (en)  0 (disable clamp) 1(enable clamp)
  #define BIT_MSK__MHL_COC_CTL5__REG_COC_RSV_B7_B0                                     0xFF

// MHL CoC 7th Ctl Register
#define REG_ADDR__MHL_COC_CTL6                                           (ANAPHY_RXDPLL | 0x0034)
  // (ReadWrite, Bits 7:0) 
  // 2 byte researved pI coc_rsvd[4]:  (ctl_clamp) 0(O_100mV = 50mV)1 (O_100mV = 100mV); coc_rsvd[3]: (clamp_sel) 0( bypass)), 1(select); coc_rsvd[2:1]: (leak_ctrl) ; coc_rsvd[0]: (en)  0 (disable clamp) 1(enable clamp)
  #define BIT_MSK__MHL_COC_CTL6__REG_COC_RSV_B15_B8                                    0xFF

// MHL Misc 2nd Ctl Register
#define REG_ADDR__MHL_MISC_CTL1                                          (ANAPHY_RXDPLL | 0x0035)
  // (ReadWrite, Bits 7:0) 
  // changed before tapeout reseaved signal of tx :[15:12] [11:6]   d2d1_tdm_drv_ctl [5:0]  ck_tdm_drv_ctl
  #define BIT_MSK__MHL_MISC_CTL1__REG_RSV_B7_B0                                         0xFF

// MHL Misc 3rd Ctl Register
#define REG_ADDR__MHL_MISC_CTL2                                          (ANAPHY_RXDPLL | 0x0036)
  // (ReadWrite, Bits 7:0) 
  // changed before tapeout reseaved signal :[15:12] [11:6]   d2d1_tdm_drv_ctl [5:0]  ck_tdm_drv_ctl
  #define BIT_MSK__MHL_MISC_CTL2__REG_RSV_B15_B8                                        0xFF

// TMDS Control 2 Register
#define REG_ADDR__TMDS_CTRL2                                             (ANAPHY_RXDPLL | 0x0037)
  // (ReadWrite, Bits 3:0) 
  // Driver reference pre-drive control
  #define BIT_MSK__TMDS_CTRL2__REG_DT_PREDRV_RFT_CTL                                 0x0F
  // (ReadWrite, Bits 4) 
  // power switch enable signal for etmds
  #define BIT_MSK__TMDS_CTRL2__REG_PWRON_ETMDS                                       0x10
  // (ReadWrite, Bits 5) 
  // power switch enable signal for hsic
  #define BIT_MSK__TMDS_CTRL2__REG_PWRON_HSIC                                        0x20
  // (ReadWrite, Bits 6) 
  // datapath poweron 0 - power off 1 - power on
  #define BIT_MSK__TMDS_CTRL2__REG_PWRON_DP                                          0x40
  // (ReadWrite, Bits 7) 
  // power switch enable signal for PLL
  #define BIT_MSK__TMDS_CTRL2__REG_PWRON_PLL                                         0x80

// DP Cntrl Register
#define REG_ADDR__DP_CTRL                                                (ANAPHY_RXDPLL | 0x0038)
  // (ReadWrite, Bits 0) 
  // 
  #define BIT_MSK__DP_CTRL__REG_DP_PRE_POST_SEL                                   0x01
  // (ReadWrite, Bits 1) 
  // 
  #define BIT_MSK__DP_CTRL__REG_DP_TAP1_EN                                        0x02
  // (ReadWrite, Bits 2) 
  // 
  #define BIT_MSK__DP_CTRL__REG_DP_TAP1_SGN                                       0x04
  // (ReadWrite, Bits 3) 
  // 
  #define BIT_MSK__DP_CTRL__REG_DP_TAP2_EN                                        0x08
  // (ReadWrite, Bits 4) 
  // 
  #define BIT_MSK__DP_CTRL__REG_DP_TAP2_SGN                                       0x10
  // (ReadWrite, Bits 5) 
  // 
  #define BIT_MSK__DP_CTRL__REG_DT_PREDIV_FEEDCAP_EN                              0x20

// DP cntrl1 Register
#define REG_ADDR__DP_CTRL1                                               (ANAPHY_RXDPLL | 0x0039)
  // (ReadWrite, Bits 3:0) 
  // coc driver slew rate control signal
  #define BIT_MSK__DP_CTRL1__REG_DT_DRV_IREF_CTL                                   0x0F
  // (ReadWrite, Bits 7:4) 
  // coc interface timing control signal
  #define BIT_MSK__DP_CTRL1__REG_DT_DRV_TAP1_CTL                                   0xF0

// DP cntrl2 Register
#define REG_ADDR__DP_CTRL2                                               (ANAPHY_RXDPLL | 0x003A)
  // (ReadWrite, Bits 3:0) 
  // 
  #define BIT_MSK__DP_CTRL2__REG_DT_DRV_TAP2_CTL                                   0x0F
  // (ReadWrite, Bits 7:4) 
  // 
  #define BIT_MSK__DP_CTRL2__REG_DT_DRV_VBIAS_CASCTL                               0xF0

// DP cntrl3 Register
#define REG_ADDR__DP_CTRL3                                               (ANAPHY_RXDPLL | 0x003B)
  // (ReadWrite, Bits 3:0) 
  // 
  #define BIT_MSK__DP_CTRL3__REG_DT_DRV_LOWPWR                                     0x0F

// OSC Control  Register
#define REG_ADDR__OSC_CTRL                                               (ANAPHY_RXDPLL | 0x003C)
  // (ReadWrite, Bits 3:0) 
  // regiser overwrite value for reg_osc_ctl of tx_phy.  This is valid if 0x00A0[7] is 1'b1. Desription of reg_osc_ctl port in IO description is osc speed control signal, digital need calibration.
  #define BIT_MSK__OSC_CTRL__REG_OSC_CTL                                           0x0F
  // (ReadWrite, Bits 4) 
  // osc enable signal
  #define BIT_MSK__OSC_CTRL__REG_OSC_EN                                            0x10

// TEST MODE Control  Register
#define REG_ADDR__TEST_MODE_CTRL                                         (ANAPHY_RXDPLL | 0x003D)
  // (ReadWrite, Bits 2:0) 
  // test mode control signal of tx_phy 3b'001 clk_bypass enable 3b'110 bgrtest (reserved)
  #define BIT_MSK__TEST_MODE_CTRL__REG_TX_TEST_MODE                                      0x07

// COC Control  Register
#define REG_ADDR__COC_CTRL                                               (ANAPHY_RXDPLL | 0x003E)
  // (ReadWrite, Bits 3:0) 
  // coc gain control
  #define BIT_MSK__COC_CTRL__REG_COC_GAIN_CTL                                      0x0F
  // (ReadWrite, Bits 4) 
  // 
  #define BIT_MSK__COC_CTRL__REG_CTS_TCK_PHASE                                     0x10

// DOC IF Register
#define REG_ADDR__DOC_IF                                                 (ANAPHY_RXDPLL | 0x003F)
  // (ReadWrite, Bits 7:0) 
  // doc interface timing control (Not used for [7:4]): [3] choose the sampler clock for 10-b retiming clock generation: 0: mck[1] (default); 1: mck[0]. [2]: choose input clock for token syncrhonization: 0: tck[1] (default); 1: tck[0]. [1]: Invert tck[1:0] clock input. [0] Invert bcki clock input.
  #define BIT_MSK__DOC_IF__REG_DOC_IF                                            0xFF

// DOC BIAS Register
#define REG_ADDR__DOC_BIAS                                               (ANAPHY_RXDPLL | 0x0040)
  // (ReadWrite, Bits 7:0) 
  // doc bias level option control: [7:5] bias current control in adder bias: 000: default; 100: + gain; 011: - gain. [4] bias reference source selection in adder bias: 0: use constant Gm reference; 1: resistor divider reference. [3:0]  resistance compensation in voltage reference generator: 0000: +20%; 0001: +10%; 0011: default; 0111: -10%; 1111: -20%.
  #define BIT_MSK__DOC_BIAS__REG_DOC_BIAS                                          0xFF

// DOC RSV Register
#define REG_ADDR__DOC_RSV                                                (ANAPHY_RXDPLL | 0x0041)
  // (ReadWrite, Bits 7:0) 
  // reserved control pins for doc (Not used for [5:4;2]): [7:6] AC-coupling termination voltage set: 00: 0.8*vdd; 01: 0.75*vdd (default); 10: 0.72*vdd; 11: 0.67*vdd.  [3]: adder gain control by load resistance change: 0: default; 1: lower gain. [1:0] adder gain control by source degeneration: 00: max gain; 10: default; 11: min gain.
  #define BIT_MSK__DOC_RSV__REG_DOC_RSV                                           0xFF

// DOC CTRL #1 Register
#define REG_ADDR__DOC_CTRL_1                                             (ANAPHY_RXDPLL | 0x0042)
  // (ReadWrite, Bits 0) 
  // doc rx bias enable signal: 1: Enable AC termination; bias; reference; and differential adder.
  #define BIT_MSK__DOC_CTRL_1__REG_DOC_RXBIAS_EN                                     0x01
  // (ReadWrite, Bits 1) 
  // doc data enable signal in source DOC rx part: 1: Enable sampler and 10-b retimer.
  #define BIT_MSK__DOC_CTRL_1__REG_DOC_RXDATA_EN                                     0x02
  // (ReadWrite, Bits 3:2) 
  // doc operation/ test mode control (Not used)
  #define BIT_MSK__DOC_CTRL_1__REG_DOC_OPMODE                                        0x0C
  // (ReadWrite, Bits 6:4) 
  // dummy driver source resistance control
  #define BIT_MSK__DOC_CTRL_1__REG_DOC_DM_TERM                                       0x70

// DOC CTRL #2 Register
#define REG_ADDR__DOC_CTRL_2                                             (ANAPHY_RXDPLL | 0x0043)
  // (ReadWrite, Bits 3:0) 
  // dummy driver fixed current source control by I2C
  #define BIT_MSK__DOC_CTRL_2__REG_DOC_DM_SWING_I2C                                  0x0F
  // (ReadWrite, Bits 5:4) 
  // DOC dummy driver termination fine control
  #define BIT_MSK__DOC_CTRL_2__REG_DOC_DM_TERM_VGS                                   0x30

// HARRY EN CTRL  Register
#define REG_ADDR__HARRY_EN_CTRL                                          (ANAPHY_RXDPLL | 0x0044)
  // (ReadWrite, Bits 0) 
  // 
  #define BIT_MSK__HARRY_EN_CTRL__REG_TX_EN_BY_SCDT                                     0x01
  // (ReadWrite, Bits 1) 
  // conventional en signal for whole TX PHY.  By default, port tx_en of tx_phy is controlled fron this register bit. If 16'h4044[0] is 1'b1(HARRY_EN_CTRL), value comes from DPLL CORE
  #define BIT_MSK__HARRY_EN_CTRL__REG_TMDS_OE                                           0x02
  // (ReadWrite, Bits 7) 
  // Setting this will enable Harry irrespective of TX connection and any other conditions 0 : Normal conditions will be effective to enable Harry 1 : Overrides the above conditions and enables Harry
  #define BIT_MSK__HARRY_EN_CTRL__REG_HARRY_SW_EN                                       0x80

// D0 Tap1 Control Register
#define REG_ADDR__D0_TAP1_CTL                                            (ANAPHY_RXDPLL | 0x0045)
  // (ReadWrite, Bits 7:0) 
  // pre-emphasis strength control for D0 channel
  #define BIT_MSK__D0_TAP1_CTL__REG_D0_TAP1_CTL                                       0xFF

// D1 Tap1 Control Register
#define REG_ADDR__D1_TAP1_CTL                                            (ANAPHY_RXDPLL | 0x0046)
  // (ReadWrite, Bits 7:0) 
  // pre-emphasis strength control for D1 channel
  #define BIT_MSK__D1_TAP1_CTL__REG_D1_TAP1_CTL                                       0xFF

// D2 Tap1 Control Register
#define REG_ADDR__D2_TAP1_CTL                                            (ANAPHY_RXDPLL | 0x0047)
  // (ReadWrite, Bits 7:0) 
  // pre-emphasis strength control for D2 channel
  #define BIT_MSK__D2_TAP1_CTL__REG_D2_TAP1_CTL                                       0xFF

// CK Tap1 Control Register
#define REG_ADDR__CK_TAP1_CTL                                            (ANAPHY_RXDPLL | 0x0048)
  // (ReadWrite, Bits 7:0) 
  // pre-emphasis strength control for CK channel
  #define BIT_MSK__CK_TAP1_CTL__REG_CK_TAP1_CTL                                       0xFF

// D0 Swing Control Register
#define REG_ADDR__D0_SWING_CTL                                           (ANAPHY_RXDPLL | 0x0049)
  // (ReadWrite, Bits 7:0) 
  // D0 channel data swing control bit 
  #define BIT_MSK__D0_SWING_CTL__REG_D0_SWING_CTL                                      0xFF

// D1 Swing Control Register
#define REG_ADDR__D1_SWING_CTL                                           (ANAPHY_RXDPLL | 0x004A)
  // (ReadWrite, Bits 7:0) 
  // D1 channel data swing control bit 
  #define BIT_MSK__D1_SWING_CTL__REG_D1_SWING_CTL                                      0xFF

// D2 Swing Control Register
#define REG_ADDR__D2_SWING_CTL                                           (ANAPHY_RXDPLL | 0x004B)
  // (ReadWrite, Bits 7:0) 
  // D2 channel data swing control bit 
  #define BIT_MSK__D2_SWING_CTL__REG_D2_SWING_CTL                                      0xFF

// D0 Mismatch Control Register
#define REG_ADDR__D0_MISMATCH_CTL                                        (ANAPHY_RXDPLL | 0x004C)
  // (ReadWrite, Bits 3:0) 
  // D0 channel intra-pair skew compensation for PLUS output
  #define BIT_MSK__D0_MISMATCH_CTL__REG_D0_MISMATCH_D                                     0x0F
  // (ReadWrite, Bits 7:4) 
  // D0 channel intra-pair skew compensation for MINUS output
  #define BIT_MSK__D0_MISMATCH_CTL__REG_D0_MISMATCH_DB                                    0xF0

// D1 Mismatch Control Register
#define REG_ADDR__D1_MISMATCH_CTL                                        (ANAPHY_RXDPLL | 0x004D)
  // (ReadWrite, Bits 3:0) 
  // D1 channel intra-pair skew compensation for PLUS output
  #define BIT_MSK__D1_MISMATCH_CTL__REG_D1_MISMATCH_D                                     0x0F
  // (ReadWrite, Bits 7:4) 
  // D1 channel intra-pair skew compensation for MINUS output
  #define BIT_MSK__D1_MISMATCH_CTL__REG_D1_MISMATCH_DB                                    0xF0

// D2 Mismatch Control Register
#define REG_ADDR__D2_MISMATCH_CTL                                        (ANAPHY_RXDPLL | 0x004E)
  // (ReadWrite, Bits 3:0) 
  // D2 channel intra-pair skew compensation for PLUS output
  #define BIT_MSK__D2_MISMATCH_CTL__REG_D2_MISMATCH_D                                     0x0F
  // (ReadWrite, Bits 7:4) 
  // D2 channel intra-pair skew compensation for MINUS output
  #define BIT_MSK__D2_MISMATCH_CTL__REG_D2_MISMATCH_DB                                    0xF0

// CK Mismatch Control Register
#define REG_ADDR__CK_MISMATCH_CTL                                        (ANAPHY_RXDPLL | 0x004F)
  // (ReadWrite, Bits 3:0) 
  // CK channel intra-pair skew compensation for PLUS output
  #define BIT_MSK__CK_MISMATCH_CTL__REG_CK_MISMATCH_D                                     0x0F
  // (ReadWrite, Bits 7:4) 
  // CK channel intra-pair skew compensation for MINUS output
  #define BIT_MSK__CK_MISMATCH_CTL__REG_CK_MISMATCH_DB                                    0xF0

// D0D1 DRV IREF Control Register
#define REG_ADDR__D0D1_DRV_IREF_CTL                                      (ANAPHY_RXDPLL | 0x0050)
  // (ReadWrite, Bits 3:0) 
  // D0 driver reference current control 
  #define BIT_MSK__D0D1_DRV_IREF_CTL__REG_D0_DRV_IREF_CTL                                   0x0F
  // (ReadWrite, Bits 7:4) 
  // D1 driver reference current control 
  #define BIT_MSK__D0D1_DRV_IREF_CTL__REG_D1_DRV_IREF_CTL                                   0xF0

// D2CK DRV IREF Control Register
#define REG_ADDR__D2CK_DRV_IREF_CTL                                      (ANAPHY_RXDPLL | 0x0051)
  // (ReadWrite, Bits 3:0) 
  // D2 driver reference current control 
  #define BIT_MSK__D2CK_DRV_IREF_CTL__REG_D2_DRV_IREF_CTL                                   0x0F
  // (ReadWrite, Bits 7:4) 
  // CK driver reference current control 
  #define BIT_MSK__D2CK_DRV_IREF_CTL__REG_CK_DRV_IREF_CTL                                   0xF0

// D0D1 Slew Control Register
#define REG_ADDR__D0D1_SLEW_CTL                                          (ANAPHY_RXDPLL | 0x0052)
  // (ReadWrite, Bits 3:0) 
  // D0 channel slew rate control through feed-through cap
  #define BIT_MSK__D0D1_SLEW_CTL__REG_D0_SLEW_CTL                                       0x0F
  // (ReadWrite, Bits 7:4) 
  // D1 channel slew rate control through feed-through cap
  #define BIT_MSK__D0D1_SLEW_CTL__REG_D1_SLEW_CTL                                       0xF0

// D2CK Slew Control Register
#define REG_ADDR__D2CK_SLEW_CTL                                          (ANAPHY_RXDPLL | 0x0053)
  // (ReadWrite, Bits 3:0) 
  // D2 channel slew rate control through feed-through cap
  #define BIT_MSK__D2CK_SLEW_CTL__REG_D2_SLEW_CTL                                       0x0F
  // (ReadWrite, Bits 7:4) 
  // CK channel slew rate control through feed-through cap
  #define BIT_MSK__D2CK_SLEW_CTL__REG_CK_SLEW_CTL                                       0xF0

// D0 DRV Control Register
#define REG_ADDR__D0_DRV_CTL                                             (ANAPHY_RXDPLL | 0x0054)
  // (ReadWrite, Bits 3:0) 
  // bias vdsat control signal for D0 data driver
  #define BIT_MSK__D0_DRV_CTL__REG_D0_DRV_VNB_CTL                                    0x0F
  // (ReadWrite, Bits 7:4) 
  // bias vdsat control signal for D0 cascade transistor for data driver
  #define BIT_MSK__D0_DRV_CTL__REG_D0_DRV_VNBC_CTL                                   0xF0

// D1 DRV Control Register
#define REG_ADDR__D1_DRV_CTL                                             (ANAPHY_RXDPLL | 0x0055)
  // (ReadWrite, Bits 3:0) 
  // bias vdsat control signal for D1 data driver
  #define BIT_MSK__D1_DRV_CTL__REG_D1_DRV_VNB_CTL                                    0x0F
  // (ReadWrite, Bits 7:4) 
  // bias vdsat control signal for D1 cascade transistor for data driver
  #define BIT_MSK__D1_DRV_CTL__REG_D1_DRV_VNBC_CTL                                   0xF0

// D2 DRV Control Register
#define REG_ADDR__D2_DRV_CTL                                             (ANAPHY_RXDPLL | 0x0056)
  // (ReadWrite, Bits 3:0) 
  // bias vdsat control signal for D2 data driver
  #define BIT_MSK__D2_DRV_CTL__REG_D2_DRV_VNB_CTL                                    0x0F
  // (ReadWrite, Bits 7:4) 
  // bias vdsat control signal for D2 cascade transistor for data driver
  #define BIT_MSK__D2_DRV_CTL__REG_D2_DRV_VNBC_CTL                                   0xF0

// HARRY CTRL  Register
#define REG_ADDR__HARRY_CTRL                                             (ANAPHY_RXDPLL | 0x0057)
  // (ReadWrite, Bits 0) 
  // charge pump enable(): 1: enable COC charge pump(default setting; required to be 1'b1 in Spiderman when enable COC) 0: disable COC charge pump
  #define BIT_MSK__HARRY_CTRL__REG_COC_CP_V18_EN                                     0x01
  // (ReadWrite, Bits 1) 
  // control charge pump output voltage
  #define BIT_MSK__HARRY_CTRL__REG_CP_VCTL                                           0x02
  // (ReadWrite, Bits 2) 
  // used for the vcocal calbration period:  1= the reference voltage is VDD/6   0= the reference volatge is VDD/3 At the period of the vcocal calibration:  1) we set the PLL to be the open loop mode 2) we provide a reference voltage and make the PLL to free run 3) we compare the PLL output with the input frequency 4) If PLL[ ref clk then vcocal=vcocal+1; until the vcocal =1111 
  #define BIT_MSK__HARRY_CTRL__REG_PLL_VCTL_OLP_SEL                                  0x04
  // (ReadWrite, Bits 3) 
  // power switch enable signal for av link D0/CK channel
  #define BIT_MSK__HARRY_CTRL__REG_PWRON_D0CK                                        0x08
  // (ReadWrite, Bits 4) 
  // power switch enable signal for av link D2/D1 channel
  #define BIT_MSK__HARRY_CTRL__REG_PWRON_D2D1                                        0x10
  // (ReadWrite, Bits 5) 
  // enable signal for BIAS block
  #define BIT_MSK__HARRY_CTRL__REG_TX_BIAS_EN                                        0x20
  // (ReadWrite, Bits 6) 
  // enable signal for banner USB3 flip option support
  #define BIT_MSK__HARRY_CTRL__REG_USB_TYPEC_FLIP_EN                                 0x40

// HARRY CTRL #1 Register
#define REG_ADDR__HARRY_CTRL_1                                           (ANAPHY_RXDPLL | 0x0058)
  // (ReadWrite, Bits 3:0) 
  // 1 tap pre-emphasis enable signal for output driver
  #define BIT_MSK__HARRY_CTRL_1__REG_TAP1_EN1                                          0x0F
  // (ReadWrite, Bits 7:4) 
  // driver output enable signal: [3:0] control  D2;D1;D0;CK repectly if tx_en is 1b'0; then it will be 4b'0000
  #define BIT_MSK__HARRY_CTRL_1__REG_DP_OE1                                            0xF0

// HARRY CTRL #2 Register
#define REG_ADDR__HARRY_CTRL_2                                           (ANAPHY_RXDPLL | 0x0059)
  // (ReadWrite, Bits 3:0) 
  // [3:2]: compensate the mismatch of the current [1:0]: calibrate the current of the integration path from 0.6uA~1.6uA
  #define BIT_MSK__HARRY_CTRL_2__REG_PLL_INT_IBIAS                                     0x0F
  // (ReadWrite, Bits 5:4) 
  // ck channel slew rate control through grounded cap
  #define BIT_MSK__HARRY_CTRL_2__REG_CK_RFT_CTL                                        0x30
  // (ReadWrite, Bits 7:6) 
  // flip option support Legacy MHL mode  common mode damping clock termintaion selection 2b'00 open 2b'01 400 ohm 2b'10 200 ohm 2b'11 133 ohm this flip damping and normal mode damping should disable one of them;
  #define BIT_MSK__HARRY_CTRL_2__REG_DAMP_TERM_FLIP                                    0xC0

// D0D1D2 Term Sel Register
#define REG_ADDR__D0D1D2_TERM_SEL                                        (ANAPHY_RXDPLL | 0x005A)
  // (ReadWrite, Bits 1:0) 
  // D0 driver data channel terminal selection signal 2b'00 open 2b'01 300 ohm 2b'10 150 ohm 2b'11 100 ohm
  #define BIT_MSK__D0D1D2_TERM_SEL__REG_D0_TERM_SEL                                       0x03
  // (ReadWrite, Bits 3:2) 
  // D1 driver data channel terminal selection signal 2b'00 open 2b'01 300 ohm 2b'10 150 ohm 2b'11 100 ohm
  #define BIT_MSK__D0D1D2_TERM_SEL__REG_D1_TERM_SEL                                       0x0C
  // (ReadWrite, Bits 5:4) 
  // D2 driver data channel terminal selection signal 2b'00 open 2b'01 300 ohm 2b'10 150 ohm 2b'11 100 ohm
  #define BIT_MSK__D0D1D2_TERM_SEL__REG_D2_TERM_SEL                                       0x30

// TDM DRV CTL Register
#define REG_ADDR__TDM_DRV_CTL                                            (ANAPHY_RXDPLL | 0x005B)
  // (ReadWrite, Bits 5:0) 
  // tdm mode control signal for driver status: non-tdm mode: 001101 tdm mode: 000101 [5:4] are researved pins
  #define BIT_MSK__TDM_DRV_CTL__REG_TDM_DRV_CTL                                       0x3F

// TX DPATH EN Register
#define REG_ADDR__TX_DPATH_EN                                            (ANAPHY_RXDPLL | 0x005C)
  // (ReadWrite, Bits 3:0) 
  // data-path enable signal: [3:0] control  D2;D1;D0;CK repectly if tx_en is 1b'0; then it will be 4b'0000
  #define BIT_MSK__TX_DPATH_EN__REG_TX_DPATH_EN                                       0x0F

// COC PI Cap Control Register
#define REG_ADDR__COC_PI_CAP_CTL                                         (ANAPHY_RXDPLL | 0x005D)
  // (ReadWrite, Bits 4:0) 
  // coc CDR cap control
  #define BIT_MSK__COC_PI_CAP_CTL__REG_COC_PI_CAP_CTL                                    0x1F

// PLL Ldo Control Register
#define REG_ADDR__PLL_LDO_CTL                                            (ANAPHY_RXDPLL | 0x005E)
  // (ReadWrite, Bits 4:0) 
  // [4:3] : set the reference voltage for vcocal calibration    (00: VDD/6, 01: VDD/5, 10: VDD/4, 11: VDD/3) [2]    : 1= PLL is 3.3V power mode, 0=PLL is 1.8V power mode [1:0]: calibrate the output value of the internal LDO 
  #define BIT_MSK__PLL_LDO_CTL__REG_PLL_LDO_CTL                                       0x1F

// TXZONE Control #1 Register
#define REG_ADDR__TXZONE_CTL_1                                           (ANAPHY_RXDPLL | 0x005F)
  // (ReadWrite, Bits 0) 
  // 
  #define BIT_MSK__TXZONE_CTL_1__REG_TXZONE_PLL_MODE_OVR                               0x01
  // (ReadWrite, Bits 2:1) 
  // Software overwrite val of txzone_pll_mode. When 0 bit of this register is 1'b1, this bit is valid. [0]: 1=PLL is at close loop mode; 0=PLL is at open loop mode.      For vcocal calibration, the pll_mode[0] is the enable signal. pll_mode[0]=1, disable the calibration, pll is at close-loop.        =0, enable the calibration, pll is at open-loop, charge pump is disable [1]: NC
  #define BIT_MSK__TXZONE_CTL_1__REG_TXZONE_PLL_MODE_OVR_VAL                           0x06
  // (ReadWrite, Bits 3) 
  // Software overwrite of txzone_vcocal. If 1'b0; txzone_vcocal; else reg_txzone_vcocal_ovr_val will drive  pll_vcocal of harry
  #define BIT_MSK__TXZONE_CTL_1__REG_TXZONE_VCOCAL_OVR                                 0x08
  // (ReadWrite, Bits 7:4) 
  // Software overwrite val of calibration bits. (when 3bit of this regsiter is 1'b1, these are act as calibration bits for tx_phy)
  #define BIT_MSK__TXZONE_CTL_1__REG_TXZONE_VCOCAL_OVR_VAL                             0xF0

// TXZONE Control #2 Register
#define REG_ADDR__TXZONE_CTL_2                                           (ANAPHY_RXDPLL | 0x0060)
  // (ReadWrite, Bits 0) 
  // To overwrite txzone_div_pre coming from new zone ontroller. If 0 : txzone_div_pre coming from zone controller is driven  pre_div_ctl of harry if 1: reg_txzone_div_pre is driven to pre_div_ctl
  #define BIT_MSK__TXZONE_CTL_2__REG_TXZONE_DIV_PRE_OVR                                0x01
  // (ReadWrite, Bits 5:1) 
  // pre_div_ctl of harry in when overwrite (0 bit of the register is 1'b1) is selected.  00000: prediv ratio=1 00001: prediv ratio=1 00010: prediv ratio=2 .. 11111: prediv ratio=31
  #define BIT_MSK__TXZONE_CTL_2__REG_TXZONE_DIV_PRE                                    0x3E

// TXZONE Control #3 Register
#define REG_ADDR__TXZONE_CTL_3                                           (ANAPHY_RXDPLL | 0x0061)
  // (ReadWrite, Bits 0) 
  // To overwrite txzone_div_pst coming from new zone ontroller. If 0 : txzone_div_pst coming from zone controller is driven  pre_div_pst of harry if 1: reg_txzone_dst_pre is driven to pst_div_ctl
  #define BIT_MSK__TXZONE_CTL_3__REG_TXZONE_DIV_PST_OVR                                0x01
  // (ReadWrite, Bits 7:1) 
  // pst_div_ctl of harry in when overwrite ( 0 bit of this register is 1'b1) is selected. 0000000: postdiv ratio=1 0000001: postdiv ratio=1 0000010: postdiv ratio=2 .. 1111111: postdiv ratio=127
  #define BIT_MSK__TXZONE_CTL_3__REG_TXZONE_DIV_PST                                    0xFE

// TXZONE Control #4 Register
#define REG_ADDR__TXZONE_CTL_4                                           (ANAPHY_RXDPLL | 0x0062)
  // (ReadWrite, Bits 0) 
  // overwrite of szone_sel of haary if 0: tx_zone_sel coming from avlink_wrapper is driven to szone_sel if 1: reg_tx_zone_sel is driven to szone_sel of harry
  #define BIT_MSK__TXZONE_CTL_4__REG_TX_ZONE_SEL_OVR                                   0x01
  // (ReadWrite, Bits 2:1) 
  // soft ware overwrite value of szone_sel of tx_phy.  When 0 bit of this regsiter is 1'b1, these register bits are valid. zone control  00  1x 01  2x 10  4x 11  8x
  #define BIT_MSK__TXZONE_CTL_4__REG_TX_ZONE_SEL                                       0x06
  // (ReadWrite, Bits 3) 
  // Either to drive direct scdt from DPLL or delayed SCDT if 0: direct scdt if 1: delayed SCDT
  #define BIT_MSK__TXZONE_CTL_4__REG_SCDT_FLT_EN                                       0x08
  // (ReadWrite, Bits 7:4) 
  // These register bits control the pll_kp_bias[3:0] of tx_phy, if RX_ZONE_CTRL1 (0x407B[3]) is 1'b1. [3:2] : calibate the I16u from 0.5/0.75/1/1.25 [1:0]: calibrate the Ifb from 0.5/0.75/1/1.25  The proportion path includes two segments: one is the constant current (I16u); the other is the feedback current (Ifb) from VCO. 
  #define BIT_MSK__TXZONE_CTL_4__REG_PLL_KP_BIAS                                       0xF0

// TX DRV VBIAS CASCTL #1 Register
#define REG_ADDR__TX_DRV_VBIAS_CASCTL_1                                  (ANAPHY_RXDPLL | 0x0063)
  // (ReadWrite, Bits 3:0) 
  // D2 driver cascade bias control for bias stability option
  #define BIT_MSK__TX_DRV_VBIAS_CASCTL_1__REG_D2_DRV_VBIAS_CASCTL_B3_B0                         0x0F
  // (ReadWrite, Bits 7:4) 
  // D1 driver cascade bias control for bias stability option
  #define BIT_MSK__TX_DRV_VBIAS_CASCTL_1__REG_D1_DRV_VBIAS_CASCTL_B3_B0                         0xF0

// TX DRV VBIAS CASCTL #2 Register
#define REG_ADDR__TX_DRV_VBIAS_CASCTL_2                                  (ANAPHY_RXDPLL | 0x0064)
  // (ReadWrite, Bits 3:0) 
  // D0 driver cascade bias control for bias stability option
  #define BIT_MSK__TX_DRV_VBIAS_CASCTL_2__REG_D0_DRV_VBIAS_CASCTL_B3_B0                         0x0F
  // (ReadWrite, Bits 7:4) 
  // ck driver cascade bias control for bias stability option
  #define BIT_MSK__TX_DRV_VBIAS_CASCTL_2__REG_CK_DRV_VBIAS_CASCTL_B3_B0                         0xF0

// TX SCDT Delay Control Register
#define REG_ADDR__TX_SCDT_DLY_CTL                                        (ANAPHY_RXDPLL | 0x0065)
  // (ReadWrite, Bits 7:0) 
  // This is to control the delay of scdt coming from DPLL; when reg_scdt_flt_en is high
  #define BIT_MSK__TX_SCDT_DLY_CTL__REG_SCDT_HOLDOFF_MSB                                  0xFF

// MHL DataPath #10 Ctl Register
#define REG_ADDR__MHL_DP_CTL10                                           (ANAPHY_RXDPLL | 0x0066)
  // (ReadWrite, Bits 7:0) 
  // clock channel data swing control bit
  #define BIT_MSK__MHL_DP_CTL10__REG_CK_SWING_CTL                                      0xFF

// PLL ICP  Ctl Register
#define REG_ADDR__PLL_ICP_CTL                                            (ANAPHY_RXDPLL | 0x0067)
  // (ReadWrite, Bits 3:0) 
  // zone CP current control of tx_phy, from digital logic. If the 0x407B[4] (RX_ZONE_CTRL1) is 1'b1, then this register is valid.
  #define BIT_MSK__PLL_ICP_CTL__REG_PLL_ICP_CTL                                       0x0F

// CBUS Overwrite Ctl #0 Register
#define REG_ADDR__CBUS_OVER_CTL_0                                        (ANAPHY_RXDPLL | 0x0068)
  // (ReadWrite, Bits 0) 
  // register overwrite enable for cbus0 input ports of tx_phy.
  #define BIT_MSK__CBUS_OVER_CTL_0__REG_CBUS0_VALID_OVR                                   0x01
  // (ReadWrite, Bits 1) 
  // register overwrite enable for cbus1 input ports of yx_phy.
  #define BIT_MSK__CBUS_OVER_CTL_0__REG_CBUS1_VALID_OVR                                   0x02
  // (ReadWrite, Bits 2) 
  // control cbus0 in output/input mode for regular mode(cbus0_oe port of tx_phy). This is software overwrite. This is valid when 0 bit of this register is 1'b1.
  #define BIT_MSK__CBUS_OVER_CTL_0__REG_CBUS0_OE                                          0x04
  // (ReadWrite, Bits 3) 
  // Enable CBUS to ground resistance measurement (normal mode) (cbus0_meas_rgnd_en port of tx_phy). This is software overwrite. If 0  bit of this register is 1'b1 then it is valid.
  #define BIT_MSK__CBUS_OVER_CTL_0__REG_CBUS0_MEAS_RGND_EN                                0x08
  // (ReadWrite, Bits 4) 
  // To select either cbus0 pad output drives cbus logic or cbus1 pad output drives cbus logic. If 1'b1: cbus1 logic. If 1'b0: cbus0 logic
  #define BIT_MSK__CBUS_OVER_CTL_0__REG_CBUS_VALID_OVR                                    0x10
  // (ReadOnly, Bits 6:5) 
  // 2'b00 Rgnd ]] 2k or meas_rgnd_en ==1'b0 2'b01 Rgnd ~  2k 2'b10 Rgnd ~  1k 2'b11 Rgnd [[ 1k 
  #define BIT_MSK__CBUS_OVER_CTL_0__REG_TX_CBUS0_RGND                                     0x60
  // (ReadOnly, Bits 7) 
  // normal mode: Flag indicating rgnd measurement done 1'b0 Measurement not done yet or disable 1'b1 Measurement done rgnd[1:0] ready
  #define BIT_MSK__CBUS_OVER_CTL_0__REG_TX_CBUS0_RGND_DONE                                0x80

// CBUS Overwrite Ctl #1 Register
#define REG_ADDR__CBUS_OVER_CTL_1                                        (ANAPHY_RXDPLL | 0x0069)
  // (ReadOnly, Bits 0) 
  // data from cbus0 pad of tx_phy to digital core for normal mode.
  #define BIT_MSK__CBUS_OVER_CTL_1__REG_TX_CBUS0_C                                        0x01
  // (ReadOnly, Bits 1) 
  // hpd output (normal mode)
  #define BIT_MSK__CBUS_OVER_CTL_1__REG_TX_CBUS0_HPD_DET                                  0x02
  // (ReadWrite, Bits 2) 
  // To select grouped CBUS (ANDing CBUS0 and CBUS1) is connected to CBUS digital logic. This works when unconnected CBUS level is HIGH. 1 : Use ANDed CBUS signal in digital 0 : Based on CBUS_OVER_CTL_0[4]
  #define BIT_MSK__CBUS_OVER_CTL_1__REG_USE_GRPD_CBUS                                     0x04
  // (ReadWrite, Bits 3) 
  // To select grouped CBUS RGND Done (ORing CBUS0_RGND_DONE and CBUS1_RGND_DONE) is connected to CBUS digital logic. 1 : Use ORed CBUS*_RGND_DONE signal in digital 0 : Based on CBUS_OVER_CTL_0[4]
  #define BIT_MSK__CBUS_OVER_CTL_1__REG_USE_GRPD_CBUS_RGND                                0x08
  // (ReadWrite, Bits 4) 
  // To select grouped CBUS RGND Value is connected to CBUS digital logic. 1 : Select one of CBUS*_RGND value based on CBUS*_RGND_DONE 0 : Based on CBUS_OVER_CTL_0[4]
  #define BIT_MSK__CBUS_OVER_CTL_1__REG_USE_GRPD_CBUS_RGND_VAL                            0x10
  // (ReadWrite, Bits 5) 
  // To select the RGND measure enable gated with CBUS0 level signal to analog for CBUS PAD0. 1 : Uses CBUS0 andand CBUS_RGND_MEAS_EN is connected to analog CBUS PAD0 0 : Uses ungated CBUS_RGND_MEAS_EN is connected to analog CBUS PAD0
  #define BIT_MSK__CBUS_OVER_CTL_1__REG_USE_GATED_RGND_MEAS0_EN                           0x20
  // (ReadWrite, Bits 6) 
  // To select the RGND measure enable gated with CBUS0 level signal to analog for CBUS PAD1. 1 : Uses CBUS1 andand CBUS_RGND_MEAS_EN is connected to analog CBUS PAD1 0 : Uses ungated CBUS_RGND_MEAS_EN is connected to analog CBUS PAD1
  #define BIT_MSK__CBUS_OVER_CTL_1__REG_USE_GATED_RGND_MEAS1_EN                           0x40

// SWAY FPLL Control  #0 Register
#define REG_ADDR__SWAY_FPLL_CTRL_0                                       (ANAPHY_RXDPLL | 0x006A)
  // (ReadWrite, Bits 0) 
  // 
  #define BIT_MSK__SWAY_FPLL_CTRL_0__REG_SWAY_FPLL_BIAS_CP                                 0x01
  // (ReadWrite, Bits 1) 
  // will enable the cascode device in the VCOBIAS circuit to improve PSR. [0]=default
  #define BIT_MSK__SWAY_FPLL_CTRL_0__REG_SWAY_FPLL_BIAS_VCO                                0x02
  // (ReadWrite, Bits 2) 
  // power down from I2C (power switch power down).  Not Used. [0]= normal operation [1]=power off mode
  #define BIT_MSK__SWAY_FPLL_CTRL_0__REG_SWAY_FPLL_I2C_PD                                  0x04
  // (ReadWrite, Bits 3) 
  // pll power down.  [1]=normal operation [0]=power off mode
  #define BIT_MSK__SWAY_FPLL_CTRL_0__REG_SWAY_FPLL_PDB                                     0x08
  // (ReadWrite, Bits 5:4) 
  // used to change the PLL Loop filter resistor value [00] = 12K [01]  =10K (default) [10] = 7.8K [11] = 5.8K
  #define BIT_MSK__SWAY_FPLL_CTRL_0__REG_SWAY_RC_SEL                                       0x30

// SWAY FPLL Control  #1 Register
#define REG_ADDR__SWAY_FPLL_CTRL_1                                       (ANAPHY_RXDPLL | 0x006B)
  // (ReadWrite, Bits 7:0) 
  // pll_ctrl[4] [scapcal] = selection bit for charge pump current and vco bias current  [0]=band gap;OTA;  [1]=resister devider . pll_ctrl[3:0][bias_bgr[3:0]]bandgap output voltage caliberation [0000]= 434mv(max); ...; [1111]=352mv(min). pll_ctrl[7:5][res_ctrl[2:0]]internal resiastance caliberation  [111] = 6.8K (min); [000]= 9.6K (max).
  #define BIT_MSK__SWAY_FPLL_CTRL_1__REG_SWAY_FPLL_PLL_CTRL                                0xFF

// SWAY FPLL Control  #2 Register
#define REG_ADDR__SWAY_FPLL_CTRL_2                                       (ANAPHY_RXDPLL | 0x006C)
  // (ReadWrite, Bits 3:0) 
  // vco zone control. [0111]= default.
  #define BIT_MSK__SWAY_FPLL_CTRL_2__REG_SWAY_FPLL_VCOCAL                                  0x0F
  // (ReadWrite, Bits 4) 
  // Bandgap reference voltage input (400mV) may be provided from Rx
  #define BIT_MSK__SWAY_FPLL_CTRL_2__REG_SWAY_VBGR_IN                                      0x10

// SWAY FPLL REF DIV Register
#define REG_ADDR__SWAY_FPLL_REF_DIV                                      (ANAPHY_RXDPLL | 0x006D)
  // (ReadWrite, Bits 6:0) 
  // ref_div[6:0] pre divider control  [0000000] = Not Used; [0000001] = div-by-1; [0000010] = div-by-2; [0000011] = div-by-3 ; [1111110] = div-by-126; [1111111] = div-by-127;
  #define BIT_MSK__SWAY_FPLL_REF_DIV__REG_SWAY_PLL_REF_DIV                                  0x7F

// SWAY FPLL FB DIV INT #1 Register
#define REG_ADDR__SWAY_FPLL_FB_DIV_INT_1                                 (ANAPHY_RXDPLL | 0x006E)
  // (ReadWrite, Bits 7:0) 
  // feedback divider integer value of LSB
  #define BIT_MSK__SWAY_FPLL_FB_DIV_INT_1__REG_SWAY_PLL_FB_DIV_INT_B7_B0                         0xFF

// SWAY FPLL FB DIV INT #2 Register
#define REG_ADDR__SWAY_FPLL_FB_DIV_INT_2                                 (ANAPHY_RXDPLL | 0x006F)
  // (ReadWrite, Bits 0) 
  // feedback divider integer value of Msbit
  #define BIT_MSK__SWAY_FPLL_FB_DIV_INT_2__REG_SWAY_PLL_FB_DIV_INT_B8                            0x01

// SWAY FPLL FB DIV FRAC #1 Register
#define REG_ADDR__SWAY_FPLL_FB_DIV_FRAC_1                                (ANAPHY_RXDPLL | 0x0070)
  // (ReadWrite, Bits 7:0) 
  // feedback divider fractional value of LSB
  #define BIT_MSK__SWAY_FPLL_FB_DIV_FRAC_1__REG_SWAY_PLL_FB_DIV_FRAC_B7_B0                        0xFF

// SWAY FPLL FB DIV FRAC #2 Register
#define REG_ADDR__SWAY_FPLL_FB_DIV_FRAC_2                                (ANAPHY_RXDPLL | 0x0071)
  // (ReadWrite, Bits 7:0) 
  // feedback divider fractional value of [15:8]
  #define BIT_MSK__SWAY_FPLL_FB_DIV_FRAC_2__REG_SWAY_PLL_FB_DIV_FRAC_B15_B8                       0xFF

// SWAY FPLL FB DIV FRAC #3 Register
#define REG_ADDR__SWAY_FPLL_FB_DIV_FRAC_3                                (ANAPHY_RXDPLL | 0x0072)
  // (ReadWrite, Bits 3:0) 
  // feedback divider fractional value of MSB
  #define BIT_MSK__SWAY_FPLL_FB_DIV_FRAC_3__REG_SWAY_PLL_FB_DIV_FRAC_B19_B16                      0x0F

// SWAY FPLL SIGMADELTA Register
#define REG_ADDR__SWAY_FPLL_SIGMADELTA_CTL                               (ANAPHY_RXDPLL | 0x0073)
  // (ReadWrite, Bits 7:0) 
  // sigma delta control reigster SdmCtl[2:0] : SDM order (default 2)          1       : 1st order          2       : 2nd order          3       : NA SdmCtl[4:3] : Dither Option(default 0)          0       : off          1       : feedback dither          2       : HPF LFSR          3       : LFSR SdmCtl[6:5]   : NA SdmCtl[7]   : FPGA emulation mode          0       : normal          1       : external dN
  #define BIT_MSK__SWAY_FPLL_SIGMADELTA_CTL__REG_SWAY_PLL_SIGMADELTA_CTL                           0xFF

// SWAY FPLL FB DIV WP Register
#define REG_ADDR__SWAY_FPLL_FB_DIV_WP                                    (ANAPHY_RXDPLL | 0x0074)
  // (ReadWrite, Bits 0) 
  // Sway pll div integer and sway pll div fractional strobe signal
  #define BIT_MSK__SWAY_FPLL_FB_DIV_WP__REG_SWAY_PLL_FB_DIV_WP                                0x01

// SWAY FPLL PLL CFG #1 Register
#define REG_ADDR__SWAY_FPLL_PLL_CFG_1                                    (ANAPHY_RXDPLL | 0x0075)
  // (ReadWrite, Bits 7:0) 
  // [22] = reserved ----------------------------------------------------------------------- [21:16] post divider control  [000000] = Not Used; [000001] = div-by-1; [000010] = div-by-2; [000011] = div-by-3; ...; [111110] = div-by-62; [111111] = div-by-63 ----------------------------------------------------------------------- [15:14] if_timing_ctl  [00]= 1 delay; [01]= 0 delay; [10]= 2 delay; [11]= inverted. ---------------------------------------------------------------------- [23];[13:9] DDR scaler divider control [000000] = Not Used; [000001] = div-by-1; [000010] = div-by-2; [000011] = div-by-3; ...; [111110] = div-by-62; [111111] = div-by-63 -----------------------------------------------------------------------                                                                           [8] reserved [7:0] integer frequency input  below [0_0000_XXXX] = non working  range [0_0001_0000] = div by 32 [1_1111_1111] = div by 511
  #define BIT_MSK__SWAY_FPLL_PLL_CFG_1__REG_SWAY_FPLL_PLL_CFG_B7_B0                           0xFF

// SWAY FPLL PLL CFG #2 Register
#define REG_ADDR__SWAY_FPLL_PLL_CFG_2                                    (ANAPHY_RXDPLL | 0x0076)
  // (ReadWrite, Bits 7:0) 
  // [22] = reserved ----------------------------------------------------------------------- [21:16] post divider control  [000000] = Not Used; [000001] = div-by-1; [000010] = div-by-2; [000011] = div-by-3; ...; [111110] = div-by-62; [111111] = div-by-63 ----------------------------------------------------------------------- [15:14] if_timing_ctl  [00]= 1 delay; [01]= 0 delay; [10]= 2 delay; [11]= inverted. ---------------------------------------------------------------------- [23];[13:9] DDR scaler divider control [000000] = Not Used; [000001] = div-by-1; [000010] = div-by-2; [000011] = div-by-3; ...; [111110] = div-by-62; [111111] = div-by-63 -----------------------------------------------------------------------                                                                           [8] reserved [7:0] integer frequency input  below [0_0000_XXXX] = non working  range [0_0001_0000] = div by 32 [1_1111_1111] = div by 511
  #define BIT_MSK__SWAY_FPLL_PLL_CFG_2__REG_SWAY_FPLL_PLL_CFG_B15_B8                          0xFF

// SWAY FPLL PLL CFG #3 Register
#define REG_ADDR__SWAY_FPLL_PLL_CFG_3                                    (ANAPHY_RXDPLL | 0x0077)
  // (ReadWrite, Bits 7:0) 
  // [22] = reserved ----------------------------------------------------------------------- [21:16] post divider control  [000000] = Not Used; [000001] = div-by-1; [000010] = div-by-2; [000011] = div-by-3; ...; [111110] = div-by-62; [111111] = div-by-63 ----------------------------------------------------------------------- [15:14] if_timing_ctl  [00]= 1 delay; [01]= 0 delay; [10]= 2 delay; [11]= inverted. ---------------------------------------------------------------------- [23];[13:9] DDR scaler divider control [000000] = Not Used; [000001] = div-by-1; [000010] = div-by-2; [000011] = div-by-3; ...; [111110] = div-by-62; [111111] = div-by-63 -----------------------------------------------------------------------                                                                           [8] reserved [7:0] integer frequency input  below [0_0000_XXXX] = non working  range [0_0001_0000] = div by 32 [1_1111_1111] = div by 511
  #define BIT_MSK__SWAY_FPLL_PLL_CFG_3__REG_SWAY_FPLL_PLL_CFG_B23_B16                         0xFF

// SWAY FPLL CP_S Register
#define REG_ADDR__SWAY_FPLL_CP_S                                         (ANAPHY_RXDPLL | 0x0078)
  // (ReadWrite, Bits 3:0) 
  // charge pump current control  [0000]= no current; [0001]= 1uA; [0010]=2uA .. [1010]=10uA (default)  ; [1111]= 15uA.
  #define BIT_MSK__SWAY_FPLL_CP_S__REG_SWAY_FPLL_CP_S                                    0x0F

// RX Zone Control  #0 Register
#define REG_ADDR__RX_ZONE_CTRL0                                          (ANAPHY_RXDPLL | 0x007A)
  // (ReadWrite, Bits 0) 
  // Zone Calculation start (RX) enable
  #define BIT_MSK__RX_ZONE_CTRL0__REG_RXZONE_START                                      0x01
  // (ReadWrite, Bits 4) 
  // RX zone VCO Software Lock overwritten value.  (locked signal from digital core  to enable driver oe output indicate signal for digital to check whether PLL is locked or not. By default, value comes from zone_vco module. If 7 bit of this register is 1'b1, value of this bit drives on. )
  #define BIT_MSK__RX_ZONE_CTRL0__REG_RX_ZONEVCO_LOCK_VAL                               0x10
  // (ReadWrite, Bits 5) 
  // TX zone VCO Software Lock
  #define BIT_MSK__RX_ZONE_CTRL0__REG_TX_ZONEVCO_LOCK_VAL                               0x20
  // (ReadWrite, Bits 6) 
  // RX zone VCO Software Lock Overwrite
  #define BIT_MSK__RX_ZONE_CTRL0__REG_RX_ZONEVCO_LOCK_OVR                               0x40
  // (ReadWrite, Bits 7) 
  // TX zone VCO Software Lock Overwrite
  #define BIT_MSK__RX_ZONE_CTRL0__REG_TX_ZONEVCO_LOCK_OVR                               0x80

// Zone Control  #1 Register
#define REG_ADDR__RX_ZONE_CTRL1                                          (ANAPHY_RXDPLL | 0x007B)
  // (ReadWrite, Bits 0) 
  // TX Zone controller SW overwrite enable
  #define BIT_MSK__RX_ZONE_CTRL1__REG_TX_SZONE_SW_OVR                                   0x01
  // (ReadWrite, Bits 2:1) 
  // TX Zone controller SW overwrite value
  #define BIT_MSK__RX_ZONE_CTRL1__REG_TX_SZONE_SW_VAL                                   0x06
  // (ReadWrite, Bits 3) 
  // TX Zone controller SW overwrite enable for txzone_i_sel.
  #define BIT_MSK__RX_ZONE_CTRL1__REG_TX_PLL_KP_BIAS_OVR                                0x08
  // (ReadWrite, Bits 4) 
  // TX Zone controller SW overwrite enable for txzone_bias_bgr_d
  #define BIT_MSK__RX_ZONE_CTRL1__REG_TX_PLL_ICP_CTL_OVR                                0x10
  // (ReadWrite, Bits 7:5) 
  // RX Zone controller (DPLL) SW overwrite value
  #define BIT_MSK__RX_ZONE_CTRL1__REG_RX_SZONE_SW_VAL                                   0xE0

// Zone Control  #2 Register
#define REG_ADDR__RX_ZONE_CTRL2                                          (ANAPHY_RXDPLL | 0x007C)
  // (ReadWrite, Bits 0) 
  // rxzone pst div over write enable. If 1: enable; else disable
  #define BIT_MSK__RX_ZONE_CTRL2__REG_RXZONE_PST_DIV_OVR                                0x01
  // (ReadWrite, Bits 7:1) 
  // rxzone pst div over write value; it is valid when reg_rxzone_pst_div_ovr is 1'b1 0000000: postdiv ratio=1 0000001: postdiv ratio=1 0000010: postdiv ratio=2 .. 1111111: postdiv ratio=127
  #define BIT_MSK__RX_ZONE_CTRL2__REG_RXZONE_PST_DIV_OVR_VAL                            0xFE

// Zone Control  #3 Register
#define REG_ADDR__RX_ZONE_CTRL3                                          (ANAPHY_RXDPLL | 0x007D)
  // (ReadWrite, Bits 0) 
  // rxzonei_sel over write enable. If 1: enable; else disable
  #define BIT_MSK__RX_ZONE_CTRL3__REG_RXZONE_I_SEL_OVR                                  0x01
  // (ReadWrite, Bits 4:1) 
  // rxzone i_sel over write value; it is valid when reg_rxzone_i_sel_ovr is 1'b1 
  #define BIT_MSK__RX_ZONE_CTRL3__REG_RXZONE_I_SEL_OVR_VAL                              0x1E
  // (ReadWrite, Bits 5) 
  // RX Zone controller SW overwrite enable
  #define BIT_MSK__RX_ZONE_CTRL3__REG_RX_SZONE_SW_OVR                                   0x20

// DPLL Configuration 1 Register
#define REG_ADDR__DPLL_CFG1                                              (ANAPHY_RXDPLL | 0x00A0)
  // (ReadWrite, Bits 0) 
  // Selection of EQV between DEQ(0) and i2c(1)
  #define BIT_MSK__DPLL_CFG1__REG_CFG_EV_SEL                                        0x01
  // (ReadWrite, Bits 1) 
  // Selection of BWV between DEQ(0) and i2c(1)
  #define BIT_MSK__DPLL_CFG1__REG_CFG_BV_SEL                                        0x02
  // (ReadWrite, Bits 3:2) 
  // EQ scanning mode (default = 2'b00)
  #define BIT_MSK__DPLL_CFG1__REG_CFG_MODE                                          0x0C
  // (ReadWrite, Bits 4) 
  // Enable external sync for the ease of testing (default = 1'b0)
  #define BIT_MSK__DPLL_CFG1__REG_CFG_SPCE_EN                                       0x10
  // (ReadWrite, Bits 5) 
  // Auto engine decision enable (default = 1'b1)
  #define BIT_MSK__DPLL_CFG1__REG_CFG_REG_EDON                                      0x20
  // (ReadWrite, Bits 7:6) 
  // LPF tap control (default = 2'b00)
  #define BIT_MSK__DPLL_CFG1__REG_CFG_TAPS                                          0xC0

// DPLL Configuration 2 Register
#define REG_ADDR__DPLL_CFG2                                              (ANAPHY_RXDPLL | 0x00A1)
  // (ReadWrite, Bits 2:0) 
  // Bit count limit control (default = 3'b010)
  #define BIT_MSK__DPLL_CFG2__REG_CFG_BS                                            0x07
  // (ReadWrite, Bits 3) 
  // Enable bypass mode (default = 1'b0)
  #define BIT_MSK__DPLL_CFG2__REG_CFG_BYP                                           0x08
  // (ReadWrite, Bits 5:4) 
  // Bypass channel selection (default = 2'b00)
  #define BIT_MSK__DPLL_CFG2__REG_CFG_CHAN_SEL                                      0x30
  // (ReadWrite, Bits 7:6) 
  // Stable rescan mode (default = 2'b11)
  #define BIT_MSK__DPLL_CFG2__REG_CFG_STB_RSC                                       0xC0

// DPLL Configuration 3 Register
#define REG_ADDR__DPLL_CFG3                                              (ANAPHY_RXDPLL | 0x00A2)
  // (ReadWrite, Bits 0) 
  // Enable extended EQ searching (default = 1'b1)
  #define BIT_MSK__DPLL_CFG3__REG_CFG_EXT_EQ                                        0x01
  // (ReadWrite, Bits 1) 
  // Enable extended BW searching (default = 1'b0)
  #define BIT_MSK__DPLL_CFG3__REG_CFG_EXT_BW                                        0x02
  // (ReadWrite, Bits 2) 
  // Eye monitor only at DE low period (default = 1'b0)
  #define BIT_MSK__DPLL_CFG3__REG_CFG_DE_LO                                         0x04
  // (ReadWrite, Bits 3) 
  // Strength feature enable (default = 1'b0)
  #define BIT_MSK__DPLL_CFG3__REG_CFG_STRTH                                         0x08
  // (ReadWrite, Bits 4) 
  // Tracking decition control (default = 1'b0)
  #define BIT_MSK__DPLL_CFG3__REG_CFG_LOWLMT                                        0x10
  // (ReadWrite, Bits 5) 
  // Eye openness check control (default = 1'b0)
  #define BIT_MSK__DPLL_CFG3__REG_CFG_VLDCHK                                        0x20
  // (ReadWrite, Bits 6) 
  // PLL B/W scanning enable (default = 1'b1)
  #define BIT_MSK__DPLL_CFG3__REG_CFG_BWS_ON                                        0x40
  // (ReadWrite, Bits 7) 
  // Relaxed eye enable (default = 1'b0)
  #define BIT_MSK__DPLL_CFG3__REG_CFG_RLXE_ON                                       0x80

// DPLL Configuration 4 Register
#define REG_ADDR__DPLL_CFG4                                              (ANAPHY_RXDPLL | 0x00A3)
  // (ReadWrite, Bits 5:0) 
  // Edge use control (default = 6'b011100)
  #define BIT_MSK__DPLL_CFG4__REG_CFG_W_CON                                         0x3F
  // (ReadWrite, Bits 6) 
  // Manual MHL gbox active high reset   0 - Normal mode; 1 - Reset (default = 1'b0)
  #define BIT_MSK__DPLL_CFG4__REG_CFG_RI_GBOX_RST                                   0x40
  // (ReadWrite, Bits 7) 
  // 1 - Use SCDT based reset in SSC FIFO reset and 0 - No use of SCDT based reset (default = 1'b1)
  #define BIT_MSK__DPLL_CFG4__SCDT_AUTO_RESET_EN                                    0x80

// DPLL ev_b Register
#define REG_ADDR__EV_VAL_B                                               (ANAPHY_RXDPLL | 0x00A4)
  // (ReadWrite, Bits 7:0) 
  // User specified EQV via i2c of channel b equalizer control used by DPLL auto EQ control eq_ctl[1:0]      DC gain (in dB) 00: 2.6 01: 2.57  10: -1.93 11: -2.52 eq_ctl[4:2]      AC gain (in dB) 000: -2.72 001: -1.77 010: -0.88 011: -0.15 100:  0.39 101: 0.82 110: 1.25 111: 1.41 eq_ctl[5]         input common mode level 0:  868mV 1:  789mV eq_ctl[7:6]      output common mode level 00: 753mV 01: 793.6mV 10: 814.5mV 11: 856.7mV  reg_cfg_ev_sel, (0[0]) should be 1'b1. If this is zero, eq val comes from DPLL.
  #define BIT_MSK__EV_VAL_B__REG_CFG_EV_I2C_B                                      0xFF

// DPLL ev_g Register
#define REG_ADDR__EV_VAL_G                                               (ANAPHY_RXDPLL | 0x00A5)
  // (ReadWrite, Bits 7:0) 
  // User specified EQV via i2c of channel g
  #define BIT_MSK__EV_VAL_G__REG_CFG_EV_I2C_G                                      0xFF

// DPLL ev_r Register
#define REG_ADDR__EV_VAL_R                                               (ANAPHY_RXDPLL | 0x00A6)
  // (ReadWrite, Bits 7:0) 
  // User specified EQV via i2c of channel r
  #define BIT_MSK__EV_VAL_R__REG_CFG_EV_I2C_R                                      0xFF

// DPLL bv Register
#define REG_ADDR__BV_VAL                                                 (ANAPHY_RXDPLL | 0x00A7)
  // (ReadWrite, Bits 7:0) 
  // User specified BWV via i2c. reg_cfg_bv_sel, (0[1]) should be 1'b1. reg_cfg_bv_i2c[4:3] :  set the reference voltage for vcocal calibration   (00: VDD/6, 01: VDD/5, 10: VDD/4, 11: VDD/3) reg_cfg_bv_i2c[2]:  1= PLL is 3.3V power mode, LDO input ref=3.3v/3.6                        0=PLL is 1.8V power mode, LDO input ref=1.8v/2      reg_cfg_bv_i2c[1:0]: calibrate the output value of the internal LDO   At the period of the vcocal calibration: 1) we set the PLL to be the open loop mode 2) we provide a reference voltage and make the PLL to free run 3) we compare the PLL output with the input frequency 4) If PLL[ ref clk then vcocal=vcocal+1, until the vcocal =1111 
  #define BIT_MSK__BV_VAL__REG_CFG_BV_I2C                                        0xFF

// PEQ_VAL0 Register
#define REG_ADDR__PEQ_VAL0                                               (ANAPHY_RXDPLL | 0x00A8)
  // (ReadWrite, Bits 7:0) 
  // One of EQVs used in DEQ 
  #define BIT_MSK__PEQ_VAL0__REG_CFG_PEQ_VAL0                                      0xFF

// PEQ_VAL1 Register
#define REG_ADDR__PEQ_VAL1                                               (ANAPHY_RXDPLL | 0x00A9)
  // (ReadWrite, Bits 7:0) 
  // One of EQVs used in DEQ 
  #define BIT_MSK__PEQ_VAL1__REG_CFG_PEQ_VAL1                                      0xFF

// PEQ_VAL2 Register
#define REG_ADDR__PEQ_VAL2                                               (ANAPHY_RXDPLL | 0x00AA)
  // (ReadWrite, Bits 7:0) 
  // One of EQVs used in DEQ 
  #define BIT_MSK__PEQ_VAL2__REG_CFG_PEQ_VAL2                                      0xFF

// PEQ_VAL3 Register
#define REG_ADDR__PEQ_VAL3                                               (ANAPHY_RXDPLL | 0x00AB)
  // (ReadWrite, Bits 7:0) 
  // One of EQVs used in DEQ 
  #define BIT_MSK__PEQ_VAL3__REG_CFG_PEQ_VAL3                                      0xFF

// PEQ_VAL4 Register
#define REG_ADDR__PEQ_VAL4                                               (ANAPHY_RXDPLL | 0x00AC)
  // (ReadWrite, Bits 7:0) 
  // One of EQVs used in DEQ 
  #define BIT_MSK__PEQ_VAL4__REG_CFG_PEQ_VAL4                                      0xFF

// PEQ_VAL5 Register
#define REG_ADDR__PEQ_VAL5                                               (ANAPHY_RXDPLL | 0x00AD)
  // (ReadWrite, Bits 7:0) 
  // One of EQVs used in DEQ 
  #define BIT_MSK__PEQ_VAL5__REG_CFG_PEQ_VAL5                                      0xFF

// PEQ_VAL6 Register
#define REG_ADDR__PEQ_VAL6                                               (ANAPHY_RXDPLL | 0x00AE)
  // (ReadWrite, Bits 7:0) 
  // One of EQVs used in DEQ 
  #define BIT_MSK__PEQ_VAL6__REG_CFG_PEQ_VAL6                                      0xFF

// PEQ_VAL7 Register
#define REG_ADDR__PEQ_VAL7                                               (ANAPHY_RXDPLL | 0x00AF)
  // (ReadWrite, Bits 7:0) 
  // One of EQVs used in DEQ 
  #define BIT_MSK__PEQ_VAL7__REG_CFG_PEQ_VAL7                                      0xFF

// PBW_VAL0 Register
#define REG_ADDR__PBW_VAL0                                               (ANAPHY_RXDPLL | 0x00B0)
  // (ReadWrite, Bits 7:0) 
  // One of BWVs used in DEQ  
  #define BIT_MSK__PBW_VAL0__REG_CFG_PBW_VAL0                                      0xFF

// PBW_VAL1 Register
#define REG_ADDR__PBW_VAL1                                               (ANAPHY_RXDPLL | 0x00B1)
  // (ReadWrite, Bits 7:0) 
  // One of BWVs used in DEQ  
  #define BIT_MSK__PBW_VAL1__REG_CFG_PBW_VAL1                                      0xFF

// PBW_VAL2 Register
#define REG_ADDR__PBW_VAL2                                               (ANAPHY_RXDPLL | 0x00B2)
  // (ReadWrite, Bits 7:0) 
  // One of BWVs used in DEQ 
  #define BIT_MSK__PBW_VAL2__REG_CFG_PBW_VAL2                                      0xFF

// PBW_VAL3 Register
#define REG_ADDR__PBW_VAL3                                               (ANAPHY_RXDPLL | 0x00B3)
  // (ReadWrite, Bits 7:0) 
  // One of BWVs used in DEQ 
  #define BIT_MSK__PBW_VAL3__REG_CFG_PBW_VAL3                                      0xFF

// DPLL Configuration 5 Register
#define REG_ADDR__DPLL_CFG5                                              (ANAPHY_RXDPLL | 0x00B4)
  // (ReadWrite, Bits 0) 
  // TMDS encoder bypass for 10b loop back (default = 1'b0)
  #define BIT_MSK__DPLL_CFG5__REG_CFG_RI_ENC_BYP                                    0x01
  // (ReadWrite, Bits 1) 
  // Enable SYNC recovery (default = 1'b1)
  #define BIT_MSK__DPLL_CFG5__REG_CFG_RI_RECOV_EN                                   0x02
  // (ReadWrite, Bits 2) 
  // Alternative control of MHL gear box(default = 1'b0)
  #define BIT_MSK__DPLL_CFG5__REG_CFG_RI_GBOX_ALT_CTL_EN                            0x04
  // (ReadWrite, Bits 5:3) 
  // SCDT and MHL MODE based MHL gear box reset control(default = 3'b111)
  #define BIT_MSK__DPLL_CFG5__REG_CFG_RI_GBOX_SCDT_RST                              0x38
  // (ReadWrite, Bits 7:6) 
  // Eye monitor chan selection (default = 2'd0)
  #define BIT_MSK__DPLL_CFG5__REG_CFG_RI_ECHAN_SEL                                  0xC0

// DPLL Configuration 6 Register
#define REG_ADDR__DPLL_CFG6                                              (ANAPHY_RXDPLL | 0x00B5)
  // (ReadWrite, Bits 0) 
  // Eye monitor enable (default = 1'b0)
  #define BIT_MSK__DPLL_CFG6__REG_CFG_RI_EEVAL                                      0x01
  // (ReadWrite, Bits 3:1) 
  // Eye monitor byte selection (default = 3'd0)
  #define BIT_MSK__DPLL_CFG6__REG_CFG_RI_EBYTE_SEL                                  0x0E
  // (ReadWrite, Bits 4) 
  // 1 - Reset zone control logic when SCDT is 0; 0 - No use SCDT (default = 1'b0)
  #define BIT_MSK__DPLL_CFG6__REG_CFG_RI_USE_SCDT                                   0x10
  // (ReadWrite, Bits 5) 
  // Stop bp movement (default = 1'b0)
  #define BIT_MSK__DPLL_CFG6__REG_CFG_RI_BP_FIX                                     0x20
  // (ReadWrite, Bits 6) 
  // 1 - Zone 2x is not used in zone decision; Only 1x and 4x are used; 0 - Zone 2x is used as well(default = 1'b0
  #define BIT_MSK__DPLL_CFG6__REG_CFG_RI_NO_ZONE2X                                  0x40
  // (ReadWrite, Bits 7) 
  // TMDS (q0; q1; q2) bit order swap (default = 1'b0)
  #define BIT_MSK__DPLL_CFG6__REG_CFG_RI_SWAP                                       0x80

// GBOX RESET 1 Register
#define REG_ADDR__GBOX_RST1                                              (ANAPHY_RXDPLL | 0x00B6)
  // (ReadWrite, Bits 7:0) 
  // Gear box reset length when ri_gbox_scdt_rst is 1(default = 16'h4e20 (16'd20000) for 10ms) *In simulation; you have to reduce this; for example; to 0.5ms (16'h3ff) or less to reduce the simulation time
  #define BIT_MSK__GBOX_RST1__REG_CFG_RI_GBOX_RST_LEN_B7_B0                         0xFF

// GBOX RESET 2 Register
#define REG_ADDR__GBOX_RST2                                              (ANAPHY_RXDPLL | 0x00B7)
  // (ReadWrite, Bits 7:0) 
  // Gear box reset length when ri_gbox_scdt_rst is 1(default = 16'h4e20 (16'd20000) for 10ms) *In simulation; you have to reduce this; for example; to 0.5ms (16'h3ff) or less to reduce the simulation time
  #define BIT_MSK__GBOX_RST2__REG_CFG_RI_GBOX_RST_LEN_B15_B8                        0xFF

// ZONE CTRL RST 1 Register
#define REG_ADDR__ZCTRL_RST1                                             (ANAPHY_RXDPLL | 0x00B8)
  // (ReadWrite, Bits 7:0) 
  // 0 - Use CKDT without any delay to reset zone control n - Use CKDT (and SCDT) with given delay n * 256us (default = 12'd5)
  #define BIT_MSK__ZCTRL_RST1__REG_CFG_RI_ZCTL_RST_DLY_B7_B0                         0xFF

// ZONE CTRL RST 2 Register
#define REG_ADDR__ZCTRL_RST2                                             (ANAPHY_RXDPLL | 0x00B9)
  // (ReadWrite, Bits 3:0) 
  // 0 - Use CKDT without any delay to reset zone control n - Use CKDT (and SCDT) with given delay n * 256us (default = 12'd5)
  #define BIT_MSK__ZCTRL_RST2__REG_CFG_RI_ZCTL_RST_DLY_B11_B8                        0x0F
  // (ReadWrite, Bits 4) 
  // DC compensation (Alice scheme) enable (default = 1'b0)
  #define BIT_MSK__ZCTRL_RST2__REG_CFG_RI_DC_CP_EN                                   0x10
  // (ReadWrite, Bits 7:5) 
  // Eye monitor use decision matrix (default = 3'b100)
  #define BIT_MSK__ZCTRL_RST2__REG_CFG_RI_DEC_CON                                    0xE0

// DPLL Configuration 7 Register
#define REG_ADDR__DPLL_CFG7                                              (ANAPHY_RXDPLL | 0x00BA)
  // (ReadWrite, Bits 1:0) 
  // Delay of div20sync going to decimator. 2'b00 is the minimum delay and 2'b11 is the maximum (default = 2'b00)
  #define BIT_MSK__DPLL_CFG7__REG_CFG_RI_DIV20_CTRL                                 0x03
  // (ReadWrite, Bits 2) 
  // Use of DE glitch in EQ scanning (default = 1'b0)
  #define BIT_MSK__DPLL_CFG7__REG_CFG_GLT_ON                                        0x04
  // (ReadWrite, Bits 4:3) 
  // PLL mode value (default = 2'b01) 1X MHL mode
  #define BIT_MSK__DPLL_CFG7__REG_CFG_RI_PLL_MODE_I2C                               0x18
  // (ReadWrite, Bits 6:5) 
  // Disable/Enable reset per CKDT and PLL lock (default = 2'b10)
  #define BIT_MSK__DPLL_CFG7__REG_CFG_RI_RST_CON                                    0x60
  // (ReadWrite, Bits 7) 
  // Align DIV3 to SYNC (default = 1'b0)
  #define BIT_MSK__DPLL_CFG7__REG_CFG_RI_SYNC4DIV3                                  0x80

// OLOOP 1 Register
#define REG_ADDR__OLOOP1                                                 (ANAPHY_RXDPLL | 0x00BB)
  // (ReadWrite, Bits 7:0) 
  // PLL open loop settling time (default = 17'd0)
  #define BIT_MSK__OLOOP1__REG_CFG_RI_OLOOP_STIME_B7_B0                          0xFF

// OLOOP 2 Register
#define REG_ADDR__OLOOP2                                                 (ANAPHY_RXDPLL | 0x00BC)
  // (ReadWrite, Bits 7:0) 
  // PLL open loop settling time (default = 17'd0)
  #define BIT_MSK__OLOOP2__REG_CFG_RI_OLOOP_STIME_B15_B8                         0xFF

// ZONE CTRL 1 Register
#define REG_ADDR__ZCTRL_1                                                (ANAPHY_RXDPLL | 0x00BD)
  // (ReadWrite, Bits 0) 
  // PLL open loop settling time (default = 17'd0)
  #define BIT_MSK__ZCTRL_1__REG_CFG_RI_OLOOP_STIME_B16                            0x01
  // (ReadWrite, Bits 4:1) 
  // Zone control parameters (default = 4'b1000) [3 : 2] - zonectl_mode; [1] - strict; [0] - longer
  #define BIT_MSK__ZCTRL_1__REG_CFG_RI_ZONE_CTRL                                  0x1E
  // (ReadWrite, Bits 7:5) 
  // szone value (default = 3'b001)
  #define BIT_MSK__ZCTRL_1__REG_CFG_RI_SZONE_I2C                                  0xE0

// ALT ZONE CTRL 1 Register
#define REG_ADDR__ALT_Z_CTRL1                                            (ANAPHY_RXDPLL | 0x00BE)
  // (ReadWrite, Bits 7:0) 
  // Alternative zone controller control registers from i2c [7:0]
  #define BIT_MSK__ALT_Z_CTRL1__REG_CFG_RI_ALLW_CL_DIV4_B7_B0                         0xFF

// ALT ZONE CTRL 2 and 1x support Register
#define REG_ADDR__ALT_Z_CTRL2                                            (ANAPHY_RXDPLL | 0x00BF)
  // (ReadWrite, Bits 2:0) 
  // Alternative zone controller control registers from i2c [10:8]
  #define BIT_MSK__ALT_Z_CTRL2__REG_CFG_RI_ALLW_CL_DIV4_B10_B8                        0x07
  // (ReadWrite, Bits 3) 
  // MHL 1X mode (default 1 to support Link clock at 1x)
  #define BIT_MSK__ALT_Z_CTRL2__MHL1X_MODE                                            0x08
  // (ReadWrite, Bits 4) 
  // auto zone support for 1x Link clock
  #define BIT_MSK__ALT_Z_CTRL2__REG_RI_AUTO_ZONE_MHL1X                                0x10
  // (ReadWrite, Bits 5) 
  // Always in 1x zone control mode (0 for autozone control)
  #define BIT_MSK__ALT_Z_CTRL2__REG_RI_ALWAYS_1X_MHL1X                                0x20
  // (ReadWrite, Bits 6) 
  // 1 - Zone 8x is not used in zone decision;
  #define BIT_MSK__ALT_Z_CTRL2__REG_CFG_RI_NO_ZONE8X                                  0x40
  // (ReadWrite, Bits 7) 
  // 1 - Use new alternative MHL DP (default)  0 - Use conventional MHL DP Even if it's 0 for PP mode; HW automatically uses  new MHL DP
  #define BIT_MSK__ALT_Z_CTRL2__REG_CFG_RI_USE_NEW_MHL                                0x80

// CL REF 1 Register
#define REG_ADDR__CL_REF_CLK1                                            (ANAPHY_RXDPLL | 0x00C0)
  // (ReadWrite, Bits 7:0) 
  // (default = TBD per characterization)
  #define BIT_MSK__CL_REF_CLK1__REG_CFG_RI_ALLW_CL_REF_B7_B0                          0xFF

// CL REF 2 Register
#define REG_ADDR__CL_REF_CLK2                                            (ANAPHY_RXDPLL | 0x00C1)
  // (ReadWrite, Bits 2:0) 
  // (default = TBD per characterization)
  #define BIT_MSK__CL_REF_CLK2__REG_CFG_RI_ALLW_CL_REF_B10_B8                         0x07
  // (ReadWrite, Bits 5) 
  //  
  #define BIT_MSK__CL_REF_CLK2__REG_CFG_RI_ENH_HOP_SM                                 0x20
  // (ReadWrite, Bits 6) 
  //  
  #define BIT_MSK__CL_REF_CLK2__REG_CFG_RI_HOP_SM_IN_SCAN                             0x40
  // (ReadWrite, Bits 7) 
  //  
  #define BIT_MSK__CL_REF_CLK2__REG_CFG_RI_IGN_REOPEN                                 0x80

// OL DIV4 1 Register
#define REG_ADDR__OL_DIV4CLK1                                            (ANAPHY_RXDPLL | 0x00C2)
  // (ReadWrite, Bits 7:0) 
  // (default = TBD per characterization)
  #define BIT_MSK__OL_DIV4CLK1__REG_CFG_RI_ALLW_OL_DIV4_B7_B0                         0xFF

// OL DIV4 2 Register
#define REG_ADDR__OL_DIV4CLK2                                            (ANAPHY_RXDPLL | 0x00C3)
  // (ReadWrite, Bits 2:0) 
  // (default = TBD per characterization)
  #define BIT_MSK__OL_DIV4CLK2__REG_CFG_RI_ALLW_OL_DIV4_B10_B8                        0x07

// OL REF 1 Register
#define REG_ADDR__OL_REF_CLK1                                            (ANAPHY_RXDPLL | 0x00C4)
  // (ReadWrite, Bits 7:0) 
  // (default = TBD per characterization)
  #define BIT_MSK__OL_REF_CLK1__REG_CFG_RI_ALLW_OL_REF_B7_B0                          0xFF

// OL REF 2 Register
#define REG_ADDR__OL_REF_CLK2                                            (ANAPHY_RXDPLL | 0x00C5)
  // (ReadWrite, Bits 2:0) 
  // (default = TBD per characterization)
  #define BIT_MSK__OL_REF_CLK2__REG_CFG_RI_ALLW_OL_REF_B10_B8                         0x07
  // (ReadOnly, Bits 6:3) 
  // Error report (to i2c) [3] - abnormal_empty [2] - abnormal_full [1] - empty [0] - full
  #define BIT_MSK__OL_REF_CLK2__REG_CFG_RO_ERR_RPT                                    0x78

// ZONE VAR 1 Register
#define REG_ADDR__ZONE_VAR1                                              (ANAPHY_RXDPLL | 0x00C6)
  // (ReadWrite, Bits 7:0) 
  // (default = TBD per characterization)
  #define BIT_MSK__ZONE_VAR1__REG_CFG_RI_ALLW_ZONE_VAR_B7_B0                        0xFF

// ZONE VAR 2 Register
#define REG_ADDR__ZONE_VAR2                                              (ANAPHY_RXDPLL | 0x00C7)
  // (ReadWrite, Bits 2:0) 
  // (default = TBD per characterization)
  #define BIT_MSK__ZONE_VAR2__REG_CFG_RI_ALLW_ZONE_VAR_B10_B8                       0x07
  // (ReadOnly, Bits 4:3) 
  // Error report of new alternative DP. [1] - empty [0] - full
  #define BIT_MSK__ZONE_VAR2__REG_CFG_RO_ERR_RPT_ALT                                0x18
  // (ReadWrite, Bits 7:5) 
  // Align turn on/off for 10b BIST
  #define BIT_MSK__ZONE_VAR2__REG_CFG_RI_CTR_ALIGN_OFF                              0xE0

// N RUN CL Register
#define REG_ADDR__N_RUN_CL                                               (ANAPHY_RXDPLL | 0x00C8)
  // (ReadWrite, Bits 7:0) 
  // (default = TBD per characterization)
  #define BIT_MSK__N_RUN_CL__REG_CFG_RI_N_RUN_CL                                   0xFF

// N RUN OL Register
#define REG_ADDR__N_RUN_OL                                               (ANAPHY_RXDPLL | 0x00C9)
  // (ReadWrite, Bits 7:0) 
  // (default = TBD per characterization)
  #define BIT_MSK__N_RUN_OL__REG_CFG_RI_N_RUN_OL                                   0xFF

// N IDLE Register
#define REG_ADDR__N_IDLE                                                 (ANAPHY_RXDPLL | 0x00CA)
  // (ReadWrite, Bits 7:0) 
  // (default = TBD per characterization)
  #define BIT_MSK__N_IDLE__REG_CFG_RI_N_IDLING                                   0xFF

// CMP MON Register
#define REG_ADDR__CMO_MON_PRD                                            (ANAPHY_RXDPLL | 0x00CB)
  // (ReadWrite, Bits 3:0) 
  // (default = TBD per characterization)
  #define BIT_MSK__CMO_MON_PRD__REG_CFG_RI_CMP_PERD                                   0x0F
  // (ReadWrite, Bits 7:4) 
  // (default = TBD per characterization)
  #define BIT_MSK__CMO_MON_PRD__REG_CFG_RI_MON_PERD                                   0xF0

// INIT DLY Register
#define REG_ADDR__INT_PRMBL                                              (ANAPHY_RXDPLL | 0x00CC)
  // (ReadWrite, Bits 3:0) 
  // (default = TBD per characterization)
  #define BIT_MSK__INT_PRMBL__REG_CFG_RI_INIT_DLY                                   0x0F
  // (ReadWrite, Bits 7:4) 
  // # of DI preamble for auto 1080p mode detection Max is 8 (default = 4'd6)
  #define BIT_MSK__INT_PRMBL__REG_CFG_RI_PRMBL_THRSHLD                              0xF0

// DPLL MISC Register
#define REG_ADDR__DPLL_MISC                                              (ANAPHY_RXDPLL | 0x00CD)
  // (ReadWrite, Bits 0) 
  // 1 - Enable additional BCH code to MHL 2x mode 0 - No BCH code (default = 1'b0) 
  #define BIT_MSK__DPLL_MISC__REG_CFG_RI_BCH_CODE_EN                                0x01
  // (ReadWrite, Bits 1) 
  // 1 - Auto detection of 1080p (2x) mode 0 - Manual mode Auto mode is removed from MHL spec So this should be 1'b0 (default = 1'b0)
  #define BIT_MSK__DPLL_MISC__REG_CFG_RI_M1080P_DET_EN                              0x02
  // (ReadWrite, Bits 2) 
  // mode_1080p value from user. If m1080p_det_en is 0; m1080p_val becomes mode_1080p output       (default = 1'b0; i.e. 3X mode)
  #define BIT_MSK__DPLL_MISC__REG_CFG_RI_M1080P_VAL                                 0x04
  // (ReadWrite, Bits 3) 
  // overriding m1080p_val using register method (default from CBUS status register) default is disable
  #define BIT_MSK__DPLL_MISC__REG_CFG_RI_M1080P_VAL_OVR                             0x08
  // (ReadWrite, Bits 4) 
  // 0 - Use external div20sync (current scheme) 1 - Use internally generated one (new scheme) (default = 1'b1) 
  #define BIT_MSK__DPLL_MISC__REG_CFG_RI_USE_INT_DIV20                              0x10
  // (ReadWrite, Bits 5) 
  // Zone control algorithm selection (default = 1'b0) 0 - Current one; 1 - Alternative one 
  #define BIT_MSK__DPLL_MISC__REG_CFG_RI_ZONE_ALG_SEL                               0x20
  // (ReadWrite, Bits 6) 
  // 0 - Eye is not considered in Zone/EQ reseting 1 - Iff eye = 0s; we reset Zone and EQ (default = 1'b1)
  #define BIT_MSK__DPLL_MISC__REG_CFG_RI_ZONE_EQ_RST_CON                            0x40
  // (ReadWrite, Bits 7) 
  // Zone controller and EQ controller reset enable per the scan value (default = 1'b0) 
  #define BIT_MSK__DPLL_MISC__REG_CFG_RI_ZONE_EQ_RST_EN                             0x80

// DPLL STATUS1 Register
#define REG_ADDR__DPLL_STATUS1                                           (ANAPHY_RXDPLL | 0x00CE)
  // (ReadOnly, Bits 4:0) 
  // Monitoring bp for debugging 
  #define BIT_MSK__DPLL_STATUS1__RO_BP_OUT_B                                           0x1F
  // (ReadOnly, Bits 5) 
  // Engine decision output of channel B 
  #define BIT_MSK__DPLL_STATUS1__RO_B_EDOUT                                            0x20
  // (ReadOnly, Bits 6) 
  // Engine decision output of channel G 
  #define BIT_MSK__DPLL_STATUS1__RO_G_EDOUT                                            0x40
  // (ReadOnly, Bits 7) 
  // Engine decision output of channel R 
  #define BIT_MSK__DPLL_STATUS1__RO_R_EDOUT                                            0x80

// DPLL STATUS2 Register
#define REG_ADDR__DPLL_STATUS2                                           (ANAPHY_RXDPLL | 0x00CF)
  // (ReadOnly, Bits 4:0) 
  // Monitoring bp for debugging 
  #define BIT_MSK__DPLL_STATUS2__RO_BP_OUT_G                                           0x1F
  // (ReadOnly, Bits 6:5) 
  // PLL mode 
  #define BIT_MSK__DPLL_STATUS2__RO_PLL_MODE_OUT                                       0x60
  // (ReadOnly, Bits 7) 
  // MHL SYNC monitor
  #define BIT_MSK__DPLL_STATUS2__RO_SYNC_MON                                           0x80

// DPLL STATUS3 Register
#define REG_ADDR__DPLL_STATUS3                                           (ANAPHY_RXDPLL | 0x00D0)
  // (ReadOnly, Bits 4:0) 
  // Monitoring bp for debugging 
  #define BIT_MSK__DPLL_STATUS3__RO_BP_OUT_R                                           0x1F
  // (ReadOnly, Bits 5) 
  // EQ scan stable indicator of channel_b
  #define BIT_MSK__DPLL_STATUS3__RO_STABLE_O_B                                         0x20
  // (ReadOnly, Bits 6) 
  // EQ scan stable indicator of channel_g
  #define BIT_MSK__DPLL_STATUS3__RO_STABLE_O_G                                         0x40
  // (ReadOnly, Bits 7) 
  // EQ scan stable indicator of channel_r
  #define BIT_MSK__DPLL_STATUS3__RO_STABLE_O_R                                         0x80

// DPLL STATUS4 Register
#define REG_ADDR__DPLL_STATUS4                                           (ANAPHY_RXDPLL | 0x00D1)
  // (ReadOnly, Bits 3:0) 
  // Eye open info for B 
  #define BIT_MSK__DPLL_STATUS4__RO_EOPEN_B                                            0x0F
  // (ReadOnly, Bits 7:4) 
  // Eye open info for G
  #define BIT_MSK__DPLL_STATUS4__RO_EOPEN_G                                            0xF0

// DPLL STATUS5 Register
#define REG_ADDR__DPLL_STATUS5                                           (ANAPHY_RXDPLL | 0x00D2)
  // (ReadOnly, Bits 3:0) 
  // Eye open info for R
  #define BIT_MSK__DPLL_STATUS5__RO_EOPEN_R                                            0x0F
  // (ReadOnly, Bits 4) 
  // 1 - MHL PP (2x) mode and 0 - other mode
  #define BIT_MSK__DPLL_STATUS5__RO_MODE_1080P                                         0x10
  // (ReadOnly, Bits 7:5) 
  // zone control value
  #define BIT_MSK__DPLL_STATUS5__RO_SZONE                                              0xE0

// DPLL STATUS6 Register
#define REG_ADDR__DPLL_STATUS6                                           (ANAPHY_RXDPLL | 0x00D3)
  // (ReadOnly, Bits 7:0) 
  // PLL B/W value from DEQ
  #define BIT_MSK__DPLL_STATUS6__RO_BV_DEQ                                             0xFF

// DPLL STATUS7 Register
#define REG_ADDR__DPLL_STATUS7                                           (ANAPHY_RXDPLL | 0x00D4)
  // (ReadOnly, Bits 7:0) 
  // PLL EQ value of channel b from DEQ
  #define BIT_MSK__DPLL_STATUS7__RO_EV_DEQ_B                                           0xFF

// DPLL STATUS8 Register
#define REG_ADDR__DPLL_STATUS8                                           (ANAPHY_RXDPLL | 0x00D5)
  // (ReadOnly, Bits 7:0) 
  // PLL EQ value of channel g from DEQ
  #define BIT_MSK__DPLL_STATUS8__RO_EV_DEQ_G                                           0xFF

// DPLL STATUS9 Register
#define REG_ADDR__DPLL_STATUS9                                           (ANAPHY_RXDPLL | 0x00D6)
  // (ReadOnly, Bits 7:0) 
  // PLL EQ value of channel r from DEQ
  #define BIT_MSK__DPLL_STATUS9__RO_EV_DEQ_R                                           0xFF

// DPLL STATUS10 Register
#define REG_ADDR__DPLL_STATUS10                                          (ANAPHY_RXDPLL | 0x00D7)
  // (ReadOnly, Bits 7:0) 
  // Current scanning indicator of channel b
  #define BIT_MSK__DPLL_STATUS10__RO_SCAN_VAL_B                                         0xFF

// DPLL STATUS11 Register
#define REG_ADDR__DPLL_STATUS11                                          (ANAPHY_RXDPLL | 0x00D8)
  // (ReadOnly, Bits 7:0) 
  // Current scanning indicator of channel g
  #define BIT_MSK__DPLL_STATUS11__RO_SCAN_VAL_G                                         0xFF

// DPLL STATUS12 Register
#define REG_ADDR__DPLL_STATUS12                                          (ANAPHY_RXDPLL | 0x00D9)
  // (ReadOnly, Bits 7:0) 
  // Current scanning indicator of channel r
  #define BIT_MSK__DPLL_STATUS12__RO_SCAN_VAL_R                                         0xFF

// Calibration OTP Oscillator Compare Register
#define REG_ADDR__DPLL_STATUS13                                          (ANAPHY_RXDPLL | 0x00DA)
  // (ReadOnly, Bits 7:0) 
  // Internal eye monitor
  #define BIT_MSK__DPLL_STATUS13__RO_EDGE_DET                                           0xFF

// DPLLMHL3 OFIFO ERR Low Byte Register
#define REG_ADDR__DPLLM3_OFEL                                            (ANAPHY_RXDPLL | 0x00DB)
  // (ReadOnly, Bits 7:0) 
  // OSD FIFO error report
  #define BIT_MSK__DPLLM3_OFEL__RO_DPLL_OFIFO_ERR_B7_B0                               0xFF

// DPLLMHL3 OFIFO ERR High Byte Register
#define REG_ADDR__DPLLM3_OFEH                                            (ANAPHY_RXDPLL | 0x00DC)
  // (ReadOnly, Bits 3:0) 
  // OSD FIFO error report
  #define BIT_MSK__DPLLM3_OFEH__RO_DPLL_OFIFO_ERR_B11_B8                              0x0F

// DPLLMHL3 CFG Register
#define REG_ADDR__DPLLM3_CFG                                             (ANAPHY_RXDPLL | 0x00DD)
  // (ReadWrite, Bits 0) 
  // MHL3(1)/other(0) overwriting when ri_mhl3m_ovr is 1
  #define BIT_MSK__DPLLM3_CFG__REG_DPLL_MHL3M_VAL                                    0x01
  // (ReadWrite, Bits 1) 
  // 1 - Overwirte MHL3 mode w/ ri_mhl3m_val   0 - MHL3 based on external input (default)
  #define BIT_MSK__DPLLM3_CFG__REG_DPLL_MHL3M_OVR                                    0x02
  // (ReadWrite, Bits 2) 
  // ri_algn_4sync
  #define BIT_MSK__DPLLM3_CFG__REG_DPLL_ALGN_4SYNC                                   0x04
  // (ReadWrite, Bits 4:3) 
  // 0 - MHL3 1 lane; 1 - MHL3 2 lanes; 2 - MHL3 3 lanes
  #define BIT_MSK__DPLLM3_CFG__REG_DPLL_MHL3_NLN                                     0x18
  // (ReadWrite, Bits 5) 
  // Control the bit order for 8b10b decoder input   0 - No swap (default) and 1 - Swap
  #define BIT_MSK__DPLLM3_CFG__REG_DPLL_8B10B_SWAP                                   0x20
  // (ReadWrite, Bits 7:6) 
  // AV link code in MHL3; 1 - 8b10b and 0 - TMDS
  #define BIT_MSK__DPLLM3_CFG__REG_DPLL_8B10B_CODE                                   0xC0

// DPLLMHL3 BP FIX B Register
#define REG_ADDR__DPLLM3_BP_B                                            (ANAPHY_RXDPLL | 0x00DE)
  // (ReadWrite, Bits 4:0) 
  // bp fix value of b channel
  #define BIT_MSK__DPLLM3_BP_B__REG_DPLL_BP_FIX_VAL_B                                 0x1F

// DPLLMHL3 BP FIX G Register
#define REG_ADDR__DPLLM3_BP_G                                            (ANAPHY_RXDPLL | 0x00DF)
  // (ReadWrite, Bits 4:0) 
  // bp fix value of g channel
  #define BIT_MSK__DPLLM3_BP_G__REG_DPLL_BP_FIX_VAL_G                                 0x1F

// DPLLMHL3 BP FIX R Register
#define REG_ADDR__DPLLM3_BP_R                                            (ANAPHY_RXDPLL | 0x00E0)
  // (ReadWrite, Bits 4:0) 
  // bp fix value of r channel
  #define BIT_MSK__DPLLM3_BP_R__REG_DPLL_BP_FIX_VAL_R                                 0x1F

// DPLLMHL3 VV Register
#define REG_ADDR__DPLLM3_VV_I2C                                          (ANAPHY_RXDPLL | 0x00E1)
  // (ReadWrite, Bits 7:0) 
  // User specified PI via i2c 
  #define BIT_MSK__DPLLM3_VV_I2C__REG_DPLL_VV_I2C                                       0xFF

// DPLLMHL3 VV CTL Register
#define REG_ADDR__DPLLM3_VV_CTL                                          (ANAPHY_RXDPLL | 0x00E2)
  // (ReadWrite, Bits 0) 
  // Selection of PI between DEQ(0) and i2c(1) 
  #define BIT_MSK__DPLLM3_VV_CTL__REG_DPLL_VV_SEL                                       0x01
  // (ReadWrite, Bits 1) 
  // PLL PI scanning enable 
  #define BIT_MSK__DPLLM3_VV_CTL__REG_DPLL_VTS_ON                                       0x02
  // (ReadWrite, Bits 2) 
  // Enable extended PI searching 
  #define BIT_MSK__DPLLM3_VV_CTL__REG_DPLL_EXT_VTS                                      0x04

// DPLLMHL3 PVT VAL0 Register
#define REG_ADDR__DPLLM3_PVT0                                            (ANAPHY_RXDPLL | 0x00E3)
  // (ReadWrite, Bits 7:0) 
  // one of Pis used in DEQ
  #define BIT_MSK__DPLLM3_PVT0__REG_DPLL_PVT_VAL0                                     0xFF

// DPLLMHL3 PVT VAL1 Register
#define REG_ADDR__DPLLM3_PVT1                                            (ANAPHY_RXDPLL | 0x00E4)
  // (ReadWrite, Bits 7:0) 
  // one of Pis used in DEQ
  #define BIT_MSK__DPLLM3_PVT1__REG_DPLL_PVT_VAL1                                     0xFF

// DPLLMHL3 PVT VAL2 Register
#define REG_ADDR__DPLLM3_PVT2                                            (ANAPHY_RXDPLL | 0x00E5)
  // (ReadWrite, Bits 7:0) 
  // one of Pis used in DEQ
  #define BIT_MSK__DPLLM3_PVT2__REG_DPLL_PVT_VAL2                                     0xFF

// DPLLMHL3 PVT VAL3 Register
#define REG_ADDR__DPLLM3_PVT3                                            (ANAPHY_RXDPLL | 0x00E6)
  // (ReadWrite, Bits 7:0) 
  // one of Pis used in DEQ
  #define BIT_MSK__DPLLM3_PVT3__REG_DPLL_PVT_VAL3                                     0xFF

// DPLLMHL3 MISC0 Register
#define REG_ADDR__DPLLM3_MISC0                                           (ANAPHY_RXDPLL | 0x00E7)
  // (ReadWrite, Bits 0) 
  // DEQ scan order change 
  #define BIT_MSK__DPLLM3_MISC0__REG_DPLL_EQ_SCAN_ORD                                  0x01
  // (ReadWrite, Bits 1) 
  // Use extra interlane deskewer 
  #define BIT_MSK__DPLLM3_MISC0__REG_DPLL_USE_DESKEW                                   0x02
  // (ReadWrite, Bits 2) 
  // OSD FIFO error recovery scheme 
  #define BIT_MSK__DPLLM3_MISC0__REG_DPLL_ERR_RCV                                      0x04
  // (ReadWrite, Bits 3) 
  // OSD FIFO alternative control enable 
  #define BIT_MSK__DPLLM3_MISC0__REG_DPLL_ALT_CTL_EN                                   0x08
  // (ReadWrite, Bits 4) 
  // OSD FIFO use (1) or not use (0) 
  #define BIT_MSK__DPLLM3_MISC0__REG_DPLL_USE_OSD_BUF                                  0x10
  // (ReadWrite, Bits 5) 
  // OSD FIFO recovery mechanism 
  #define BIT_MSK__DPLLM3_MISC0__REG_DPLL_REC_SEL                                      0x20
  // (ReadWrite, Bits 6) 
  // Load o_osd_ext_* for analog tracking 
  #define BIT_MSK__DPLLM3_MISC0__REG_DPLL_OPEN_OBS                                     0x40

// DPLLMHL3 SZONE Register
#define REG_ADDR__DPLLM3_SZONE                                           (ANAPHY_RXDPLL | 0x00E8)
  // (ReadWrite, Bits 0) 
  // 1 - Overwriting ao_szone w/ val_ao_szone (MHL3)      0 - No overwriting (from i2c; default = 1'b0) 
  #define BIT_MSK__DPLLM3_SZONE__REG_DPLL_OVR_AO_SZONE                                 0x01
  // (ReadWrite, Bits 3:1) 
  // ao_szone value from i2c
  #define BIT_MSK__DPLLM3_SZONE__REG_DPLL_VAL_AO_SZONE                                 0x0E

// DPLL BW CTRL 1 Register
#define REG_ADDR__DPLL_BW_CFG1                                           (ANAPHY_RXDPLL | 0x00E9)
  // (ReadWrite, Bits 3:0) 
  // VCOCAL_DEF for MHL  mode (default = 4'b0010)
  #define BIT_MSK__DPLL_BW_CFG1__RI_VCOCAL_DEF_MHL1X                                   0x0F
  // (ReadWrite, Bits 7:4) 
  // VCOCAL_DEF for HDMI mode (default = 4'b0010)
  #define BIT_MSK__DPLL_BW_CFG1__RI_VCOCAL_DEF_HDMI                                    0xF0

// DPLL BW CTRL 2 Register
#define REG_ADDR__DPLL_BW_CFG2                                           (ANAPHY_RXDPLL | 0x00EA)
  // (ReadWrite, Bits 0) 
  // 1 - Different BW set for MHL and 0 - Same BW set for both of MHL and HDMI (default)
  #define BIT_MSK__DPLL_BW_CFG2__RI_EN_MHL1X_C                                         0x01
  // (ReadWrite, Bits 1) 
  // 1 - Enable to use MEQs in MHL mode and 0 - Always use PEQ regardless of MHL or HDMI
  #define BIT_MSK__DPLL_BW_CFG2__RI_MHL1X_EQ_EN                                        0x02
  // (ReadWrite, Bits 2) 
  // Drives the bit[8] of dpll_eq_ctl_b output of Sherman Digital
  #define BIT_MSK__DPLL_BW_CFG2__RI_EQ_CTL_B                                           0x04
  // (ReadWrite, Bits 3) 
  // Drives the bit[8] of dpll_eq_ctl_g output of Sherman Digital
  #define BIT_MSK__DPLL_BW_CFG2__RI_EQ_CTL_G                                           0x08
  // (ReadWrite, Bits 4) 
  // Drives the bit[8] of dpll_eq_ctl_r output of Sherman Digital
  #define BIT_MSK__DPLL_BW_CFG2__RI_EQ_CTL_R                                           0x10

// MEQ_VAL0 Register
#define REG_ADDR__MEQ_VAL0                                               (ANAPHY_RXDPLL | 0x00EB)
  // (ReadWrite, Bits 7:0) 
  // 1st EQ value in MHL Default value as of now is 8'h20 
  #define BIT_MSK__MEQ_VAL0__REG_CFG_MEQ_VAL0                                      0xFF

// MEQ_VAL1 Register
#define REG_ADDR__MEQ_VAL1                                               (ANAPHY_RXDPLL | 0x00EC)
  // (ReadWrite, Bits 7:0) 
  // 2nd EQ value in MHL Default value as of now is 8'h40 
  #define BIT_MSK__MEQ_VAL1__REG_CFG_MEQ_VAL1                                      0xFF

// MEQ_VAL2 Register
#define REG_ADDR__MEQ_VAL2                                               (ANAPHY_RXDPLL | 0x00ED)
  // (ReadWrite, Bits 7:0) 
  // 3rd EQ value in MHL Default value as of now is 8'h33 
  #define BIT_MSK__MEQ_VAL2__REG_CFG_MEQ_VAL2                                      0xFF

// MEQ_VAL3 Register
#define REG_ADDR__MEQ_VAL3                                               (ANAPHY_RXDPLL | 0x00EE)
  // (ReadWrite, Bits 7:0) 
  // 4th EQ value in MHL Default value as of now is 8'h43 
  #define BIT_MSK__MEQ_VAL3__REG_CFG_MEQ_VAL3                                      0xFF

// DPLL MISC2 Register
#define REG_ADDR__DPLL_MISC2                                             (ANAPHY_RXDPLL | 0x00EF)
  // (ReadWrite, Bits 0) 
  // 1: MHL1x mode and 0: other mode in overwriting (default).
  #define BIT_MSK__DPLL_MISC2__REG_CFG_RI_MHL1X_MODE_VAL                             0x01
  // (ReadWrite, Bits 1) 
  // 1: MHLpp mode and 0: other mode in overwriting (default).
  #define BIT_MSK__DPLL_MISC2__REG_CFG_RI_MHLPP_MODE_VAL                             0x02
  // (ReadWrite, Bits 2) 
  // 1: Overwrite MHL mode (1x or PP) using ri_mhl**_mode_val. 0: MHL mode based on CBUS (default).
  #define BIT_MSK__DPLL_MISC2__REG_CFG_RI_MHL_MODE_OVR                               0x04
  // (ReadWrite, Bits 3) 
  // HDMI(0: default)/MHL(1) overwriting value when ri_hdmim_ovr is 1.
  #define BIT_MSK__DPLL_MISC2__REG_CFG_RI_HDMIM_VAL                                  0x08
  // (ReadWrite, Bits 4) 
  // 1: Overwrite MHL/HDMI mode w/ ri_hdmim_val. 0: MHL/HDMI based on CBUS HW (default).
  #define BIT_MSK__DPLL_MISC2__REG_CFG_RI_HDMIM_OVR                                  0x10
  // (ReadWrite, Bits 6:5) 
  // ao_mhl_test and ao_mhl_pp_en overwriting value (default=2'b00). [1]: ao_mhl_test. [0]: ao_mhl_pp_en
  #define BIT_MSK__DPLL_MISC2__REG_CFG_RI_PLLCON_VAL                                 0x60
  // (ReadWrite, Bits 7) 
  // 1: Overwriting ao_mhl_test and ao_mhl_pp_en w/ ri_pllcon_val. 0: No overwriting (default).
  #define BIT_MSK__DPLL_MISC2__REG_CFG_RI_PLLCON_OVR                                 0x80

// DPLL HDMI2 Register
#define REG_ADDR__DPLL_HDMI2                                             (ANAPHY_RXDPLL | 0x00F0)
  // (ReadWrite, Bits 0) 
  // 1: HDMI2 ON Overwrite with ri_hdmi2_on_val 0: HDMI2 ON value from CBUS/Top
  #define BIT_MSK__DPLL_HDMI2__RI_HDMI2_ON_OVR                                       0x01
  // (ReadWrite, Bits 1) 
  // HDMI2 ON value. Considered only when ri_hdmi2_on_ovr is HIGH.
  #define BIT_MSK__DPLL_HDMI2__RI_HDMI2_ON_VAL                                       0x02
  // (ReadWrite, Bits 2) 
  // 1: Scramble ON Overwrite with ri_scramble_on_val 0: Scramble ON value from CBUS/Top
  #define BIT_MSK__DPLL_HDMI2__RI_SCRAMBLE_ON_OVR                                    0x04
  // (ReadWrite, Bits 3) 
  // Scramble ON value. Considered only when ri_scramble_on_ovr is HIGH.
  #define BIT_MSK__DPLL_HDMI2__RI_SCRAMBLE_ON_VAL                                    0x08
  // (ReadWrite, Bits 4) 
  // Scrambler on only after detecting scrambled stat.
  #define BIT_MSK__DPLL_HDMI2__RI_STAT_AND_ON                                        0x10
  // (ReadWrite, Bits 5) 
  // hdmi2 scdt on
  #define BIT_MSK__DPLL_HDMI2__RI_HDMI2_SCDT_ON                                      0x20

// DPLL PI Control Register
#define REG_ADDR__DPLL_VV_DEQ                                            (ANAPHY_RXDPLL | 0x00F1)
  // (ReadOnly, Bits 7:0) 
  // Contains the PI Control value from DEQ
  #define BIT_MSK__DPLL_VV_DEQ__RO_VV_DEQ                                             0xFF

// DPLL IPS VAL0 Register
#define REG_ADDR__DPLL_IPS_VAL0                                          (ANAPHY_RXDPLL | 0x00F2)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__DPLL_IPS_VAL0__RI_IPS_VAL0                                           0xFF

// DPLL IPS VAL1 Register
#define REG_ADDR__DPLL_IPS_VAL1                                          (ANAPHY_RXDPLL | 0x00F3)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__DPLL_IPS_VAL1__RI_IPS_VAL1                                           0xFF

// DPLL IPS VAL2 Register
#define REG_ADDR__DPLL_IPS_VAL2                                          (ANAPHY_RXDPLL | 0x00F4)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__DPLL_IPS_VAL2__RI_IPS_VAL2                                           0xFF

// DPLL IPS VAL3 Register
#define REG_ADDR__DPLL_IPS_VAL3                                          (ANAPHY_RXDPLL | 0x00F5)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__DPLL_IPS_VAL3__RI_IPS_VAL3                                           0xFF

// DPLL IPS VAL4 Register
#define REG_ADDR__DPLL_IPS_VAL4                                          (ANAPHY_RXDPLL | 0x00F6)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__DPLL_IPS_VAL4__RI_IPS_VAL4                                           0xFF

// DPLL IPS VAL5 Register
#define REG_ADDR__DPLL_IPS_VAL5                                          (ANAPHY_RXDPLL | 0x00F7)
  // (ReadWrite, Bits 7:0) 
  // 
  #define BIT_MSK__DPLL_IPS_VAL5__RI_IPS_VAL5                                           0xFF

// DPLL Control0 Register
#define REG_ADDR__DPLL_CTRL0                                             (ANAPHY_RXDPLL | 0x00F8)
  // (ReadWrite, Bits 1:0) 
  // 
  #define BIT_MSK__DPLL_CTRL0__RI_IPSCON                                             0x03
  // (ReadWrite, Bits 4:2) 
  // 
  #define BIT_MSK__DPLL_CTRL0__RI_CLR_ERRCNT                                         0x1C
  // (ReadWrite, Bits 7:5) 
  // 
  #define BIT_MSK__DPLL_CTRL0__RI_CLR_LOCKED                                         0xE0

// DPLL Control1 Register
#define REG_ADDR__DPLL_CTRL1                                             (ANAPHY_RXDPLL | 0x00F9)
  // (ReadWrite, Bits 0) 
  // 
  #define BIT_MSK__DPLL_CTRL1__RI_PERIOD_SEL                                         0x01
  // (ReadWrite, Bits 7:1) 
  // 
  #define BIT_MSK__DPLL_CTRL1__RI_PERIOD_CON                                         0xFE

// DPLL Control2 Register
#define REG_ADDR__DPLL_CTRL2                                             (ANAPHY_RXDPLL | 0x00FA)
  // (ReadWrite, Bits 0) 
  // 
  #define BIT_MSK__DPLL_CTRL2__RI_USE_INV_CLK                                        0x01
  // (ReadWrite, Bits 1) 
  // DPLL IC Soft Reset: This bit controls the Soft Reset of the DPLL for HDMI2 and MHL3 IC Reset. Polarity of this bit in the logic is an Active LOW but the description below is straight forward. 0 - DPLL IC Reset asserted 1 - DPLL IC Reset deasserted
  #define BIT_MSK__DPLL_CTRL2__RI_SW_ICRST_N                                         0x02
  // (ReadWrite, Bits 6:4) 
  // Scrambler Control
  #define BIT_MSK__DPLL_CTRL2__RI_SCRAMBLER_CON                                      0x70

// DPLL Channel Control Register
#define REG_ADDR__DPLL_CH_CTRL                                           (ANAPHY_RXDPLL | 0x00FB)
  // (ReadWrite, Bits 1:0) 
  // Channel Swap: This field controls interpretation of the colour per DPLL input Channel. Value programmed into this register indicates the respective colour of the data received on the respective TMDS lane. The Channel swapping is as per the below values. Value - Ch0  Ch1  Ch2 2'b00 -  B      G       R 2'b01 -  R      B       G 2'b1x -  G      R       B
  #define BIT_MSK__DPLL_CH_CTRL__RI_D_CH_SWAP                                          0x03
  // (ReadWrite, Bits 2) 
  // support flappable connector for MHL3 one lane configuration. 0-Data over CH0(normal mode) (default = 1'b0) 1-Data over CH1(flipping mode)
  #define BIT_MSK__DPLL_CH_CTRL__RI_1CH_FLIP                                           0x04
  // (ReadWrite, Bits 5:3) 
  // Data Line Swap: Each bit of this field controls the data pin usage per DPLL input Channel. Value programmed into each bit controls the line used for data latching/capturing. The Line swapping per Channel is as given below. 0 - Does Not Swap Dp - Dn 1 - Swaps Dp - Dn Channel assignment per bit from MSb to LSB is as given below. {Ch2 Ch1 Ch0}
  #define BIT_MSK__DPLL_CH_CTRL__RI_D_PN_SWAP                                          0x38

// NEW DPLL CFG Register
#define REG_ADDR__NEW_DPLL_CFG                                           (ANAPHY_RXDPLL | 0x00FC)
  // (ReadWrite, Bits 0) 
  // Enable reduced latency option
  #define BIT_MSK__NEW_DPLL_CFG__RI_RED_LAT                                            0x01
  // (ReadWrite, Bits 1) 
  // Enable MHL3+ TDD mode sync detection
  #define BIT_MSK__NEW_DPLL_CFG__RI_TDD_MODE                                           0x02
  // (ReadWrite, Bits 2) 
  // Enable limited past upto 16 cycles
  #define BIT_MSK__NEW_DPLL_CFG__RI_ENH_ALGN_FIFO                                      0x04
  // (ReadWrite, Bits 3) 
  // Enable using multi-SYNCs in sync period in MHL+ TDD mode
  #define BIT_MSK__NEW_DPLL_CFG__RI_ALLOW_MSYNC                                        0x08
  // (ReadWrite, Bits 4) 
  // Enable auto EQ per channel for 600MHz+ operation
  #define BIT_MSK__NEW_DPLL_CFG__RI_EQ_PER_CH                                          0x10
  // (ReadWrite, Bits 5) 
  // For TMDS SYNC; enable to look for twp SYNCs instead of one SYNC in TDD mode
  #define BIT_MSK__NEW_DPLL_CFG__RI_TWO_TMDS_SYNC                                      0x20
  // (ReadWrite, Bits 6) 
  // MHL1/2 descrambler ON (if 1); OFF (if 0); deafult is 1'b0
  #define BIT_MSK__NEW_DPLL_CFG__RI_MHL12_SCON                                         0x40

// DPLL SYNC PATTERN TDD #0 Register
#define REG_ADDR__SYNC_PATTERN_TDD_0                                     (ANAPHY_RXDPLL | 0x00FD)
  // (ReadWrite, Bits 7:0) 
  // 10b sync pattern for MHL3+ TDD mode[7:0]
  #define BIT_MSK__SYNC_PATTERN_TDD_0__RI_SYNC_PAT_B7_B0                                     0xFF

// DPLL SYNC PATTERN TDD #1 Register
#define REG_ADDR__SYNC_PATTERN_TDD_1                                     (ANAPHY_RXDPLL | 0x00FE)
  // (ReadWrite, Bits 1:0) 
  // 10b sync pattern for MHL3+ TDD mode[9:8]
  #define BIT_MSK__SYNC_PATTERN_TDD_1__RI_SYNC_PAT_B9_B8                                     0x03

// DPLL DFIFO ERROR STATUS Register
#define REG_ADDR__DPLL_DFIFO_ERROR_STS                                   (ANAPHY_RXDPLL | 0x00FF)
  // (ReadOnly, Bits 3:0) 
  // Error status indication of data fifo; which is added to improve timing
  #define BIT_MSK__DPLL_DFIFO_ERROR_STS__RO_DFIFO_ERR                                          0x0F

//***************************************************************************
// AVLINK_TXZONE. Address: 60
// Tx Zone Ctl0 Register
#define REG_ADDR__TX_ZONE_CTL0                                           (AVLINK_TXZONE | 0x0000)
  // (ReadWrite, Bits 7:0) 
  // Used to decide the zone range. Fixed to 8.
  #define BIT_MSK__TX_ZONE_CTL0__REG_MAX_DIFF_LIMIT                                    0xFF

// Tx Zone Ctl1 Register
#define REG_ADDR__TX_ZONE_CTL1                                           (AVLINK_TXZONE | 0x0001)
  // (ReadWrite, Bits 7:0) 
  //   Zone control parameters (from i2c; default = 6'b00000)   [7:6]    : df_tap   [5]    : mult_comp   [4]    : sel_cecclk   [3:2]    : zonectl_mode   [1]    : strict   [0]    : longer   After transition state; it should be programmed to 4'b10** thru   i2c for normal PLL operation
  #define BIT_MSK__TX_ZONE_CTL1__REG_TX_ZONE_CTRL                                      0xFF

// Tx Zone Ctl2 Register
#define REG_ADDR__TX_ZONE_CTL2                                           (AVLINK_TXZONE | 0x0002)
  // (ReadWrite, Bits 1:0) 
  // MHL2 Tx zone select from I2C 00: 1x Zone 01: 2x Zone 10: 4x Zone 11: 8x Zone
  #define BIT_MSK__TX_ZONE_CTL2__REG_TX_ZONE                                           0x03
  // (ReadOnly, Bits 7:6) 
  // MHL2 Tx zone status 00: 1x Zone 01: 2x Zone 10: 4x Zone 11: 8x Zone
  #define BIT_MSK__TX_ZONE_CTL2__REG_TX_ZONE_SEL                                       0xC0

// Tx Zone Ctl3 Register
#define REG_ADDR__TX_ZONE_CTL3                                           (AVLINK_TXZONE | 0x0003)
  // (ReadOnly, Bits 5:0) 
  // [5]    : overflow flag [4:0]    : counter
  #define BIT_MSK__TX_ZONE_CTL3__HRV_ZONE_CTRL3                                        0x3F
  // (ReadWrite, Bits 7:6) 
  // [7]    : run reference clock counter   : reg_tx_zone_ctrl3[1] [6]    : clear reference clock counter : reg_tx_zone_ctrl3[0]
  #define BIT_MSK__TX_ZONE_CTL3__REG_TX_ZONE_CTRL3                                     0xC0

// TX Zone Ctl 4 Register
#define REG_ADDR__TX_ZONE_CTL4                                           (AVLINK_TXZONE | 0x0004)
  // (ReadWrite, Bits 3:2) 
  // Select frequency ratio betweeen hdmi_clk and pxl_clk 2'b00 0.5x mode. hdmi_clk_freq = 0.5*pxl_clk_freq 2'b01 1x mode. hdmi_clk_freq = 1*pxl_clk_freq (default) 2'b10 2x mode. hdmi_clk_freq = 2*pxl_clk_freq 2'b11 4x mode. hdmi_clk_freq = 4*pxl_clk_freq
  #define BIT_MSK__TX_ZONE_CTL4__REG_HDMI_CLK_RATIO                                    0x0C

// TX Zone Ctl 5 Register
#define REG_ADDR__TX_ZONE_CTL5                                           (AVLINK_TXZONE | 0x0005)
  // (ReadWrite, Bits 3) 
  // measure enable signal for zone control. when enable;  pll is in open loop
  #define BIT_MSK__TX_ZONE_CTL5__REG_MEAS_FVCO                                         0x08
  // (ReadWrite, Bits 7) 
  // Enable clock detect
  #define BIT_MSK__TX_ZONE_CTL5__REG_CLKDETECT_EN                                      0x80

// Zone VCO Control Register
#define REG_ADDR__TX_ZONEVCO_CTL                                         (AVLINK_TXZONE | 0x0006)
  // (ReadWrite, Bits 0) 
  // 1 to start auto zone calculation.  To start next calculation, it should be cleared first and asserted.
  #define BIT_MSK__TX_ZONEVCO_CTL__REG_ZONEVCO_START                                     0x01
  // (ReadWrite, Bits 2) 
  // 1 to overide zone control select
  #define BIT_MSK__TX_ZONEVCO_CTL__REG_TX_ZONE_SEL_OVR                                   0x04
  // (ReadWrite, Bits 4:3) 
  // zone select when overide is set to 1
  #define BIT_MSK__TX_ZONEVCO_CTL__REG_TX_ZONE_SEL                                       0x18
  // (ReadWrite, Bits 5) 
  // 1 to overide pll lock
  #define BIT_MSK__TX_ZONEVCO_CTL__REG_PLL_LK_OVR                                        0x20
  // (ReadWrite, Bits 6) 
  // pll lock when overide is set
  #define BIT_MSK__TX_ZONEVCO_CTL__REG_PLL_LK                                            0x40

// MHL3 CTS Control Register
#define REG_ADDR__MHL3CTS_CTL                                            (AVLINK_TXZONE | 0x0007)
  // (ReadWrite, Bits 1) 
  // Select MHL3 CTS operation mode 1 - 3 lanes (default) 0 - 2 lanes
  #define BIT_MSK__MHL3CTS_CTL__REG_MHL3CTS_3LANE                                     0x02
  // (ReadWrite, Bits 3:2) 
  // Select the output clock for MHL3 CTS 00 - 1/2 of link clock when reg_mhl3cts_3lane = 1'b0 or 1/3 of link clock when reg_mhl3cts_3lane = 1'b1 01 - 1/4 of link clock when reg_mhl3cts_3lane = 1'b0 or 1/6 of link clock when reg_mhl3cts_3lane = 1'b1 10 - 1/8 of link clock when reg_mhl3cts_3lane = 1'b0 or 1/12 of link clock when reg_mhl3cts_3lane = 1'b1 (default) 11 - 1/16 of link clock when reg_mhl3cts_3lane = 1'b0 or 1/24 of link clock when reg_mhl3cts_3lane = 1'b1
  #define BIT_MSK__MHL3CTS_CTL__REG_MHL3CTS_CLKOUT_SEL                                0x0C
  // (ReadWrite, Bits 4) 
  // Select MHL3 CTS operation mode 1 - 1 lanes (default) 0 - up to reg_mhl3cts_3lane (0xB4[1])
  #define BIT_MSK__MHL3CTS_CTL__REG_MHL3CTS_1LANE                                     0x10
  // (ReadWrite, Bits 6) 
  // Enable MHL3 CTS Snoop mode
  #define BIT_MSK__MHL3CTS_CTL__REG_COC_DOC_SNOOP_EN                                  0x40
  // (ReadWrite, Bits 7) 
  // Enable MHL3 CTS mode
  #define BIT_MSK__MHL3CTS_CTL__REG_MHL3CTS_EN                                        0x80

// TX X BIST CNTL Register
#define REG_ADDR__TX_XBIST_CNTL                                          (AVLINK_TXZONE | 0x0008)
  // (ReadWrite, Bits 0) 
  // select bist data path to serializer
  #define BIT_MSK__TX_XBIST_CNTL__REG_BIST_SEL                                          0x01
  // (ReadWrite, Bits 1) 
  // 1'b0  txbist is disabled.    (default value)1'b1 -  txbist is enabled.   
  #define BIT_MSK__TX_XBIST_CNTL__REG_BIST_EN                                           0x02
  // (ReadWrite, Bits 2) 
  // 1'b1 - divide clock by 2
  #define BIT_MSK__TX_XBIST_CNTL__REG_HALF_CLK_SEL                                      0x04
  // (ReadWrite, Bits 3) 
  // Make AV link data speed 4x slower. 1 = enable
  #define BIT_MSK__TX_XBIST_CNTL__REG_QUARTER_CLK_SEL                                   0x08
  // (ReadWrite, Bits 5) 
  // Disable create signature if = 1'b1
  #define BIT_MSK__TX_XBIST_CNTL__REG_DISABLE_ENC                                       0x20
  // (ReadWrite, Bits 6) 
  // Backward compatibility for previous version.
  #define BIT_MSK__TX_XBIST_CNTL__REG_LEGACY                                            0x40

// TX X BIST INST LOW Register
#define REG_ADDR__TX_XBIST_INST_LOW                                      (AVLINK_TXZONE | 0x0009)
  // (ReadWrite, Bits 7:0) 
  // 11-bit Instruction register for Red Green and Blue channels. LSB 8 bits here and 2 bits to follow
  #define BIT_MSK__TX_XBIST_INST_LOW__REG_INSTRUCTION_B7_B0                                 0xFF

// TX X BIST INST HIGH Register
#define REG_ADDR__TX_XBIST_INST_HIGH                                     (AVLINK_TXZONE | 0x000A)
  // (ReadWrite, Bits 2:0) 
  // 11-bit Instruction register for Red Green and Blue channels. LSB 8 bits here and 2 bits to follow
  #define BIT_MSK__TX_XBIST_INST_HIGH__REG_INSTRUCTION_B10_B8                                0x07

// TX X BIST PATTERN LOW Register
#define REG_ADDR__TX_XBIST_PAT_LOW                                       (AVLINK_TXZONE | 0x000B)
  // (ReadWrite, Bits 7:0) 
  // pattern control register for Red Green and Blue channels.
  #define BIT_MSK__TX_XBIST_PAT_LOW__REG_PATTERN_B7_B0                                     0xFF

// TX X BIST PATTERN HIGH Register
#define REG_ADDR__TX_XBIST_PAT_HIGH                                      (AVLINK_TXZONE | 0x000C)
  // (ReadWrite, Bits 1:0) 
  // pattern control register for Red Green and Blue channels.
  #define BIT_MSK__TX_XBIST_PAT_HIGH__REG_PATTERN_B9_B8                                     0x03

// TX X BIST CONFIGURE LOW Register
#define REG_ADDR__TX_XBIST_CONF_LOW                                      (AVLINK_TXZONE | 0x000D)
  // (ReadWrite, Bits 7:0) 
  // TBA
  #define BIT_MSK__TX_XBIST_CONF_LOW__REG_CONFIGURE_B7_B0                                   0xFF

// TX X BIST CONFIGURE HIGH Register
#define REG_ADDR__TX_XBIST_CONF_HIGH                                     (AVLINK_TXZONE | 0x000E)
  // (ReadWrite, Bits 1:0) 
  // TBA
  #define BIT_MSK__TX_XBIST_CONF_HIGH__REG_CONFIGURE_B9_B8                                   0x03

// TX X BIST STATUS Register
#define REG_ADDR__TX_XBIST_STATUS                                        (AVLINK_TXZONE | 0x000F)
  // (ReadOnly, Bits 7:0) 
  // bit 1 and 0 for channel 0; bit 3 and 2 for channel 1; bit 5 and 4 for channel 3, bit 7 and 6 for channel 4. 00 : tx bist is disable. 01 : tx bist is enable. 10 : tx bist is running. 11 : tx bist is done.
  #define BIT_MSK__TX_XBIST_STATUS__BIST_STATE                                            0xFF

// TX XBIST Test Period Count Register
#define REG_ADDR__TX_XBIST_PAT_PERIOD_CNT                                (AVLINK_TXZONE | 0x0010)
  // (ReadWrite, Bits 7:0) 
  // Number of specified test to be repeated ( 3    reg_period_cnt    255 ) for rand1; rand2; DC and hs10Bus
  #define BIT_MSK__TX_XBIST_PAT_PERIOD_CNT__REG_PAT_PERIOD_CNT_B7_B0                              0xFF

// HDMI Control 0 Register
#define REG_ADDR__HDMICTL0                                               (AVLINK_TXZONE | 0x0011)
  // (ReadWrite, Bits 0) 
  // 1:  Bit swap Q data out from HDMI2 encoder 0:  No swap (default)
  #define BIT_MSK__HDMICTL0__REG_Q_9T0                                             0x01
  // (ReadWrite, Bits 1) 
  // 1:  Has 4 full channels (RGB; CK) (default) 0:  Force CK channel to all zero
  #define BIT_MSK__HDMICTL0__REG_USE_CH_MUX                                        0x02
  // (ReadWrite, Bits 2) 
  // 1:  Invert tx bit  for ch0;1;2CK 0:  Normal (default)
  #define BIT_MSK__HDMICTL0__REG_TX_BIT_INV                                        0x04

// HDMI Control 1 Register
#define REG_ADDR__HDMICTL1                                               (AVLINK_TXZONE | 0x0012)
  // (ReadWrite, Bits 2:0) 
  // 000:  select ch0 001:  select ch1 010:  select ch2 011:  select ch3 100:  select ch4 101:  select ch5 110:  select ck
  #define BIT_MSK__HDMICTL1__REG_Q0_SEL                                            0x07
  // (ReadWrite, Bits 5:3) 
  // 000:  select ch0 001:  select ch1 010:  select ch2 011:  select ch3 100:  select ch4 101:  select ch5 110:  select ck
  #define BIT_MSK__HDMICTL1__REG_Q1_SEL                                            0x38

// HDMI Control 2 Register
#define REG_ADDR__HDMICTL2                                               (AVLINK_TXZONE | 0x0013)
  // (ReadWrite, Bits 2:0) 
  // 000:  select ch0 001:  select ch1 010:  select ch2 011:  select ch3 100:  select ch4 101:  select ch5 110:  select ck
  #define BIT_MSK__HDMICTL2__REG_Q2_SEL                                            0x07
  // (ReadWrite, Bits 5:3) 
  // 000:  select ch0 001:  select ch1 010:  select ch2 011:  select ch3 100:  select ch4 101:  select ch5 110:  select ck
  #define BIT_MSK__HDMICTL2__REG_Q3_SEL                                            0x38

// HDMI Control 3 Register
#define REG_ADDR__HDMICTL3                                               (AVLINK_TXZONE | 0x0014)
  // (ReadWrite, Bits 2:0) 
  // 000:  select ch0 001:  select ch1 010:  select ch2 011:  select ch3 100:  select ch4 101:  select ch5 110:  select ck
  #define BIT_MSK__HDMICTL3__REG_Q4_SEL                                            0x07
  // (ReadWrite, Bits 5:3) 
  // 000:  select ch0 001:  select ch1 010:  select ch2 011:  select ch3 100:  select ch4 101:  select ch5 110:  select ck
  #define BIT_MSK__HDMICTL3__REG_Q5_SEL                                            0x38

// HDMI Control 4 Register
#define REG_ADDR__HDMICTL4                                               (AVLINK_TXZONE | 0x0015)
  // (ReadWrite, Bits 2:0) 
  // 000:  select ch0 001:  select ch1 010:  select ch2 011:  select ch3 100:  select ch4 101:  select ch5 110:  select ck
  #define BIT_MSK__HDMICTL4__REG_QC_SEL                                            0x07

// AVLINK SW Reset Register
#define REG_ADDR__SW_RST                                                 (AVLINK_TXZONE | 0x0016)
  // (ReadWrite, Bits 2) 
  // Software reset for MHL3 CTS logic 1 - Reset 0 - Normal operation (default)
  #define BIT_MSK__SW_RST__REG_MHL3CTS_RST                                       0x04

// ZONE CTRL_0 Register
#define REG_ADDR__TX_ZONE_CTRL_0                                            (AVLINK_TXZONE | 0x0080)
  // (ReadWrite, Bits 0) 
  // 1 to start auto zone calculation. To start next calculation it should be cleared first and asserted
  #define BIT_MSK__TX_ZONE_CTRL_0__RI_ZONE_ST                                            0x01
  // (ReadWrite, Bits 1) 
  // select the zone calcuation start.  0 is hardware start. 1 is register start
  #define BIT_MSK__TX_ZONE_CTRL_0__RI_ZONE_ST_SEL                                        0x02
  // (ReadWrite, Bits 3:2) 
  // 2bit register signal to select when ocnt is stopped for zone calculation. 00: 512 is selected 01: 256 is selected 10: 128 is selected 11: 64 is selected
  #define BIT_MSK__TX_ZONE_CTRL_0__RI_OCNT_STP                                           0x0C
  // (ReadWrite, Bits 5:4) 
  // Register 0x02 0x03 read out signals select. 00: ro_zone_cnt; 01: ro_precnt; 10: ro_pstcnt; 11: ro_oclk_in_pclk
  #define BIT_MSK__TX_TX_ZONE_CTRL_0__RI_DEBUG_SEL                                          0x30

// ZONE STATUS_0 Register
#define REG_ADDR__TX_ZONE_STATUS_0                                          (AVLINK_TXZONE | 0x0081)
  // (ReadOnly, Bits 0) 
  // It is high when zone input clock is high than 1G
  #define BIT_MSK__TX_ZONE_STATUS_0__RO_F1G                                                0x01
  // (ReadOnly, Bits 3:1) 
  // 3bit zone control value.
  #define BIT_MSK__TX_ZONE_STATUS_0__RO_SZONE                                              0x0E
  // (ReadOnly, Bits 7) 
  // pll lock status. 1 indicate pll locked. It is enabled if ri_lkdt_en
  #define BIT_MSK__TX_ZONE_STATUS_0__RO_PLL_LK                                             0x80

// Debug_0 Register
#define REG_ADDR__TX_DEBUG_0                                                (AVLINK_TXZONE | 0x0082)
  // (ReadOnly, Bits 7:0) 
  // Output debug signals according to register 0x00[5:4]. 00: ro_zone_cnt[15:0]; 01: ro_precnt[15:0]; 10: ro_pstcnt[15:0]; 11: ro_oclk_in_pclk[15:0].
  #define BIT_MSK__TX_DEBUG_0__RO_DEBUG_B7_B0                                        0xFF

// Debug_1 Register
#define REG_ADDR__TX_DEBUG_1                                                (AVLINK_TXZONE | 0x0083)
  // (ReadOnly, Bits 7:0) 
  // Output debug signals according to register 0x00[5:4]. 00: ro_zone_cnt[15:0]; 01: ro_precnt[15:0]; 10: ro_pstcnt[15:0]; 11: ro_oclk_in_pclk[15:0].
  #define BIT_MSK__TX_DEBUG_1__RO_DEBUG_B15_B8                                       0xFF

// VCOCAL CTRL_0 Register
#define REG_ADDR__TX_VCOCAL_CTRL_0                                          (AVLINK_TXZONE | 0x0084)
  // (ReadWrite, Bits 0) 
  // 1bit register signal to start vcocal. To start next calculation it should be cleared first and asserted.
  #define BIT_MSK__TX_VCOCAL_CTRL_0__RI_VCOCAL_ST                                          0x01
  // (ReadWrite, Bits 1) 
  // select the VCOCAL start.  0 is hardware start. 1 is register start
  #define BIT_MSK__TX_VCOCAL_CTRL_0__RI_VCOCAL_ST_SEL                                      0x02
  // (ReadWrite, Bits 4:2) 
  // 3bit register signal to select the wait time from vcocal update to next vcocal calibration 000: 16us is selected 001: 8us is selected 010: 4us is selected 011:2us is selected 100:2us is selected 101:? 
  #define BIT_MSK__TX_VCOCAL_CTRL_0__RI_OCNTV_WAIT                                         0x1C
  // (ReadWrite, Bits 7:5) 
  // 3bit register signal to select when ocntv is stopped for vcocal update. 1 clock cycle is 200ns. 000: 512 Clock cycle is selected 001: 256 Clock cycle is selected 010: 128 Clock cycle is selected 011: 64 Clock cycle is selected 100: 32 Clock cycle is selected 
  #define BIT_MSK__TX_VCOCAL_CTRL_0__RI_OCNTV_STP                                          0xE0

// VCOCAL STATUS_0 Register
#define REG_ADDR__TX_VCOCAL_STATUS_0                                        (AVLINK_TXZONE | 0x0085)
  // (ReadOnly, Bits 3:0) 
  // Calibrated VCO value. 4bits signals with PHY
  #define BIT_MSK__TX_VCOCAL_STATUS_0__RO_VCOCAL                                             0x0F

// PRECLK_FORCE_CTL Register
#define REG_ADDR__TX_PRECLK_FORCE_CTL                                       (AVLINK_TXZONE | 0x0086)
  // (ReadWrite, Bits 0) 
  // 1: When preclk is not stable force the whole zone vco block to reset.
  #define BIT_MSK__TX_PRECLK_FORCE_CTL__RI_FRCRSTN_EN                                         0x01
  // (ReadWrite, Bits 1) 
  // 1: Enable watch dog force idle function and force FSM to idle state.
  #define BIT_MSK__TX_PRECLK_FORCE_CTL__RI_FRCIDLE_EN                                         0x02
  // (ReadWrite, Bits 2) 
  // 1: SW forces FSM to idle state.
  #define BIT_MSK__TX_PRECLK_FORCE_CTL__RI_FRCIDLE_SW                                         0x04
  // (ReadWrite, Bits 3) 
  // 1: Enable watch dog force reset function and force the whole zone vco block to reset.
  #define BIT_MSK__TX_PRECLK_FORCE_CTL__RI_FRCIDLE_RSTN_EN                                    0x08
  // (ReadWrite, Bits 4) 
  // 1:  Register ro_oclk_in_pclk is oclk5m counter value in preclk N cycles 
  #define BIT_MSK__TX_PRECLK_FORCE_CTL__RI_OCLKPCLK_EN                                        0x10

// PRECLK_CNT_MAX Register
#define REG_ADDR__TX_PRECLK_CNT_MAX                                         (AVLINK_TXZONE | 0x0087)
  // (ReadWrite, Bits 7:0) 
  // The max value of preclk counter. Internal counter max = {ri_preclk_cnt_max; 8'h0}-1.
  #define BIT_MSK__TX_PRECLK_CNT_MAX__RI_PRECLK_CNT_MAX                                     0xFF

// OCLK_CNT_MAX Register
#define REG_ADDR__TX_OCLK_CNT_MAX                                           (AVLINK_TXZONE | 0x0088)
  // (ReadWrite, Bits 7:0) 
  // The max value of oclk5m counter. Preclk is out of range when oclk5m counter [ri_oclk5m_cnt_min or ]{ri_oclk5m_cnt_max; 8'h0}.
  #define BIT_MSK__TX_OCLK_CNT_MAX__RI_OCLK5M_CNT_MAX                                     0xFF

// OCLK_CNT_MIN Register
#define REG_ADDR__TX_OCLK_CNT_MIN                                           (AVLINK_TXZONE | 0x0089)
  // (ReadWrite, Bits 7:0) 
  // The min value of oclk5m counter. Preclk is out of range when oclk5m counter [ri_oclk5m_cnt_min or ]{ri_oclk5m_cnt_max; 8'h0}.
  #define BIT_MSK__TX_OCLK_CNT_MIN__RI_OCLK5M_CNT_MIN                                     0xFF

// PRE_DIVIDER Register
#define REG_ADDR__TX_PRE_DIV                                                (AVLINK_TXZONE | 0x008A)
  // (ReadOnly, Bits 4:0) 
  // 5bit pre-divider based on vcocal
  #define BIT_MSK__TX_PRE_DIV__RO_DIV_PRE                                            0x1F

// POST_DIVIDER Register
#define REG_ADDR__TX_POST_DIV                                               (AVLINK_TXZONE | 0x008B)
  // (ReadOnly, Bits 6:0) 
  // 7bit post-divider based on vcocal
  #define BIT_MSK__TX_POST_DIV__RO_DIV_PST                                            0x7F

// VCOCAL STATUS_1 Register
#define REG_ADDR__TX_VCOCAL_STATUS_1                                        (AVLINK_TXZONE | 0x008C)
  // (ReadOnly, Bits 3:0) 
  // Charge pump number select based on vcocal  0000:0; 0001:1;0011:2;1111:4
  #define BIT_MSK__TX_VCOCAL_STATUS_1__RO_I_SEL                                              0x0F
  // (ReadOnly, Bits 7:4) 
  // Bias control for pump current control based on vcocal 0000:0.5x; 0101:0.75x;1010:1.0x; 1111:1.25
  #define BIT_MSK__TX_VCOCAL_STATUS_1__RO_BIAS_BGR_D                                         0xF0

// PLL_MODE0 Register
#define REG_ADDR__TX_PLL_MODE0                                              (AVLINK_TXZONE | 0x008D)
  // (ReadWrite, Bits 0) 
  // pll_mode over write enable
  #define BIT_MSK__TX_PLL_MODE0__RI_PLL_MODE_OW_EN                                     0x01
  // (ReadWrite, Bits 2:1) 
  // pll_mode value for over write
  #define BIT_MSK__TX_PLL_MODE0__RI_PLL_MODE_OW                                        0x06
  // (ReadOnly, Bits 4:3) 
  // pll mode status during zone_vco
  #define BIT_MSK__TX_PLL_MODE0__RO_PLL_MODE                                           0x18
  // (ReadWrite, Bits 6) 
  // hdmi/mhl select overwrite enable
  #define BIT_MSK__TX_PLL_MODE0__RI_HDMI_MHLN_SEL_OW_EN                                0x40
  // (ReadWrite, Bits 7) 
  // HDMI/MHL select for overwrite
  #define BIT_MSK__TX_PLL_MODE0__RI_HDMI_MHLN_SEL_OW                                   0x80

// SZONE_OW Register
#define REG_ADDR__TX_SZONE_OW                                               (AVLINK_TXZONE | 0x008E)
  // (ReadWrite, Bits 0) 
  // Szone over write enable
  #define BIT_MSK__TX_SZONE_OW__RI_ZONE_OW_EN                                         0x01
  // (ReadWrite, Bits 3:1) 
  // szone value for over write
  #define BIT_MSK__TX_SZONE_OW__RI_ZONE_OW                                            0x0E
  // (ReadWrite, Bits 4) 
  // TX/RX select overwrite enable
  #define BIT_MSK__TX_SZONE_OW__RI_TX_RXN_SEL_OW_EN                                   0x10
  // (ReadWrite, Bits 5) 
  // TX/RX select for overwrite
  #define BIT_MSK__TX_SZONE_OW__RI_TX_RXN_SEL_OW                                      0x20
  // (ReadWrite, Bits 6) 
  // Shinny mode enable
  #define BIT_MSK__TX_SZONE_OW__RI_SHINNY_EN                                          0x40

// ISEL_OW Register
#define REG_ADDR__TX_ISEL_OW                                                (AVLINK_TXZONE | 0x008F)
  // (ReadWrite, Bits 0) 
  // isel over write enable
  #define BIT_MSK__TX_ISEL_OW__RI_ISEL_OW_EN                                         0x01
  // (ReadWrite, Bits 4:1) 
  // isel value for over write
  #define BIT_MSK__TX_ISEL_OW__RI_ISEL_OW                                            0x1E

// BIAS_BGR Register
#define REG_ADDR__TX_BIAS_BGR_D                                             (AVLINK_TXZONE | 0x0090)
  // (ReadWrite, Bits 0) 
  // bias_bgr_d over write enable
  #define BIT_MSK__TX_BIAS_BGR_D__RI_BIAS_BGR_D_OW_EN                                   0x01
  // (ReadWrite, Bits 4:1) 
  // bias_bgr_d  value for over write
  #define BIT_MSK__TX_BIAS_BGR_D__RI_BIAS_BGR_D_OW                                      0x1E

// DIV_PRE_OW Register
#define REG_ADDR__TX_DIV_PRE_OW                                             (AVLINK_TXZONE | 0x0091)
  // (ReadWrite, Bits 0) 
  // div_pre over write enable
  #define BIT_MSK__TX_DIV_PRE_OW__RI_DIV_PRE_OW_EN                                      0x01
  // (ReadWrite, Bits 5:1) 
  // div_pre value for over write
  #define BIT_MSK__TX_DIV_PRE_OW__RI_DIV_PRE_OW                                         0x3E

// DIV_PST_OW Register
#define REG_ADDR__TX_DIV_PST_OW                                             (AVLINK_TXZONE | 0x0092)
  // (ReadWrite, Bits 0) 
  // div_pst over write enable
  #define BIT_MSK__TX_DIV_PST_OW__RI_DIV_PST_OW_EN                                      0x01
  // (ReadWrite, Bits 7:1) 
  // div_pst value for over write
  #define BIT_MSK__TX_DIV_PST_OW__RI_DIV_PST_OW                                         0xFE

// VCOCAL_OW Register
#define REG_ADDR__TX_VCOCAL_OW                                              (AVLINK_TXZONE | 0x0093)
  // (ReadWrite, Bits 0) 
  // vco over write enable
  #define BIT_MSK__TX_VCOCAL_OW__RI_VCOCAL_OW_EN                                       0x01
  // (ReadWrite, Bits 4:1) 
  // vco value for over write
  #define BIT_MSK__TX_VCOCAL_OW__RI_VCOCAL_OW                                          0x1E
  // (ReadWrite, Bits 7) 
  // 1/16 vco cal enable. The mode is enable when ri_vcocal_st_sel is 1.
  #define BIT_MSK__TX_VCOCAL_OW__RI_1VCOCAL_EN                                         0x80

// ZONE_INTR Register
#define REG_ADDR__TX_ZONE_INTR                                              (AVLINK_TXZONE | 0x0094)
  // (ReadWrite, Bits 0) 
  // 
  #define BIT_MSK__TX_ZONE_INTR__REG_ZONE_DONE                                         0x01
  // (ReadWrite, Bits 1) 
  // 
  #define BIT_MSK__TX_ZONE_INTR__REG_VCOCAL_DONE                                       0x02
  // (ReadWrite, Bits 2) 
  // 
  #define BIT_MSK__TX_ZONE_INTR__REG_LKDT_TIMEOUT                                      0x04
  // (ReadWrite, Bits 3) 
  // pll lock intr
  #define BIT_MSK__TX_ZONE_INTR__REG_PLL_LK                                            0x08
  // (ReadWrite, Bits 4) 
  // preclk abnormal intr
  #define BIT_MSK__TX_ZONE_INTR__REG_PRECLK_ABN                                        0x10
  // (ReadWrite, Bits 5) 
  // preclk stable intr
  #define BIT_MSK__TX_ZONE_INTR__REG_PRECLK_STB                                        0x20

// ZONE_INTR_MASK Register
#define REG_ADDR__TX_ZONE_INTR_MASK                                         (AVLINK_TXZONE | 0x0095)
  // (ReadWrite, Bits 0) 
  // INTR mask for reg_zone_done
  #define BIT_MSK__TX_ZONE_INTR_MASK__RI_MASK0                                              0x01
  // (ReadWrite, Bits 1) 
  // INTR mask for reg_vcocal_done
  #define BIT_MSK__TX_ZONE_INTR_MASK__RI_MASK1                                              0x02
  // (ReadWrite, Bits 2) 
  // INTR mask for reg_lkdt_timeout
  #define BIT_MSK__TX_ZONE_INTR_MASK__RI_MASK2                                              0x04
  // (ReadWrite, Bits 3) 
  // 
  #define BIT_MSK__TX_ZONE_INTR_MASK__RI_MASK3                                              0x08
  // (ReadWrite, Bits 4) 
  // 
  #define BIT_MSK__TX_ZONE_INTR_MASK__RI_MASK4                                              0x10
  // (ReadWrite, Bits 5) 
  // 
  #define BIT_MSK__TX_ZONE_INTR_MASK__RI_MASK5                                              0x20

// ZONE_CTRL_1 Register
#define REG_ADDR__TX_ZONE_CTRL_1                                            (AVLINK_TXZONE | 0x0096)
  // (ReadWrite, Bits 7:0) 
  // 7: mhl12_pp mode enable. 6: mhl3tdd 3.6G or 6G select. 1 is 3.6G 5: mhl3 tdd mode enable 4. mhl3 enable 3:2: mhl3 TX mode ref clock select 00: 24Mhz; 01: 30Mhz; 10:240Mhz 1:0: Shinny mode ref clock select
  #define BIT_MSK__TX_ZONE_CTRL_1__RI_ZONECTRL_1                                         0xFF

// ZONE_CTRL_2 Register
#define REG_ADDR__TX_ZONE_CTRL_2                                            (AVLINK_TXZONE | 0x0097)
  // (ReadWrite, Bits 7:0) 
  // [0]: ri_rx_hdmi2p0; [1]: ri_rx_doc; [2]: ri_tx_hdmi_db; [3]: ri_rx_doc_75m; [4]: ri_otzv_en; [5]: ri_dbg_vcocal_en
  #define BIT_MSK__TX_ZONE_CTRL_2__RI_ZONECTRL_2                                         0xFF

// PLL_LK_DLY Register
#define REG_ADDR__TX_PLL_LK_DLY                                             (AVLINK_TXZONE | 0x0098)
  // (ReadWrite, Bits 7:0) 
  // pll_lk delay time: {ri_pll_lk_dly; 3'b111}
  #define BIT_MSK__TX_PLL_LK_DLY__RI_PLL_LK_DLY                                         0xFF

// LKDT_CTRL_0 Register
#define REG_ADDR__TX_LKDT_CTRL_0                                            (AVLINK_TXZONE | 0x0099)
  // (ReadWrite, Bits 1:0) 
  // 2bit register signal to select 5M oclk cycles for lockdetect counter 00: 64 01: 128  10:256 11:512 
  #define BIT_MSK__TX_LKDT_CTRL_0__RI_OCNTL_STP                                          0x03
  // (ReadWrite, Bits 3:2) 
  // 2bit register signal to select 5M oclk cycles after 1 lockdetect is finined and before next starte 00:10  01: 20  10: 40 11: 80
  #define BIT_MSK__TX_LKDT_CTRL_0__RI_OCNTLW_STP                                         0x0C
  // (ReadWrite, Bits 6) 
  // 1 to enable lockdetect check. When it is enabled  pll_unlk report the status of PLL UNLOCK. If ri_autozv_en  when pll unlock HW automatically start the zone calculation and VCO calibration again.
  #define BIT_MSK__TX_LKDT_CTRL_0__RI_LKDT_EN                                            0x40
  // (ReadWrite, Bits 7) 
  // 1 to enable auto zonevco calibration. If pll unlock it will enable new zone/vco calibration. 
  #define BIT_MSK__TX_LKDT_CTRL_0__RI_AUTOZV_EN                                          0x80

// LKDT_CTRL1 Register
#define REG_ADDR__TX_LKDT_CTRL1                                             (AVLINK_TXZONE | 0x009A)
  // (ReadWrite, Bits 7:0) 
  // Threshold for LKDT timeout. If number of timeout reaches threshold reg_lkdt_timeout interrupt is generated
  #define BIT_MSK__TX_LKDT_CTRL1__RI_LKDT_TO                                            0xFF

// LKDT_CTRL2 Register
#define REG_ADDR__TX_LKDT_CTRL2                                             (AVLINK_TXZONE | 0x009B)
  // (ReadWrite, Bits 7:0) 
  // The threshold ref and fb clock counter difference to indicate pll unlock
  #define BIT_MSK__TX_LKDT_CTRL2__RI_LKDT_DIFF_B7_B0                                    0xFF

// LKDT_CTRL3 Register
#define REG_ADDR__TX_LKDT_CTRL3                                             (AVLINK_TXZONE | 0x009C)
  // (ReadWrite, Bits 7:0) 
  // The threshold ref and fb clock counter difference to indicate pll unlock
  #define BIT_MSK__TX_LKDT_CTRL3__RI_LKDT_DIFF_B15_B8                                   0xFF

// OCLK_CNT_THR Register
#define REG_ADDR__TX_OCLK_CNT_THR                                           (AVLINK_TXZONE | 0x009D)
  // (ReadWrite, Bits 7:0) 
  // The threshold of oclk5m counter. Preclk is not stable when oclk5m counter difference is bigger than the threshold.
  #define BIT_MSK__TX_OCLK_CNT_THR__RI_OCLK5M_CNT_THR                                     0xFF

// ZVTIMER_MAX Register
#define REG_ADDR__TX_ZVTIMER_MAX                                            (AVLINK_TXZONE | 0x009E)
  // (ReadWrite, Bits 7:0) 
  // zvtimer max value {ri_zvtimer_max; 8'h0}.
  #define BIT_MSK__TX_ZVTIMER_MAX__RI_ZVTIMER_MAX                                        0xFF

// ZVSTATE Register 
#define REG_ADDR__TX_ZVSTATE                                                (AVLINK_TXZONE | 0x009F)
  // (ReadOnly, Bits 2:0) 
  // 
  #define BIT_MSK__TX_ZVSTATE__RO_ZVSTATE                                            0x07
  // (ReadOnly, Bits 4:3) 
  // 
  #define BIT_MSK__TX_ZVSTATE__RO_VSTATE                                             0x18
  // (ReadOnly, Bits 5) 
  // 
  #define BIT_MSK__TX_ZVSTATE__PRECLK_ABN                                            0x20
  // (ReadWrite, Bits 6) 
  // 1: diffrence threshold is calculated internally. 0: diffrence threshold is setting through register 0x1D.
  #define BIT_MSK__TX_ZVSTATE__RI_DIFF_THR_CAL_EN                                    0x40
  // (ReadWrite, Bits 7) 
  // 1: enable vcocal_adj function; 0: disable 
  #define BIT_MSK__TX_ZVSTATE__RI_VCO_ADJ_EN                                         0x80

// VCOCAL ADJUST Register 
#define REG_ADDR__TX_VCOCAL_ADJ                                             (AVLINK_TXZONE | 0x00A0)
  // (ReadWrite, Bits 3:0) 
  // [3]: 0: vcocal final value  (0[[F) =calculated vcocal value + ri_vcocal_adj[2:0].        1: vcocal final value  (0[[F) =calculated vcocal value - ri_vcocal_adj[2:0].
  #define BIT_MSK__TX_VCOCAL_ADJ__RI_VCOCAL_ADJ                                         0x0F
  // (ReadWrite, Bits 4) 
  // 0: f50m_chk final value=calculated value + ri_f50m_chk_adj[7:0]. 1: f50m_chk final value=calculated value - ri_f50m_chk_adj[7:0] (if less than 0; =0).
  #define BIT_MSK__TX_VCOCAL_ADJ__RI_F50M_CHK_ADJ_8                                     0x10
  // (ReadWrite, Bits 5) 
  // 0: f100m_chk final value=calculated value + ri_f100m_chk_adj[7:0]. 1: f100m_chk final value=calculated value - ri_f100m_chk_adj[7:0] (if less than 0; =0).
  #define BIT_MSK__TX_VCOCAL_ADJ__RI_F100M_CHK_ADJ_8                                    0x20
  // (ReadWrite, Bits 6) 
  // 0: f200m_chk final value=calculated value + ri_f200m_chk_adj[7:0]. 1: f200m_chk final value=calculated value - ri_f200m_chk_adj[7:0] (if less than 0; =0).
  #define BIT_MSK__TX_VCOCAL_ADJ__RI_F200M_CHK_ADJ_8                                    0x40
  // (ReadWrite, Bits 7) 
  // 0: f400m_chk final value=calculated value + ri_f400m_chk_adj[7:0]. 1: f400m_chk final value=calculated value - ri_f400m_chk_adj[7:0] (if less than 0; =0).
  #define BIT_MSK__TX_VCOCAL_ADJ__RI_F400M_CHK_ADJ_8                                    0x80

// ZONECAL ADJUST_0 Register 
#define REG_ADDR__TX_ZONECAL_ADJ_0                                          (AVLINK_TXZONE | 0x00A1)
  // (ReadWrite, Bits 7:0) 
  // Refer to register 0x20[4].
  #define BIT_MSK__TX_ZONECAL_ADJ_0__RI_F50M_CHK_ADJ                                       0xFF

// ZONECAL ADJUST_1 Register 
#define REG_ADDR__TX_ZONECAL_ADJ_1                                          (AVLINK_TXZONE | 0x00A2)
  // (ReadWrite, Bits 7:0) 
  // Refer to register 0x20[5].
  #define BIT_MSK__TX_ZONECAL_ADJ_1__RI_F100M_CHK_ADJ                                      0xFF

// ZONECAL ADJUST_2 Register 
#define REG_ADDR__TX_ZONECAL_ADJ_2                                          (AVLINK_TXZONE | 0x00A3)
  // (ReadWrite, Bits 7:0) 
  // Refer to register 0x20[6].
  #define BIT_MSK__TX_ZONECAL_ADJ_2__RI_F200M_CHK_ADJ                                      0xFF

// ZONECAL ADJUST_3 Register 
#define REG_ADDR__TX_ZONECAL_ADJ_3                                          (AVLINK_TXZONE | 0x00A4)
  // (ReadWrite, Bits 7:0) 
  // Refer to register 0x20[7].
  #define BIT_MSK__TX_ZONECAL_ADJ_3__RI_F400M_CHK_ADJ                                      0xFF

//***************************************************************************
// COCSRC. Address: 60
// CoC 1st Status Register
#define REG_ADDR__COC_STAT_0                                             (COCSRC | 0x0000)
  // (ReadOnly, Bits 5:0) 
  // CoC status 1st byte
  #define BIT_MSK__COC_STAT_0__COC_STATUS0_B5_B0                                     0x3F
  // (ReadOnly, Bits 6) 
  // bit_error 8b/10 error
  #define BIT_MSK__COC_STAT_0__COC_STATUS0_B6                                        0x40
  // (ReadOnly, Bits 7) 
  // lock; PLL lock status
  #define BIT_MSK__COC_STAT_0__COC_STATUS0_B7                                        0x80

// CoC 2nd Status Register
#define REG_ADDR__COC_STAT_1                                             (COCSRC | 0x0001)
  // (ReadOnly, Bits 5:0) 
  // dt_tmax0: Sink data rising edge position
  #define BIT_MSK__COC_STAT_1__COC_STATUS1_B5_B0                                     0x3F
  // (ReadOnly, Bits 7:6) 
  // CoC status 2nd byte
  #define BIT_MSK__COC_STAT_1__COC_STATUS1_B7_B6                                     0xC0

// CoC 3rd Status Register
#define REG_ADDR__COC_STAT_2                                             (COCSRC | 0x0002)
  // (ReadOnly, Bits 5:0) 
  // dt_tmax1: Sink data falling edge position
  #define BIT_MSK__COC_STAT_2__COC_STATUS2_B5_B0                                     0x3F
  // (ReadOnly, Bits 7:6) 
  // CoC status 3rd byte
  #define BIT_MSK__COC_STAT_2__COC_STATUS2_B7_B6                                     0xC0

// CoC 4th Status Register
#define REG_ADDR__COC_STAT_3                                             (COCSRC | 0x0003)
  // (ReadOnly, Bits 7:0) 
  // CoC internal register read back. Please refer to coc_control15[3:0]
  #define BIT_MSK__COC_STAT_3__COC_STATUS3_B7_B0                                     0xFF

// CoC 5th Status Register
#define REG_ADDR__COC_STAT_4                                             (COCSRC | 0x0004)
  // (ReadOnly, Bits 7:0) 
  // CoC internal register read back. Please refer to coc_control[6:4]
  #define BIT_MSK__COC_STAT_4__COC_STATUS4_B7_B0                                     0xFF

// CoC 6th Status Register
#define REG_ADDR__COC_STAT_5                                             (COCSRC | 0x0005)
  // (ReadOnly, Bits 7:0) 
  // CoC internal register read back. Please refer to coc_control[6:4]
  #define BIT_MSK__COC_STAT_5__COC_STATUS5_B7_B0                                     0xFF

// CoC 7th Status Register
#define REG_ADDR__COC_STAT_6                                             (COCSRC | 0x0006)
  // (ReadOnly, Bits 0) 
  // meas_Aout_done
  #define BIT_MSK__COC_STAT_6__COC_STATUS6_B0                                        0x01
  // (ReadOnly, Bits 1) 
  // meas_Ain_done
  #define BIT_MSK__COC_STAT_6__COC_STATUS6_B1                                        0x02
  // (ReadOnly, Bits 2) 
  // meas_Aoffset_done
  #define BIT_MSK__COC_STAT_6__COC_STATUS6_B2                                        0x04
  // (ReadOnly, Bits 3) 
  // received comma1
  #define BIT_MSK__COC_STAT_6__COC_STATUS6_B3                                        0x08
  // (ReadOnly, Bits 4) 
  // received comma2
  #define BIT_MSK__COC_STAT_6__COC_STATUS6_B4                                        0x10
  // (ReadOnly, Bits 5) 
  // DAC stable1 done
  #define BIT_MSK__COC_STAT_6__COC_STATUS6_B5                                        0x20
  // (ReadOnly, Bits 6) 
  // received sink side signal
  #define BIT_MSK__COC_STAT_6__COC_STATUS6_B6                                        0x40
  // (ReadOnly, Bits 7) 
  // Calibration done indicator
  #define BIT_MSK__COC_STAT_6__COC_STATUS6_B7                                        0x80

// CoC 8th Status Register
#define REG_ADDR__COC_STAT_7                                             (COCSRC | 0x0007)
  // (ReadOnly, Bits 7:0) 
  // CoC internal register read back. Please refer to coc_control[6:4]
  #define BIT_MSK__COC_STAT_7__COC_STATUS7_B7_B0                                     0xFF

// CoC 9th Status Register
#define REG_ADDR__COC_STAT_8                                             (COCSRC | 0x0008)
  // (ReadOnly, Bits 7:0) 
  // BIST error cnt[7:0]. Please refer to 0x709[3:0]
  #define BIT_MSK__COC_STAT_8__COC_STATUS8_B7_B0                                     0xFF

// CoC 10th Status Register
#define REG_ADDR__COC_STAT_9                                             (COCSRC | 0x0009)
  // (ReadOnly, Bits 3:0) 
  // BIST error cnt[11:8]. Please refer to 0x708[7:0]
  #define BIT_MSK__COC_STAT_9__COC_STATUS9_B3_B0                                     0x0F
  // (ReadOnly, Bits 4) 
  // BIST done indicator
  #define BIT_MSK__COC_STAT_9__COC_STATUS9_B4                                        0x10
  // (ReadOnly, Bits 5) 
  // decode error
  #define BIT_MSK__COC_STAT_9__COC_STATUS9_B5                                        0x20
  // (ReadOnly, Bits 6) 
  // running disparity error
  #define BIT_MSK__COC_STAT_9__COC_STATUS9_B6                                        0x40
  // (ReadOnly, Bits 7) 
  // code violation error
  #define BIT_MSK__COC_STAT_9__COC_STATUS9_B7                                        0x80

// CoC 11th Status Register
#define REG_ADDR__COC_STAT_A                                             (COCSRC | 0x000A)
  // (ReadOnly, Bits 7:0) 
  // RX 8 bit data after 8b/10b decoder
  #define BIT_MSK__COC_STAT_A__COC_STATUSA_B7_B0                                     0xFF

// CoC 12th Status Register
#define REG_ADDR__COC_STAT_B                                             (COCSRC | 0x000B)
  // (ReadOnly, Bits 7:0) 
  // Rx 10 bit data before 8b/10 decoder LSb[7:0]
  #define BIT_MSK__COC_STAT_B__COC_STATUSB_B7_B0                                     0xFF

// CoC 13th Status Register
#define REG_ADDR__COC_STAT_C                                             (COCSRC | 0x000C)
  // (ReadOnly, Bits 1:0) 
  // Rx 10 bit data before 8b/10b decoder MSb[9:8]
  #define BIT_MSK__COC_STAT_C__COC_STATUSC_B1_B0                                     0x03
  // (ReadOnly, Bits 2) 
  // Rx 8 bit K indicator
  #define BIT_MSK__COC_STAT_C__COC_STATUSC_B2                                        0x04
  // (ReadOnly, Bits 7:3) 
  // CoC status 13th byte
  #define BIT_MSK__COC_STAT_C__COC_STATUSC_B7_B3                                     0xF8

// CoC 14th Status Register
#define REG_ADDR__COC_STAT_D                                             (COCSRC | 0x000D)
  // (ReadOnly, Bits 7:0) 
  // CoC internal register read back. Please refer to coc_control[6:4]
  #define BIT_MSK__COC_STAT_D__COC_STATUSD_B7_B0                                     0xFF

// CoC 15th Status Register
#define REG_ADDR__COC_STAT_E                                             (COCSRC | 0x000E)
  // (ReadOnly, Bits 7:0) 
  // CoC internal register read back. Please refer to coc_control[6:4]
  #define BIT_MSK__COC_STAT_E__COC_STATUSE_B7_B0                                     0xFF

// CoC 16th Status Register
#define REG_ADDR__COC_STAT_F                                             (COCSRC | 0x000F)
  // (ReadOnly, Bits 3:0) 
  // state_COC_FSM: calibration FSM current state
  #define BIT_MSK__COC_STAT_F__COC_STATUSF_B3_B0                                     0x0F
  // (ReadOnly, Bits 7:4) 
  // CoC status 16th byte
  #define BIT_MSK__COC_STAT_F__COC_STATUSF_B7_B4                                     0xF0

// CoC 1st Ctl Register
#define REG_ADDR__COC_CTL0                                               (COCSRC | 0x0010)
  // (ReadWrite, Bits 0) 
  // reg_tx_drv_en: manual tx driver enable
  #define BIT_MSK__COC_CTL0__REG_COC_CONTROL0_B0                                   0x01
  // (ReadWrite, Bits 1) 
  // dgb_av_sel: debug data to AV channel 1: dtx_av 0: drx_av
  #define BIT_MSK__COC_CTL0__REG_COC_CONTROL0_B1                                   0x02
  // (ReadWrite, Bits 2) 
  // rg_cal_en: Enable auto calibration FSM
  #define BIT_MSK__COC_CTL0__REG_COC_CONTROL0_B2                                   0x04
  // (ReadWrite, Bits 4:3) 
  // rg_lpf_sel: LPF Select 11: 7 bit average 10: 5 bit average 01: 3 bit average 00: no LPF
  #define BIT_MSK__COC_CTL0__REG_COC_CONTROL0_B4_B3                                0x18
  // (ReadWrite, Bits 5) 
  // rg_sel_alpha: Select between 1: I2C alpha value 0: auto calibrated alpha value
  #define BIT_MSK__COC_CTL0__REG_COC_CONTROL0_B5                                   0x20
  // (ReadWrite, Bits 6) 
  // rg_sel_cal_auto: Select state value 1: CoC state machine 0: I2C
  #define BIT_MSK__COC_CTL0__REG_COC_CONTROL0_B6                                   0x40
  // (ReadWrite, Bits 7) 
  // coc_150M_en: generate 150 MHz clock for CoC
  #define BIT_MSK__COC_CTL0__REG_COC_CONTROL0_B7                                   0x80

// CoC 2nd Ctl Register
#define REG_ADDR__COC_CTL1                                               (COCSRC | 0x0011)
  // (ReadWrite, Bits 5:0) 
  // rg_coc_fe0: Falling edge position for 0. High for rg_coc_fe0*2 cycles
  #define BIT_MSK__COC_CTL1__REG_COC_CONTROL1_B5_B0                                0x3F
  // (ReadWrite, Bits 7:6) 
  // rg_bist_pattern_msb0: 10 bit MSB 2 bit or K char. Bit 7 and 6 for 2 MSb of 10 bit pattern 0; or 6: 8bit pattern K char
  #define BIT_MSK__COC_CTL1__REG_COC_CONTROL1_B7_B6                                0xC0

// CoC 3rd Ctl Register
#define REG_ADDR__COC_CTL2                                               (COCSRC | 0x0012)
  // (ReadWrite, Bits 5:0) 
  // rg_coc_fe1: Falling edge position for 1. high for rg_coc_fe1*2 cycles
  #define BIT_MSK__COC_CTL2__REG_COC_CONTROL2_B5_B0                                0x3F
  // (ReadWrite, Bits 7:6) 
  // rg_bist_pattern_msb0: 10 bit MSB 2 bit or K char. Bit 7 and 6 for 2 MSb of 10 bit pattern 1; or bit 6 for 8bit pattern K char
  #define BIT_MSK__COC_CTL2__REG_COC_CONTROL2_B7_B6                                0xC0

// CoC 4th Ctl Register
#define REG_ADDR__COC_CTL3                                               (COCSRC | 0x0013)
  // (ReadWrite, Bits 6:0) 
  // dac_stable_time: the clock is 600 MHz if [7] = 0; 100ns/1.6ns/4 = 60/4 = 15 if [7] = 1; 160ns/1.6ns/4 = 100/4 = 25
  #define BIT_MSK__COC_CTL3__REG_COC_CONTROL3_B6_B0                                0x7F
  // (ReadWrite, Bits 7) 
  // DAC step adjust; set [6:0] according to DAC stable time 2 steps each time; requires more DAC stable time 1:2 steps each time; need 160ns DAC stable time 0:1 steps each time; need 100ns DAC stable time
  #define BIT_MSK__COC_CTL3__REG_COC_CONTROL3_B7                                   0x80

// CoC 5th Ctl Register
#define REG_ADDR__COC_CTL4                                               (COCSRC | 0x0014)
  // (ReadWrite, Bits 6:0) 
  // rg_ec_delay: Manual echo cancelling delay parameter. Forsrc 0-89
  #define BIT_MSK__COC_CTL4__REG_COC_CONTROL4_B6_B0                                0x7F
  // (ReadWrite, Bits 7) 
  // rg_ec_delay_sel: Echo cancelling delay select 1: fixed manual echo cancelling 0: calibrate echo cancelling value
  #define BIT_MSK__COC_CTL4__REG_COC_CONTROL4_B7                                   0x80

// CoC 6th Ctl Register
#define REG_ADDR__COC_CTL5                                               (COCSRC | 0x0015)
  // (ReadWrite, Bits 7:0) 
  // CoC control register 6th byte
  #define BIT_MSK__COC_CTL5__REG_COC_CONTROL5                                      0xFF

// CoC 7th Ctl Register
#define REG_ADDR__COC_CTL6                                               (COCSRC | 0x0016)
  // (ReadWrite, Bits 5:0) 
  // rg_smpl_position: Manual sampling position. 0 - 39
  #define BIT_MSK__COC_CTL6__REG_COC_CONTROL6_B5_B0                                0x3F
  // (ReadWrite, Bits 6) 
  // rg_boundary_sel: deserializer boundary position select 1: fixed manual deserializer boundary position 0: calirated deserializer boundary position
  #define BIT_MSK__COC_CTL6__REG_COC_CONTROL6_B6                                   0x40
  // (ReadWrite, Bits 7) 
  // rg_smpl_position_sel: Sampling position select 1: fixed manual sampling position 0: calibrated sampling position
  #define BIT_MSK__COC_CTL6__REG_COC_CONTROL6_B7                                   0x80

// CoC 8th Ctl Register
#define REG_ADDR__COC_CTL7                                               (COCSRC | 0x0017)
  // (ReadWrite, Bits 2:0) 
  // rg_tx_pattern_sel: tx pattern selection 100~111: RSVD 110         : 2 bit interface mode 101         : CTS in non-aligned mode 100         : enable CTS 011         : 10 bit fixed pattern 010         : 8 bit fixed pattern 001         : BIST 000         : Normal mode
  #define BIT_MSK__COC_CTL7__REG_COC_CONTROL7_B2_B0                                0x07
  // (ReadWrite, Bits 4:3) 
  // rg_lb_bist_sel: loopback bit 11: near-end analog loopback bist enabled 10: near-end digital loopback bist enabled 01: far-end loopback bist enabled 00: normal mode
  #define BIT_MSK__COC_CTL7__REG_COC_CONTROL7_B4_B3                                0x18
  // (ReadWrite, Bits 5) 
  // rg_clear_bist_err: clear bist error counter
  #define BIT_MSK__COC_CTL7__REG_COC_CONTROL7_5                                    0x20
  // (ReadWrite, Bits 6) 
  // rg_clear_error: clear 8b/10b error status
  #define BIT_MSK__COC_CTL7__REG_COC_CONTROL7_6                                    0x40
  // (ReadWrite, Bits 7) 
  // reg_error_inject: 8b/10b error inject
  #define BIT_MSK__COC_CTL7__REG_COC_CONTROL7_B7                                   0x80

// CoC 9th Ctl Register
#define REG_ADDR__COC_CTL8                                               (COCSRC | 0x0018)
  // (ReadWrite, Bits 7:0) 
  // CoC control register 9th byte
  #define BIT_MSK__COC_CTL8__REG_COC_CONTROL8                                      0xFF

// CoC 10th Ctl Register
#define REG_ADDR__COC_CTL9                                               (COCSRC | 0x0019)
  // (ReadWrite, Bits 7:0) 
  // reg_bist_pattern_lsb0 For 10 bit fixed pattern 0; {reg_coc_control1[7:6]; reg_control9[7:0] For 8 bit fixed pattern; reg_coc_control1[7:6] should be set to 2'b01
  #define BIT_MSK__COC_CTL9__REG_COC_CONTROL9                                      0xFF

// CoC 11th Ctl Register
#define REG_ADDR__COC_CTLA                                               (COCSRC | 0x001A)
  // (ReadWrite, Bits 7:0) 
  // reg_bist_pattern_lsb1 For 10 bit fixed pattern 1. {reg_coc_control2[7:6]; reg_coc_controlA[7:0]} For 8 bit pattern; reg_coc_control2[7:6] should be set to 2'b01
  #define BIT_MSK__COC_CTLA__REG_COC_CONTROLA                                      0xFF

// CoC 12th Ctl Register
#define REG_ADDR__COC_CTLB                                               (COCSRC | 0x001B)
  // (ReadWrite, Bits 7:0) 
  // rg_max_timeout: calibration maximum timeout time 1.66ns * 2^19 * reg_coc_controlB (0.87ms - 221.9ms)
  #define BIT_MSK__COC_CTLB__REG_COC_CONTROLB                                      0xFF

// CoC 13th Ctl Register
#define REG_ADDR__COC_CTLC                                               (COCSRC | 0x001C)
  // (ReadWrite, Bits 7:0) 
  // rg_min_wait: calibration minimum wait time 1.66ns * 2^8 * reg_coc_controlC (423ns - 107.9us)
  #define BIT_MSK__COC_CTLC__REG_COC_CONTROLC                                      0xFF

// CoC 14th Ctl Register
#define REG_ADDR__COC_CTLD                                               (COCSRC | 0x001D)
  // (ReadWrite, Bits 6:0) 
  // rg_ctrl_vth_h: manual vth_h control; if rg_sel_alpha (reg_coc_control0[5]) is set
  #define BIT_MSK__COC_CTLD__REG_COC_CONTROLD_B6_B0                                0x7F
  // (ReadWrite, Bits 7) 
  // Bit order swap 1: Swap 0: No swap
  #define BIT_MSK__COC_CTLD__REG_COC_CONTROLD_B7                                   0x80

// CoC 15th Ctl Register
#define REG_ADDR__COC_CTLE                                               (COCSRC | 0x001E)
  // (ReadWrite, Bits 6:0) 
  // rg_ctrl_vth_l: manual vth_l control; if rg_sel_alpha (reg_coc_control0[5]) is set
  #define BIT_MSK__COC_CTLE__REG_COC_CONTROLE_B6_B0                                0x7F
  // (ReadWrite, Bits 7) 
  // CoC/DoC control register 15th byte
  #define BIT_MSK__COC_CTLE__REG_COC_CONTROLE_B7                                   0x80

// CoC 16th Ctl Register
#define REG_ADDR__COC_CTLF                                               (COCSRC | 0x001F)
  // (ReadWrite, Bits 7:0) 
  // CoC control register 16th byte
  #define BIT_MSK__COC_CTLF__REG_COC_CONTROLF                                      0xFF

// CoC 17th Ctl Register
#define REG_ADDR__COC_CTL10                                              (COCSRC | 0x0020)
  // (ReadWrite, Bits 3:0) 
  // k_char_1t0_l: default comma K28.1
  #define BIT_MSK__COC_CTL10__REG_COC_CONTROL10_B3_B0                               0x0F
  // (ReadWrite, Bits 7:4) 
  // k_char_1t0_h: default comma K28.5
  #define BIT_MSK__COC_CTL10__REG_COC_CONTROL10_B7_B4                               0xF0

// CoC 18th Ctl Register
#define REG_ADDR__COC_CTL11                                              (COCSRC | 0x0021)
  // (ReadWrite, Bits 3:0) 
  // CoC control register 18th byte
  #define BIT_MSK__COC_CTL11__REG_COC_CONTROL11_B3_B0                               0x0F
  // (ReadWrite, Bits 7:4) 
  // BIST length f: infinite length 8: 13us     - 100 7: 10^8us - 27'h5F5_E100 6: 10^7us - 27'h098_9680 5: 10^6us - 27'h00F_4240 4: 10^5us - 27'h001_86A0 3: 4s         - 27'h1C9_C380 2: 2s         - 27'h0E4_E1C0 1: 1s         - 27'h072_70E0 0: stop
  #define BIT_MSK__COC_CTL11__REG_COC_CONTROL11_B7_B4                               0xF0

// CoC 19th Ctl Register
#define REG_ADDR__COC_CTL12                                              (COCSRC | 0x0022)
  // (ReadWrite, Bits 5:0) 
  // Reserved
  #define BIT_MSK__COC_CTL12__REG_COC_CONTROL12_B5_B0                               0x3F
  // (ReadWrite, Bits 6) 
  // Enable CTS non-aligned mode
  #define BIT_MSK__COC_CTL12__REG_COC_CONTROL12_B6                                  0x40
  // (ReadWrite, Bits 7) 
  // Reserved
  #define BIT_MSK__COC_CTL12__REG_COC_CONTROL12_B7                                  0x80

// CoC 20th Ctl Register
#define REG_ADDR__COC_CTL13                                              (COCSRC | 0x0023)
  // (ReadWrite, Bits 7:0) 
  // Reserved
  #define BIT_MSK__COC_CTL13__REG_COC_CONTROL13                                     0xFF

// CoC 21st Ctl Register
#define REG_ADDR__COC_CTL14                                              (COCSRC | 0x0024)
  // (ReadWrite, Bits 3:0) 
  // dbg_state_COC_FSM: I2C selected state; if rg_cal_en (reg_coc_control0[2]) is not set and reg_coc_control15[7] is set
  #define BIT_MSK__COC_CTL14__REG_COC_CONTROL14_B3_B0                               0x0F
  // (ReadWrite, Bits 7:4) 
  // rg_boundary: deserializer boundary position; if rg_boundary_sel (reg_coc_control6[6] ) is set
  #define BIT_MSK__COC_CTL14__REG_COC_CONTROL14_B7_B4                               0xF0

// CoC 22nd Ctl Register
#define REG_ADDR__COC_CTL15                                              (COCSRC | 0x0025)
  // (ReadWrite, Bits 3:0) 
  // Control what can be read out from status3 1111 - 1011: RSVD 1010: phase adjusted (snk side only) 1001: sap; sampling point - [5:0] 0 - 39 1000: cp; comma pointer - [3:0] 0 - 7 0111: redge_ph (snk side only) 0110: ec_delay - [6:0] 0 - 89 0101: clock rising edge position: dt_redet - [5:0] 0 -39 0100: Aoffset[6:0] 0011: Aout[6:0] 0010: Ain[6:0] 0001: ctrl_vth_h[6:0] 0000: ctrl_vth_l[6:0] RSVD 10: RSVD 01: ec_delay 00: clock rising edge position: dt_redet
  #define BIT_MSK__COC_CTL15__REG_COC_CONTROL15_B3_B0                               0x0F
  // (ReadWrite, Bits 6:4) 
  // Bit 7 related mux selection for internal register read byte 1-5. The read values are on coc_status4 ([39:32]); coc_status5 ([31:24]); coc_status7([23;16]); coc_statusD([15:8]); and coc_statusE([7:0]) 111 - 101: RSVD 100: drx 011: drx_pre 010: ne_del_dtx 001: drx_h_40b_1z 000: drx_l_40b_1z
  #define BIT_MSK__COC_CTL15__REG_COC_CONTROL15_B6_B4                               0x70
  // (ReadWrite, Bits 7) 
  // 150 MHz domain read pulse (auto reset)
  #define BIT_MSK__COC_CTL15__REG_COC_CONTROL15_7                                   0x80

// CoC Interrupt Register
#define REG_ADDR__COC_INTR                                               (COCSRC | 0x0026)
  // (ReadWrite, Bits 0) 
  // COC PLL lock status change interrupt
  #define BIT_MSK__COC_INTR__REG_COC_INTR_STAT0                                    0x01
  // (ReadWrite, Bits 1) 
  // COC Calibration done interrupt
  #define BIT_MSK__COC_INTR__REG_COC_INTR_STAT1                                    0x02
  // (ReadWrite, Bits 2) 
  // COC 8b/10b error interrupt
  #define BIT_MSK__COC_INTR__REG_COC_INTR_STAT2                                    0x04
  // (ReadWrite, Bits 3) 
  // COC calibration state machine received Comma1 interrupt
  #define BIT_MSK__COC_INTR__REG_COC_INTR_STAT3                                    0x08
  // (ReadWrite, Bits 4) 
  // COC calibration state machine received Comma2 interrupt
  #define BIT_MSK__COC_INTR__REG_COC_INTR_STAT4                                    0x10
  // (ReadWrite, Bits 5) 
  // COC calibration state machine timeout interrupt
  #define BIT_MSK__COC_INTR__REG_COC_INTR_STAT5                                    0x20

// CoC Interrupt Mask Register
#define REG_ADDR__COC_INTR_MASK                                          (COCSRC | 0x0027)
  // (ReadWrite, Bits 0) 
  // Interrupt mask for COC PLL lock status change interrupt
  #define BIT_MSK__COC_INTR_MASK__REG_COC_INTR_MASK0                                    0x01
  // (ReadWrite, Bits 1) 
  // Interrupt mask for COC Calibration done interrupt
  #define BIT_MSK__COC_INTR_MASK__REG_COC_INTR_MASK1                                    0x02
  // (ReadWrite, Bits 2) 
  // Interrupt mask for COC 8b/10b error interrupt
  #define BIT_MSK__COC_INTR_MASK__REG_COC_INTR_MASK2                                    0x04
  // (ReadWrite, Bits 3) 
  // Interrupt mask for COC calibration state machine received Comma1 interrupt
  #define BIT_MSK__COC_INTR_MASK__REG_COC_INTR_MASK3                                    0x08
  // (ReadWrite, Bits 4) 
  // Interrupt mask for COC calibration state machine received Comma2 interrupt
  #define BIT_MSK__COC_INTR_MASK__REG_COC_INTR_MASK4                                    0x10
  // (ReadWrite, Bits 5) 
  // Interrupt mask for COC calibration state machine time out interrupt
  #define BIT_MSK__COC_INTR_MASK__REG_COC_INTR_MASK5                                    0x20

// CoC Misc 1st Ctl Register
#define REG_ADDR__COC_MISC_CTL0                                          (COCSRC | 0x0028)
  // (ReadWrite, Bits 0) 
  // Enable to override coc output enable generated by internal state machine
  #define BIT_MSK__COC_MISC_CTL0__REG_COC_OE_OVR                                        0x01
  // (ReadWrite, Bits 1) 
  // If bit 0 is enabled; coc output enable
  #define BIT_MSK__COC_MISC_CTL0__REG_COC_OE                                            0x02
  // (ReadWrite, Bits 2) 
  // Enable to bring DoC debug signal into AV Channel
  #define BIT_MSK__COC_MISC_CTL0__REG_COC_DBG_AV_EN                                     0x04
  // (ReadWrite, Bits 4:3) 
  // When bit 2 is set; select what CoC debug data is put into AV Channel 00: {dtx_av[4:0]; drx_av[4:0]} 01: drx_h_40b[4:0] 10: drx_l_40b[4:0] 11: {dtx_av[4:0]; drx_av[4:0]}
  #define BIT_MSK__COC_MISC_CTL0__REG_COC_DBG_AV_SEL                                    0x18
  // (ReadWrite, Bits 7) 
  // Enable to bring DoC debug signal to GPIO pins
  #define BIT_MSK__COC_MISC_CTL0__REG_COC_DBG_GPIO_EN                                   0x80

// CoC 23rd Ctl Register
#define REG_ADDR__COC_CTL16                                              (COCSRC | 0x0029)
  // (ReadWrite, Bits 7:0) 
  // CoC control 23rd byte
  #define BIT_MSK__COC_CTL16__REG_COC_CONTROL16_B7_B0                               0xFF

// CoC 24th Ctl Register
#define REG_ADDR__COC_CTL17                                              (COCSRC | 0x002A)
  // (ReadWrite, Bits 3:0) 
  // MHL3 Spec timing parameter 0
  #define BIT_MSK__COC_CTL17__REG_COC_CONTROL17_B3_B0                               0x0F
  // (ReadWrite, Bits 7:4) 
  // MHL3 Spec timing parameter 1
  #define BIT_MSK__COC_CTL17__REG_COC_CONTROL17_B7_B4                               0xF0

// CoC 25th Ctl Register
#define REG_ADDR__COC_CTL18                                              (COCSRC | 0x002B)
  // (ReadWrite, Bits 3:0) 
  // MHL3 Spec timing parameter 2
  #define BIT_MSK__COC_CTL18__REG_COC_CONTROL18_B3_B0                               0x0F
  // (ReadWrite, Bits 7:4) 
  // MHL3 Spec timing parameter 3
  #define BIT_MSK__COC_CTL18__REG_COC_CONTROL18_B7_B4                               0xF0

// CoC 26th Ctl Register
#define REG_ADDR__COC_CTL19                                              (COCSRC | 0x002C)
  // (ReadWrite, Bits 3:0) 
  // MHL3 Spec timing parameter 4
  #define BIT_MSK__COC_CTL19__REG_COC_CONTROL19_B3_B0                               0x0F
  // (ReadWrite, Bits 7:4) 
  // MHL3 Spec timing parameter 5
  #define BIT_MSK__COC_CTL19__REG_COC_CONTROL19_B7_B4                               0xF0

// CoC 27th Ctl Register
#define REG_ADDR__COC_CTL1A                                              (COCSRC | 0x002D)
  // (ReadWrite, Bits 1:0) 
  // rg_rx_pattern_sel: rx BIST pattern selection 11: 10bit fixed rx BIST 10: 8bit fixed rx BIST 01: LSFR rx BIST 00: rx BIST disable
  #define BIT_MSK__COC_CTL1A__REG_COC_CONTROL1A_B1_B0                               0x03
  // (ReadWrite, Bits 7:2) 
  // Reserved
  #define BIT_MSK__COC_CTL1A__REG_COC_CONTROL1A_B7_B2                               0xFC

// CoC 28th Ctl Register
#define REG_ADDR__COC_CTL1B                                              (COCSRC | 0x002E)
  // (ReadWrite, Bits 7:0) 
  // Reserved
  #define BIT_MSK__COC_CTL1B__REG_COC_CONTROL1B                                     0xFF

// CoC 29th Ctl Register
#define REG_ADDR__COC_CTL1C                                              (COCSRC | 0x002F)
  // (ReadWrite, Bits 7:0) 
  // Reserved
  #define BIT_MSK__COC_CTL1C__REG_COC_CONTROL1C                                     0xFF

// CoC 30th Ctl Register
#define REG_ADDR__COC_CTL1D                                              (COCSRC | 0x0030)
  // (ReadWrite, Bits 7:0) 
  // Reserved
  #define BIT_MSK__COC_CTL1D__REG_COC_CONTROL1D                                     0xFF

// DoC 1st Status Register
#define REG_ADDR__DOC_STAT_0                                             (COCSRC | 0x0039)
  // (ReadOnly, Bits 5:0) 
  // clock rising edge position
  #define BIT_MSK__DOC_STAT_0__DOC_STATUS0_B7_B0                                     0x3F
  // (ReadOnly, Bits 6) 
  // 8b/10b error
  #define BIT_MSK__DOC_STAT_0__DOC_STATUS0_B6                                        0x40
  // (ReadOnly, Bits 7) 
  // pll lock state
  #define BIT_MSK__DOC_STAT_0__DOC_STATUS0_B7                                        0x80

// DoC 2nd Status Register
#define REG_ADDR__DOC_STAT_1                                             (COCSRC | 0x003A)
  // (ReadOnly, Bits 7:0) 
  // DOC status 2nd byte
  #define BIT_MSK__DOC_STAT_1__DOC_STATUS1_B7_B0                                     0xFF

// DoC 3rd Status Register
#define REG_ADDR__DOC_STAT_2                                             (COCSRC | 0x003B)
  // (ReadOnly, Bits 7:0) 
  // DOC status 3rd byte
  #define BIT_MSK__DOC_STAT_2__DOC_STATUS2_B7_B0                                     0xFF

// DoC 4th Status Register
#define REG_ADDR__DOC_STAT_3                                             (COCSRC | 0x003C)
  // (ReadOnly, Bits 7:0) 
  // DOC status 4th byte
  #define BIT_MSK__DOC_STAT_3__DOC_STATUS3_B7_B0                                     0xFF

// DoC 5th Status Register
#define REG_ADDR__DOC_STAT_4                                             (COCSRC | 0x003D)
  // (ReadOnly, Bits 7:0) 
  // DOC status 5th byte
  #define BIT_MSK__DOC_STAT_4__DOC_STATUS4_B7_B0                                     0xFF

// DoC 6th Status Register
#define REG_ADDR__DOC_STAT_5                                             (COCSRC | 0x003E)
  // (ReadOnly, Bits 7:0) 
  // DOC status 6th byte
  #define BIT_MSK__DOC_STAT_5__DOC_STATUS5_B7_B0                                     0xFF

// DoC 7th Status Register
#define REG_ADDR__DOC_STAT_6                                             (COCSRC | 0x003F)
  // (ReadOnly, Bits 0) 
  // meas_Aout_done
  #define BIT_MSK__DOC_STAT_6__DOC_STATUS6_B0                                        0x01
  // (ReadOnly, Bits 1) 
  // meas_Ain_done
  #define BIT_MSK__DOC_STAT_6__DOC_STATUS6_B1                                        0x02
  // (ReadOnly, Bits 2) 
  // received comma1
  #define BIT_MSK__DOC_STAT_6__DOC_STATUS6_B2                                        0x04
  // (ReadOnly, Bits 3) 
  // received comma2
  #define BIT_MSK__DOC_STAT_6__DOC_STATUS6_B3                                        0x08
  // (ReadOnly, Bits 7:4) 
  // DOC status 7th byte
  #define BIT_MSK__DOC_STAT_6__DOC_STATUS6_B7_B4                                     0xF0

// DoC 8th Status Register
#define REG_ADDR__DOC_STAT_7                                             (COCSRC | 0x0040)
  // (ReadOnly, Bits 7:0) 
  // DOC status 8th byte
  #define BIT_MSK__DOC_STAT_7__DOC_STATUS7_B7_B0                                     0xFF

// DoC 9th Status Register
#define REG_ADDR__DOC_STAT_8                                             (COCSRC | 0x0041)
  // (ReadOnly, Bits 7:0) 
  // BIST error cnt[7:0]
  #define BIT_MSK__DOC_STAT_8__DOC_STATUS8_B7_B0                                     0xFF

// DoC 10th Status Register
#define REG_ADDR__DOC_STAT_9                                             (COCSRC | 0x0042)
  // (ReadOnly, Bits 3:0) 
  // BIST error cnt[15:11]
  #define BIT_MSK__DOC_STAT_9__DOC_STATUS9_B3_B0                                     0x0F
  // (ReadOnly, Bits 4) 
  // BIST error saturate status
  #define BIT_MSK__DOC_STAT_9__DOC_STATUS9_B4                                        0x10
  // (ReadOnly, Bits 5) 
  // decode error
  #define BIT_MSK__DOC_STAT_9__DOC_STATUS9_B5                                        0x20
  // (ReadOnly, Bits 6) 
  // running disparity error
  #define BIT_MSK__DOC_STAT_9__DOC_STATUS9_B6                                        0x40
  // (ReadOnly, Bits 7) 
  // code violation error
  #define BIT_MSK__DOC_STAT_9__DOC_STATUS9_B7                                        0x80

// DoC 11th Status Register
#define REG_ADDR__DOC_STAT_A                                             (COCSRC | 0x0043)
  // (ReadOnly, Bits 7:0) 
  // Rx 8 bit data after 8b/10 decoder
  #define BIT_MSK__DOC_STAT_A__DOC_STATUSA_B7_B0                                     0xFF

// DoC 12th Status Register
#define REG_ADDR__DOC_STAT_B                                             (COCSRC | 0x0044)
  // (ReadOnly, Bits 7:0) 
  // Rx 10 bit pattern [7:0] before 8b/10b decoder
  #define BIT_MSK__DOC_STAT_B__DOC_STATUSB_B7_B0                                     0xFF

// DoC 13th Status Register
#define REG_ADDR__DOC_STAT_C                                             (COCSRC | 0x0045)
  // (ReadOnly, Bits 1:0) 
  // Rx 10 bit data [9:8] before 8b/10 decoder
  #define BIT_MSK__DOC_STAT_C__DOC_STATUSC_B1_B0                                     0x03
  // (ReadOnly, Bits 2) 
  // Rx 8 bit K
  #define BIT_MSK__DOC_STAT_C__DOC_STATUSC_B2                                        0x04
  // (ReadOnly, Bits 3) 
  // Rx 8b/10b decode error
  #define BIT_MSK__DOC_STAT_C__DOC_STATUSC_B3                                        0x08
  // (ReadOnly, Bits 4) 
  // Rx 8b/10b rd error
  #define BIT_MSK__DOC_STAT_C__DOC_STATUSC_B4                                        0x10
  // (ReadOnly, Bits 5) 
  // Rx 8b/10b code error
  #define BIT_MSK__DOC_STAT_C__DOC_STATUSC_B5                                        0x20
  // (ReadOnly, Bits 7:6) 
  // DOC status 14th byte
  #define BIT_MSK__DOC_STAT_C__DOC_STATUSC_B7_B6                                     0xC0

// DoC 14th Status Register
#define REG_ADDR__DOC_STAT_D                                             (COCSRC | 0x0046)
  // (ReadOnly, Bits 7:0) 
  // DOC status 14th byte
  #define BIT_MSK__DOC_STAT_D__DOC_STATUSD_B7_B0                                     0xFF

// DoC 15th Status Register
#define REG_ADDR__DOC_STAT_E                                             (COCSRC | 0x0047)
  // (ReadOnly, Bits 7:0) 
  // DOC status 15th byte
  #define BIT_MSK__DOC_STAT_E__DOC_STATUSE_B7_B0                                     0xFF

// DoC 16th Status Register
#define REG_ADDR__DOC_STAT_F                                             (COCSRC | 0x0048)
  // (ReadOnly, Bits 7:0) 
  // Doc state
  #define BIT_MSK__DOC_STAT_F__DOC_STATUSF_B7_B0                                     0xFF

// DoC FSM Status Register
#define REG_ADDR__DOC_FSM                                                (COCSRC | 0x004A)
  // (ReadOnly, Bits 7:4) 
  // DoC state machine state
  #define BIT_MSK__DOC_FSM__STATE_DOC_FSM_B3_B0                                   0xF0

// DoC 1st CFG Register
#define REG_ADDR__DOC_CFG0                                               (COCSRC | 0x004B)
  // (ReadWrite, Bits 3:0) 
  // comma K28.5
  #define BIT_MSK__DOC_CFG0__REG_K_CHAR_1T0_B3_B0                                  0x0F
  // (ReadWrite, Bits 7:4) 
  // comma K28.1
  #define BIT_MSK__DOC_CFG0__REG_K_CHAR_1T0_B7_B4                                  0xF0

// DoC 2nd CFG Register
#define REG_ADDR__DOC_CFG1                                               (COCSRC | 0x004C)
  // (ReadWrite, Bits 3:0) 
  // comma K28.2
  #define BIT_MSK__DOC_CFG1__REG_K_CHAR_3T2_B3_B0                                  0x0F
  // (ReadWrite, Bits 7:4) 
  // comma K28.3
  #define BIT_MSK__DOC_CFG1__REG_K_CHAR_3T2_B7_B4                                  0xF0

// DoC 5th CFG Register
#define REG_ADDR__DOC_CFG4                                               (COCSRC | 0x004F)
  // (ReadWrite, Bits 3:0) 
  // DoC state machine state to be forced
  #define BIT_MSK__DOC_CFG4__REG_DBG_STATE_DOC_FSM                                 0x0F

// DoC 1st Ctl Register
#define REG_ADDR__DOC_CTL0                                               (COCSRC | 0x0052)
  // (ReadWrite, Bits 0) 
  // Generate 150 MHz clock for Doc
  #define BIT_MSK__DOC_CTL0__REG_DOC_CONTROL0_B0                                   0x01
  // (ReadWrite, Bits 1) 
  // Enable debug data to AV channel 1: 150 MHz clock 0: drx_h
  #define BIT_MSK__DOC_CTL0__REG_DOC_CONTROL0_B1                                   0x02
  // (ReadWrite, Bits 2) 
  // Enable auto calibration: rg_cal_en
  #define BIT_MSK__DOC_CTL0__REG_DOC_CONTROL0_B2                                   0x04
  // (ReadWrite, Bits 3) 
  // Enable debug data to AV channel 1: dem_rs 0: drx_l
  #define BIT_MSK__DOC_CTL0__REG_DOC_CONTROL0_B3                                   0x08
  // (ReadWrite, Bits 4) 
  // Enable debug data to AV channel 1: dtx 0: drx
  #define BIT_MSK__DOC_CTL0__REG_DOC_CONTROL0_B4                                   0x10
  // (ReadWrite, Bits 5) 
  // Select I2C alpha value (1) or auto calibration alpha (0)
  #define BIT_MSK__DOC_CTL0__REG_DOC_CONTROL0_B5                                   0x20
  // (ReadWrite, Bits 6) 
  // Select state value 1: DoC state machine 0: I2C
  #define BIT_MSK__DOC_CTL0__REG_DOC_CONTROL0_B6                                   0x40
  // (ReadWrite, Bits 7) 
  // Enable LPF
  #define BIT_MSK__DOC_CTL0__REG_DOC_CONTROL0_B7                                   0x80

// DoC 2nd Ctl Register
#define REG_ADDR__DOC_CTL1                                               (COCSRC | 0x0053)
  // (ReadWrite, Bits 0) 
  // DoC tx driver enable in manual mode
  #define BIT_MSK__DOC_CTL1__REG_DOC_CONTROL1_B0                                   0x01
  // (ReadWrite, Bits 1) 
  // Enable reflection noise cancelling
  #define BIT_MSK__DOC_CTL1__REG_DOC_CONTROL1_B1                                   0x02
  // (ReadWrite, Bits 4:2) 
  // manual offset for ck_edge_sel; tx_drv_en
  #define BIT_MSK__DOC_CTL1__REG_DOC_CONTROL1_B4_B2                                0x1C
  // (ReadWrite, Bits 7:5) 
  // manual offset for em_en
  #define BIT_MSK__DOC_CTL1__REG_DOC_CONTROL1_B7_B5                                0xE0

// DoC 3rd Ctl Register
#define REG_ADDR__DOC_CTL2                                               (COCSRC | 0x0054)
  // (ReadWrite, Bits 7:0) 
  // DAC wait time
  #define BIT_MSK__DOC_CTL2__REG_DOC_CONTROL2                                      0xFF

// DoC 4th Ctl Register
#define REG_ADDR__DOC_CTL3                                               (COCSRC | 0x0055)
  // (ReadWrite, Bits 6:0) 
  // manual echo cancelling delay parameter
  #define BIT_MSK__DOC_CTL3__REG_DOC_CONTROL3_B6_B0                                0x7F
  // (ReadWrite, Bits 7) 
  // 1: fixed manual echo cancelling 0: calibrate echo cancelling value
  #define BIT_MSK__DOC_CTL3__REG_DOC_CONTROL3_B7                                   0x80

// DoC 5th Ctl Register
#define REG_ADDR__DOC_CTL4                                               (COCSRC | 0x0056)
  // (ReadWrite, Bits 7:0) 
  // DoC control register 5th byte
  #define BIT_MSK__DOC_CTL4__REG_DOC_CONTROL4_B7_B0                                0xFF

// DoC 6th Ctl Register
#define REG_ADDR__DOC_CTL5                                               (COCSRC | 0x0057)
  // (ReadWrite, Bits 1:0) 
  // manual sampling position (0-3) 4x oversampling
  #define BIT_MSK__DOC_CTL5__REG_DOC_CONTROL5_B1_B0                                0x03
  // (ReadWrite, Bits 5:2) 
  // manual deserialization boundary position
  #define BIT_MSK__DOC_CTL5__REG_DOC_CONTROL5_B5_B2                                0x3C
  // (ReadWrite, Bits 7:6) 
  // DOC control register 6th byte
  #define BIT_MSK__DOC_CTL5__REG_DOC_CONTROL5_B7_B6                                0xC0

// DoC 7th Ctl Register
#define REG_ADDR__DOC_CTL6                                               (COCSRC | 0x0058)
  // (ReadWrite, Bits 3:0) 
  // mux selection
  #define BIT_MSK__DOC_CTL6__REG_DOC_CONTROL6_B3_B0                                0x0F
  // (ReadWrite, Bits 6:4) 
  // DOC control register 7th byte
  #define BIT_MSK__DOC_CTL6__REG_DOC_CONTROL6_B6_B4                                0x70
  // (ReadWrite, Bits 7) 
  // 600 MHz domain read pulse (auto reset)
  #define BIT_MSK__DOC_CTL6__REG_DOC_CONTROL6_7                                    0x80

// DoC 8th Ctl Register
#define REG_ADDR__DOC_CTL7                                               (COCSRC | 0x0059)
  // (ReadWrite, Bits 2:0) 
  // Tx pattern selection 000: Normal mode 001: BIST 010: 8 bit fixed pattern 011: 10 bit fixed pattern 100: enable CTS 101: RSVD 110: RSVD 111: RSVD
  #define BIT_MSK__DOC_CTL7__REG_DOC_CONTROL7_B2_B0                                0x07
  // (ReadWrite, Bits 4:3) 
  // loopback  bist 00: Normal mode 01: far-end loopback bist en 10: near-end loopback bist en 11: near-end analog loopback bist en
  #define BIT_MSK__DOC_CTL7__REG_DOC_CONTROL7_B4_B3                                0x18
  // (ReadWrite, Bits 5) 
  // clear bist error counter (auto reset)
  #define BIT_MSK__DOC_CTL7__REG_DOC_CONTROL7_5                                    0x20
  // (ReadWrite, Bits 6) 
  // clear 8b/10b error status (auto reset)
  #define BIT_MSK__DOC_CTL7__REG_DOC_CONTROL7_6                                    0x40
  // (ReadWrite, Bits 7) 
  // 8b/10b error inject
  #define BIT_MSK__DOC_CTL7__REG_DOC_CONTROL7_B7                                   0x80

// DoC 9th Ctl Register
#define REG_ADDR__DOC_CTL8                                               (COCSRC | 0x006D)
  // (ReadWrite, Bits 1:0) 
  // 10bit fixed pattern 0 MSB; or 0: K char
  #define BIT_MSK__DOC_CTL8__REG_DOC_CONTROL8_B1_B0                                0x03
  // (ReadWrite, Bits 3:2) 
  // 10bit fixed pattern 1 MSB; or 2: K char
  #define BIT_MSK__DOC_CTL8__REG_DOC_CONTROL8_B3_B2                                0x0C
  // (ReadWrite, Bits 7:4) 
  // DOC control register 9th byte
  #define BIT_MSK__DOC_CTL8__REG_DOC_CONTROL8_B7_B4                                0xF0

// DoC 10th Ctl Register
#define REG_ADDR__DOC_CTL9                                               (COCSRC | 0x006E)
  // (ReadWrite, Bits 7:0) 
  // 8/10 bit fixed pattern 0 (for 10 bit combined with reg_doc_control8[1:0])
  #define BIT_MSK__DOC_CTL9__REG_DOC_CONTROL9                                      0xFF

// DoC 11th Ctl Register
#define REG_ADDR__DOC_CTLA                                               (COCSRC | 0x006F)
  // (ReadWrite, Bits 7:0) 
  // 8/10 bit fixed pattern 1 (for 10 bit combined with reg_doc_control8[3:2])
  #define BIT_MSK__DOC_CTLA__REG_DOC_CONTROLA                                      0xFF

// DoC 12th Ctl Register
#define REG_ADDR__DOC_CTLB                                               (COCSRC | 0x0070)
  // (ReadWrite, Bits 7:0) 
  // Calibration maximum timeout time
  #define BIT_MSK__DOC_CTLB__REG_DOC_CONTROLB                                      0xFF

// DoC 13th Ctl Register
#define REG_ADDR__DOC_CTLC                                               (COCSRC | 0x0071)
  // (ReadWrite, Bits 7:0) 
  // Calibration minimum wait time
  #define BIT_MSK__DOC_CTLC__REG_DOC_CONTROLC                                      0xFF

// DoC 14th Ctl Register
#define REG_ADDR__DOC_CTLD                                               (COCSRC | 0x0072)
  // (ReadWrite, Bits 3:0) 
  // minimum number of ones in measure Aout state
  #define BIT_MSK__DOC_CTLD__REG_DOC_CONTROLD_B3_B0                                0x0F
  // (ReadWrite, Bits 6:4) 
  // Phase tracking LPF
  #define BIT_MSK__DOC_CTLD__REG_DOC_CONTROLD_B6_B4                                0x70
  // (ReadWrite, Bits 7) 
  // Stop DoC BIST
  #define BIT_MSK__DOC_CTLD__REG_DOC_CONTROLD_B7                                   0x80

// DoC 15th Ctl Register
#define REG_ADDR__DOC_CTLE                                               (COCSRC | 0x0073)
  // (ReadWrite, Bits 7:0) 
  // DOC/DoC control register 15th byte
  #define BIT_MSK__DOC_CTLE__REG_DOC_CONTROLE                                      0xFF

// DoC 16th Ctl Register
#define REG_ADDR__DOC_CTLF                                               (COCSRC | 0x0074)
  // (ReadWrite, Bits 7:0) 
  // DOC control register 16th byte
  #define BIT_MSK__DOC_CTLF__REG_DOC_CONTROLF                                      0xFF

// DoC Interrupt Register
#define REG_ADDR__DOC_INTR                                               (COCSRC | 0x0075)
  // (ReadWrite, Bits 0) 
  // DOC PLL lock status change interrupt
  #define BIT_MSK__DOC_INTR__REG_DOC_INTR_STAT0                                    0x01
  // (ReadWrite, Bits 1) 
  // DOC Calibration done interrupt
  #define BIT_MSK__DOC_INTR__REG_DOC_INTR_STAT1                                    0x02
  // (ReadWrite, Bits 2) 
  // DOC 8b/10b error interrupt
  #define BIT_MSK__DOC_INTR__REG_DOC_INTR_STAT2                                    0x04
  // (ReadWrite, Bits 3) 
  // DOC calibration state machine received Comma1 interrupt
  #define BIT_MSK__DOC_INTR__REG_DOC_INTR_STAT3                                    0x08
  // (ReadWrite, Bits 4) 
  // DOC calibration state machine received Comma2 interrupt
  #define BIT_MSK__DOC_INTR__REG_DOC_INTR_STAT4                                    0x10
  // (ReadWrite, Bits 5) 
  // DOC trap interrupt (including state change; Comma1 received; Comma2 received; meaure Aout done; detect Phout)
  #define BIT_MSK__DOC_INTR__REG_DOC_INTR_STAT5                                    0x20
  // (ReadWrite, Bits 6) 
  // DOC time out interrupt
  #define BIT_MSK__DOC_INTR__REG_DOC_INTR_STAT6                                    0x40

// DoC Interrupt Register
#define REG_ADDR__DOC_INTR_MASK                                          (COCSRC | 0x0076)
  // (ReadWrite, Bits 0) 
  // Interrupt mask for DOC PLL lock status change interrupt
  #define BIT_MSK__DOC_INTR_MASK__REG_DOC_INTR_MASK0                                    0x01
  // (ReadWrite, Bits 1) 
  // Interrupt mask for DOC Calibration done interrupt
  #define BIT_MSK__DOC_INTR_MASK__REG_DOC_INTR_MASK1                                    0x02
  // (ReadWrite, Bits 2) 
  // Interrupt mask for DOC 8b/10b error interrupt
  #define BIT_MSK__DOC_INTR_MASK__REG_DOC_INTR_MASK2                                    0x04
  // (ReadWrite, Bits 3) 
  // Interrupt mask for DOC calibration state machine received Comma1 interrupt
  #define BIT_MSK__DOC_INTR_MASK__REG_DOC_INTR_MASK3                                    0x08
  // (ReadWrite, Bits 4) 
  // Interrupt mask for DOC calibration state machine received Comma2 interrupt
  #define BIT_MSK__DOC_INTR_MASK__REG_DOC_INTR_MASK4                                    0x10
  // (ReadWrite, Bits 5) 
  // Interrupt mask for DOC trap interrupt
  #define BIT_MSK__DOC_INTR_MASK__REG_DOC_INTR_MASK5                                    0x20
  // (ReadWrite, Bits 6) 
  // Interrupt mask for DOC time out interrupt
  #define BIT_MSK__DOC_INTR_MASK__REG_DOC_INTR_MASK6                                    0x40

// DoC Misc 1st Ctl Register
#define REG_ADDR__DOC_MISC_CTL0                                          (COCSRC | 0x0077)
  // (ReadWrite, Bits 0) 
  // Enable to override doc output enable generated by internal state machine
  #define BIT_MSK__DOC_MISC_CTL0__REG_DOC_OE_OVR                                        0x01
  // (ReadWrite, Bits 1) 
  // If bit 0 is enabled; doc output enable
  #define BIT_MSK__DOC_MISC_CTL0__REG_DOC_OE                                            0x02
  // (ReadWrite, Bits 2) 
  // Enable to bring DoC debug signal into AV Channel
  #define BIT_MSK__DOC_MISC_CTL0__REG_DOC_DBG_AV_EN                                     0x04
  // (ReadWrite, Bits 4:3) 
  // When bit 2 is set; select what CoC debug data is put into AV Channel 00: doc_r_2_av 01: doc_t_2_av 10: doc_i_2_av 11: doc_i_2_av
  #define BIT_MSK__DOC_MISC_CTL0__REG_DOC_DBG_AV_SEL                                    0x18
  // (ReadWrite, Bits 7) 
  // Enable to override doc output enable generated by internal state machine
  #define BIT_MSK__DOC_MISC_CTL0__REG_DOC_DBG_GPIO_EN                                   0x80

// DoC Misc 3rd Ctl Register
#define REG_ADDR__DOC_MISC_CTL2                                          (COCSRC | 0x0079)
  // (ReadWrite, Bits 7:0) 
  // TBD
  #define BIT_MSK__DOC_MISC_CTL2__REG_DOC_DM_SWING                                      0xFF

// DoC Misc 4th Ctl Register
#define REG_ADDR__DOC_MISC_CTL3                                          (COCSRC | 0x007A)
  // (ReadWrite, Bits 7:0) 
  // TBD
  #define BIT_MSK__DOC_MISC_CTL3__REG_DOC_SLEW_B7_B0                                    0xFF

// DoC Misc 5th Ctl Register
#define REG_ADDR__DOC_MISC_CTL4                                          (COCSRC | 0x007B)
  // (ReadWrite, Bits 7:0) 
  // TBD
  #define BIT_MSK__DOC_MISC_CTL4__REG_DOC_SLEW_B15_B8                                   0xFF

// DoC Misc 6th Ctl Register
#define REG_ADDR__DOC_MISC_CTL5                                          (COCSRC | 0x007C)
  // (ReadWrite, Bits 7:0) 
  // TBD
  #define BIT_MSK__DOC_MISC_CTL5__REG_DOC_SLEW_B23_B16                                  0xFF

// DoC 17th Ctl Register
#define REG_ADDR__DOC_CTL10                                              (COCSRC | 0x0081)
  // (ReadWrite, Bits 7:0) 
  // DOC control register 17th byte
  #define BIT_MSK__DOC_CTL10__REG_DOC_CONTROL10                                     0xFF

// DoC 18th Ctl Register
#define REG_ADDR__DOC_CTL11                                              (COCSRC | 0x0082)
  // (ReadWrite, Bits 7:0) 
  // DOC control register 18th byte
  #define BIT_MSK__DOC_CTL11__REG_DOC_CONTROL11                                     0xFF

// DoC 19th Ctl Register
#define REG_ADDR__DOC_CTL12                                              (COCSRC | 0x0083)
  // (ReadWrite, Bits 7:0) 
  // DOC control register 19th byte
  #define BIT_MSK__DOC_CTL12__REG_DOC_CONTROL12                                     0xFF

// DoC 20th Ctl Register
#define REG_ADDR__DOC_CTL13                                              (COCSRC | 0x0084)
  // (ReadWrite, Bits 7:0) 
  // DOC control register 20th byte
  #define BIT_MSK__DOC_CTL13__REG_DOC_CONTROL13                                     0xFF

// DoC 21st Ctl Register
#define REG_ADDR__DOC_CTL14                                              (COCSRC | 0x0085)
  // (ReadWrite, Bits 7:0) 
  // DOC control register 21st byte
  #define BIT_MSK__DOC_CTL14__REG_DOC_CONTROL14                                     0xFF

// DoC 22nd Ctl Register
#define REG_ADDR__DOC_CTL15                                              (COCSRC | 0x0086)
  // (ReadWrite, Bits 7:0) 
  // DOC control register 22nd byte
  #define BIT_MSK__DOC_CTL15__REG_DOC_CONTROL15                                     0xFF

// DoC 23rd Ctl Register
#define REG_ADDR__DOC_CTL16                                              (COCSRC | 0x0087)
  // (ReadWrite, Bits 7:0) 
  // DOC control register 23rd byte
  #define BIT_MSK__DOC_CTL16__REG_DOC_CONTROL16                                     0xFF

// DoC 24th Ctl Register
#define REG_ADDR__DOC_CTL17                                              (COCSRC | 0x0088)
  // (ReadWrite, Bits 7:0) 
  // DOC control register 24th byte
  #define BIT_MSK__DOC_CTL17__REG_DOC_CONTROL17                                     0xFF

// DoC 25th Ctl Register
#define REG_ADDR__DOC_CTL18                                              (COCSRC | 0x0089)
  // (ReadWrite, Bits 7:0) 
  // DOC control register 25th byte
  #define BIT_MSK__DOC_CTL18__REG_DOC_CONTROL18                                     0xFF

// DoC 11th Status Register
#define REG_ADDR__DOC_STAT_10                                            (COCSRC | 0x0091)
  // (ReadOnly, Bits 7:0) 
  // DOC status 11th byte
  #define BIT_MSK__DOC_STAT_10__DOC_STATUS10_B7_B0                                    0xFF

// DoC 12th Status Register
#define REG_ADDR__DOC_STAT_11                                            (COCSRC | 0x0092)
  // (ReadOnly, Bits 7:0) 
  // DOC status 12th byte
  #define BIT_MSK__DOC_STAT_11__DOC_STATUS11_B7_B0                                    0xFF

// DoC 13th Status Register
#define REG_ADDR__DOC_STAT_12                                            (COCSRC | 0x0093)
  // (ReadOnly, Bits 7:0) 
  // DOC status 13th byte
  #define BIT_MSK__DOC_STAT_12__DOC_STATUS12_B7_B0                                    0xFF

// DoC 14th Status Register
#define REG_ADDR__DOC_STAT_13                                            (COCSRC | 0x0094)
  // (ReadOnly, Bits 7:0) 
  // DOC status 14th byte
  #define BIT_MSK__DOC_STAT_13__DOC_STATUS13_B7_B0                                    0xFF

// DoC 15th Status Register
#define REG_ADDR__DOC_STAT_14                                            (COCSRC | 0x0095)
  // (ReadOnly, Bits 7:0) 
  // DOC status 15th byte
  #define BIT_MSK__DOC_STAT_14__DOC_STATUS14_B7_B0                                    0xFF

// DoC 16th Status Register
#define REG_ADDR__DOC_STAT_15                                            (COCSRC | 0x0096)
  // (ReadOnly, Bits 7:0) 
  // DOC status 16th byte
  #define BIT_MSK__DOC_STAT_15__DOC_STATUS15_B7_B0                                    0xFF

// DoC 17th Status Register
#define REG_ADDR__DOC_STAT_16                                            (COCSRC | 0x0097)
  // (ReadOnly, Bits 7:0) 
  // DOC status 17th byte
  #define BIT_MSK__DOC_STAT_16__DOC_STATUS16_B7_B0                                    0xFF

// DoC 18th Status Register
#define REG_ADDR__DOC_STAT_17                                            (COCSRC | 0x0098)
  // (ReadOnly, Bits 7:0) 
  // DOC status 18th byte
  #define BIT_MSK__DOC_STAT_17__DOC_STATUS17_B7_B0                                    0xFF

// DoC 19th Status Register
#define REG_ADDR__DOC_STAT_18                                            (COCSRC | 0x0099)
  // (ReadOnly, Bits 7:0) 
  // DOC status 19th byte
  #define BIT_MSK__DOC_STAT_18__DOC_STATUS18_B7_B0                                    0xFF

// DoC 19th Status Register
#define REG_ADDR__DOC_STAT_19                                            (COCSRC | 0x009A)
  // (ReadOnly, Bits 7:0) 
  // DOC status 20th byte
  #define BIT_MSK__DOC_STAT_19__DOC_STATUS19_B7_B0                                    0xFF

// DoC 1st Equalization LSB Ctl Register
#define REG_ADDR__DOC_EQ0_L                                              (COCSRC | 0x009B)
  // (ReadWrite, Bits 7:0) 
  // DoC 1st Equalization LSB
  #define BIT_MSK__DOC_EQ0_L__REG_DOC_EQ0_B7_B0                                     0xFF

// DoC 1st Equalization MSB Ctl Register
#define REG_ADDR__DOC_EQ0_M                                              (COCSRC | 0x009C)
  // (ReadWrite, Bits 7:0) 
  // DoC 1st Equalization MSB
  #define BIT_MSK__DOC_EQ0_M__REG_DOC_EQ0_B15_B8                                    0xFF

// DoC 2nd Equalization LSB Ctl Register
#define REG_ADDR__DOC_EQ1_L                                              (COCSRC | 0x009D)
  // (ReadWrite, Bits 7:0) 
  // DoC 2nd Equalization LSB
  #define BIT_MSK__DOC_EQ1_L__REG_DOC_EQ1_B7_B0                                     0xFF

// DoC 2nd Equalization MSB Ctl Register
#define REG_ADDR__DOC_EQ1_M                                              (COCSRC | 0x009E)
  // (ReadWrite, Bits 7:0) 
  // DoC 2nd Equalization MSB
  #define BIT_MSK__DOC_EQ1_M__REG_DOC_EQ1_B15_B8                                    0xFF

// DoC 3rd Equalization LSB Ctl Register
#define REG_ADDR__DOC_EQ2_L                                              (COCSRC | 0x009F)
  // (ReadWrite, Bits 7:0) 
  // DoC 3rd Equalization LSB
  #define BIT_MSK__DOC_EQ2_L__REG_DOC_EQ2_B7_B0                                     0xFF

// DoC 3rd Equalization MSB Ctl Register
#define REG_ADDR__DOC_EQ2_H                                              (COCSRC | 0x00A0)
  // (ReadWrite, Bits 7:0) 
  // DoC 3rd Equalization MSB
  #define BIT_MSK__DOC_EQ2_H__REG_DOC_EQ2_B15_B8                                    0xFF

// DoC 4th Equalization LSB Ctl Register
#define REG_ADDR__DOC_EQ3_L                                              (COCSRC | 0x00A1)
  // (ReadWrite, Bits 7:0) 
  // DoC 4th Equalization LSB
  #define BIT_MSK__DOC_EQ3_L__REG_DOC_EQ3_B7_B0                                     0xFF

// DoC 4th Equalization MSB Ctl Register
#define REG_ADDR__DOC_EQ3_H                                              (COCSRC | 0x00A2)
  // (ReadWrite, Bits 7:0) 
  // DoC 4th Equalization MSB
  #define BIT_MSK__DOC_EQ3_H__REG_DOC_EQ3_B15_B8                                    0xFF

// DoC 5th Equalization LSB Ctl Register
#define REG_ADDR__DOC_EQ4_L                                              (COCSRC | 0x00A3)
  // (ReadWrite, Bits 7:0) 
  // DoC 5th Equalization LSB
  #define BIT_MSK__DOC_EQ4_L__REG_DOC_EQ4_B7_B0                                     0xFF

// DoC 5th Equalization MSB Ctl Register
#define REG_ADDR__DOC_EQ4_H                                              (COCSRC | 0x00A4)
  // (ReadWrite, Bits 7:0) 
  // DoC 5th Equalization MSB
  #define BIT_MSK__DOC_EQ4_H__REG_DOC_EQ4_B15_B8                                    0xFF

// DoC 6th Equalization LSB Ctl Register
#define REG_ADDR__DOC_EQ5_L                                              (COCSRC | 0x00A5)
  // (ReadWrite, Bits 7:0) 
  // DoC 6th Equalization LSB
  #define BIT_MSK__DOC_EQ5_L__REG_DOC_EQ5_B7_B0                                     0xFF

// DoC 6th Equalization MSB Ctl Register
#define REG_ADDR__DOC_EQ5_H                                              (COCSRC | 0x00A6)
  // (ReadWrite, Bits 7:0) 
  // DoC 5th Equalization MSB
  #define BIT_MSK__DOC_EQ5_H__REG_DOC_EQ5_B15_B8                                    0xFF

// DoC 7th Equalization LSB Ctl Register
#define REG_ADDR__DOC_EQ6_L                                              (COCSRC | 0x00A7)
  // (ReadWrite, Bits 7:0) 
  // DoC 7th Equalization LSB
  #define BIT_MSK__DOC_EQ6_L__REG_DOC_EQ6_B7_B0                                     0xFF

// DoC 7th Equalization MSB Ctl Register
#define REG_ADDR__DOC_EQ6_H                                              (COCSRC | 0x00A8)
  // (ReadWrite, Bits 7:0) 
  // DoC 7th Equalization MSB
  #define BIT_MSK__DOC_EQ6_H__REG_DOC_EQ6_B15_B8                                    0xFF

// DoC 8th Equalization LSB Ctl Register
#define REG_ADDR__DOC_EQ7_L                                              (COCSRC | 0x00A9)
  // (ReadWrite, Bits 7:0) 
  // DoC 8th Equalization LSB
  #define BIT_MSK__DOC_EQ7_L__REG_DOC_EQ7_B7_B0                                     0xFF

// DoC 8th Equalization MSB Ctl Register
#define REG_ADDR__DOC_EQ7_H                                              (COCSRC | 0x00AA)
  // (ReadWrite, Bits 7:0) 
  // DoC 8th Equalization MSB
  #define BIT_MSK__DOC_EQ7_H__REG_DOC_EQ7_B15_B8                                    0xFF

// MHL CoC  aecho Ctl Register
#define REG_ADDR__MHL_COC_AECHO_CTL                                      (COCSRC | 0x00AB)
  // (ReadWrite, Bits 0) 
  // Enable CoC analog echo canceller
  #define BIT_MSK__MHL_COC_AECHO_CTL__REG_COC_AECHO_EN                                      0x01

// DoC/CoC Control Register
#define REG_ADDR__COC_DOC_CTL                                            (COCSRC | 0x00AD)
  // (ReadWrite, Bits 7) 
  // when mhl3_en is enable : mhl3_doc or mhl3_coc mode  selection 1'b0 mhl3 CoC mode 1'b1 mhl3 DoC mode
  #define BIT_MSK__COC_DOC_CTL__REG_MHL3_DOC_SEL                                      0x80

// DoC/CoC Software Reset Register
#define REG_ADDR__COC_DOC_SRTS                                           (COCSRC | 0x00AF)
  // (ReadWrite, Bits 7) 
  // CoC/DoC software reset 1'b0 normat operation (default) 1'b1 reset CoC/DoC module
  #define BIT_MSK__COC_DOC_SRTS__REG_COC_DOC_RST                                       0x80

//***************************************************************************
// RX_XBIST. Address: 60
// RX XBIST CNTL Register
#define REG_ADDR__RX_XBIST_CNTL                                          (RX_XBIST | 0x0000)
  // (ReadWrite, Bits 0) 
  // 1'b0  rxbist is disabled (default).     1'b1 -  rxbist is enabled.       
  #define BIT_MSK__RX_XBIST_CNTL__REG_BIST_EN                                           0x01
  // (ReadWrite, Bits 1) 
  // 1'b1 - enables data alignment check in BGR channels in 10-bit domain. 
  #define BIT_MSK__RX_XBIST_CNTL__REG_BAC_EN                                            0x02
  // (ReadWrite, Bits 2) 
  // 1'b1 - enable single channel xbist done status only
  #define BIT_MSK__RX_XBIST_CNTL__REG_SINGLE_CHAN                                       0x04
  // (ReadWrite, Bits 3) 
  // 1'b1 - DPLL align check off is enabled
  #define BIT_MSK__RX_XBIST_CNTL__REG_ENABLE_CTR_ALIGN_OFF                              0x08
  // (ReadWrite, Bits 5:4) 
  // masks error for debug: [1] masks internal cs_error; [0] masks dcbw_error;  no mask if 00
  #define BIT_MSK__RX_XBIST_CNTL__REG_ERROR_MASK_B1_B0                                  0x30
  // (ReadWrite, Bits 6) 
  // For backward compatibility support
  #define BIT_MSK__RX_XBIST_CNTL__REG_LEGACY                                            0x40
  // (ReadWrite, Bits 7) 
  // 1'b1 - manual disable align off
  #define BIT_MSK__RX_XBIST_CNTL__REG_MAN_ALIGN_OFF                                     0x80

// RX XBIST INST LOW Register
#define REG_ADDR__RX_XBIST_INST_LOW                                      (RX_XBIST | 0x0001)
  // (ReadWrite, Bits 7:0) 
  // [7:0] of 10-bit Instruction register for Blue, Green and Red channels. [10:9] to follow                                                                                                                                                                                                                                                                                                                                                      [9:6]  OPCODE 4'b0000 - max_en 4'b0001 - max48_en 4'b0011 - half_en 4'b0100 - half48_en 4'b0101 - rand1_en 4'b0110 - rand1_en 4'b0111 - stress_en 4'b1000 - hfreq_en 4'b1001 - lfreq_en 4'b1010 - DC test_en 4'b1011 - hs10Bus_en 4'b1110 - user_en 4'b1111 - all_en [5:0] - defined control input for User defined instruciton  (see XBIST User Document v1.1)                                            
  #define BIT_MSK__RX_XBIST_INST_LOW__REG_INSTRUCTION_B7_B0                                 0xFF

// RX XBIST INST HIGH Register
#define REG_ADDR__RX_XBIST_INST_HIGH                                     (RX_XBIST | 0x0002)
  // (ReadWrite, Bits 1:0) 
  // [9:8] of 10-bit Instruction register for Blue, Green and Red channels                                                                                                                                                                                                                                                                                                                                                    [9:6]  OPCODE 4'b0000 - max_en 4'b0001 - max48_en 4'b0011 - half_en 4'b0100 - half48_en 4'b0101 - rand1_en 4'b0110 - rand1_en 4'b0111 - stress_en 4'b1000 - hfreq_en 4'b1001 - lfreq_en 4'b1010 - dctest_en 4'b1011 - hs10Bus_en 4'b1110 - user_en 4'b1111 - all_en                      
  #define BIT_MSK__RX_XBIST_INST_HIGH__REG_INSTRUCTION_B9_B8                                 0x03
  // (ReadWrite, Bits 7:4) 
  // For debug only:  00 - disable, 01 - 2, 10 - 4, 11 : unused
  #define BIT_MSK__RX_XBIST_INST_HIGH__REG_DCBW_CONF                                         0xF0

// RX XBIST STATE Register
#define REG_ADDR__RX_XBIST_STATE                                         (RX_XBIST | 0x0003)
  // (ReadOnly, Bits 1:0) 
  // Channel 0 BIST state - 2'b00 IDLE, 2'b01 INIT, 2'b10 RUN, 2'b11 DONE 
  #define BIT_MSK__RX_XBIST_STATE__BIST_STATE_B                                          0x03
  // (ReadOnly, Bits 3:2) 
  // Channel 1 BIST state - 2'b00 IDLE, 2'b01 INIT, 2'b10 RUN, 2'b11 DONE 
  #define BIT_MSK__RX_XBIST_STATE__BIST_STATE_G                                          0x0C
  // (ReadOnly, Bits 5:4) 
  // Channel 2 BIST state - 2'b00 IDLE, 2'b01 INIT, 2'b10 RUN, 2'b11 DONE 
  #define BIT_MSK__RX_XBIST_STATE__BIST_STATE_R                                          0x30

// RX XBIST STATUS Register
#define REG_ADDR__RX_XBIST_STATUS                                        (RX_XBIST | 0x0004)
  // (ReadOnly, Bits 2:0) 
  // RxBIST errors for RGB;      if 3'b000 then no error;   otherwise error
  #define BIT_MSK__RX_XBIST_STATUS__BIST_ERROR                                            0x07
  // (ReadOnly, Bits 3) 
  // Byte alignment error;       if 1'b0  then no error;       otherwise  error.
  #define BIT_MSK__RX_XBIST_STATUS__BAC_ERROR                                             0x08
  // (ReadOnly, Bits 7) 
  // Test status. 1'b0 = bist running or off; 1'b1 = bist done.
  #define BIT_MSK__RX_XBIST_STATUS__BIST_DONE                                             0x80

// RX XBIST BER 0 LOW Register
#define REG_ADDR__RX_XBIST_BER0_LOW                                      (RX_XBIST | 0x0005)
  // (ReadOnly, Bits 7:0) 
  // BER error count of channel 0 [7:0]
  #define BIT_MSK__RX_XBIST_BER0_LOW__RX_XBIST_BER0_LOW                                     0xFF

// RX XBIST BER 0 HIGH Register
#define REG_ADDR__RX_XBIST_BER0_HIGH                                     (RX_XBIST | 0x0006)
  // (ReadOnly, Bits 7:0) 
  // BER error count of channel 0 [15:8]
  #define BIT_MSK__RX_XBIST_BER0_HIGH__RX_XBIST_BER0_HIGH                                    0xFF

// RX XBIST BER 1 LOW Register
#define REG_ADDR__RX_XBIST_BER1_LOW                                      (RX_XBIST | 0x0007)
  // (ReadOnly, Bits 7:0) 
  // BER error count of channel 1 [7:0]
  #define BIT_MSK__RX_XBIST_BER1_LOW__RX_XBIST_BER1_LOW                                     0xFF

// RX XBIST BER 1 HIGH Register
#define REG_ADDR__RX_XBIST_BER1_HIGH                                     (RX_XBIST | 0x0008)
  // (ReadOnly, Bits 7:0) 
  // BER error count of channel 1 [15:8]
  #define BIT_MSK__RX_XBIST_BER1_HIGH__RX_XBIST_BER1_HIGH                                    0xFF

// RX XBIST BER 2 LOW Register
#define REG_ADDR__RX_XBIST_BER2_LOW                                      (RX_XBIST | 0x0009)
  // (ReadOnly, Bits 7:0) 
  // BER error count of channel 2 [7:0]
  #define BIT_MSK__RX_XBIST_BER2_LOW__RX_XBIST_BER2_LOW                                     0xFF

// RX XBIST BER 2 HIGH Register
#define REG_ADDR__RX_XBIST_BER2_HIGH                                     (RX_XBIST | 0x000A)
  // (ReadOnly, Bits 7:0) 
  // BER error count of channel 2 [15:8]
  #define BIT_MSK__RX_XBIST_BER2_HIGH__RX_XBIST_BER2_HIGH                                    0xFF

//***************************************************************************
// RX_ZONE. Address: 60
// ZONE CTRL_0 Register
#define REG_ADDR__RX_ZONE_CTRL_0                                            (RX_ZONE | 0x0080)
  // (ReadWrite, Bits 0) 
  // 1 to start auto zone calculation. To start next calculation it should be cleared first and asserted
  #define BIT_MSK__RX_ZONE_CTRL_0__RI_ZONE_ST                                            0x01
  // (ReadWrite, Bits 1) 
  // select the zone calcuation start.  0 is hardware start. 1 is register start
  #define BIT_MSK__RX_ZONE_CTRL_0__RI_ZONE_ST_SEL                                        0x02
  // (ReadWrite, Bits 3:2) 
  // 2bit register signal to select when ocnt is stopped for zone calculation. 00: 512 is selected 01: 256 is selected 10: 128 is selected 11: 64 is selected
  #define BIT_MSK__RX_ZONE_CTRL_0__RI_OCNT_STP                                           0x0C
  // (ReadWrite, Bits 5:4) 
  // Register 0x02 0x03 read out signals select. 00: ro_zone_cnt; 01: ro_precnt; 10: ro_pstcnt; 11: ro_oclk_in_pclk
  #define BIT_MSK__RX_ZONE_CTRL_0__RI_DEBUG_SEL                                          0x30

// ZONE STATUS_0 Register
#define REG_ADDR__RX_ZONE_STATUS_0                                          (RX_ZONE | 0x0081)
  // (ReadOnly, Bits 0) 
  // It is high when zone input clock is high than 1G
  #define BIT_MSK__RX_ZONE_STATUS_0__RO_F1G                                                0x01
  // (ReadOnly, Bits 3:1) 
  // 3bit zone control value.
  #define BIT_MSK__RX_ZONE_STATUS_0__RO_SZONE                                              0x0E
  // (ReadOnly, Bits 7) 
  // pll lock status. 1 indicate pll locked. It is enabled if ri_lkdt_en
  #define BIT_MSK__RX_ZONE_STATUS_0__RO_PLL_LK                                             0x80

// Debug_0 Register
#define REG_ADDR__RX_DEBUG_0                                                (RX_ZONE | 0x0082)
  // (ReadOnly, Bits 7:0) 
  // Output debug signals according to register 0x00[5:4]. 00: ro_zone_cnt[15:0]; 01: ro_precnt[15:0]; 10: ro_pstcnt[15:0]; 11: ro_oclk_in_pclk[15:0].
  #define BIT_MSK__RX_DEBUG_0__RO_DEBUG_B7_B0                                        0xFF

// Debug_1 Register
#define REG_ADDR__RX_DEBUG_1                                                (RX_ZONE | 0x0083)
  // (ReadOnly, Bits 7:0) 
  // Output debug signals according to register 0x00[5:4]. 00: ro_zone_cnt[15:0]; 01: ro_precnt[15:0]; 10: ro_pstcnt[15:0]; 11: ro_oclk_in_pclk[15:0].
  #define BIT_MSK__RX_DEBUG_1__RO_DEBUG_B15_B8                                       0xFF

// VCOCAL CTRL_0 Register
#define REG_ADDR__RX_VCOCAL_CTRL_0                                          (RX_ZONE | 0x0084)
  // (ReadWrite, Bits 0) 
  // 1bit register signal to start vcocal. To start next calculation it should be cleared first and asserted.
  #define BIT_MSK__RX_VCOCAL_CTRL_0__RI_VCOCAL_ST                                          0x01
  // (ReadWrite, Bits 1) 
  // select the VCOCAL start.  0 is hardware start. 1 is register start
  #define BIT_MSK__RX_VCOCAL_CTRL_0__RI_VCOCAL_ST_SEL                                      0x02
  // (ReadWrite, Bits 4:2) 
  // 3bit register signal to select the wait time from vcocal update to next vcocal calibration 000: 16us is selected 001: 8us is selected 010: 4us is selected 011:2us is selected 100:2us is selected 101:? 
  #define BIT_MSK__RX_VCOCAL_CTRL_0__RI_OCNTV_WAIT                                         0x1C
  // (ReadWrite, Bits 7:5) 
  // 3bit register signal to select when ocntv is stopped for vcocal update. 1 clock cycle is 200ns. 000: 512 Clock cycle is selected 001: 256 Clock cycle is selected 010: 128 Clock cycle is selected 011: 64 Clock cycle is selected 100: 32 Clock cycle is selected 
  #define BIT_MSK__RX_VCOCAL_CTRL_0__RI_OCNTV_STP                                          0xE0

// VCOCAL STATUS_0 Register
#define REG_ADDR__RX_VCOCAL_STATUS_0                                        (RX_ZONE | 0x0085)
  // (ReadOnly, Bits 3:0) 
  // Calibrated VCO value. 4bits signals with PHY
  #define BIT_MSK__RX_VCOCAL_STATUS_0__RO_VCOCAL                                             0x0F

// PRECLK_FORCE_CTL Register
#define REG_ADDR__RX_PRECLK_FORCE_CTL                                       (RX_ZONE | 0x0086)
  // (ReadWrite, Bits 0) 
  // 1: When preclk is not stable force the whole zone vco block to reset.
  #define BIT_MSK__RX_PRECLK_FORCE_CTL__RI_FRCRSTN_EN                                         0x01
  // (ReadWrite, Bits 1) 
  // 1: Enable watch dog force idle function and force FSM to idle state.
  #define BIT_MSK__RX_PRECLK_FORCE_CTL__RI_FRCIDLE_EN                                         0x02
  // (ReadWrite, Bits 2) 
  // 1: SW forces FSM to idle state.
  #define BIT_MSK__RX_PRECLK_FORCE_CTL__RI_FRCIDLE_SW                                         0x04
  // (ReadWrite, Bits 3) 
  // 1: Enable watch dog force reset function and force the whole zone vco block to reset.
  #define BIT_MSK__RX_PRECLK_FORCE_CTL__RI_FRCIDLE_RSTN_EN                                    0x08
  // (ReadWrite, Bits 4) 
  // 1:  Register ro_oclk_in_pclk is oclk5m counter value in preclk N cycles 
  #define BIT_MSK__RX_PRECLK_FORCE_CTL__RI_OCLKPCLK_EN                                        0x10

// PRECLK_CNT_MAX Register
#define REG_ADDR__RX_PRECLK_CNT_MAX                                         (RX_ZONE | 0x0087)
  // (ReadWrite, Bits 7:0) 
  // The max value of preclk counter. Internal counter max = {ri_preclk_cnt_max; 8'h0}-1.
  #define BIT_MSK__RX_PRECLK_CNT_MAX__RI_PRECLK_CNT_MAX                                     0xFF

// OCLK_CNT_MAX Register
#define REG_ADDR__RX_OCLK_CNT_MAX                                           (RX_ZONE | 0x0088)
  // (ReadWrite, Bits 7:0) 
  // The max value of oclk5m counter. Preclk is out of range when oclk5m counter [ri_oclk5m_cnt_min or ]{ri_oclk5m_cnt_max; 8'h0}.
  #define BIT_MSK__RX_OCLK_CNT_MAX__RI_OCLK5M_CNT_MAX                                     0xFF

// OCLK_CNT_MIN Register
#define REG_ADDR__RX_OCLK_CNT_MIN                                           (RX_ZONE | 0x0089)
  // (ReadWrite, Bits 7:0) 
  // The min value of oclk5m counter. Preclk is out of range when oclk5m counter [ri_oclk5m_cnt_min or ]{ri_oclk5m_cnt_max; 8'h0}.
  #define BIT_MSK__RX_OCLK_CNT_MIN__RI_OCLK5M_CNT_MIN                                     0xFF

// PRE_DIVIDER Register
#define REG_ADDR__RX_PRE_DIV                                                (RX_ZONE | 0x008A)
  // (ReadOnly, Bits 4:0) 
  // 5bit pre-divider based on vcocal
  #define BIT_MSK__RX_PRE_DIV__RO_DIV_PRE                                            0x1F

// POST_DIVIDER Register
#define REG_ADDR__RX_POST_DIV                                               (RX_ZONE | 0x008B)
  // (ReadOnly, Bits 6:0) 
  // 7bit post-divider based on vcocal
  #define BIT_MSK__RX_POST_DIV__RO_DIV_PST                                            0x7F

// VCOCAL STATUS_1 Register
#define REG_ADDR__RX_VCOCAL_STATUS_1                                        (RX_ZONE | 0x008C)
  // (ReadOnly, Bits 3:0) 
  // Charge pump number select based on vcocal  0000:0; 0001:1;0011:2;1111:4
  #define BIT_MSK__RX_VCOCAL_STATUS_1__RO_I_SEL                                              0x0F
  // (ReadOnly, Bits 7:4) 
  // Bias control for pump current control based on vcocal 0000:0.5x; 0101:0.75x;1010:1.0x; 1111:1.25
  #define BIT_MSK__RX_VCOCAL_STATUS_1__RO_BIAS_BGR_D                                         0xF0

// PLL_MODE0 Register
#define REG_ADDR__RX_PLL_MODE0                                              (RX_ZONE | 0x008D)
  // (ReadWrite, Bits 0) 
  // pll_mode over write enable
  #define BIT_MSK__RX_PLL_MODE0__RI_PLL_MODE_OW_EN                                     0x01
  // (ReadWrite, Bits 2:1) 
  // pll_mode value for over write
  #define BIT_MSK__RX_PLL_MODE0__RI_PLL_MODE_OW                                        0x06
  // (ReadOnly, Bits 4:3) 
  // pll mode status during zone_vco
  #define BIT_MSK__RX_PLL_MODE0__RO_PLL_MODE                                           0x18
  // (ReadWrite, Bits 6) 
  // hdmi/mhl select overwrite enable
  #define BIT_MSK__RX_PLL_MODE0__RI_HDMI_MHLN_SEL_OW_EN                                0x40
  // (ReadWrite, Bits 7) 
  // HDMI/MHL select for overwrite
  #define BIT_MSK__RX_PLL_MODE0__RI_HDMI_MHLN_SEL_OW                                   0x80

// SZONE_OW Register
#define REG_ADDR__RX_SZONE_OW                                               (RX_ZONE | 0x008E)
  // (ReadWrite, Bits 0) 
  // Szone over write enable
  #define BIT_MSK__RX_SZONE_OW__RI_ZONE_OW_EN                                         0x01
  // (ReadWrite, Bits 3:1) 
  // szone value for over write
  #define BIT_MSK__RX_SZONE_OW__RI_ZONE_OW                                            0x0E
  // (ReadWrite, Bits 4) 
  // TX/RX select overwrite enable
  #define BIT_MSK__RX_SZONE_OW__RI_TX_RXN_SEL_OW_EN                                   0x10
  // (ReadWrite, Bits 5) 
  // TX/RX select for overwrite
  #define BIT_MSK__RX_SZONE_OW__RI_TX_RXN_SEL_OW                                      0x20
  // (ReadWrite, Bits 6) 
  // Shinny mode enable
  #define BIT_MSK__RX_SZONE_OW__RI_SHINNY_EN                                          0x40

// ISEL_OW Register
#define REG_ADDR__RX_ISEL_OW                                                (RX_ZONE | 0x008F)
  // (ReadWrite, Bits 0) 
  // isel over write enable
  #define BIT_MSK__RX_ISEL_OW__RI_ISEL_OW_EN                                         0x01
  // (ReadWrite, Bits 4:1) 
  // isel value for over write
  #define BIT_MSK__RX_ISEL_OW__RI_ISEL_OW                                            0x1E

// BIAS_BGR Register
#define REG_ADDR__RX_BIAS_BGR_D                                             (RX_ZONE | 0x0090)
  // (ReadWrite, Bits 0) 
  // bias_bgr_d over write enable
  #define BIT_MSK__RX_BIAS_BGR_D__RI_BIAS_BGR_D_OW_EN                                   0x01
  // (ReadWrite, Bits 4:1) 
  // bias_bgr_d  value for over write
  #define BIT_MSK__RX_BIAS_BGR_D__RI_BIAS_BGR_D_OW                                      0x1E

// DIV_PRE_OW Register
#define REG_ADDR__RX_DIV_PRE_OW                                             (RX_ZONE | 0x0091)
  // (ReadWrite, Bits 0) 
  // div_pre over write enable
  #define BIT_MSK__RX_DIV_PRE_OW__RI_DIV_PRE_OW_EN                                      0x01
  // (ReadWrite, Bits 5:1) 
  // div_pre value for over write
  #define BIT_MSK__RX_DIV_PRE_OW__RI_DIV_PRE_OW                                         0x3E

// DIV_PST_OW Register
#define REG_ADDR__RX_DIV_PST_OW                                             (RX_ZONE | 0x0092)
  // (ReadWrite, Bits 0) 
  // div_pst over write enable
  #define BIT_MSK__RX_DIV_PST_OW__RI_DIV_PST_OW_EN                                      0x01
  // (ReadWrite, Bits 7:1) 
  // div_pst value for over write
  #define BIT_MSK__RX_DIV_PST_OW__RI_DIV_PST_OW                                         0xFE

// VCOCAL_OW Register
#define REG_ADDR__RX_VCOCAL_OW                                              (RX_ZONE | 0x0093)
  // (ReadWrite, Bits 0) 
  // vco over write enable
  #define BIT_MSK__RX_VCOCAL_OW__RI_VCOCAL_OW_EN                                       0x01
  // (ReadWrite, Bits 4:1) 
  // vco value for over write
  #define BIT_MSK__RX_VCOCAL_OW__RI_VCOCAL_OW                                          0x1E
  // (ReadWrite, Bits 7) 
  // 1/16 vco cal enable. The mode is enable when ri_vcocal_st_sel is 1.
  #define BIT_MSK__RX_VCOCAL_OW__RI_1VCOCAL_EN                                         0x80

// ZONE_INTR Register
#define REG_ADDR__RX_ZONE_INTR                                              (RX_ZONE | 0x0094)
  // (ReadWrite, Bits 0) 
  // 
  #define BIT_MSK__RX_ZONE_INTR__REG_ZONE_DONE                                         0x01
  // (ReadWrite, Bits 1) 
  // 
  #define BIT_MSK__RX_ZONE_INTR__REG_VCOCAL_DONE                                       0x02
  // (ReadWrite, Bits 2) 
  // 
  #define BIT_MSK__RX_ZONE_INTR__REG_LKDT_TIMEOUT                                      0x04
  // (ReadWrite, Bits 3) 
  // pll lock intr
  #define BIT_MSK__RX_ZONE_INTR__REG_PLL_LK                                            0x08
  // (ReadWrite, Bits 4) 
  // preclk abnormal intr
  #define BIT_MSK__RX_ZONE_INTR__REG_PRECLK_ABN                                        0x10
  // (ReadWrite, Bits 5) 
  // preclk stable intr
  #define BIT_MSK__RX_ZONE_INTR__REG_PRECLK_STB                                        0x20

// ZONE_INTR_MASK Register
#define REG_ADDR__RX_ZONE_INTR_MASK                                         (RX_ZONE | 0x0095)
  // (ReadWrite, Bits 0) 
  // INTR mask for reg_zone_done
  #define BIT_MSK__RX_ZONE_INTR_MASK__RI_MASK0                                              0x01
  // (ReadWrite, Bits 1) 
  // INTR mask for reg_vcocal_done
  #define BIT_MSK__RX_ZONE_INTR_MASK__RI_MASK1                                              0x02
  // (ReadWrite, Bits 2) 
  // INTR mask for reg_lkdt_timeout
  #define BIT_MSK__RX_ZONE_INTR_MASK__RI_MASK2                                              0x04
  // (ReadWrite, Bits 3) 
  // 
  #define BIT_MSK__RX_ZONE_INTR_MASK__RI_MASK3                                              0x08
  // (ReadWrite, Bits 4) 
  // 
  #define BIT_MSK__RX_ZONE_INTR_MASK__RI_MASK4                                              0x10
  // (ReadWrite, Bits 5) 
  // 
  #define BIT_MSK__RX_ZONE_INTR_MASK__RI_MASK5                                              0x20

// ZONE_CTRL_1 Register
#define REG_ADDR__RX_ZONE_CTRL_1                                            (RX_ZONE | 0x0096)
  // (ReadWrite, Bits 7:0) 
  // 7: mhl12_pp mode enable. 6: mhl3tdd 3.6G or 6G select. 1 is 3.6G 5: mhl3 tdd mode enable 4. mhl3 enable 3:2: mhl3 TX mode ref clock select 00: 24Mhz; 01: 30Mhz; 10:240Mhz 1:0: Shinny mode ref clock select
  #define BIT_MSK__RX_ZONE_CTRL_1__RI_ZONECTRL_1                                         0xFF

// ZONE_CTRL_2 Register
#define REG_ADDR__RX_ZONE_CTRL_2                                            (RX_ZONE | 0x0097)
  // (ReadWrite, Bits 7:0) 
  // [0]: ri_rx_hdmi2p0; [1]: ri_rx_doc; [2]: ri_tx_hdmi_db; [3]: ri_rx_doc_75m; [4]: ri_otzv_en; [5]: ri_dbg_vcocal_en
  #define BIT_MSK__RX_ZONE_CTRL_2__RI_ZONECTRL_2                                         0xFF

// PLL_LK_DLY Register
#define REG_ADDR__RX_PLL_LK_DLY                                             (RX_ZONE | 0x0098)
  // (ReadWrite, Bits 7:0) 
  // pll_lk delay time: {ri_pll_lk_dly; 3'b111}
  #define BIT_MSK__RX_PLL_LK_DLY__RI_PLL_LK_DLY                                         0xFF

// LKDT_CTRL_0 Register
#define REG_ADDR__RX_LKDT_CTRL_0                                            (RX_ZONE | 0x0099)
  // (ReadWrite, Bits 1:0) 
  // 2bit register signal to select 5M oclk cycles for lockdetect counter 00: 64 01: 128  10:256 11:512 
  #define BIT_MSK__RX_LKDT_CTRL_0__RI_OCNTL_STP                                          0x03
  // (ReadWrite, Bits 3:2) 
  // 2bit register signal to select 5M oclk cycles after 1 lockdetect is finined and before next starte 00:10  01: 20  10: 40 11: 80
  #define BIT_MSK__RX_LKDT_CTRL_0__RI_OCNTLW_STP                                         0x0C
  // (ReadWrite, Bits 6) 
  // 1 to enable lockdetect check. When it is enabled  pll_unlk report the status of PLL UNLOCK. If ri_autozv_en  when pll unlock HW automatically start the zone calculation and VCO calibration again.
  #define BIT_MSK__RX_LKDT_CTRL_0__RI_LKDT_EN                                            0x40
  // (ReadWrite, Bits 7) 
  // 1 to enable auto zonevco calibration. If pll unlock it will enable new zone/vco calibration. 
  #define BIT_MSK__RX_LKDT_CTRL_0__RI_AUTOZV_EN                                          0x80

// LKDT_CTRL1 Register
#define REG_ADDR__RX_LKDT_CTRL1                                             (RX_ZONE | 0x009A)
  // (ReadWrite, Bits 7:0) 
  // Threshold for LKDT timeout. If number of timeout reaches threshold reg_lkdt_timeout interrupt is generated
  #define BIT_MSK__RX_LKDT_CTRL1__RI_LKDT_TO                                            0xFF

// LKDT_CTRL2 Register
#define REG_ADDR__RX_LKDT_CTRL2                                             (RX_ZONE | 0x009B)
  // (ReadWrite, Bits 7:0) 
  // The threshold ref and fb clock counter difference to indicate pll unlock
  #define BIT_MSK__RX_LKDT_CTRL2__RI_LKDT_DIFF_B7_B0                                    0xFF

// LKDT_CTRL3 Register
#define REG_ADDR__RX_LKDT_CTRL3                                             (RX_ZONE | 0x009C)
  // (ReadWrite, Bits 7:0) 
  // The threshold ref and fb clock counter difference to indicate pll unlock
  #define BIT_MSK__RX_LKDT_CTRL3__RI_LKDT_DIFF_B15_B8                                   0xFF

// OCLK_CNT_THR Register
#define REG_ADDR__RX_OCLK_CNT_THR                                           (RX_ZONE | 0x009D)
  // (ReadWrite, Bits 7:0) 
  // The threshold of oclk5m counter. Preclk is not stable when oclk5m counter difference is bigger than the threshold.
  #define BIT_MSK__RX_OCLK_CNT_THR__RI_OCLK5M_CNT_THR                                     0xFF

// ZVTIMER_MAX Register
#define REG_ADDR__RX_ZVTIMER_MAX                                            (RX_ZONE | 0x009E)
  // (ReadWrite, Bits 7:0) 
  // zvtimer max value {ri_zvtimer_max; 8'h0}.
  #define BIT_MSK__RX_ZVTIMER_MAX__RI_ZVTIMER_MAX                                        0xFF

// ZVSTATE Register 
#define REG_ADDR__RX_ZVSTATE                                                (RX_ZONE | 0x009F)
  // (ReadOnly, Bits 2:0) 
  // 
  #define BIT_MSK__RX_ZVSTATE__RO_ZVSTATE                                            0x07
  // (ReadOnly, Bits 4:3) 
  // 
  #define BIT_MSK__RX_ZVSTATE__RO_VSTATE                                             0x18
  // (ReadOnly, Bits 5) 
  // 
  #define BIT_MSK__RX_ZVSTATE__PRECLK_ABN                                            0x20
  // (ReadWrite, Bits 6) 
  // 1: diffrence threshold is calculated internally. 0: diffrence threshold is setting through register 0x1D.
  #define BIT_MSK__RX_ZVSTATE__RI_DIFF_THR_CAL_EN                                    0x40
  // (ReadWrite, Bits 7) 
  // 1: enable vcocal_adj function; 0: disable 
  #define BIT_MSK__RX_ZVSTATE__RI_VCO_ADJ_EN                                         0x80

// VCOCAL ADJUST Register 
#define REG_ADDR__RX_VCOCAL_ADJ                                             (RX_ZONE | 0x00A0)
  // (ReadWrite, Bits 3:0) 
  // [3]: 0: vcocal final value  (0[[F) =calculated vcocal value + ri_vcocal_adj[2:0].        1: vcocal final value  (0[[F) =calculated vcocal value - ri_vcocal_adj[2:0].
  #define BIT_MSK__RX_VCOCAL_ADJ__RI_VCOCAL_ADJ                                         0x0F
  // (ReadWrite, Bits 4) 
  // 0: f50m_chk final value=calculated value + ri_f50m_chk_adj[7:0]. 1: f50m_chk final value=calculated value - ri_f50m_chk_adj[7:0] (if less than 0; =0).
  #define BIT_MSK__RX_VCOCAL_ADJ__RI_F50M_CHK_ADJ_8                                     0x10
  // (ReadWrite, Bits 5) 
  // 0: f100m_chk final value=calculated value + ri_f100m_chk_adj[7:0]. 1: f100m_chk final value=calculated value - ri_f100m_chk_adj[7:0] (if less than 0; =0).
  #define BIT_MSK__RX_VCOCAL_ADJ__RI_F100M_CHK_ADJ_8                                    0x20
  // (ReadWrite, Bits 6) 
  // 0: f200m_chk final value=calculated value + ri_f200m_chk_adj[7:0]. 1: f200m_chk final value=calculated value - ri_f200m_chk_adj[7:0] (if less than 0; =0).
  #define BIT_MSK__RX_VCOCAL_ADJ__RI_F200M_CHK_ADJ_8                                    0x40
  // (ReadWrite, Bits 7) 
  // 0: f400m_chk final value=calculated value + ri_f400m_chk_adj[7:0]. 1: f400m_chk final value=calculated value - ri_f400m_chk_adj[7:0] (if less than 0; =0).
  #define BIT_MSK__RX_VCOCAL_ADJ__RI_F400M_CHK_ADJ_8                                    0x80

// ZONECAL ADJUST_0 Register 
#define REG_ADDR__RX_ZONECAL_ADJ_0                                          (RX_ZONE | 0x00A1)
  // (ReadWrite, Bits 7:0) 
  // Refer to register 0x20[4].
  #define BIT_MSK__RX_ZONECAL_ADJ_0__RI_F50M_CHK_ADJ                                       0xFF

// ZONECAL ADJUST_1 Register 
#define REG_ADDR__RX_ZONECAL_ADJ_1                                          (RX_ZONE | 0x00A2)
  // (ReadWrite, Bits 7:0) 
  // Refer to register 0x20[5].
  #define BIT_MSK__RX_ZONECAL_ADJ_1__RI_F100M_CHK_ADJ                                      0xFF

// ZONECAL ADJUST_2 Register 
#define REG_ADDR__RX_ZONECAL_ADJ_2                                          (RX_ZONE | 0x00A3)
  // (ReadWrite, Bits 7:0) 
  // Refer to register 0x20[6].
  #define BIT_MSK__RX_ZONECAL_ADJ_2__RI_F200M_CHK_ADJ                                      0xFF

// ZONECAL ADJUST_3 Register 
#define REG_ADDR__RX_ZONECAL_ADJ_3                                          (RX_ZONE | 0x00A4)
  // (ReadWrite, Bits 7:0) 
  // Refer to register 0x20[7].
  #define BIT_MSK__RX_ZONECAL_ADJ_3__RI_F400M_CHK_ADJ                                      0xFF

#endif // _SI_DRV_CP8630_REGS_H_
