#include "av_config.h"
#include "gsv2k2.h"

/* Resoure Content, silicon dependent */

static const uint8 RxPktID[20] ={0xE0, /*AV_PKT_AV_INFO_FRAME */
                                 0xE3, /*AV_PKT_AUDIO_INFO_FRAME*/
                                 0xEF, /*AV_PKT_ACP_PACKET*/
                                 0xE6, /*AV_PKT_SPD_PACKET*/
                                 0xF2, /*AV_PKT_ISRC1_PACKET*/
                                 0xF5, /*AV_PKT_ISRC2_PACKET*/
                                 0xF8, /*AV_PKT_GMD_PACKET*/
                                 0xFF, /*AV_PKT_GC_PACKET*/
                                 0xE9, /*AV_PKT_MPEG_PACKET*/
                                 0xEC, /*AV_PKT_VS_PACKET*/
                                 0x36, /*AV_PKT_AUDIO_CHANNEL_STATUS*/
                                 0xFF, /*AV_PKT_AUDIO_SAMPLE_PACKET*/
                                 0xFF, /*AV_PKT_ACR_PACKET*/
                                 0xFF, /*AV_PKT_EXT_AV_INFO_FRAME*/
                                 0x3C, /*AV_PKT_HDR_PACKET*/
                                 0xFF};/*AV_PKT_ALL_PACKETS*/

static const uint8 RxPktPtr[20] ={0x00, /*AV_PKT_AV_INFO_FRAME, add Checksum */
                                  0x1C, /*AV_PKT_AUDIO_INFO_FRAME*/
                                  0x70, /*AV_PKT_ACP_PACKET*/
                                  0x2A, /*AV_PKT_SPD_PACKET*/
                                  0x8C, /*AV_PKT_ISRC1_PACKET*/
                                  0xA8, /*AV_PKT_ISRC2_PACKET*/
                                  0xC4, /*AV_PKT_GMD_PACKET*/
                                  0xFF, /*AV_PKT_GC_PACKET*/
                                  0x46, /*AV_PKT_MPEG_PACKET*/
                                  0x54, /*AV_PKT_VS_PACKET*/
                                  0x36, /*AV_PKT_AUDIO_CHANNEL_STATUS*/
                                  0xFF, /*AV_PKT_AUDIO_SAMPLE_PACKET*/
                                  0xFF, /*AV_PKT_ACR_PACKET*/
                                  0xFF, /*AV_PKT_EXT_AV_INFO_FRAME*/
                                  0x20, /*AV_PKT_HDR_PACKET*/
                                  0xFF, /*AV_PKT_SPARE2_PACKET*/
                                  0xFF, /*AV_PKT_SPARE3_PACKET*/
                                  0xFF, /*AV_PKT_SPARE4_PACKET*/
                                  0x20, /*AV_PKT_HDR_PACKET*/
                                  0xFF};/*AV_PKT_ALL_PACKETS*/

static const uint8 TxPktPtr[20] ={0x22, /*AV_PKT_AV_INFO_FRAME */
                                  0x5D, /*AV_PKT_AUDIO_INFO_FRAME*/
                                  0x7F, /*AV_PKT_ACP_PACKET*/
                                  0x3E, /*AV_PKT_SPD_PACKET*/
                                  0x9E, /*AV_PKT_ISRC1_PACKET*/
                                  0xBD, /*AV_PKT_ISRC2_PACKET*/
                                  0xDC, /*AV_PKT_GMD_PACKET*/
                                  0x52, /*AV_PKT_GC_PACKET*/
                                  0x6E, /*AV_PKT_MPEG_PACKET*/
                                  0x00, /*AV_PKT_VS_PACKET*/
                                  0x15, /*AV_PKT_AUDIO_CHANNEL_STATUS*/
                                  0xFF, /*AV_PKT_AUDIO_SAMPLE_PACKET*/
                                  0xFF, /*AV_PKT_ACR_PACKET*/
                                  0xFF, /*AV_PKT_EXT_AV_INFO_FRAME*/
                                  0x59, /*AV_PKT_HDR_PACKET*/
                                  0x78, /*AV_PKT_SPARE2_PACKET*/
                                  0xFF, /*AV_PKT_SPARE3_PACKET*/
                                  0xFF, /*AV_PKT_SPARE4_PACKET*/
                                  0xFF, /*AV_PKT_UNKNOWN_PACKET*/
                                  0xFF};/*AV_PKT_ALL_PACKETS*/

static const uchar AudioSfTable[] = {
    (uchar)AV_AUD_FS_32KHZ,     3,
    (uchar)AV_AUD_FS_44KHZ,     0,
    (uchar)AV_AUD_FS_48KHZ,     2,
    (uchar)AV_AUD_FS_88KHZ,     8,
    (uchar)AV_AUD_FS_96KHZ,    10,
    (uchar)AV_AUD_FS_176KHZ,   12,
    (uchar)AV_AUD_FS_192KHZ,   14,
    (uchar)AV_AUD_FS_HBR,       9,
    (uchar)AV_AUD_FS_FROM_STRM, 0,
    0xff,                0xff
};

static const uchar ChanMapping[32] = {
        0x1, 0x3, 0x3, 0x3, 0x5, 0x7, 0x7, 0x7,
        0x5, 0x7, 0x7, 0x7, 0xD, 0xF, 0xF, 0xF,
        0xD, 0xF, 0xF, 0xF, 0x9, 0xB, 0xB, 0xB,
        0xD, 0xF, 0xF, 0xF, 0xD, 0xF, 0xF, 0xF
};

/* HDTV YCbCr (Limited Range) to RGB (Limited Range) */
static const uint8 CscYcc709ToRgb[]= {
    0xAC, 0x53, 0x08, 0x00, 0x00, 0x00, 0x19, 0xD6,
    0x1C, 0x56, 0x08, 0x00, 0x1E, 0x88, 0x02, 0x91,
    0x1F, 0xFF, 0x08, 0x00, 0x0E, 0x85, 0x18, 0xBE
};

/* HDTV YCbCr (Limited Range) to RGB (Full Range) */
static const uint8 CscYuv709ToRgb[]= {
    0xE7, 0x34, 0x04, 0xAD, 0x00, 0x00, 0x1C, 0x1B,
    0x1D, 0xDC, 0x04, 0xAD, 0x1F, 0x24, 0x01, 0x35,
    0x00, 0x00, 0x04, 0xAD, 0x08, 0x7C, 0x1B, 0x77
};

/* SDTV YCbCr (Limited Range) to RGB (Limited Range) */
static const uint8 CscYcc601ToRgb[]= {
    0xAA, 0xF8, 0x08, 0x00, 0x00, 0x00, 0x1A, 0x84,
    0x1A, 0x6A, 0x08, 0x00, 0x1D, 0x50, 0x04, 0x23,
    0x1F, 0xFC, 0x08, 0x00, 0x0D, 0xDE, 0x19, 0x13
};

/* SDTV YCbCr (Limited Range) to RGB (Full Range) */
static const uint8 CscYuv601ToRgb[]= {
    0xE6, 0x69, 0x04, 0xAC, 0x00, 0x00, 0x1C, 0x81,
    0x1C, 0xBC, 0x04, 0xAD, 0x1E, 0x6E, 0x02, 0x20,
    0x1F, 0xFE, 0x04, 0xAD, 0x08, 0x1A, 0x1B, 0xA9
};

/* RGB (Limited Range) to HDTV YCbCr (Limited Range) */
static const uint8 CscRgbToYcc709[]= {
    0x88, 0x2E, 0x18, 0x93, 0x1F, 0x3F, 0x08, 0x00,
    0x03, 0x67, 0x0B, 0x71, 0x01, 0x28, 0x00, 0x00,
    0x1E, 0x21, 0x19, 0xB2, 0x08, 0x2D, 0x08, 0x00
};

/* RGB (Full Range) to HDTV YCbCr (Limited Range) */
static const uint8 CscRgbToYuv709[]= {
    0x86, 0xFF, 0x19, 0xA6, 0x1F, 0x5B, 0x08, 0x00,
    0x02, 0xE9, 0x09, 0xCB, 0x00, 0xFD, 0x01, 0x00,
    0x1E, 0x66, 0x1A, 0x9B, 0x06, 0xFF, 0x08, 0x00
};

/* RGB (Limited Range) to SDTV YCbCr (Limited Range) */
static const uint8 CscRgbToYcc601[]= {
    0x88, 0x2E, 0x19, 0x26, 0x1E, 0xAC, 0x08, 0x00,
    0x04, 0xC9, 0x09, 0x65, 0x01, 0xD2, 0x00, 0x00,
    0x1D, 0x3F, 0x1A, 0x93, 0x08, 0x2E, 0x08, 0x00
};

/* RGB (Full Range) to SDTV YCbCr (Limited Range) */
static const uint8 CscRgbToYuv601[]= {
    0x86, 0xFF, 0x1A, 0x24, 0x1E, 0xDD, 0x08, 0x00,
    0x04, 0x18, 0x08, 0x0A, 0x01, 0x8F, 0x01, 0x00,
    0x1D, 0xA5, 0x1B, 0x5C, 0x06, 0xFF, 0x08, 0x00
};

static const uint8 CscRgbFRtoYcc709FR[]= {
    0x88, 0x2D, 0xF8, 0x93, 0xFF, 0x3F, 0x08, 0x00,
    0x03, 0x68, 0x0B, 0x71, 0x01, 0x27, 0x00, 0x00,
    0xFE, 0x21, 0xF9, 0xB2, 0x08, 0x2D, 0x08, 0x00
};

static const uint8 CscRgbFRtoYcc601FR[]= {
    0x88, 0x2D, 0xF9, 0x27, 0xFE, 0xAC, 0x08, 0x00,
    0x04, 0xC9, 0x09, 0x64, 0x01, 0xD3, 0x00, 0x00,
    0xFD, 0x3F, 0xFA, 0x93, 0x08, 0x2D, 0x08, 0x00
};

/* RGB (Full Range) to RGB (Limited Range) */
static const uint8 CscRgbFRtoRgbLR[]= {
    0x8D, 0xBC, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x0D, 0xBC, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0D, 0xBC, 0x01, 0x00
};

/* RGB (Limited Range) to RGB (Full Range) */
static const uint8 CscRgbLRtoRgbFR[]= {
    0xA9, 0x50, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x6B,
    0x00, 0x00, 0x09, 0x50, 0x00, 0x00, 0x1F, 0x6B,
    0x00, 0x00, 0x00, 0x00, 0x09, 0x50, 0x1F, 0x6B
};

static const uint8 CscYcc709FRtoRgbFR[]= {
    0xAC, 0x52, 0x08, 0x00, 0x00, 0x00, 0xF9, 0xD7,
    0xFC, 0x54, 0x08, 0x00, 0xFE, 0x89, 0x02, 0x91,
    0x00, 0x00, 0x08, 0x00, 0x0E, 0x87, 0xF8, 0xBC
};

static const uint8 CscYcc709FRtoRgbLR[]= {
    0xAA, 0xD4, 0x07, 0x08, 0x00, 0x00, 0xFB, 0x16,
    0xFC, 0xD8, 0x06, 0xE0, 0xFE, 0xBE, 0x02, 0xB5,
    0x00, 0x00, 0x07, 0x08, 0x0C, 0xC5, 0xFA, 0x1E
};

/* HDTV YCbCr (Limited Range) to SDTV YCbCr (Limited Range) */
static const uint8 CscYcc709LRtoYcc601LR[]= {
    0xA7, 0xDD, 0x00, 0x00, 0x1F, 0x6C, 0x00, 0x5B,
    0x01, 0x88, 0x08, 0x00, 0x00, 0xCB, 0x1E, 0xD6,
    0x1F, 0x1D, 0x00, 0x00, 0x07, 0xEB, 0x00, 0x7B
};

/* HDTV YCbCr (Limited Range) to SDTV YCbCr (Full Range) */
static const uint8 CscYcc709LRtoYcc601FR[]= {
    0xA8, 0xEB, 0x00, 0x00, 0x1F, 0x58, 0x1F, 0xDE,
    0x01, 0xC9, 0x09, 0x50, 0x00, 0xEC, 0x1F, 0x25,
    0x1E, 0xFF, 0x00, 0x00, 0x08, 0xFA, 0x03, 0x1F
};

static const uint8 CscYcc709LRtoYcc709FR[]= {
    0xA9, 0x1A, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x73,
    0x00, 0x00, 0x09, 0x4F, 0x00, 0x00, 0xFF, 0x6B,
    0x00, 0x00, 0x00, 0x00, 0x09, 0x1A, 0xFF, 0x73
};

static const uint8 CscYcc709FRtoYcc709LR[]= {
    0x8E, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8,
    0x00, 0x00, 0x0D, 0xB0, 0x20, 0x00, 0x1F, 0x25,
    0x20, 0x00, 0x00, 0x00, 0x0E, 0x0E, 0x00, 0xF8
};

static const uint8 CscYcc709FRtoYcc601LR[]= {
    0x8D, 0xD2, 0x00, 0x00, 0x1E, 0xFD, 0x01, 0x98,
    0x02, 0xB1, 0x0D, 0xB0, 0x01, 0x64, 0x1D, 0x1A,
    0x1E, 0x72, 0x00, 0x00, 0x0D, 0xEA, 0x01, 0xD2
};

static const uint8 CscYcc601FRtoRgbFR[]= {
    0xAA, 0xF8, 0x08, 0x00, 0x00, 0x00, 0xFA, 0x84,
    0xFA, 0x6A, 0x08, 0x00, 0xFD, 0x50, 0x04, 0x23,
    0x00, 0x00, 0x08, 0x00, 0x0D, 0xDB, 0xF9, 0x12
};

static const uint8 CscYcc601FRtoRgbLR[]= {
    0xA9, 0xA4, 0x07, 0x08, 0x00, 0x00, 0xFB, 0xAE,
    0xFB, 0x34, 0x06, 0xE0, 0xFD, 0xB1, 0x04, 0x0E,
    0x00, 0x00, 0x07, 0x08, 0x0C, 0x2E, 0xFA, 0x69
};

static const uint8 CscYcc601FRtoYcc709LR[]= {
    0xA7, 0x2D, 0x00, 0x00, 0x00, 0x87, 0x00, 0x25,
    0x1E, 0x89, 0x06, 0xDE, 0x1F, 0x41, 0x01, 0x9B,
    0x00, 0xCB, 0x00, 0x00, 0x07, 0x21, 0x00, 0x09
};

/* SDTV YCbCr (Limited Range) to HDTV YCbCr (Limited Range)*/
static const uint8 CscYcc601LRtoYcc709LR[]= {
    0xA8, 0x33, 0x00, 0x00, 0x00, 0x99, 0x1F, 0x99,
    0x1E, 0x56, 0x08, 0x00, 0x1F, 0x13, 0x01, 0x4B,
    0x00, 0xEA, 0x00, 0x00, 0x08, 0x26, 0x1F, 0x78
};

/* SDTV YCbCr (Limited Range) to SDTV YCbCr (Full Range) */
static const uint8 CscYcc601LRtoYcc601FR[]= {
    0xA9, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x6E,
    0x00, 0x00, 0x09, 0x50, 0x00, 0x00, 0x1F, 0x6B,
    0x00, 0x00, 0x00, 0x00, 0x09, 0x1B, 0x1F, 0x6E
};

/* SDTV YCbCr (Full Range) to SDTV YCbCr (Limited Range) */
static const uint8 CscYcc601FRtoYcc601LR[]= {
    0x8E, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8,
    0x00, 0x00, 0x0D, 0xC0, 0x00, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0E, 0x10, 0x00, 0xF8
};

static const uint8 CscYcc601LRtoYcc709FR[]= {
    0xA9, 0x56, 0x00, 0x00, 0x00, 0xAE, 0x1E, 0xFE,
    0x1E, 0x0E, 0x09, 0x5A, 0x1E, 0xEC, 0x00, 0xED,
    0x01, 0x0B, 0x00, 0x00, 0x09, 0x46, 0x1E, 0xD7
};

/*SDTV YCbCr (Full Range)to HDTV YCbCr (Full Range)*/
static const uint8 CscYcc601FRtoYcc709FR[]= {
    0xA8, 0x34, 0x00, 0x00, 0x00, 0x9A, 0xFF, 0x99,
    0xFE, 0x56, 0x08, 0x00, 0xFF, 0x13, 0x01, 0x4B,
    0x00, 0xEB, 0x00, 0x00, 0x08, 0xD1, 0xFF, 0x22
};

/*HDTV YCbCr (Full Range) to SDTV YCbCr (Full Range)*/
static const uint8 CscYcc709FRtoYcc601FR[]= {
    0xA7, 0xDE, 0x00, 0x00, 0xFF, 0x6C, 0x00, 0x5B,
    0x01, 0x89, 0x08, 0x00, 0x00, 0xCB, 0xFE, 0xD6,
    0xFF, 0x1D, 0x00, 0x00, 0x07, 0xEB, 0x00, 0x7C
};

/*RGB (Limited Range) to SDTV YCbCr (Full Range)*/
static const uint8 CscRgbLRtoYcc601FR[]= {
    0x89, 0x84, 0xF8, 0x08, 0xFE, 0x74, 0x08, 0x00,
    0x05, 0x91, 0x0A, 0xEE, 0x02, 0x1F, 0xFE, 0xD6,
    0xFC, 0xCC, 0xF9, 0xB0, 0x09, 0x84, 0x08, 0x00
};

/*RGB (Limited Range) to HDTV YCbCr (Full Range)*/
static const uint8 CscRgbLRtoYcc709FR[]= {
    0x89, 0x84, 0xF7, 0x5C, 0xFF, 0x20, 0x08, 0x00,
    0x03, 0xF7, 0x0D, 0x50, 0x01, 0x57, 0xFE, 0xD6,
    0xFD, 0xD2, 0xF8, 0xAA, 0x09, 0x84, 0x08, 0x00
};

typedef struct
{
    AvVideoCs  InCs;
    AvVideoCs  OutCs;
    const uint8 *ConvTable;
} AvCscTables;

static const AvCscTables CscTables[] = {
    {AV_CS_RGB,           AV_CS_YCC_709,      CscRgbFRtoYcc709FR},
    {AV_CS_RGB,           AV_CS_YCC_601,      CscRgbFRtoYcc601FR},
    {AV_CS_LIM_RGB,       AV_CS_YCC_601,      CscRgbLRtoYcc601FR},
    {AV_CS_LIM_RGB,       AV_CS_YCC_709,      CscRgbLRtoYcc709FR},
    {AV_CS_LIM_RGB,       AV_CS_LIM_YCC_709,  CscRgbToYcc709},
    {AV_CS_RGB,           AV_CS_LIM_YCC_709,  CscRgbToYuv709},
    {AV_CS_LIM_RGB,       AV_CS_LIM_YCC_601,  CscRgbToYcc601},
    {AV_CS_RGB,           AV_CS_LIM_YCC_601,  CscRgbToYuv601},
    {AV_CS_LIM_RGB,       AV_CS_RGB,          CscRgbLRtoRgbFR},
    {AV_CS_RGB,           AV_CS_LIM_RGB,      CscRgbFRtoRgbLR},
    {AV_CS_LIM_YCC_709,   AV_CS_LIM_RGB,      CscYcc709ToRgb},
    {AV_CS_LIM_YCC_601,   AV_CS_LIM_RGB,      CscYcc601ToRgb},
    {AV_CS_LIM_YCC_709,   AV_CS_RGB,          CscYcc709ToRgb},
    {AV_CS_LIM_YCC_601,   AV_CS_RGB,          CscYcc601ToRgb},
    {AV_CS_YCC_709,       AV_CS_RGB,          CscYcc709FRtoRgbFR},
    {AV_CS_YCC_601,       AV_CS_RGB,          CscYcc601FRtoRgbFR},
    {AV_CS_LIM_YCC_601,   AV_CS_LIM_YCC_709,  CscYcc601LRtoYcc709LR},
    {AV_CS_LIM_YCC_709,   AV_CS_LIM_YCC_601,  CscYcc709LRtoYcc601LR},
    {AV_CS_YCC_601,       AV_CS_LIM_YCC_709,  CscYcc601FRtoYcc709LR},
    {AV_CS_LIM_YCC_709,   AV_CS_YCC_601,      CscYcc709LRtoYcc601FR},
    {AV_CS_LIM_YCC_601,   AV_CS_YCC_601,      CscYcc601LRtoYcc601FR},
    {AV_CS_YCC_601,       AV_CS_LIM_YCC_601,  CscYcc601FRtoYcc601LR},
    {AV_CS_LIM_YCC_601,   AV_CS_YCC_709,      CscYcc601LRtoYcc709FR},
    {AV_CS_LIM_YCC_709,   AV_CS_YCC_709,      CscYcc709LRtoYcc709FR},
    {AV_CS_YCC_709,       AV_CS_LIM_YCC_709,  CscYcc709FRtoYcc709LR},
    {AV_CS_YCC_709,       AV_CS_LIM_YCC_601,  CscYcc709FRtoYcc601LR},
    {AV_CS_YCC_709,       AV_CS_LIM_RGB,      CscYcc709FRtoRgbLR},
    {AV_CS_YCC_601,       AV_CS_LIM_RGB,      CscYcc601FRtoRgbLR},
    {AV_CS_YCC_601,       AV_CS_YCC_709,      CscYcc601FRtoYcc709FR},
    {AV_CS_YCC_709,       AV_CS_YCC_601,      CscYcc709FRtoYcc601FR},
    {AV_CS_AUTO,          AV_CS_AUTO,         NULL}
};

enum {
    CEC_RX_BUFFER1 = 0,
    CEC_RX_BUFFER2 = 1,
    CEC_RX_BUFFER3 = 2
};

static const uint8 Gsv2k2InitTable[] = {
    /* 01-01 Chip Power Up */
    0x02,0x25,0x06, // CP 420-444 disable
    0x00,0x00,0x00, // power up Core
    0x00,0xFE,0xFF, // Reset Rx PHY
    0x00,0xFE,0x00, // Set Rx PHY
    0x00,0xFF,0x7F, // Reset Digital
    0x00,0xFF,0x00, // Set Digital
    0x00,0x02,0x0E,
    0x00,0xF7,0x0F, // Reset Tx PHY
    0x00,0xF7,0x00, // Set Tx PHY
    0x01,0xCE,0xFF, // Manual Rx Port Fifo Control
    0x01,0xC5,0x4C, // MPLL Start Up Step 1
    0x01,0xC6,0x01, // MPLL Start Up Step 1, VC=low
    0x00,0x9B,0x00, // Set Audio IO Tristate and Dual In to avoid power consumption
    0x00,0x01,0xF3, // Enable both cores and point to invalid input port
    //0x00,0x07,0x83, // porb manual overwrite
    //0x00,0xB5,0x0F, // pwr_tmdspll_en_override_val_port_v
    0x00,0xB8,0x0F, // i2c_bandgap_en_port_v always enable
#if Gsv2k2SingleInput
    0x01,0x4F,0x04, // RxA CKIO refin enable, RxB disable
    0x37,0x7B,0x07, // power down RxB 1D & 2D
    0x00,0xB6,0x01, // pwr_channel_en_override_val_port_v
    0x00,0xB7,0x01, // pwr_bg_en_override_val_port_v
    0x00,0xB4,0x01, // pwr_override_en_port_v
    //0x00,0x90,0x01, // Enable Rx detection (Rx Sense)
#else
    0x01,0x4F,0x0C, // RxA & RxB CKIO refin enable
    0x00,0xB6,0x03, // pwr_channel_en_override_val_port_v
    0x00,0xB7,0x03, // pwr_bg_en_override_val_port_v
    0x00,0xB4,0x03, // pwr_override_en_port_v
    //0x00,0x90,0x03, // Enable Rx detection (Rx Sense)
#endif

    0x00,0xA4,0x88, // TXA/B triming=1000
    //0x00,0xA5,0x88, // TXC/D triming=1000
    0x00,0xA2,0x88, // RXA/B triming=1000
    //0x00,0xA6,0x88, // RXC/D triming=1000
    0x01,0xBF,0x04, // calibration
    0x01,0x02,0x01, // [0]vsp_man_en = 1, 2002 default=1, 2006/2008 default=0
    0x01,0xC1,0x00, // bit[7] dpll_clock_sel = 0; 0: 297MHz/6=49.5MHz; 1: 27MHz XOR.
    /* 01-04-01, Load OTP into Instruction RAM */
#if Gsv2k2RomFromOtp
    0x01,0xDB,0x05, //[2]=1 i2c access spireg; [1]=1 HDCP/RSA/ Read OTP; [0]=1 Encrypted Key
    0xA4,0x10,0x00, //
    0xA4,0x11,0x00, //
    0xA4,0x40,0x01, //# Override OTP MR
    0x01,0xDB,0x07, //[2]=1 i2c access spireg; [1]=1 HDCP/RSA/ Read OTP; [0]=1 Encrypted Key
    0x00,0x97,0x00, //Disable txport_a/b/c/d_hdcp1p4_hpd_reset_en
//    0x00,0x02,0x0E, //Power up tx port a/b/c/d
    0x00,0x93,0xF0, //enable mcu clock
    0x60,0x81,0x02, //[0] i2c_hdcp1p4_pgm_ram_en=0; [1]i2c_hdcp1p4_load_otp_to_ram_en=1
    0x70,0x81,0x02, //[0] i2c_hdcp1p4_pgm_ram_en=0; [1]i2c_hdcp1p4_load_otp_to_ram_en=1
    0x01,0xF1,0x05, //
    0x01,0xF2,0xF8, //i2c_trim_value_otp_offset=1528
    0x01,0xFB,0x01, //i2c_trim_instr_sel=1, means load 2048 bytes instruction into INSTR RAM
    0x01,0xF0,0x00, //
    0x01,0xF0,0x01, //toggle i2c_man_rd_trim_on_bus_start
    0x01,0xF0,0x00, //AVES 2 i2c access interval is about 0.5s, it's enough to load
#endif
    /* 01-02 Rx Init, write lane0 can write all lane0/1/2 */
    0x05,0x72,0x01, // RxA Ckio Low Threshold
    0x05,0x75,0x21, // RxB Ckio Low Threshold
    0x05,0x73,0xEE, // bit[1] rxb_ckio_en_z0 = 1
    0x05,0x70,0xEE, // bit[1] rxa_ckio_en_z0 = 1
    0x05,0x77,0x09, // rxa enlarge eq range
    0x05,0x79,0x10, // rxa enlarge eq range
    0x05,0x7B,0x09, // rxb enlarge eq range
    0x05,0x7D,0x10, // rxb enlarge eq range
    //0x00,0xAF,0x3F, // manual override all RX 5V to 1, covered 2002/2006/2008
    0x00,0x93,0xF0, // manually enable Rx DDC clock
    0x27,0x50,0x80, // manual set RXA CDR PI slewrate to 0
    0x37,0x50,0x80, // manual set RXB CDR PI slewrate to 0
    0x01,0xC6,0x00, // MPLL Start Up Step 2
    0x01,0xC5,0xCC, // MPLL Start Up Step 2, VC=high
    /* 01-03, Tx Init */
    0x00,0x09,0x88, // bit[6][2]txcore_1/2_dis_osc_clk=0, enable osc clock
    0x05,0x59,0x80, // TXA RPLL spare bit79=1
    0x05,0x89,0x80, // TXB RPLL spare bit79=1
//    0x00,0x02,0x0E, // Power up tx port a/b
    0x60,0x0D,0x01, // scdc_ctrl_clk_data_override=1
    0x60,0x43,0x0F, // [1]scdc_scr_fsm_dis=1; [0]scdc_tmds_clk_ratio_fsm_dis=1
    0x70,0x0D,0x01, // scdc_ctrl_clk_data_override=1
    0x70,0x43,0x0F, // [1]scdc_scr_fsm_dis=1; [0]scdc_tmds_clk_ratio_fsm_dis=1
    0x60,0xF2,0x70, // TMDS SER_EN always enabled
    0x70,0xF2,0x70, // TMDS SER_EN always enabled
    //0x60,0xD4,0x54, // TxA Phy Characater, Preemp = 101
    0x60,0xD5,0xBE, // TxA Phy Characater, Swing = 1111
    //0x70,0xD4,0x54, // TxB Phy Characater, Preemp = 101, 100 removed by red cable
    0x70,0xD5,0xB2, // TxB Phy Characater, Swing = 1100
    /* HPA is manually controlled */
    0x00,0xB1,0x90, //; Programmable No Delay
    /* 01-04-02, Load OTP into Instruction RAM */
#if Gsv2k2RomFromOtp
    0x60,0x81,0x00, //[0] i2c_hdcp1p4_pgm_ram_en=0; [1]i2c_hdcp1p4_load_otp_to_ram_en=0
    0x70,0x81,0x00, //[0] i2c_hdcp1p4_pgm_ram_en=0; [1]i2c_hdcp1p4_load_otp_to_ram_en=0
    0x60,0x80,0x01, //[0] i2c_hdcp1p4_ram_replace_rom_en=1
    0x70,0x80,0x01, //[0] i2c_hdcp1p4_ram_replace_rom_en=1
    0x00,0x97,0x0F, //Enable txport_a/b/c/d_hdcp1p4_hpd_reset_en
    0x00,0xF8,0x0F, //Reset Tx Port ROM instruction
    0x00,0xF8,0x00, //Reset Tx Port ROM instruction
    0x01,0xDC,0x02, //Trigger HDCP KSV reload
#endif
    /* Audio Bypass Function */
#if Gsv2k2AudioBypass
    0x20,0x8E,0x81,
    0x22,0x83,0x80,
    0x40,0xA9,0x00,
    0x40,0x01,0x57,
    0x40,0x1D,0x03, /* tx use rx cts, no downscaling allowed */
    0x50,0xA9,0x00,
    0x50,0x01,0x57,
    0x50,0x1D,0x03, /* tx use rx cts, no downscaling allowed */
#endif
#if Gsv2k2MuxMode
    0x40,0xA0,0x01, /* Mux Mode Kpt Shift disable */
    0x50,0xA0,0x01, /* Mux Mode Kpt Shift disable */
#endif
    /* Extra Configuration */
    0x01,0x01,0x0C, // Default CP Status
    0x23,0x01,0x01, // Rx1 SCDC Version = 1
    0x33,0x01,0x01, // Rx2 SCDC Version = 1
    //0x21,0x07,0x01, // Disable Rx1 HDCP 2.2 ECC Check, HP rescue only
    //0x31,0x07,0x01, // Disable Rx2 HDCP 2.2 ECC Check, HP rescue only
    0x20,0x24,0x84, // Change Rx1 H UnLock Threshold
    0x12,0xF4,0x03, // All Downscaled/420 Timing Polarity is Positive
    0x00,0x99,0x02, // Disable RxID auto move and 1p4 repeater
    0x01,0xC0,0x00, // set audio module divider
    0x22,0x4A,0x32, // set almost empty threshold
    0x22,0x54,0x3F, // audio_sample_cnt_threshold
    0x22,0x62,0x80, // Manual TDM Disable */
    0x22,0x87,0x80, // Set Output Pin Number */
    0x22,0x01,0x08, // HBR - Auto HBR Out, Output I2S Data
    0x22,0x64,0x00, // HBR over I2S, Sel I2S Out Default
    0x22,0x13,0x63, // Disable N/CTS Interrupt
    0x22,0x14,0x0C, // Disable Parity Error Interrupt
    0x22,0x15,0xC7, // Disable F N/CTS Interrupt
    0x22,0x16,0x03, // Disable AvMute/ECC Interrupt
    //0x20,0x1B,0x08, // TERC4 Error Detection Disabled, HP rescue only
    //0x22,0x46,0x40, // Disable ECC, HP rescue only
    0x22,0x50,0x04, // No CSdata Interrupt
    0x20,0x67,0xA0, // Apll Delta Manual Enable
    0x20,0x6C,0x80, // Apll Delta Code
    0x20,0x6D,0x72, // Enable Fifo Adjust
    0x20,0x9A,0x40, // Audio Lock Threshold = 64
    0x20,0x7C,0xFF, // Large CTS Stability Delta
    0x22,0x10,0x3F, // Large CTS Change Threshold
    0x20,0x14,0x01, // Manual Rx1 Audio Output MCLK Factor = x2
    0x20,0x8F,0x01, // Manual Control Rx1 Audio Output MCLK Factor
    0x12,0x6C,0x02, // CP 444-420 configuration
    0x12,0x73,0x03, // CP 444-420 configuration
    0x12,0x6F,0x03, // Lower margin to make CP output stable
    0x60,0xDD,0x01, // Tx ARC Detection Default Setting
    0x70,0xDD,0x01, // Tx ARC Detection Default Setting
    0x01,0xC5,0x0C, // MPLL Start Up Step 3, normal
    //0x02,0x1D,0x0A, // RxA VCO Max Freq = 2.8GHz
    //0x02,0x1E,0xF0, // RxA VCO Max Freq = 2.8GHz
    //0x02,0x4D,0x0A, // RxB VCO Max Freq = 2.8GHz
    //0x02,0x4E,0xF0, // RxB VCO Max Freq = 2.8GHz
    0x01,0xFD,0xFF,
    0x05,0x52,0x6F,
    0x05,0x62,0x6F,
    0x05,0x82,0x6F,
    0x05,0x92,0x6F,
    0x05,0x52,0x2F,
    0x05,0x62,0x2F,
    0x05,0x82,0x2F,
    0x05,0x92,0x2F,
    0x01,0xFD,0x00,
    0x40,0x1A,0x90, // Tx1 Audio Layout Override
    0x50,0x1A,0x90, // Tx2 Audio Layout Override
    0x40,0xA6,0x10, // Tx1 Fifo Reset on Lock
    0x50,0xA6,0x10, // Tx2 Fifo Reset on Lock
    0x42,0xFD,0x02, // Tx1 1080p30 VIC is incorrect, don't trust AVIIF detect
    0x52,0xFD,0x02, // Tx2 1080p30 VIC is incorrect, don't trust AVIIF detect
    0x62,0x08,0x01, // TxA revocation check pass
    0x62,0x0B,0x42, // TxA Formal DDC read
    0x62,0x2B,0x02,
    0x62,0x5D,0x03, // TxA Clear RxID Ready Flag
    0x60,0xF4,0x30, // TxA Ser Manual Reset but not Enabled
    0x60,0xF5,0x80, // TxA Ser Parity Reset Enable
    0x72,0x08,0x01, // TxB revocation check pass
    0x72,0x0B,0x42, // TxB Formal DDC read
    0x72,0x2B,0x02,
    0x72,0x5D,0x03, // TxB Clear RxID Ready Flag
    0x70,0xF4,0x30, // TxB Ser Manual Reset but not Enabled
    0x70,0xF5,0x80, // TxB Ser Parity Reset Enable
    0x01,0x16,0xFF, // HDCP noise 1p5m set
    0x00,0x93,0x03, // HDCP Clock Enable
    0x03,0x0B,0x01, // Enable Status Detection Bits
    0x26,0x70,0x20, // Rx RAM1 Edid Size is fixed to 256 bytes
    0x26,0x7E,0x20, // Rx RAM2 Edid Size is fixed to 256 bytes
    0x20,0xBE,0x04, // Rx1 Strong ECC AVMute Enable
    0x20,0x22,0x20, // Rx1 DC Fifo no disable
    0x21,0x12,0x00, // Rx1 Disable HDCP 2.2 Auto Switch
    0x21,0x1F,0x02,
    0xFF,0xFF,0xFF
};

static const uint8 Gsv2k2EqTable[] = {
    0x58,0x01, //eq_term_mode = 1
    //0x40,0x03, //RXA select V2 CDR, default
    0x13,0x01, //RXA/B h0floor=1
    0x19,0x03, //RXA/B max eye check 3 times
    0x5A,0x07, //h0ref bias tune = 111
    0x60,0x00,
    0x61,0x01, //; i2c_cdr_meh_cycles = 255
    0x04,0x28, // cdr setting time=40
    0x03,0x03, // first gain ctrl = 4, second gain ctrl 1, Fixed CDR bandwidth
    0x09,0x1B, //[3]=1 remove odd edge;
               //[1]=1, if not found eq cfg use init EQ;
               //[0]Loop all EQ cfgs combination
    0x0A,0x8F, //eq_init_en_khp_t=1
    0x0B,0x87, //eq_init_en_a0_t=1
    0x0C,0x01, //follow WX's table
    0x0D,0x83, //eq_init_en_aeq_stg1_gain=1
    0x0E,0x01, //follow WX's table
    0x0F,0x80, //eq_init_en_ctle_freqhp_t=1
    0x70,0x11, //[4]cdr_2d_eye_measure_en = 1, [1:0]cdr_2d_measure_mode[1:0]=1
    0x3F,0x22, //EQ Reset Bit
    0x01,0x00, //EQ FSM Enable
    0x73,0x3B, // cdr_2d_max_phase_offset=59
    0xFF,0xFF
};

static const uchar Gsv2k2VideoColorAutoVicTable[] = {
    31,75,33,73,64,77, /* 1080p50 */
    16,76,34,74,63,78, /* 1080p60 */
    96,106,94,104,     /* 4k50    */
    97,107,95,105,     /* 4k60    */
    101,99,            /* 4ks50   */
    102,100,           /* 4ks60   */
    1,                 /* 640x480p*/
    2,3,48,49,56,57,   /* 480p60  */
    4,69,47,71,        /* 720p60  */
    19,68,41,70,       /* 720p50  */
    17,18,42,43,52,53, /* 576p50  */
    32,72,             /* 1080p24 */
    93,103,            /* 4k24    */
    98,                /* 4ks24   */
    0xff
};

static const uint8 Gsv2k2RxAIn420Table[] = {
    0x00,0x01,0x89,//RxA-Rx1, Rx2 Core Enable
    0x05,0x60,0x88,
    0x05,0x90,0x89,
    0x02,0x12,0x00,
    0x02,0x25,0x06,
    0x00,0xC5,0x00,
    0x00,0x13,0x00,
    0x02,0x23,0x00,
    0x02,0x53,0x03,
    0x05,0x78,0x50,
    0x05,0x7C,0x00,
    0x02,0x17,0x00,
    0x02,0x18,0x00,
    0x02,0x47,0x80,
    0x02,0x48,0x20,
    0x02,0xE0,0x81,
    0x02,0xEA,0x80,
    //0x00,0xFF,0x01, // Digital Reset when PLL change
    //0x00,0xFF,0x00,
    /* End */
    0xFF,0xFF,0xFF
};

static const uint8 Gsv2k2RxBIn420Table[] = {
    0x00,0x01,0x98,//RxB-Rx1, Rx2 Core Enable
    0x05,0x60,0x89,
    0x05,0x90,0x88,
    0x02,0x12,0x00,
    0x02,0x25,0x06,
    0x00,0xC5,0x00,
    0x00,0x13,0x00,
    0x02,0x23,0x03,
    0x02,0x53,0x00,
    0x05,0x78,0x00,
    0x05,0x7C,0x50,
    0x02,0x17,0x80,
    0x02,0x18,0x20,
    0x02,0x47,0x00,
    0x02,0x48,0x00,
    0x02,0xE0,0x81,
    0x02,0xEA,0x80,
    //0x00,0xFF,0x01, // Digital Reset when PLL change
    //0x00,0xFF,0x00,
    /* End */
    0xFF,0xFF,0xFF
};

static const uint8 Gsv2k2RxAInNon420Table[] = {
    0x00,0x01,0x87,//RxA-Rx1, Rx2 Core Disable
    0x05,0x60,0x88,
    0x05,0x90,0x88,
    0x02,0x12,0x00,
    0x02,0x25,0x06,
    0x00,0xC5,0x00,
    0x00,0x13,0x01,
    0x02,0x23,0x00,
    0x02,0x53,0x00,
    0x05,0x78,0x00,
    0x05,0x7C,0x00,
    0x02,0x17,0x00,
    0x02,0x18,0x00,
    0x02,0x47,0x00,
    0x02,0x48,0x00,
    0x02,0xE0,0x00,
    0x02,0xEA,0x00,
    0x02,0xEC,0x00,
    0x02,0xE1,0x00,
    0x02,0xE5,0x00,
    0x02,0xE4,0x00,
    //0x00,0xFF,0x01, // Digital Reset when PLL change
    //0x00,0xFF,0x00,
    /* End */
    0xFF,0xFF,0xFF
};

static const uint8 Gsv2k2RxBInNon420Table[] = {
    0x00,0x01,0x97,//RxB-Rx1, Rx2 Core Disable
    0x05,0x60,0x88,
    0x05,0x90,0x88,
    0x02,0x12,0x00,
    0x02,0x25,0x06,
    0x00,0xC5,0x00,
    0x00,0x13,0x01,
    0x02,0x23,0x00,
    0x02,0x53,0x00,
    0x05,0x78,0x00,
    0x05,0x7C,0x00,
    0x02,0x17,0x00,
    0x02,0x18,0x00,
    0x02,0x47,0x00,
    0x02,0x48,0x00,
    0x02,0xE0,0x00,
    0x02,0xEA,0x00,
    0x02,0xEC,0x00,
    0x02,0xE1,0x00,
    0x02,0xE5,0x00,
    0x02,0xE4,0x00,
    //0x00,0xFF,0x01, // Digital Reset when PLL change
    //0x00,0xFF,0x00,
    /* End */
    0xFF,0xFF,0xFF
};
